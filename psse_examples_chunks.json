[
  {
    "id": 0,
    "text": "--- Area Data \u2014 .txt ---\n\nArea Data \u2014 \n\nArea Data\u00b6\n\naareachar\n\n return an array of character values for subsystem areas.\n\naareacount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the area data family.\n\naareacplx\n\n return an array of complex values for subsystem areas.\n\naareaint\n\n return an array of integer values for subsystem areas.\n\naareareal\n\n return an array of real values for subsystem areas.\n\naareatypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the area data family (aAreaInt, aAreaReal, aAreaCplx and aAreaChar).\n\n--- Area Subsystems \u2014 .txt ---\n\nArea Subsystems \u2014 \n\nArea Subsystems\u00b6\n\nasys\n\n define an area subsystem.\n\nasysdef\n\n set the definition of an area subsystem.\n\nasysinit\n\n initialize or re-initialize an area subsystem.\n\n--- Assign Branch Quantities To Output Channels \u2014 .txt ---\n\nAssign Branch Quantities To Output Channels \u2014 \n\nAssign Branch Quantities To Output Channels\u00b6\n\nbranch_app_r_x_channel\n\n add a pair of output channels containing the apparent impedance, as seen at the from bus of a specified branch, along with a corresponding call to the RELAY2 monitoring model.\n\nbranch_mva_channel\n\n add an output channel containing the MVA flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\n\nbranch_p_and_q_channel\n\n add a pair of output channels containing the active and reactive power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\n\nbranch_p_channel\n\n add an output channel containing the active power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\n\nthree_wnd_app_r_x_channel\n\n add a pair of output channels containing the apparent impedance as seen at the from bus of a specified three-winding transformer, along with a corresponding call to the RELAY3 monitoring model.\n\nthree_wnd_mva_channel\n\n add an output channel containing the MVA flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\n\nthree_wnd_p_and_q_channel\n\n add a pair of output channels containing the active and reactive power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\n\nthree_wnd_p_channel\n\n add an output channel containing the active power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\n\n--- Assign Machine Quantities To Output Channels \u2014 .txt ---\n\nAssign Machine Quantities To Output Channels \u2014 \n\nAssign Machine Quantities To Output Channels\u00b6\n\nmachine_app_r_x_channel\n\n add a pair of output channels containing the apparent impedance of the system, as seen from the terminals of a specified machine, along with a corresponding call to the GENTMZ monitoring model.\n\nmachine_array_channel\n\n add an output channel containing a plant related model variable of a designated type for a specified machine.\n\nmachine_iterm_channel\n\n add an output channel containing the terminal current of a specified machine, along with a corresponding call to the GENTMC monitoring model.\n\n--- Assign Other Quantities To Output Channels \u2014 .txt ---\n\nAssign Other Quantities To Output Channels \u2014 \n\nAssign Other Quantities To Output Channels\u00b6\n\nbus_frequency_channel\n\n add an output channel containing the per unit frequency deviation at a specified bus.\n\nstate_channel\n\n add an output channel containing the value of a specified STATE.\n\nvar_channel\n\n add an output channel containing the value of a specified VAR.\n\nvoltage_and_angle_channel\n\n add a pair of output channels containing the voltage magnitude in per unit and phase angle in degrees of a specified bus, along with a corresponding call to the VOLMAG monitoring model.\n\nvoltage_channel\n\n add an output channel containing the voltage magnitude in per unit of a specified bus, along with a corresponding call to the VOLMAG monitoring model.\n\n--- Auxiliary Signal Models \u2014 .txt ---\n\nAuxiliary Signal Models \u2014 \n\nAuxiliary Signal Models\u00b6\n\nadd_fctsauxsignal_model\n\n add a FACTS device auxiliary signal model at the specified injection point of the designated FACTS device.\n\nadd_mtdcauxsignal_model\n\n add a multi-terminal dc line auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.\n\nadd_ttdcauxsignal_model\n\n add a two-terminal dc line auxiliary signal model at the specified injection point of the designated two-terminal dc line.\n\nadd_vsdcauxsignal_model\n\n add a VSC dc line auxiliary signal model at the specified injection point of the designated VSC dc line.\n\nauxmod_pack\n\n remove entries that are marked as unused from the auxiliary signal model connection tables and the auxiliary signal array allocation tables.\n\nauxmod_unconnected\n\n list or remove from dynamics working memory those auxiliary signal models that are assigned to dc lines or FACTS devices that are not present in the current power flow working case (unconnected).\n\nauxmod_user\n\n list user-written auxiliary signal model definitions or to remove user-written auxiliary signal model definitions that are not assigned to any dc lines or FACTS devices (unused) from the user model definition tables.\n\nchange_fctsauxmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified FACTS device.\n\nchange_fctsauxmod_con\n\n change the value of a CON of an auxiliary signal model of a specified FACTS device.\n\nchange_fctsauxmod_data\n\nchange_fctsauxmod_icon\n\n change the value of an integer ICON of an auxiliary signal model of a specified FACTS device.\n\nchange_fctsauxmod_var\n\n change the value of a VAR of an auxiliary signal model of a specified FACTS device.\n\nchange_mtdcauxmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified multi-terminal dc line.\n\nchange_mtdcauxmod_con\n\n change the value of a CON of an auxiliary signal model of a specified multi- terminal dc line.\n\nchange_mtdcauxmod_data\n\nchange_mtdcauxmod_icon\n\n change the value of an integer ICON of an auxiliary signal model of a specified multi-terminal dc line.\n\nchange_mtdcauxmod_var\n\n change the value of a VAR of an auxiliary signal model of a specified multi- terminal dc line.\n\nchange_ttdcauxmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified two-terminal dc line.\n\nchange_ttdcauxmod_con\n\n change the value of a CON of an auxiliary signal model of a specified two- terminal dc line.\n\nchange_ttdcauxmod_data\n\nchange_ttdcauxmod_icon\n\n change the value of an integer ICON of an auxiliary signal model of a specified two-terminal dc line.\n\nchange_ttdcauxmod_var\n\n change the value of a VAR of an auxiliary signal model of a specified two- terminal dc line.\n\nchange_vsdcauxmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified VSC dc line.\n\nchange_vsdcauxmod_con\n\n change the value of a CON of an auxiliary signal model of a specified VSC dc line.\n\nchange_vsdcauxmod_data\n\nchange_vsdcauxmod_icon\n\n change the value of an integer ICON of an auxiliary signal model of a specified VSC dc line.\n\nchange_vsdcauxmod_var\n\n change the value of a VAR of an auxiliary signal model of a specified VSC dc line.\n\nfctsauxmod_remove\n\n remove an auxiliary signal model from the specified injection point of a designated FACTS device.\n\nfctsauxmod_status\n\n change the status of the auxiliary signal model at the specified injection point of a designated FACTS device.\n\nmtdcauxmod_remove\n\n remove an auxiliary signal model from the specified auxiliary signal index of the designated multi-terminal dc line.\n\nmtdcauxmod_status\n\n change the status of the auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.\n\nttdcauxmod_remove\n\n remove an auxiliary signal model from the specified injection point of the designated two-terminal dc line.\n\nttdcauxmod_status\n\n change the status of the auxiliary signal model at the specified injection point of the designated two-terminal dc line.\n\nvsdcauxmod_remove\n\n remove an auxiliary signal model from the specified injection point of the designated VSC dc line.\n\nvsdcauxmod_status\n\n change the status of the auxiliary signal model at the specified injection point of the designated VSC dc line.\n\n--- Branch Data \u2014 .txt ---\n\nBranch Data \u2014 \n\nBranch Data\u00b6\n\nabrnchar\n\n return an array of character values for subsystem branches.\n\nabrncount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the branch data family.\n\nabrncplx\n\n return an array of complex values for subsystem branches.\n\nabrnint\n\n return an array of integer values for subsystem branches.\n\nabrnreal\n\n return an array of real values for subsystem branches.\n\nabrntypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch data family (aBrnInt, aBrnReal, aBrnCplx and aBrnChar).\n\n--- Branch Flow Data \u2014 .txt ---\n\nBranch Flow Data \u2014 \n\nBranch Flow Data\u00b6\n\naflowchar\n\n return an array of character values for subsystem branches.\n\naflowcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the branch flow data family.\n\naflowcplx\n\n return an array of complex values for subsystem branches.\n\naflowint\n\n return an array of integer values for subsystem branches.\n\naflowreal\n\n return an array of real values for subsystem branches.\n\naflowtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch flow data family (aFlowInt, aFlowReal, aFlowCplx and aFlowChar).\n\n--- Bus Data \u2014 .txt ---\n\nBus Data \u2014 \n\nBus Data\u00b6\n\nabuschar\n\n return an array of character values for subsystem buses.\n\nabuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the bus data family.\n\nabuscplx\n\n return an array of complex values for subsystem buses.\n\nabusint\n\n return an array of integer values for subsystem buses.\n\nabusreal\n\n return an array of real values for subsystem buses.\n\nabustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the bus data family (aBusInt, aBusReal, aBusCplx and aBusChar).\n\n--- Bus Subsystems \u2014 .txt ---\n\nBus Subsystems \u2014 \n\nBus Subsystems\u00b6\n\nbsys\n\n define a bus subsystem.\n\nbsysadd\n\n add elements to an existing bus subsystem.\n\nbsysdef\n\n set the definition of a bus subsystem.\n\nbsysdelo\n\n delete a single bus from a bus subsystem.\n\nbsysinit\n\n initialize or re-initialize a bus subsystem.\n\nbsysmem\n\n replicate the specified bus subsystem in a bus subsystem file.\n\nbsyso\n\n build a bus subsystem one bus at a time.\n\nbsysrcl\n\n recall a specified bus subsystem saved in a bus subsystem file.\n\n--- Cct Models \u2014 .txt ---\n\nCct Models \u2014 \n\nCct Models\u00b6\n\nadd_cct2dco_model\n\n add an \u201cother\u201d type model attached to a 2-terminal dc line.\n\nadd_cct2wtd_model\n\n add a 2-winding transformer device model to the specified 2-winding transformer.\n\nadd_cct3wtd_model\n\n add a 3-winding transformer device model to the specified 3-winding transformer.\n\nadd_cctbrnd_model\n\n add a branch device model to the specified branch.\n\nadd_cctbrno_model\n\n add a branch \u201cother\u201d model to the specified branch.\n\nadd_cctbuso_model\n\n add an \u201cother\u201d type model attached to a bus.\n\nadd_cctmcno_model\n\n add a machine other model to the specified machine.\n\nadd_cctmcnp_model\n\n add a machine protection model to the specified machine.\n\nadd_cctmsco_model\n\n add a miscellaneous \u201cother\u201d type model with the specified model instance.\n\nadd_cctswso_model\n\nadd_cctswso_model_2\n\n add a switched shunt \u201cother\u201d model to the specified bus.\n\ncct2dco_list\n\n list \u201cother\u201d type models attached to 2-terminal dc lines.\n\ncct2dcomod_remove\n\n remove an \u201cother\u201d type model attached to a 2-terminal dc line.\n\ncct2dcomod_status\n\n change status of an \u201cother\u201d type model attached to a 2-terminal dc line.\n\ncct2wtd_list\n\n list \u201cother\u201d type models attached to 2-winding transformers.\n\ncct2wtdmod_remove\n\n remove a 2-winding transformer device model attached to the specified 2-winding transformer.\n\ncct2wtdmod_status\n\n change the status of a 2-winding transformer device model attached to the specified 2-winding transformer.\n\ncct3wtd_list\n\n list \u201cother\u201d type models attached to 3-winding transformers.\n\ncct3wtdmod_remove\n\n remove a 3-winding transformer device model attached to the specified 3-winding transformer.\n\ncct3wtdmod_status\n\n change the status of a 3-winding transformer device model attached to the specified 3-winding transformer.\n\ncctbrnd_list\n\n list device type models attached to branches.\n\ncctbrndmod_remove\n\n remove a branch device model attached to the specified branch.\n\ncctbrndmod_status\n\n change the status of a branch device model attached to the specified branch.\n\ncctbrno_list\n\n list \u201cother\u201d type models attached to branches.\n\ncctbrnomod_remove\n\n remove a branch \u201cother\u201d model attached to the specified branch.\n\ncctbrnomod_status\n\n change the status of a branch \u201cother\u201d model attached to the specified branch.\n\ncctbuso_list\n\n list \u201cother\u201d type models attached to buses.\n\ncctbusomod_remove\n\n remove an \u201cother\u201d type model attached to a bus.\n\ncctbusomod_status\n\n change status of an \u201cother\u201d type model attached to a bus.\n\ncctmcno_list\n\n list \u201cother\u201d type models attached to machines.\n\ncctmcnomod_remove\n\n remove a machine \u201cother\u201d model attached to the specified machine.\n\ncctmcnomod_status\n\n change status of a machine \u201cother\u201d model attached to the specified machine.\n\ncctmcnp_list\n\n list protection models attached to machines.\n\ncctmcnpmod_remove\n\n remove a machine protection model attached to the specified machine.\n\ncctmcnpmod_status\n\n change status of a machine protection model attached to the specified machine.\n\ncctmod_pack\n\n pack CCT model definition tables.\n\ncctmod_user\n\n list or remove user-written CCT model definitions.\n\ncctmsco_list\n\n list miscellaneous \u201cother\u201d type models.\n\ncctmscomod_remove\n\n remove a miscellaneous \u201cother\u201d type model with the specified model instance.\n\ncctmscomod_status\n\n change status of a miscellaneous \u201cother\u201d type model with the specified model instance.\n\ncctswso_list\n\n list \u201cother\u201d type models attached to switched shunts.\n\ncctswsomod_remove\n\ncctswsomod_remove_2\n\n remove an \u201cother\u201d type model attached to a switched shunt.\n\ncctswsomod_status\n\ncctswsomod_status_2\n\n change status of an \u201cother\u201d type model attached to a switched shunt.\n\nchange_cct2dcomod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\n\nchange_cct2dcomod_con\n\n change the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\n\nchange_cct2dcomod_icon\n\n change the value of an integer ICON of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\n\nchange_cct2dcomod_var\n\n change the value of VAR of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\n\nchange_cct2wtdmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the 2-winding transformer device model of a specified branch.\n\nchange_cct2wtdmod_con\n\n change the value of a real constant (CON) of the 2-winding transformer device model of a specified branch.\n\nchange_cct2wtdmod_icon\n\n change the value of an integer ICON of the 2-winding transformer device model of a specified branch.\n\nchange_cct2wtdmod_var\n\n change the value of VAR of the 2-winding transformer device model of a specified branch.\n\nchange_cct3wtdmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the 3-winding transformer device model of a specified branch.\n\nchange_cct3wtdmod_con\n\n change the value of a real constant (CON) of the 3-winding transformer device model of a specified branch.\n\nchange_cct3wtdmod_icon\n\n change the value of an integer ICON of the 3-winding transformer device model of a specified branch.\n\nchange_cct3wtdmod_var\n\n change the value of VAR of the 3-winding transformer device model of a specified branch.\n\nchange_cctbrndmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the branch device model of a specified branch.\n\nchange_cctbrndmod_con\n\n change the value of a real constant (CON) of the branch device model of a specified branch.\n\nchange_cctbrndmod_icon\n\n change the value of an integer ICON of the branch device model of a specified branch.\n\nchange_cctbrndmod_var\n\n change the value of VAR of the branch device model of a specified branch.\n\nchange_cctbrnomod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the branch \u201cother\u201d model of a specified branch.\n\nchange_cctbrnomod_con\n\n change the value of a real constant (CON) of the branch \u201cother\u201d model of a specified branch.\n\nchange_cctbrnomod_icon\n\n change the value of an integer ICON of the branch \u201cother\u201d model of a specified branch.\n\nchange_cctbrnomod_var\n\n change the value of VAR of the branch \u201cother\u201d model of a specified branch.\n\nchange_cctbusomod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified bus.\n\nchange_cctbusomod_con\n\n change the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified bus.\n\nchange_cctbusomod_icon\n\n change the value of an integer ICON of the \u201cother\u201d type model attached to a specified bus.\n\nchange_cctbusomod_var\n\n change the value of VAR of the \u201cother\u201d type model attached to a specified bus.\n\nchange_cctmcnomod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the machine \u201cother\u201d model for a specified machine.\n\nchange_cctmcnomod_con\n\n change the value of a real constant (CON) of the machine \u201cother\u201d model for a specified machine.\n\nchange_cctmcnomod_icon\n\n change the value of an integer ICON of the machine \u201cother\u201d model for a specified machine.\n\nchange_cctmcnomod_var\n\n change the value of VAR of the machine \u201cother\u201d model for a specified machine.\n\nchange_cctmcnpmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the machine protection model of a specified machine.\n\nchange_cctmcnpmod_con\n\n change the value of a real constant (CON) of the machine protection model of a specified machine.\n\nchange_cctmcnpmod_icon\n\n change the value of an integer ICON of the machine protection model of a specified machine.\n\nchange_cctmcnpmod_var\n\n change the value of VAR of the machine protection model of a specified machine.\n\nchange_cctmscomod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the miscellaneous \u201cother\u201d type model with the specified model instance.\n\nchange_cctmscomod_con\n\n change the value of a real constant (CON) of the miscellaneous \u201cother\u201d type model with the specified model instance.\n\nchange_cctmscomod_icon\n\n change the value of an integer ICON of the miscellaneous \u201cother\u201d type model with the specified model instance.\n\nchange_cctmscomod_var\n\n change the value of VAR of the miscellaneous \u201cother\u201d type model with the specified model instance.\n\nchange_cctswsomod_chricn\n\nchange_cctswsomod_chricn_2\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified switched shunt.\n\nchange_cctswsomod_con\n\nchange_cctswsomod_con_2\n\n change the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified switched shunt.\n\nchange_cctswsomod_icon\n\nchange_cctswsomod_icon_2\n\n change the value of an integer ICON of the \u201cother\u201d type model attached to a specified switched shunt.\n\nchange_cctswsomod_var\n\nchange_cctswsomod_var_2\n\n change the value of VAR of the \u201cother\u201d type model attached to a specified switched shunt.\n\n--- Character Data \u2014 .txt ---\n\nCharacter Data \u2014 \n\nCharacter Data\u00b6\n\nget_char_length\n\n return the number of characters required to accommodate the data corresponding to the specified STRING entries, which can be for any of the a*Char data retrieval functions.\n\n--- Dc Line Related Models \u2014 .txt ---\n\nDc Line Related Models \u2014 \n\nDc Line Related Models\u00b6\n\nadd_mtdcline_model\n\n add a multi-terminal dc line model to the specified multi-terminal dc line.\n\nadd_ttdcline_model\n\n add a two-terminal dc line model to the specified two-terminal dc line.\n\nadd_vsdcline_model\n\n add a VSC dc line model to the specified VSC dc line.\n\nchange_mtdclmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the multi-terminal dc line model of a specified multi-terminal dc line.\n\nchange_mtdclmod_con\n\n change the value of a CON of the multi-terminal dc line model of a specified multi-terminal dc line.\n\nchange_mtdclmod_data\n\nchange_mtdclmod_icon\n\n change the value of an integer ICON of the multi-terminal dc line model of a specified multi-terminal dc line.\n\nchange_mtdclmod_var\n\n change the value of a VAR of the multi-terminal dc line model of a specified multi-terminal dc line.\n\nchange_ttdclmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the two-terminal dc line model of a specified two-terminal dc line.\n\nchange_ttdclmod_con\n\n change the value of a CON of the two-terminal dc line model of a specified two- terminal dc line.\n\nchange_ttdclmod_data\n\nchange_ttdclmod_icon\n\n change the value of an integer ICON of the two-terminal dc line model of a specified two-terminal dc line.\n\nchange_ttdclmod_var\n\n change the value of a VAR of the two-terminal dc line model of a specified two- terminal dc line.\n\nchange_vsdclmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the VSC dc line model of a specified VSC dc line.\n\nchange_vsdclmod_con\n\n change the value of a CON of the VSC dc line model of a specified VSC dc line.\n\nchange_vsdclmod_data\n\nchange_vsdclmod_icon\n\n change the value of an integer ICON of the VSC dc line model of a specified VSC dc line.\n\nchange_vsdclmod_var\n\n change the value of a VAR of the VSC dc line model of a specified VSC dc line.\n\ndclmod_pack\n\n remove entries that are marked as unused from the dc line model connection tables and the dc line array allocation tables.\n\ndclmod_unconnected\n\n list or remove from dynamics working memory those dc line models that are assigned to dc lines that are not present in the current power flow working case (unconnected).\n\ndclmod_user\n\n list user-written dc line model definitions or to remove user-written dc line model definitions that are not assigned to any dc lines (unused) from the user model definition tables.\n\nmtdclmod_remove\n\n remove the multi-terminal dc line model from a specified multi-terminal dc line.\n\nmtdclmod_status\n\n change the status of the multi-terminal dc line model at a specified multi- terminal dc line.\n\nttdclmod_remove\n\n remove the two-terminal dc line model from a specified two-terminal dc line.\n\nttdclmod_status\n\n change the status of the two-terminal dc line model at a specified two-terminal end line.\n\nvsdclmod_remove\n\n remove the VSC dc line model from a specified VSC dc line.\n\nvsdclmod_status\n\n change the status of the VSC dc line model at a specified VSC dc line.\n\n--- Diagram View \u2014 .txt ---\n\nDiagram View \u2014 \n\nDiagram View\u00b6\n\nchangediagcontour\n\n change the contour parameters for the contour in the active Slider diagram in the GUI.\n\ncheckdiagfile\n\n check the active Slider Diagram in the GUI against the current network case.\n\nclosediagfile\n\n close the active Slider Diagram in the GUI without prompting to save the Diagram.\n\ndeletediagcontour\n\n delete the contour from the active Slider Diagram in the GUI.\n\nenablediagcontour\n\n specify the contour parameters and display a contour in the active Slider Diagram in the GUI.\n\nexportbuslocfile\n\nexportbuslocfile_2\n\n export the bus location from the active Slider Diagram in the GUI to a file.\n\nexportimagefile\n\nexportimagefile_2\n\n export an image of the active Slider Diagram in the GUI to a file.\n\ngexmbus\n\n create a GEXM/GOUT display of a bus in an active Slider diagram in the GUI.\n\ngrowbus\n\n GROW a bus in an active Slider diagram in the GUI.\n\ngrowbuslevels\n\n GROW a bus and all the connected buses up to the specified number of levels away in an active Slider diagram in the GUI.\n\ngrowdiagram\n\ngrowdiagram_2\n\n GROW a bus and all the connected buses in an active Slider diagram in the GUI.\n\ngrowstation\n\nThis API routine was first introduced in release 34.\n\ngrpg\n\n produce a GRPG report in the active Slider diagram in the GUI.\n\nimportdrawfile\n\n import a Draw Data File into an active Slider diagram in the GUI.\n\nimportimagefile\n\n import an image into the background layer of the active Slider diagram in the GUI.\n\nnewdiagfile\n\n open a new Slider diagram in the GUI.\n\nnextdiagfiledataset\n\nThis API is used to display the next element in the active data set on the active Slider diagram.\n\nopenaccfile\n\nopenaccfile_2\n\nThis API is used to open an existing ACC results file for displaying results on diagram.\n\nopenbuslocfile\n\n open an existing bus location file in the GUI.\n\nopendiagfile\n\n open an existing Slider diagram in the GUI.\n\nprevdiagfiledataset\n\nThis API is used to display the previous element in the active data set on the active Slider diagram.\n\nprintdiagfile\n\nprintdiagfile_2\n\n print the active Slider diagram in the GUI.\n\nrefreshdiagcontour\n\n refresh the contour in the active Slider diagram in the GUI.\n\nrefreshdiagfile\n\n refresh the results and styles in the active Slider diagram in the GUI.\n\nrenumdiagfile\n\n renumber buses in the active Slider diagram in the GUI.\n\nsavediagfile\n\n save the active Slider diagram in the GUI.\n\nsetdiagautofile\n\n specify an automation file that is run each time results are updated on the active Slider diagram.\n\nsetdiagfont\n\n specify the default text font in the active Slider diagram.\n\nsetdiagprec\n\nsetdiagprec_2\n\n specify the precision of results displayed in Slider Diagrams.\n\nsetdiagprop\n\nsetdiagprop_2\n\nsetdiagprop_3\n\nsetdiagprop_4\n\nsetdiagprop_5\n\n specify basic properties in the active Slider diagram.\n\nsetdiagresaccc\n\nsetdiagresaccc_2\n\nsetdiagresaccc_3\n\n set the ACCC analysis annotation options in the active Slider diagram.\n\nsetdiagresascc\n\nsetdiagresascc_2\n\nsetdiagresascc_3\n\nThis API is used to set the ASCC short circuit analysis annotation options in the active Slider diagram.\n\nsetdiagresdata\n\nsetdiagresdata_2\n\nsetdiagresdata_3\n\n specify the basic Power Flow annotation options in the active Slider Diagram.\n\nsetdiagresdyn\n\nsetdiagresdyn_2\n\nThis API is used to set the dynamic simulation annotation options in the active Slider diagram.\n\nsetdiagresgdif\n\n specify the case comparison voltage and range checking annotation options in the active Slider diagram.\n\nsetdiagresiec\n\nsetdiagresiec_2\n\nsetdiagresiec_3\n\n specify the IEC annotation options in the active Slider diagram.\n\nsetdiagresmust\n\nThis API is used to set the MUST simulation annotation options in the active Slider diagram.\n\nsetdiagresopf\n\nsetdiagresopf_2\n\nsetdiagresopf_3\n\n specify the OPF annotation options in the active Slider diagram.\n\nsetdiagrespflowcheck\n\nsetdiagrespflowcheck_2\n\nsetdiagrespflowcheck_3\n\n specify the Power Flow voltage and range checking annotation options in the active Slider Diagram.\n\nsetdiagrespflowoptions\n\nsetdiagrespflowoptions_2\n\nsetdiagrespflowoptions_3\n\n specify the basic Power Flow annotation options in the active Slider diagram.\n\nsetdiagresrel\n\nsetdiagresrel_2\n\nsetdiagresrel_3\n\n specify the reliability annotation options in the active Slider diagram.\n\nsetdiagresscgr\n\n specify the short circuit analysis voltage and range checking annotation options in the active Slider diagram.\n\nsetdiagrestypeacc\n\n set the type of results displayed in the active Slider diagram to ACCC results.\n\nsetdiagrestypeascc\n\n set the type of results displayed in the active Slider diagram to ASCC fault calculation results.\n\nsetdiagrestypedata\n\n set the type of results displayed in the active Slider diagram to impedance data values.\n\nsetdiagrestypedyn\n\n set the type of results displayed in the active Slider diagram to Dynamics data results.\n\nsetdiagrestypegdif\n\n set the type of results displayed in the active Slider diagram to the differences in values between the current network case and a supplied comparison case.\n\nsetdiagrestypegic\n\n set the type of results displayed in the active Slider diagram to GIC solution results.\n\nsetdiagrestypeharm\n\n set the type of results displayed in the active Slider diagram to Harmonics solution results.\n\nsetdiagrestypeiec\n\n set the type of results displayed in the active Slider diagram to IEC Fault calculation results.\n\nsetdiagrestypemust\n\n set the type of results displayed in the active Slider diagram to MUST solution results.\n\nsetdiagrestypeopf\n\n set the type of results displayed in the active Slider diagram to OPF solution results.\n\nsetdiagrestypepflow\n\n set the type of results displayed in the active Slider diagram to Power Flow results.\n\nsetdiagrestyperel\n\n set the type of results displayed in the active Slider diagram to reliability analysis results.\n\nsetdiagrestypescgr\n\n set the type of results displayed in the active Slider diagram to the results of a short circuit analysis.\n\nsetdiagrestypetspf\n\n set the type of results displayed in the active Slider diagram to TSPF solution results.\n\nsetdiagresvrcs\n\nsetdiagresvrcs_2\n\n specify the system diagram defaults for Voltage coloring and style, Out of Service coloring and style etc.\n\nsetdiagtitle\n\n set the title of the active Slider diagram.\n\nswitchdiagfiledataset\n\nThis API is used to rotate through values for the current element in the active data set on the active Slider diagram.\n\nupdatebuslocdiagfile\n\n update bus locations in the active Slider diagram in the GUI using the positions found in the current bus location file.\n\n--- Dynamic Simulation Operation \u2014 .txt ---\n\nDynamic Simulation Operation \u2014 \n\nDynamic Simulation Operation\u00b6\n\naddmodellibrary\n\n add a library to the list to be searched for library models.\n\nastr\n\n calculate and replicates the state variable system matrices in the form required by the Linear Dynamic Analysis Program, LSYSAN (activity ASTR).\n\naulist\n\n list auxiliary signal models that inject signals into dc lines or FACTS devices connected to subsystem buses, along with their storage locations in the dynamics data arrays.\n\nchange_channel_out_file\n\n modify the dynamic simulation channel output filename in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).\n\nchange_chricn\n\n change the value of an element of the CHRICN array (a character ICON).\n\nchange_con\n\n change the value of an element of the CON array.\n\nchange_gref\n\n change the value of the element of the GREF (governor reference) array associated with a specified machine.\n\nchange_icon\n\n change the value of an element of the ICON array (an integer ICON).\n\nchange_state\n\n change the value of an element of the STATE array, as well as the values of the corresponding time derivative (DSTATE) and the associated memory cell used in the integration algorithm (STORE).\n\nchange_swsref\n\nchange_swsref_2\n\n change the value of the element of the SWREF array associated with a specified switched shunt.\n\nchange_var\n\n change the value of an element of the VAR array.\n\nchange_vref\n\n change the value of the element of the VREF array associated with a specified machine.\n\ncrctrun\n\n run critical clearing time calculation in dynamic simulations.\n\ndclist\n\n list dc line models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n\ndlst\n\n tabulate specified portions of one or more of the PSSE dynamics data storage arrays.\n\ndocu\n\n tabulate the data associated with equipment models referenced in the user\u2019s simulation setup.\n\ndropmodellibrary\n\n remove a library from the list being searched for library models.\n\ndropmodelprogram\n\n remove a model from the list of known library models; library models are added to this list the first time that they are called.\n\ndyda\n\n replicate dynamics model data in the form of a Dynamics Data Input file.\n\ndynamics_solution_param_2\n\n modify the dynamic simulation solution parameters (except the channel output filename) in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).\n\ndynamics_solution_params\n\ndynamicsmode\n\n return PSSE to dynamics mode following the use of the POWERFLOWMODE API while in dynamics mode.\n\ndynexportcsv\n\n export dynamics engine and dynamics model messages that are displayed after running a dynamics simulation to CSV file format.\n\ndyre_add\n\n read a Dynamics Model Raw Data File and append the model references specified in its data records to the simulation data already contained in dynamics working memory (activity DYRE,ADD).\n\ndyre_new\n\n clear dynamics working memory, read a Dynamics Data File, and place the model references specified on its data records into dynamics working memory.\n\nerun\n\n calculate PSSE state-space dynamic simulations of excitation system response tests.\n\nestr_open_circuit_test\n\n initialize a PSSE dynamic simulation for excitation system open circuit response simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.\n\nestr_response_ratio_test\n\n initialize a PSSE dynamic simulation for excitation system response ratio test simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.\n\nfclist\n\n list FACTS device models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n\ngrun\n\n calculate PSSE state-space dynamic simulations of turbine-governor response tests.\n\ngstr\n\n initialize a PSSE dynamic simulation for governor response simulations and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.\n\nincrement_gref\n\n add a specified value to the value of the element of the GREF (governor reference) array associated with a specified machine.\n\nincrement_swsref\n\nincrement_swsref_2\n\n add a specified value to the value of the element of the SWREF (switched shunt reference) array associated with a specified switched shunt.\n\nincrement_vref\n\n add a specified value to the value of the element of the VREF (voltage reference) array associated with a specified machine.\n\nldclist\n\n list load models connected to subsystem loads along with their storage locations in the dynamics data arrays.\n\nldlist\n\n list load models connected to subsystem loads along with their storage locations in the dynamics data arrays.\n\nload_array_channel\n\n add an output channel containing the active or reactive component of a designated load.\n\nmlst\n\n list plant models connected to subsystem machines along with their storage locations in the dynamics data arrays.\n\nmrun\n\n calculate PSSE extended term dynamic simulations.\n\nmstr\n\n initialize a PSSE dynamic simulation for extended term simulations and to specify the Channel Output File into which the output channel values are to be recorded during the dynamic simulation.\n\npowerflowmode\n\n switch PSSE from dynamics mode to power flow mode.\n\npsas\n\n convert a PSAS Command File into a PSSE Response File.\n\nrllist\n\n list line relay models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n\nrstr\n\n read a dynamics Snapshot File into PSSE working memory.\n\nrun\n\n calculate PSSE state-space dynamic simulations.\n\nrwdy\n\n replicate portions of dynamics model data in the form of either a breaker duty data file, unit inertia and governor data file, or PSSPLT relay characteristic data file.\n\nset_chnfil_type\n\n set/Get the channel output file type (extended type or not).\n\nset_disable_run\n\n enable or disable the simulation option setting that precludes dynamic simulation runs in the event there are fatal errors in the model data.\n\nset_freq_relay_v_thresh\n\nThis API is used to set voltage threshold for use in frequency relay models.\n\nset_genang\n\nset_genang_2\n\nset_genang_3\n\n enable or disable the simulation option setting that scans for generators for which the angle differs from the angular average by more than a specified threshold.\n\nset_genang_subsys_flag\n\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scan for generators exceeding angle threshold.\n\nset_genpwr\n\n enable or disable the simulation option setting that scans for generators for which the mechanical power differs from its electrical power by more than a specified threshold.\n\nset_genspdev\n\n enable or disable the simulation option setting that scans for generators for which the speed deviation is more than a specified threshold.\n\nset_genspdev_subsys_flag\n\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans for generators for which the speed deviation is more than a specified threshold.\n\nset_load_model_thresh\n\nThis API is used to set the MW, P over Q, and load bus voltage thresholds for load models.\n\nset_model_debug_output_flag\n\n enable or disable the simulation option setting for dynamic model debug output.\n\nset_netfrq\n\n enable or disable the simulation option setting that models the frequency dependence of network parameters.\n\nset_next_channel\n\n assign the next available channel index value.\n\nset_next_icon\n\n assign the next available ICON index value.\n\nset_next_var\n\n assign the next available VAR index value.\n\nset_osscan\n\n enable or disable the simulation option setting that scans for out-of-step conditions using a generic relay.\n\nset_osscan_2\n\nset_osscan_subsys_flag\n\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans for out-of-step conditions using a generic relay.\n\nset_relang\n\n enable or disable the simulation option setting that expresses the ANGLE array relative to a designated reference angle.\n\nset_relscn\n\n enable or disable the simulation option setting that scans branches using a generic branch relay.\n\nset_relscn_subsys_flag\n\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans of branches using a generic branch relay.\n\nset_vltscn\n\n enable or disable the simulation option setting that scans buses for high or low values of voltage magnitude.\n\nset_vltscn_subsys_flag\n\nUse this API api for get/set the flag that is used for the subsystem definition for performing scans of buses for high or low voltage magnitudes.\n\nset_volt_viol_subsys_flag\n\nThis API is used to set the flag to denote the bus subsystem to be used for voltage violation (voltage recovery and voltage dip) checks.\n\nset_voltage_dip_check\n\nThis API is used to enable or disable the simulation option setting which scans buses for voltage dip (back-swing).\n\nset_voltage_rec_check\n\nThis API is used to enable or disable the simulation option setting which scans buses for voltage recovery (primary and secondary recovery).\n\nset_zsorce_reconcile_flag\n\n enable or disable the simulation option setting for automatic ZSORCE reconciliation.\n\nsize_ds\n\n obtain a summary of utilization in the general purpose dynamics data storage arrays as well as in the various model connection and allocation tables contained in dynamics working memory.\n\nsnap\n\n save PSSE dynamics working memory into a Snapshot file.\n\nstrt\n\nstrt_2\n\nThis API routine is the second release of the dynamic simulation initialization function.\n\nswslist\n\n list switched shunt models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n\ntrig_volt_violation_check\n\nThis API is used to trigger voltage violation (voltage recovery, voltage dip) checks.\n\nwnlist\n\n list wind models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n\n--- Dynamic Simulation Output Channel Operation \u2014 .txt ---\n\nDynamic Simulation Output Channel Operation \u2014 \n\nDynamic Simulation Output Channel Operation\u00b6\n\nchange_channel\n\n change the channel address and the channel identifier of a specified output channel.\n\nchsb\n\n specify, on a subsystem basis, the simulation variables to monitor during dynamic simulation runs (activity CHSB).\n\ncrt_plot_channel\n\n  assign one of the main simulation output channels to a designated CRT plot channel.\n\ndelete_all_plot_channels\n\n delete all the plot channels in the working case.\n\ndmpc\n\n replicate the output channel specifications from dynamics working memory in the form of a response file suitable for transferring them to another snapshot that models essentially the same system.\n\nlist_channel_models\n\n tabulate the output channel monitoring models referenced in the dynamic model.\n\nremove_unused_chan_models\n\n delete from the output channel monitoring model table those model references indicating equipment that is not present in the power flow working case.\n\n--- Event Studies \u2014 .txt ---\n\nEvent Studies \u2014 \n\nEvent Studies\u00b6\n\ncloseeventstudyfile\n\n close an open Event Study file.\n\nopeneventstudyfile\n\n open a new or existing event study file in the GUI.\n\nrundynamiceventstudy\n\n run a dynamic study using the active event study in the open event study file.\n\nrunpowerfloweventstudy\n\n run a power flow study using the active event study in the open event study file.\n\nsaveeventstudyfile\n\n save existing event studies in an event study file.\n\nsetactiveeventstudy\n\n select an Event Study in an Event file as the active Event Study for running dynamic or power flow event studies.\n\n--- Extension Data Access \u2014 .txt ---\n\nExtension Data Access \u2014 \n\nExtension Data Access\u00b6\n\nget_ext_acline_char\n\n get ac line character extension data.\n\nget_ext_acline_int\n\n get ac line integer extension data.\n\nget_ext_acline_logical\n\n get ac line logical extension data.\n\nget_ext_acline_real\n\n get ac line real extension data.\n\nget_ext_area_char\n\n get area character extension data.\n\nget_ext_area_int\n\n get area integer extension data.\n\nget_ext_area_logical\n\n get area logical extension data.\n\nget_ext_area_real\n\n get area real extension data.\n\nget_ext_bus_char\n\n get bus character extension data.\n\nget_ext_bus_int\n\n get bus integer extension data.\n\nget_ext_bus_logical\n\n get bus logical extension data.\n\nget_ext_bus_real\n\n get bus real extension data.\n\nget_ext_char\n\n get character extension data.\n\nget_ext_facts_char\n\n get facts device character extension data.\n\nget_ext_facts_int\n\n get facts device integer extension data.\n\nget_ext_facts_logical\n\n get facts device logical extension data.\n\nget_ext_facts_real\n\n get facts device real extension data.\n\nget_ext_fixshunt_char\n\n get fixed shunt character extension data.\n\nget_ext_fixshunt_int\n\n get fixed shunt integer extension data.\n\nget_ext_fixshunt_logical\n\n get fixed shunt logical extension data.\n\nget_ext_fixshunt_real\n\n get fixed shunt real extension data.\n\nget_ext_generator_char\n\n get generator character extension data.\n\nget_ext_generator_int\n\n get generator integer extension data.\n\nget_ext_generator_logical\n\n get generator logical extension data.\n\nget_ext_generator_real\n\n get generator real extension data.\n\nget_ext_gne_char\n\n get general network element device character extension data.\n\nget_ext_gne_int\n\n get general network element device integer extension data.\n\nget_ext_gne_logical\n\n get general network element device logical extension data.\n\nget_ext_gne_real\n\n get general network element device real extension data.\n\nget_ext_iatrans_char\n\n get inter-area transfer character extension data.\n\nget_ext_iatrans_int\n\n get inter-area transfer integer extension data.\n\nget_ext_iatrans_logical\n\n get inter-area transfer logical extension data.\n\nget_ext_iatrans_real\n\n get inter-area transfer real extension data.\n\nget_ext_indmach_char\n\n get induction machine character extension data.\n\nget_ext_indmach_int\n\n get induction machine integer extension data.\n\nget_ext_indmach_logical\n\n get induction machine logical extension data.\n\nget_ext_indmach_real\n\n get induction machine real extension data.\n\nget_ext_int\n\n get integer extension data.\n\nget_ext_load_char\n\n get load character extension data.\n\nget_ext_load_int\n\n get load integer extension data.\n\nget_ext_load_logical\n\n get load logical extension data.\n\nget_ext_load_real\n\n get load real extension data.\n\nget_ext_logical\n\n get logical extension data.\n\nget_ext_msline_char\n\n get multi-section line character extension data.\n\nget_ext_msline_int\n\n get multi-section line integer extension data.\n\nget_ext_msline_logical\n\n get multi-section line logical extension data.\n\nget_ext_msline_real\n\n get multi-section line real extension data.\n\nget_ext_ntermdc_char\n\n get multi-terminal dc line character extension data.\n\nget_ext_ntermdc_int\n\n get multi-terminal dc line integer extension data.\n\nget_ext_ntermdc_logical\n\n get multi-terminal dc line logical extension data.\n\nget_ext_ntermdc_real\n\n get multi-terminal dc line real extension data.\n\nget_ext_owner_char\n\n get owner character extension data.\n\nget_ext_owner_int\n\n get owner integer extension data.\n\nget_ext_owner_logical\n\n get owner logical extension data.\n\nget_ext_owner_real\n\n get owner real extension data.\n\nget_ext_rating_char\n\n get rating character extension data.\n\nget_ext_rating_int\n\n get rating integer extension data.\n\nget_ext_rating_logical\n\n get rating logical extension data.\n\nget_ext_rating_real\n\n get rating real extension data.\n\nget_ext_real\n\n get real extension data.\n\nget_ext_rowcount\n\n get extension data table row count.\n\nget_ext_sub_char\n\n get substation character extension data.\n\nget_ext_sub_int\n\n get substation integer extension data.\n\nget_ext_sub_logical\n\n get substation logical extension data.\n\nget_ext_sub_real\n\n get substation real extension data.\n\nget_ext_subnode_char\n\n get substation node character extension data.\n\nget_ext_subnode_int\n\n get substation node integer extension data.\n\nget_ext_subnode_logical\n\n get substation node logical extension data.\n\nget_ext_subnode_real\n\n get substation node real extension data.\n\nget_ext_subswd_char\n\n get substation switching device character extension data.\n\nget_ext_subswd_int\n\n get substation switching device integer extension data.\n\nget_ext_subswd_logical\n\n get substation switching device logical extension data.\n\nget_ext_subswd_real\n\n get substation switching device real extension data.\n\nget_ext_swshunt_char\n\n get switched shunt character extension data.\n\nget_ext_swshunt_int\n\n get switched shunt integer extension data.\n\nget_ext_swshunt_logical\n\n get switched shunt logical extension data.\n\nget_ext_swshunt_real\n\n get switched shunt real extension data.\n\nget_ext_sysswd_char\n\n get system switching device character extension data.\n\nget_ext_sysswd_int\n\n get system switching device integer extension data.\n\nget_ext_sysswd_logical\n\n get system switching device logical extension data.\n\nget_ext_sysswd_real\n\n get system switching device real extension data.\n\nget_ext_transformer_char\n\n get transformer character extension data.\n\nget_ext_transformer_int\n\n get transformer integer extension data.\n\nget_ext_transformer_logical\n\n get transformer logical extension data.\n\nget_ext_transformer_real\n\n get transformer real extension data.\n\nget_ext_twotermdc_char\n\n get two-terminal dc line character extension data.\n\nget_ext_twotermdc_int\n\n get two-terminal dc line integer extension data.\n\nget_ext_twotermdc_logical\n\n get two-terminal dc line logical extension data.\n\nget_ext_twotermdc_real\n\n get two-terminal dc line real extension data.\n\nget_ext_vscdc_char\n\n get voltage source converter dc line character extension data.\n\nget_ext_vscdc_int\n\n get voltage source converter dc line integer extension data.\n\nget_ext_vscdc_logical\n\n get voltage source converter dc line logical extension data.\n\nget_ext_vscdc_real\n\n get voltage source converter dc line real extension data.\n\nget_ext_zone_char\n\n get zone character extension data.\n\nget_ext_zone_int\n\n get zone integer extension data.\n\nget_ext_zone_logical\n\n get zone logical extension data.\n\nget_ext_zone_real\n\n get zone real extension data.\n\nset_ext_acline_char\n\n set ac line character extension data.\n\nset_ext_acline_int\n\n set ac line integer extension data.\n\nset_ext_acline_logical\n\n set ac line logical extension data.\n\nset_ext_acline_real\n\n set ac line real extension data.\n\nset_ext_area_char\n\n set area character extension data.\n\nset_ext_area_int\n\n set area integer extension data.\n\nset_ext_area_logical\n\n set area logical extension data.\n\nset_ext_area_real\n\n set area real extension data.\n\nset_ext_bus_char\n\n set bus character extension data.\n\nset_ext_bus_int\n\n set bus integer extension data.\n\nset_ext_bus_logical\n\n set bus logical extension data.\n\nset_ext_bus_real\n\n set bus real extension data.\n\nset_ext_char\n\n set character extension data.\n\nset_ext_facts_char\n\n set facts device character extension data.\n\nset_ext_facts_int\n\n set facts device integer extension data.\n\nset_ext_facts_logical\n\n set facts device logical extension data.\n\nset_ext_facts_real\n\n set facts device real extension data.\n\nset_ext_fixshunt_char\n\n set fixed shunt character extension data.\n\nset_ext_fixshunt_int\n\n set fixed shunt integer extension data.\n\nset_ext_fixshunt_logical\n\n set fixed shunt logical extension data.\n\nset_ext_fixshunt_real\n\n set fixed shunt real extension data.\n\nset_ext_generator_char\n\n set generator character extension data.\n\nset_ext_generator_int\n\n set generator integer extension data.\n\nset_ext_generator_logical\n\n set generator logical extension data.\n\nset_ext_generator_real\n\n set generator real extension data.\n\nset_ext_gne_char\n\n set general network element device character extension data.\n\nset_ext_gne_int\n\n set general network element device integer extension data.\n\nset_ext_gne_logical\n\n set general network element device logical extension data.\n\nset_ext_gne_real\n\n set general network element device real extension data.\n\nset_ext_iatrans_char\n\n set inter-area transfer character extension data.\n\nset_ext_iatrans_int\n\n set inter-area transfer integer extension data.\n\nset_ext_iatrans_logical\n\n set inter-area transfer logical extension data.\n\nset_ext_iatrans_real\n\n set inter-area transfer real extension data.\n\nset_ext_indmach_char\n\n set induction machine character extension data.\n\nset_ext_indmach_int\n\n set induction machine integer extension data.\n\nset_ext_indmach_logical\n\n set induction machine logical extension data.\n\nset_ext_indmach_real\n\n set induction machine real extension data.\n\nset_ext_int\n\n set integer extension data.\n\nset_ext_load_char\n\n set load character extension data.\n\nset_ext_load_int\n\n set load integer extension data.\n\nset_ext_load_logical\n\n set load logical extension data.\n\nset_ext_load_real\n\n set load real extension data.\n\nset_ext_logical\n\n set logical extension data.\n\nset_ext_msline_char\n\n set multi-section line character extension data.\n\nset_ext_msline_int\n\n set multi-section line integer extension data.\n\nset_ext_msline_logical\n\n set multi-section line logical extension data.\n\nset_ext_msline_real\n\n set multi-section line real extension data.\n\nset_ext_ntermdc_char\n\n set multi-terminal dc line character extension data.\n\nset_ext_ntermdc_int\n\n set multi-terminal dc line integer extension data.\n\nset_ext_ntermdc_logical\n\n set multi-terminal dc line logical extension data.\n\nset_ext_ntermdc_real\n\n set multi-terminal dc line real extension data.\n\nset_ext_owner_char\n\n set owner character extension data.\n\nset_ext_owner_int\n\n set owner integer extension data.\n\nset_ext_owner_logical\n\n set owner logical extension data.\n\nset_ext_owner_real\n\n set owner real extension data.\n\nset_ext_rating_char\n\n set rating character extension data.\n\nset_ext_rating_int\n\n set rating integer extension data.\n\nset_ext_rating_logical\n\n set rating logical extension data.\n\nset_ext_rating_real\n\n set rating real extension data.\n\nset_ext_real\n\n set real extension data.\n\nset_ext_sub_char\n\n set substation character extension data.\n\nset_ext_sub_int\n\n set substation integer extension data.\n\nset_ext_sub_logical\n\n set substation logical extension data.\n\nset_ext_sub_real\n\n set substation real extension data.\n\nset_ext_subnode_char\n\n set substation node character extension data.\n\nset_ext_subnode_int\n\n set substation node integer extension data.\n\nset_ext_subnode_logical\n\n set substation node logical extension data.\n\nset_ext_subnode_real\n\n set substation node real extension data.\n\nset_ext_subswd_char\n\n set substation switching device character extension data.\n\nset_ext_subswd_int\n\n set substation switching device integer extension data.\n\nset_ext_subswd_logical\n\n set substation switching device logical extension data.\n\nset_ext_subswd_real\n\n set substation switching device real extension data.\n\nset_ext_swshunt_char\n\n set switched shunt character extension data.\n\nset_ext_swshunt_int\n\n set switched shunt integer extension data.\n\nset_ext_swshunt_logical\n\n set switched shunt logical extension data.\n\nset_ext_swshunt_real\n\n set switched shunt real extension data.\n\nset_ext_sysswd_char\n\n set system switching device character extension data.\n\nset_ext_sysswd_int\n\n set system switching device integer extension data.\n\nset_ext_sysswd_logical\n\n set system switching device logical extension data.\n\nset_ext_sysswd_real\n\n set system switching device real extension data.\n\nset_ext_transformer_char\n\n set transformer character extension data.\n\nset_ext_transformer_int\n\n set transformer integer extension data.\n\nset_ext_transformer_logical\n\n set transformer logical extension data.\n\nset_ext_transformer_real\n\n set transformer real extension data.\n\nset_ext_twotermdc_char\n\n set two-terminal dc line character extension data.\n\nset_ext_twotermdc_int\n\n set two-terminal dc line integer extension data.\n\nset_ext_twotermdc_logical\n\n set two-terminal dc line logical extension data.\n\nset_ext_twotermdc_real\n\n set two-terminal dc line real extension data.\n\nset_ext_vscdc_char\n\n set voltage source converter dc line character extension data.\n\nset_ext_vscdc_int\n\n set voltage source converter dc line integer extension data.\n\nset_ext_vscdc_logical\n\n set voltage source converter dc line logical extension data.\n\nset_ext_vscdc_real\n\n set voltage source converter dc line real extension data.\n\nset_ext_zone_char\n\n set zone character extension data.\n\nset_ext_zone_int\n\n set zone integer extension data.\n\nset_ext_zone_logical\n\n set zone logical extension data.\n\nset_ext_zone_real\n\n set zone real extension data.\n\n--- Facts Device Bus Data \u2014 .txt ---\n\nFacts Device Bus Data \u2014 \n\nFacts Device Bus Data\u00b6\n\nafactsbuschar\n\n return an array of character values for subsystem FACTS device buses.\n\nafactsbuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device bus data family.\n\nafactsbuscplx\n\n return an array of complex values for subsystem FACTS device buses.\n\nafactsbusint\n\n return an array of integer values for subsystem FACTS device buses.\n\nafactsbusreal\n\n return an array of real values for subsystem FACTS device buses.\n\nafactsbustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device bus data family (aFactsBusInt, aFactsBusReal, aFactsBusCplx and aFactsBusChar).\n\n--- Facts Device Data \u2014 .txt ---\n\nFacts Device Data \u2014 \n\nFacts Device Data\u00b6\n\nafactschar\n\n return an array of character values for subsystem FACTS devices.\n\nafactscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device data family.\n\nafactscplx\n\n return an array of complex values for subsystem FACTS devices.\n\nafactsint\n\n return an array of integer values for subsystem FACTS devices.\n\nafactsreal\n\n return an array of real values for subsystem FACTS devices.\n\nafactstypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device data family (aFactsInt, aFactsReal, aFactsCplx and aFactsChar).\n\n--- Facts Device Models \u2014 .txt ---\n\nFacts Device Models \u2014 \n\nFacts Device Models\u00b6\n\nadd_facts_device_model\n\n add a FACTS device model to the specified FACTS device.\n\nchange_fctmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the FACTS device model of a specified FACTS device.\n\nchange_fctmod_con\n\n change the value of a CON of the FACTS device model of a specified FACTS device.\n\nchange_fctmod_data\n\nchange_fctmod_icon\n\n change the value of an integer ICON of the FACTS device model of a specified FACTS device.\n\nchange_fctmod_var\n\n change the value of a VAR of the FACTS device model of a specified FACTS device.\n\nfctmod_pack\n\n remove entries that are marked as unused from the FACTS device model connection tables and the FACTS device model array allocation tables.\n\nfctmod_remove\n\n remove the FACTS device model from a specified FACTS device.\n\nfctmod_status\n\n change the status of the FACTS device model at a specified FACTS device.\n\nfctmod_unconnected\n\n list or remove from dynamics working memory those FACTS device models that are assigned to FACTS device that are not present in the current power flow working case (unconnected).\n\nfctmod_user\n\n list user-written FACTS device model definitions or to remove user-written FACTS device model definitions that are not assigned to any FACTS devices (unused) from the user model definition tables.\n\ngmb_add_facts_dev_model\n\n add a GMB FACTS device model to the specified FACTS device.\n\n--- Fault Analysis Data \u2014 .txt ---\n\nFault Analysis Data \u2014 \n\nFault Analysis Data\u00b6\n\nmbidncs\n\n change the table name of the specified non-conventional source fault contribution table in the working case.\n\nseq_3_wind_grounding_data\n\n modify the zero sequence grounding data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).\n\nseq_3_wind_winding_data\n\n modify the zero sequence impedance data of one winding of an existing three- winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).\n\nseq_branch_data\n\nseq_branch_data_3\n\n modify the zero sequence data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Zero Sequence Non-Transformer Branch Data).\n\nseq_bus_data\n\nBus load sequence data is now accessible as load sequence data.\n\nseq_fixed_shunt_data\n\n modify the zero sequence data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Fixed Shunt Data).\n\nseq_induction_mach_data\n\nseq_induction_mach_data_2\n\nUse this API routine to modify the sequence data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Impedance Data).\n\nseq_load_data\n\nUse this API routine to modify the sequence data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).\n\nseq_machine_data\n\nseq_machine_data_3\n\nseq_machine_data_4\n\nUse this API routine to modify the sequence data of an existing machine in the working case (see PSSE Program Operation Manual, Positive Sequence Generator Impedance Data, Negative Sequence Generator Impedance Data and Zero Sequence Generator Impedance Data).\n\nseq_machine_ncs_data\n\nUse this API routine to modify a machine\u2019s existing non-conventional source fault current contribution (NCSFCC) data or to add NCSFCC data to an existing machine in the working case.\n\nseq_machine_ncs_data_purg\n\nUse this API routine to delete a machine\u2019s existing non-conventional source fault current contribution (NCSFCC) data.\n\nseq_mutual_data\n\n modify existing zero sequence mutual impedance data in the working case or to add a new zero sequence mutual coupling to the working case (see PSSE Program Operation Manual, Zero Sequence Mutual Impedance Data).\n\nseq_ncs_flt_cntrb_chng\n\nThis API routine was first introduced in release 34.\n\nseq_ncs_flt_cntrb_data\n\nseq_ncs_flt_cntrb_purg\n\nseq_ncs_table_data\n\n modify the data of an existing non-conventional source fault contribution table in the working case or to add a new non-conventional source fault contribution table to the working case.\n\nseq_ncs_table_onept\n\n modify the one data point of an existing non-conventional source fault contribution table in the working case or to add a new one data point to non-conventional source fault contribution table to the working case.\n\nseq_ncs_table_purg\n\n delete an existing non-conventional source fault contribution table from the working case.\n\nseq_ncs_table_purg_onept\n\n delete specified data point in an existing non-conventional source fault contribution table.\n\nseq_ncs_table_type\n\n get NCS table type.\n\nseq_switched_shunt_data\n\nseq_switched_shunt_data_3\n\n modify the zero sequence data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Switched Shunt Data).\n\nseq_three_winding_data\n\nseq_three_winding_data_3\n\n modify the zero sequence data of an existing three-winding transformer in the working case.\n\nseq_two_winding_data\n\nseq_two_winding_data_3\n\n modify the zero sequence data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).\n\n--- Fault Analysis Operation \u2014 .txt ---\n\nFault Analysis Operation \u2014 \n\nFault Analysis Operation\u00b6\n\nansi\n\nansi_2\n\nansi_3\n\nThis API routine executes the third release of the ANSI fault calculation function.\n\nascc\n\nascc_1a\n\nascc_2\n\nascc_3\n\nThis API is used to apply a series of faults at various locations in the working case.\n\nascc_scfile\n\nThis API reads ASCC short circuit results from SCFILE and produces same ASCC output report that was generated when SCFILE was created.\n\nbkdy\n\n calculate and report circuit breaker interrupting duty for 3-phase faults at all buses in a specified subsystem of the working case (activity BKDY).\n\ncheck_sequence_data\n\nUse this API routine to perform data checks on the selected categories of sequence data for all buses in the working case or for all buses in a specified subsystem.\n\nflat\n\nflat_2\n\nThis API routine is the second release of the flat conditions function.\n\niecs\n\niecs_2\n\niecs_3\n\niecs_4\n\nThis API executes the fourth release of the IEC short circuit calculations function.\n\niecs_scfile\n\nThis API reads IECS short circuit results from SCFILE and produces same IECS output report that was generated when SCFILE was created.\n\nnewseq\n\n initialize the fault analysis data arrays, set them to default values, and set the flag indicating that sequence data is present in the working case.\n\nsceq\n\n construct network equivalents of the positive and zero sequence networks and calculates source impedances at equivalent source nodes for all three sequences in preparation for the unbalanced fault analysis activities of PSSE.\n\nscgr\n\nscmu\n\nscmu_2\n\n calculate simultaneous unbalances.\n\nscop\n\n tabulate unbalanced fault solution output.\n\nseqd\n\nseqd_2\n\nUse this API routine to factorize the sequence matrices in preparation for unbalanced fault calculations SCMU and SPCB.\n\nsequence_network_setup\n\n specify or return the option to enable or disable automatic fault analysis sequence network setup.\n\nsqex\n\n tabulate all fault analysis data pertaining to a specified bus.\n\n--- Fixed Shunt Bus Data \u2014 .txt ---\n\nFixed Shunt Bus Data \u2014 \n\nFixed Shunt Bus Data\u00b6\n\nafxshntbuschar\n\n return an array of character values for subsystem buses.\n\nafxshntbuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt bus data family.\n\nafxshntbuscplx\n\n return an array of complex values for subsystem buses.\n\nafxshntbusint\n\n return an array of integer values for subsystem buses.\n\nafxshntbusreal\n\n return an array of real values for subsystem buses.\n\nafxshntbustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt bus data family (aFxShntBusInt, aFxShntBusReal, aFxShntBusCplx and aFxShntBusChar).\n\n--- Fixed Shunt Data \u2014 .txt ---\n\nFixed Shunt Data \u2014 \n\nFixed Shunt Data\u00b6\n\nafxshuntchar\n\n return an array of character values for subsystem fixed shunts.\n\nafxshuntcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt data family.\n\nafxshuntcplx\n\n return an array of complex values for subsystem fixed shunts.\n\nafxshuntint\n\n return an array of integer values for subsystem fixed shunts.\n\nafxshuntreal\n\n return an array of real values for subsystem fixed shunts.\n\nafxshunttypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt data family (aFxShuntInt, aFxShuntReal, aFxShuntCplx and aFxShuntChar).\n\n--- Gic Data \u2014 .txt ---\n\nGic Data \u2014 \n\nGic Data\u00b6\n\ngic_2tdc\n\n modify or add new two terminal dc GIC shunt data to the working case.\n\ngic_2tdc_chng\n\n modify new two terminal dc GIC shunt data from the working case.\n\ngic_2tdc_purg\n\n purge new two terminal dc GIC shunt data from the working case.\n\ngic_brn\n\n modify or add new GIC branch data to the working case.\n\ngic_brn_chng\n\n modify new GIC branch data from the working case.\n\ngic_brn_purg\n\n purge GIC branch data from the working case.\n\ngic_earth1d_usr\n\n modify or add new GIC User 1D Earth Model data to the working case.\n\ngic_earth1d_usr_chng\n\n modify GIC User 1D Earth Model data from the working case.\n\ngic_facts\n\n modify or add new FACTS device GIC shunt data to the working case.\n\ngic_facts_chng\n\n modify new FACTS device GIC shunt data from the working case.\n\ngic_facts_purg\n\n purge new FACTS device GIC shunt data from the working case.\n\ngic_fxsh\n\n modify or add new fixed shunt GIC shunt data to the working case.\n\ngic_fxsh_chng\n\n modify fixed shunt GIC shunt data from the working case.\n\ngic_fxsh_purg\n\n purge fixed shunt GIC shunt data from the working case.\n\ngic_load\n\n modify or add new load GIC shunt data to the working case.\n\ngic_load_chng\n\n modify load GIC shunt data from the working case.\n\ngic_load_purg\n\n purge load GIC shunt data from the working case.\n\ngic_mtdc\n\n modify or add new multi terminal dc GIC shunt data to the working case.\n\ngic_mtdc_chng\n\n modify new multi terminal dc GIC shunt data from the working case.\n\ngic_mtdc_purg\n\n purge new multi terminal dc GIC shunt data from the working case.\n\ngic_substn\n\n modify or add new GIC sub station data to the working case.\n\ngic_substn_chng\n\n modify GIC sub station data to the working case.\n\ngic_substn_purg\n\n purge GIC sub station data to the working case.\n\ngic_swsh\n\n modify or add new GIC switched shunt data to the working case.\n\ngic_swsh_chng\n\n modify GIC switched shunt data from the working case.\n\ngic_swsh_purg\n\n purge GIC switched shunt data from the working case.\n\ngic_trn\n\n modify or add new GIC transformer data to the working case.\n\ngic_trn_chng\n\n modify GIC transformer data to the working case.\n\ngic_trn_purg\n\n purge GIC transformer data from the working case.\n\ngic_vscdc\n\n modify or add new vscdc GIC shunt data to the working case.\n\ngic_vscdc_chng\n\n modify new vscdc GIC shunt data from the working case.\n\ngic_vscdc_purg\n\n purge new vscdc GIC shunt data from the working case.\n\n--- Gic Operation \u2014 .txt ---\n\nGic Operation \u2014 \n\nGic Operation\u00b6\n\ngic\n\ngic_2\n\ngic_3\n\ngic_4\n\ngic_5\n\ngic_6\n\ngic_7\n\ngic_8\n\n calculate Geomagnetically Induced Currents (GIC) in electric power system network as a result of Geomagnetic Disturbance (GMD).\n\ngic_branch_efield_nn\n\n calculate geoelectric efield induced in the network branches from specified geoelectric efield grid data using nearest neigbor (NN) alogorithm.\n\ngic_earth1d_usr_purg\n\n purge GIC User 1D Earth Model data from the working case.\n\ngic_efield_waveshape\n\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as provided in EFLDFILE.\n\ngic_efield_waveshape_ref\n\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 benhcmark event.\n\ngic_efield_waveshape_supp\n\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 supplemental event.\n\ngic_mvarloss_scaling_factors\n\nSpecify KFACTORS to determine transformer reactive power losses due to geomagnetic currents (GICs) flow.\n\ngic_new\n\n initialize all data records required for GIC analysis.\n\ngic_pf_options\n\n specify the Newton-Raphson power flow solution options used in GIC.\n\ngic_purg\n\n purge all GIC data from the working case.\n\ngic_read\n\n read GIC Data Text (.gic) File into the working case memory.\n\ngic_read_efield_grid\n\n read Geoelectric Efield Grid Data File into the working case memory.\n\ngic_thermal_impact\n\ngic_thermal_impact_1\n\n calculate Transformer Thermal Impact assessement GIC(t) curve using specified effective Eastward GIC(E) and Nortward GIC(N) for one specific transformer.\n\ngic_write\n\n write working case GIC Data to text (.gic) file.\n\ngic_write_stn\n\n write working case GIC Data to text (.gic) file version 4 that has substation data.\n\n--- Graphical Analysis Output \u2014 .txt ---\n\nGraphical Analysis Output \u2014 \n\nGraphical Analysis Output\u00b6\n\npoly_print\n\n print the results of activity POLY from a .pol results file.\n\npv_print\n\n print the results of PV analysis from the .pv results file\n\nqv_print\n\n print the results of QV analysis from a .qv resultsfile.\n\nsetfullviewgrapharea\n\n specify the parameters of the scales used for plotting the results of PV and QV analysis.\n\nsetfullviewscale\n\n specify the parameters of the scales used for plotting the results of PV and QV analysis.\n\n--- Harmonics Data \u2014 .txt ---\n\nHarmonics Data \u2014 \n\nHarmonics Data\u00b6\n\nhar_2tdc\n\n modify or add new harmonics Two Terminal DC data to the working case.\n\nhar_2tdc_chng\n\n modify harmonics Two Terminal DC data in the working case.\n\nhar_2tdc_purg\n\n purge specified harmonics Two Terminal DC data from the working case.\n\nhar_brn\n\n modify or add new harmonics branch data to the working case.\n\nhar_brn_chng\n\n modify harmonics branch data to the working case.\n\nhar_brn_purg\n\n purge specified harmonics branch data from the working case.\n\nhar_cursrc\n\n modify or add new harmonics current source table data to the working case.\n\nhar_cursrc_chng\n\n change harmonics current source table data in the working case.\n\nhar_cursrc_chng_name\n\n change harmonics current source table name in the working case.\n\nhar_cursrc_chng_onept\n\n modify one data point to harmonics current source table in the working case.\n\nhar_cursrc_name\n\n add or change harmonics current source table name in the working case.\n\nhar_cursrc_onept\n\n modify or add new one data point to harmonics current source table in the working case.\n\nhar_cursrc_purg\n\n purge specified harmonics current source table data from the working case.\n\nhar_cursrc_purg_onept\n\n purge specified data point in harmonics current source table.\n\nhar_facts\n\n modify or add new harmonics FACTS device data to the working case.\n\nhar_facts_chng\n\n modify harmonics FACTS device data in the working case.\n\nhar_facts_purg\n\n purge specified harmonics FACTS device data from the working case.\n\nhar_impchar\n\n modify or add new harmonics impedance characteristics table data to the working case.\n\nhar_impchar_chng\n\n change harmonics impedance characteristics table data in the working case.\n\nhar_impchar_chng_name\n\n change harmonics impedance characteristics table name in the working case.\n\nhar_impchar_chng_onept\n\n modify one data point to harmonics impedance characteristics table in the working case.\n\nhar_impchar_name\n\n add or change harmonics impedance characteristics table name in the working case.\n\nhar_impchar_onept\n\n modify or add new one data point to harmonics impedance characteristics table in the working case.\n\nhar_impchar_purg\n\n purge specified harmonics impedance characteristics table data from the working case.\n\nhar_impchar_purg_onept\n\n purge specified data point in harmonics impedance characteristics table.\n\nhar_indmc\n\n modify or add new harmonics induction machine data to the working case.\n\nhar_indmc_chng\n\n modify harmonics induction machine data to the working case.\n\nhar_indmc_purg\n\n purge specified harmonics induction machine data from the working case.\n\nhar_load\n\n modify or add new harmonics load data to the working case.\n\nhar_load_chng\n\n modify harmonics load data to the working case.\n\nhar_load_purg\n\n purge specified harmonics load data from the working case.\n\nhar_mach\n\n modify or add new harmonics machine data to the working case.\n\nhar_mach_chng\n\n modify harmonics machine data to the working case.\n\nhar_mach_purg\n\n purge specified harmonics machine data from the working case.\n\nhar_mtdc\n\n modify or add new harmonics Multi Terminal DC data to the working case.\n\nhar_mtdc_chng\n\n modify harmonics Multi Terminal DC data in the working case.\n\nhar_mtdc_purg\n\n purge specified harmonics Multi Terminal DC data from the working case.\n\nhar_passive_filter\n\n modify or add new harmonics passive filter data to the working case.\n\nhar_passive_filter_chng\n\n modify harmonics passive filter data in the working case.\n\nhar_passive_filter_purg\n\n purge specified harmonics passive filter data from the working case.\n\nhar_set_par_lodmdl_cigre_measurement\n\n set parameters for harmonics load data user model CIGRE_MEASUREMENT.\n\nhar_set_par_lodmdl_cigre_motive\n\n set parameters for harmonics load data user model CIGRE_MOTIVE.\n\nhar_set_par_lodmdl_cigre_passive\n\n set parameters for harmonics load data user model CIGRE_PASSIVE.\n\nhar_set_par_lodmdl_ieee_2rl_parallel\n\n set parameters for harmonics load data user model IEEE_2RL_PARALLEL.\n\nhar_set_par_lodmdl_ieee_im\n\n set parameters for harmonics load data user model IEEE_IM.\n\nhar_set_par_lodmdl_ieee_measurement\n\n set parameters for harmonics load data user model IEEE_MEASUREMENT.\n\nhar_set_par_lodmdl_ieee_skin\n\n set parameters for harmonics load data user model IEEE_SKIN.\n\nhar_set_par_lodmdl_large_async_motor\n\n set parameters for harmonics load data user model LARGE_ASYNC_MOTOR.\n\nhar_trn\n\n modify or add new harmonics transformer data to the working case.\n\nhar_trn_chng\n\n modify harmonics transformer data to the working case.\n\nhar_trn_purg\n\n purge specified harmonics transformer data from the working case.\n\nhar_vltsrc\n\n modify or add new harmonics voltage source table data to the working case.\n\nhar_vltsrc_chng\n\n change harmonics voltage source table data in the working case.\n\nhar_vltsrc_chng_name\n\n change harmonics voltage source table name in the working case.\n\nhar_vltsrc_chng_onept\n\n modify one data point to harmonics voltage source table in the working case.\n\nhar_vltsrc_name\n\n add or change harmonics voltage source table name in the working case.\n\nhar_vltsrc_onept\n\n modify or add new one data point to harmonics voltage source table in the working case.\n\nhar_vltsrc_purg\n\n purge specified harmonics voltage source table data from the working case.\n\nhar_vltsrc_purg_onept\n\n purge specified data point in harmonics voltage source table.\n\nhar_vscdc\n\n modify or add new harmonics VSCDC data to the working case.\n\nhar_vscdc_chng\n\n modify harmonics VSCDC data in the working case.\n\nhar_vscdc_purg\n\n purge specified harmonics VSCDC data from the working case.\n\n--- Harmonics Operation \u2014 .txt ---\n\nHarmonics Operation \u2014 \n\nHarmonics Operation\u00b6\n\nhar_analysis\n\nhar_analysis_2\n\n run harmonics analysis.\n\nhar_create_pfcase\n\n save working case updated for harmonic frequency and passive filters added as fixed shunts.\n\nhar_exists_dstn_results\n\nCheck if Harmonics Distortion Calculation results available in PSSE working memory from previously run harmonic analysis activity.\n\nhar_exists_fscan_results\n\nCheck if Harmonics Frequency Scan results available in PSSE working memory from previously run harmonic analysis activity.\n\nhar_export_dstn\n\n export harmonics distortion calculation results to comma separated (.csv) file.\n\nhar_export_fscan\n\n export harmonics frequency scan results to comma separated (.csv) file.\n\nhar_new\n\n initialize all data records required for Harmonics analysis.\n\nhar_purg\n\n purge all harmonics data from the working case.\n\nhar_set_resn_thresholds\n\n set parameters to filter resonances from harmonic analysis frequency scan response.\n\nhar_set_resn_thresholds_default\n\n set default parameters to filter resonances from harmonic analysis frequency scan response.\n\n--- Induction Machine Bus Data \u2014 .txt ---\n\nInduction Machine Bus Data \u2014 \n\nInduction Machine Bus Data\u00b6\n\naindmacbuschar\n\nUse this API routine to return an array of character values for subsystem buses.\n\naindmacbuscount\n\nUse this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine bus data family.\n\naindmacbuscplx\n\nUse this API routine to return an array of complex values for subsystem buses.\n\naindmacbusint\n\nUse this API routine to return an array of integer values for subsystem buses.\n\naindmacbusreal\n\nUse this API routine to return an array of real values for subsystem buses.\n\naindmacbustypes\n\nUse this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine bus data family (aIndMacBusInt, aIndMacBusReal, aIndMacBusCplx and aIndMacBusChar).\n\n--- Induction Machine Data \u2014 .txt ---\n\nInduction Machine Data \u2014 \n\nInduction Machine Data\u00b6\n\naindmacchar\n\nUse this API routine to return an array of character values for subsystem induction machines.\n\naindmaccount\n\nUse this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine data family.\n\naindmaccplx\n\nUse this API routine to return an array of complex values for subsystem induction machines.\n\naindmacint\n\nUse this API routine to return an array of integer values for subsystem induction machines.\n\naindmacreal\n\nUse this API routine to return an array of real values for subsystem induction machines.\n\naindmactypes\n\nUse this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine data family (aIndMacInt, aIndMacReal, aIndMacCplx and aIndMacChar).\n\n--- Induction Machine Models \u2014 .txt ---\n\nInduction Machine Models \u2014 \n\nInduction Machine Models\u00b6\n\nadd_indmac_model\n\n add an induction machine model to a specified machine.\n\nchange_immod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of an induction machine model at a specified machine.\n\nchange_immod_con\n\n change the value of a CON of a designated induction machine model at a specified machine.\n\nchange_immod_icon\n\n change the value of an integer ICON of a designated induction machine model at a specified machine.\n\nchange_immod_var\n\n change the value of a VAR of a designated induction machine model at a specified machine.\n\nimmod_pack\n\n remove entries that are marked as unused from the induction machine model contables.\n\nimmod_remove\n\n remove an induction machine model of a designated type from a specified machine.\n\nimmod_status\n\n change the status of an induction machine model at a specified machine.\n\nimmod_unconnected\n\n list or remove from dynamics working memory those induction machine models that are assigned to machines that are not present in the current power flow working case (unconnected).\n\nimmod_user\n\n list user-written induction machine model definitions or to remove user-written induction machine model definitions that are not assigned to any machines (unused) from the user model definition tables.\n\n--- Line Relay Models \u2014 .txt ---\n\nLine Relay Models \u2014 \n\nLine Relay Models\u00b6\n\nadd_relay_model\n\n add a line relay model in the designated relay slot of the from bus end of a specified branch.\n\nchange_rlmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nchange_rlmod_con\n\n change the value of a CON of the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nchange_rlmod_data\n\nchange_rlmod_icon\n\n change the value of an integer ICON of the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nchange_rlmod_var\n\n change the value of a VAR of the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nrlmod_pack\n\n remove entries that are marked as unused from the line relay model connection tables and the line relay model array allocation tables.\n\nrlmod_remove\n\n remove the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nrlmod_status\n\n change the status of the line relay model in the designated relay slot of the from bus end of a specified branch.\n\nrlmod_unconnected\n\n list or remove from dynamics working memory those line relay models that are assigned to branches that are not present in the current power flow working case (unconnected).\n\nrlmod_user\n\n list user-written line relay model definitions or to remove user-written line relay model definitions that are not assigned to any branches (unused) from the user model definition tables.\n\n--- Load Bus Data \u2014 .txt ---\n\nLoad Bus Data \u2014 \n\nLoad Bus Data\u00b6\n\nalodbuschar\n\n return an array of character values for subsystem buses.\n\nalodbuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the load bus data family.\n\nalodbuscplx\n\n return an array of complex values for subsystem buses.\n\nalodbusint\n\n return an array of integer values for subsystem buses.\n\nalodbusreal\n\n return an array of real values for subsystem buses.\n\nalodbustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load bus data family (aLodBusInt, aLodBusReal, aLodBusCplx and aLodBusChar).\n\n--- Load Component Models \u2014 .txt ---\n\nLoad Component Models \u2014 \n\nLoad Component Models\u00b6\n\nadd_loadc_model\n\n add a load component model of a designated type to a specified load or subsystem.\n\nchange_ldmodc_cdesc\n\n change the value of a Model Description of a load component model at a specified load or subsystem).\n\nchange_ldmodc_chricn\n\n change the value of a CHRICN of a load component model at a specified load or subsystem).\n\nchange_ldmodc_con\n\n change the value of a CON of a load component model at a specified load or subsystem.\n\nchange_ldmodc_icon\n\n change the value of a ICON of a load component model at a specified load or subsystem.\n\nchange_ldmodc_var\n\n change the value of a VAR of a load component model at a specified load or subsystem.\n\n--- Load Data \u2014 .txt ---\n\nLoad Data \u2014 \n\nLoad Data\u00b6\n\naloadchar\n\n return an array of character values for subsystem loads.\n\naloadcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the load data family.\n\naloadcplx\n\n return an array of complex values for subsystem loads.\n\naloadint\n\n return an array of integer values for subsystem loads.\n\naloadreal\n\n return an array of real values for subsystem loads.\n\naloadtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load data family (aLoadInt, aLoadReal, aLoadCplx and aLoadChar).\n\n--- Load Related Models \u2014 .txt ---\n\nLoad Related Models \u2014 \n\nLoad Related Models\u00b6\n\nadd_load_model\n\n add a load related model of a designated type to a specified load or subsystem.\n\nchange_ldmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of a load related model at a specified load or subsystem.\n\nchange_ldmod_con\n\n change the value of a CON of a load related model at a specified load or subsystem.\n\nchange_ldmod_data\n\nchange_ldmod_icon\n\n change the value of an integer ICON of a load related model at a specified load or subsystem.\n\nchange_ldmod_var\n\n change the value of a VAR of a load related model at a specified load or subsystem.\n\nldmod_pack\n\n remove entries that are marked as unused from the load model connection tables and the load model array allocation tables.\n\nldmod_remove\n\n remove a load related model of a designated type from a specified load or subsystem.\n\nldmod_status\n\n change the status of a load related model of a designated type for all subsystem loads at which it is applied.\n\nldmod_status2\n\n change the status of a load related model of a designated type at a specified load.\n\nldmod_unconnected\n\n list or remove from dynamics working memory those load related models that are assigned to loads that are not present in the current power flow working case (unconnected).\n\nldmod_user\n\n list user-written load model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables.\n\nldmodc_pack\n\n remove entries that are marked as unused from the load component model connection tables.\n\nldmodc_remove\n\n remove a load component related model of a designated type from a specified load or subsystem.\n\nldmodc_status\n\n change the status of a load related model of a designated type for all subsystem loads at which it is applied.\n\nldmodc_unconnected\n\n list or remove from dynamics working memory those load Component models that are assigned to loads that are not present in the current power flow working case (unconnected).\n\nldmodc_user\n\n list user-written load component model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables.\n\n--- Machine Data \u2014 .txt ---\n\nMachine Data \u2014 \n\nMachine Data\u00b6\n\namachchar\n\n return an array of character values for subsystem machines.\n\namachcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the machine data family.\n\namachcplx\n\n return an array of complex values for subsystem machines.\n\namachint\n\n return an array of integer values for subsystem machines.\n\namachreal\n\n return an array of real values for subsystem machines.\n\namachtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the machine data family (aMachInt, aMachReal, aMachCplx and aMachChar).\n\n--- Multi-Terminal Dc Line Converter Data \u2014 .txt ---\n\nMulti-Terminal Dc Line Converter Data \u2014 \n\nMulti-Terminal Dc Line Converter Data\u00b6\n\namultitrmdcconvchar\n\n return an array of character values for subsystem multi-terminal dc line converters.\n\namultitrmdcconvcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line converter data family.\n\namultitrmdcconvcplx\n\n return an array of complex values for subsystem multi-terminal dc line converters.\n\namultitrmdcconvint\n\n return an array of integer values for subsystem multi-terminal dc line converters.\n\namultitrmdcconvreal\n\n return an array of real values for subsystem multi-terminal dc line converters.\n\namultitrmdcconvtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (aMultiTrmDcConvInt, aMultiTrmDcConvReal, aMultiTrmDcConvCplx and aMultiTrmDcConvChar).\n\n--- Multi-Terminal Dc Line Data \u2014 .txt ---\n\nMulti-Terminal Dc Line Data \u2014 \n\nMulti-Terminal Dc Line Data\u00b6\n\namultitrmdcchar\n\n return an array of character values for subsystem multi-terminal dc lines.\n\namultitrmdccount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line data family.\n\namultitrmdccplx\n\n return an array of complex values for subsystem multi-terminal dc lines.\n\namultitrmdcint\n\n return an array of integer values for subsystem multi-terminal dc lines.\n\namultitrmdcreal\n\n return an array of real values for subsystem multi-terminal dc lines.\n\namultitrmdctypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the multi-terminal dc line data family (aMultiTrmDcInt, aMultiTrmDcReal, aMultiTrmDcCplx and aMultiTrmDcChar).\n\n--- Multiple Element Data \u2014 .txt ---\n\nMultiple Element Data \u2014 \n\nMultiple Element Data\u00b6\n\navoltagedroopchar\n\n return an array of character values for the voltage droop controls.\n\navoltagedroopcount\n\n return the number of voltage droop controls.\n\navoltagedroopint\n\n return an array of real values for the voltage droop controls.\n\navoltagedroopreal\n\n return an array of real values for the voltage droop controls.\n\ngetmodellibraries\n\nReturn the list of libraries that are searched for dynamically (i.e.\n\ngetmodelprograms\n\nReturn the list dynamically (i.e.\n\ngettspfprofilebyelement\n\n return an array of character values for the Time Series Power Flow profiles by element name.\n\ngettspfprofilecountbyelement\n\n return the number of Time Series Power Flow profile by element name.\n\ngettspfprofiledata\n\n return an array of real values for Time Series Power Flow profile data.\n\ngettspfprofiledatabyset\n\n return an array of real values for Time Series Power Flow profile data for given curve set id.\n\ngettspfprofiledatacolumncount\n\n return the number of Time Series Power Flow profile data column count for a curve set.\n\ngettspfprofiledatacount\n\n return the number of Time Series Power Flow profile data count.\n\nlast_pf\n\nReturn last attempted network solution data.\n\nrxpath\n\n return buses from starting bus to ending bus with shortest electricity distance in terms of one of two options, impedance and number of buses.\n\ntreedat\n\n return Swing Bus and Island Data of Working Case Network.\n\n--- Node Breaker Data \u2014 .txt ---\n\nNode Breaker Data \u2014 \n\nNode Breaker Data\u00b6\n\nfetch_adjvar_term_node\n\n obtain the terminal node to which an OPF adjustable bus shunt is connected to.\n\nfetch_indmachine_term_node\n\n obtain the terminal node to which a machine is connected to.\n\nfetch_load_term_node\n\n obtain the terminal node to which a load is connected to.\n\nfetch_machine_term_node\n\n obtain the terminal node to which a machine is connected to.\n\nfetch_shunt_term_node\n\n obtain the terminal node to which a shunt is connected to.\n\nfetch_sws_shunt_term_node\n\nfetch_sws_shunt_term_node_2\n\n obtain the terminal node to which a switched shunt is connected to.\n\nplant_bus_section_chng\n\nstation_2dc_bus_term_chng\n\n change the station two-term dc rectifier or inverter node terminal connection in the working case.\n\nstation_2dc_conv_term_chng\n\nThis API changes both node terminal connections of an existing two-term dc rectifier and inverter terminal data in the working case.\n\nstation_adjvar_term_chng\n\n change a substation OPF adjustable bus shunt node terminal connection in the working case.\n\nstation_branch_term_chng\n\n access existing station branch terminal data in the working case.\n\nstation_branch_term_move\n\n move one terminal node connection of a branch in the working case.\n\nstation_bus_purg\n\nThis API routine was first introduced in release 34.2.\n\nstation_chng\n\n modify the data of an existing substation data in the working case.\n\nstation_data\n\n modify the data of an existing substation data in the working case, or to add a new substation to the working case.\n\nstation_facts_bus_term_chng\n\n change the station FACTS device node terminal data connection in the working case.\n\nstation_facts_term_chng\n\nThis API changes the FACTS device sending and terminal end node terminal connections.\n\nstation_indmachine_term_chng\n\n change a substation induction machine node terminal connection in the working case.\n\nstation_load_term_chng\n\n access existing station load terminal data in the working case.\n\nstation_machine_term_chng\n\n change a substation machine terminal connection in the working case.\n\nstation_mtdc_bus_term_chng\n\n change the station multi-terminal converter node terminal connection in the working case.\n\nstation_mtdc_term_chng\n\nThis API changes both node terminal connections of an existing multi-terminal converter in the working case.\n\nstation_node_chng\n\n modify the data of an existing substation node in the working case.\n\nstation_node_data\n\n modify the data of an existing substation node in the working case, or to add a new substation node to the working case.\n\nstation_node_number\n\n change a node number in an existing substation.\n\nstation_node_purg\n\n delete a node in an existing substation.\n\nstation_number\n\n change a substation number for an existing substation.\n\nstation_purg\n\n delete a substation and all node-breaker components within that substation from the working case.\n\nstation_shunt_term_chng\n\n change a substation fixed shunt terminal connection in the working case.\n\nstation_swd_chng\n\n modify the data of an existing station switching device in the working case.\n\nstation_swd_data\n\n modify the data of an existing substation switching device in the working case, or to add a new substation switching device to the working case.\n\nstation_swd_mbid\n\n modify the circuit identifier of an existing station switching device in the working case.\n\nstation_swd_move\n\n move the \u201cto\u201d node of an existing substation switching device in the working case.\n\nstation_swd_purg\n\n delete an existing substation switching device in the working case.\n\nstation_sws_shunt_term_chng\n\nstation_sws_shunt_term_chng_2\n\n change a substation switched shunt node terminal connection in the working case.\n\nstation_three_wnd_term_chng\n\n access existing substation three-winding transformer terminal data in the working case.\n\nstation_three_wnd_term_move\n\n move one terminal node connection of a three-winding transformer in the working case.\n\nstation_vscdc_bus_term_chng\n\n change the vsc dc converter node terminal connection in the working case.\n\nstation_vscdc_conv_term_chng\n\nThis API changes both node terminal connections of an existing vsc dc converter in the working case.\n\nsystem_swd_chng\n\n modify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.\n\nsystem_swd_data\n\n add or modify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.\n\n--- Node Breaker Operation \u2014 .txt ---\n\nNode Breaker Operation \u2014 \n\nNode Breaker Operation\u00b6\n\nconvert_section_to_bus\n\nUse this API routine to convert a bus section, one that had been automatically created within a substation due to open substation switching devices, into a main network bus.\n\nisolate2dclinebybreaker\n\n isolate a two-terminal DC line using system or substation breakers.\n\nisolate3wtbybreaker\n\n isolate a three-winding transformer using system or substation breakers.\n\nisolatebusbybreaker\n\n isolate a bus using system or substation breakers.\n\nisolatefactsbybreaker\n\n isolate a FACTS device using system or substation breakers.\n\nisolateindmachinebybreaker\n\n isolate an induction machine using system or substation breakers.\n\nisolatelinebybreaker\n\n isolate a two-winding transformer or non-transformer line using system or substation breakers.\n\nisolateloadbybreaker\n\n isolate a load using system or substation breakers.\n\nisolatemachinebybreaker\n\n isolate a machine using system or substation breakers.\n\nisolatemslinebybreaker\n\n isolate a multi-section line using system or substation breakers.\n\nisolatemtdclinebybreaker\n\n isolate a multi-terminal dc line using system or substation breakers.\n\nisolatenodebybreaker\n\n isolate a substation node using system or substation breakers.\n\nisolateshuntbybreaker\n\n isolate a fixed shunt using system or substation breakers.\n\nisolateswdbybreaker\n\n isolate a substation switching device using system or substation breakers.\n\nisolateswshuntbybreaker\n\nisolateswshuntbybreaker_2\n\n isolate a switched shunt using system or substation breakers.\n\nisolatevscdclinebybreaker\n\n isolate a VSC DC line using system or substation breakers.\n\nrestorestatesfromisolate\n\n restore the network working case back to its original state; the state prior to all \u201cIsolate By Breaker\u201d actions that have been taken.\n\nstation_ampout\n\n print current within a substation.\n\nstation_build_config\n\n automatically build a general layout configuration for a bus being built within a substation.\n\nstation_list\n\n list components in a substation.\n\nstation_pout\n\nstation_pout_2\n\n print power flows within a substation.\n\nstation_tree\n\nUse this API routine to check the node breaker model and the consistency between node breaker and bus branch models.\n\n--- Non-Engineering \u2014 .txt ---\n\nNon-Engineering \u2014 \n\nNon-Engineering\u00b6\n\nalert\n\n send output to the alert device.\n\nappendrecording\n\nStart recording program operation at end of specified file.\n\nbeginreport\n\n create a new report tab in the GUI.\n\nclearalertoutput\n\nClear the Alerts/Warnings tab of the output bar in the GUI\n\nclearprogressoutput\n\nClear the Progress tab of the output bar in the GUI\n\nfilein\n\nGet input from file (Fortran unit number).\n\ngetbatdefaults\n\nRetrieve \u201cno input\u201d value for integers and reals.\n\ngetdefaultchar\n\nRetrieve \u201cno input\u201d value for characters (i.e., strings) other than filenames.\n\ngetdefaultint\n\nRetrieve \u201cno input\u201d value for integers.\n\ngetdefaultreal\n\nRetrieve \u201cno input\u201d value for reals (floats).\n\ngetloadedmodules\n\nget list of all modules currently loaded\n\ngetmodfunclist\n\nGet list if external callable methods given a module name.\n\nioflush\n\nForce all files in PSSE to flush buffers to disk, if possible.\n\nlaunch_program\n\nThis API routine was first introduced in release 34.1.\n\npagereport\n\n place a report separator on the active report tab of the GUI.\n\npauserecording\n\nPause or resume recording program operation.\n\nprogress\n\nSend output to progress device.\n\nprompt\n\nSend output to prompt device.\n\npsseinit\n\nInitialize PSSE.\n\npsseversion\n\nGet PSSE version information.\n\nrefreshgui\n\nRefresh the graphical user interface.\n\nreport\n\nSend output to report device.\n\nruniplanfile\n\nExecute an IPLAN program.\n\nrunrspnsfile\n\nRun a response file.\n\nshowloadedlibraries\n\nshowloadedmodules\n\nstartrecording\n\nStart recording program operation.\n\nstoprecording\n\nStop recording program operation.\n\nt_alert_output\n\n specify a \u201cT\u201c\u2018d alert device, i.e. a destination for a copy of everything sent to the alert device.\n\nt_progress_output\n\n specify a \u201cT\u201c\u2018d progress device, i.e. a destination for a copy of everything sent to the progress device.\n\nt_prompt_output\n\n specify a \u201cT\u201c\u2018d prompt device, i.e. a destination for a copy of everything sent to the prompt device.\n\nt_report_output\n\n specify a \u201cT\u201c\u2018d report device, i.e. a destination for a copy of everything sent to the report device.\n\nuserin\n\nGet input from interactive device.\n\n--- Optimal Power Flow Data \u2014 .txt ---\n\nOptimal Power Flow Data \u2014 \n\nOptimal Power Flow Data\u00b6\n\nnewopf\n\n initialize the working case with default OPF data for all bus oriented data records.\n\nopf_adjbrx_indv\n\n add an individual adjustable branch reactance data record to the working case.\n\nopf_adjbrx_subsys\n\n add or modify all OPF branch reactance data records in a specified subsystem of the working case.\n\nopf_adjload_tbl\n\n add an individual adjustable bus load table record to the working case.\n\nopf_adjvar_indv\n\nopf_adjvar_indv_2\n\n add an individual OPF adjustable bus shunt data record to the working case.\n\nopf_adjvar_subsys\n\n add or modify all OPF adjustable bus shunt records in a specified subsystem of the working case.\n\nopf_apdsp_tbl\n\n add an individual active power dispatch table record to the working case.\n\nopf_brflw_3wt_indv\n\n add a flow constraint record for an individual winding of a three-winding transformer in the working case.\n\nopf_brflw_brn_indv\n\n add an individual branch or two-winding transformer flow constraint record to the working case.\n\nopf_brflw_subsys\n\n add or modify all branch flow data records in a specified subsystem of the working case.\n\nopf_bus_indv\n\nopf_bus_indv_2\n\n add OPF bus voltage magnitude data to the working case.\n\nopf_bus_subsys\n\n add OPF bus attribute data for all records in a specified subsystem of the working case.\n\nopf_change_3wt_flow_id\n\n change the identifier of a flow constraint record for an individual winding of a three-winding transformer in the working case.\n\nopf_change_adjvar_id\n\nopf_change_brn_flow_id\n\n change the identifier of a branch or two-winding transformer OPF flow constraint record in the working case.\n\nopf_csttbl_lin\n\n add a linear cost curve table record to the working case.\n\nopf_csttbl_poly\n\n add a polynomial and exponential cost curve table record to the working case.\n\nopf_csttbl_quad\n\n add a quadratic cost curve table record to the working case.\n\nopf_gen_rcap_indv\n\n add an individual generation reactive capability data record to the working case.\n\nopf_gen_rcap_subsys\n\n add or modify all OPF generator reactive capability records in a specified subsystem of the working case.\n\nopf_gendsp_indv\n\n add generator dispatch data to an individual record in the working case.\n\nopf_gendsp_subsys\n\n add OPF generator dispatch data to all records in a specified subsystem of the working case.\n\nopf_genrsv_indv\n\n add an individual generator reserve data record to the working case.\n\nopf_genrsv_subsys\n\n add or modify all OPF generator reserve records in a specified subsystem of the working case.\n\nopf_intflw_3wt\n\n add a participating three-winding transformer winding to a specified interface flow constraint in the working case.\n\nopf_intflw_brn\n\n add a participating branch to a specified interface flow constraint in the working case.\n\nopf_intflw_main\n\n add an interface flow constraint record to the working case.\n\nopf_intflw_reset\n\n remove all interface branches associated with a particular interface flow constraint in the working case.\n\nopf_lnceqn_adjload\n\n add a participating adjustable bus load variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_adjvar\n\n add a participating adjustable bus shunt variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_brflow\n\n add a participating branch flow variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_intflow\n\n add a participating interface flow constraint variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_main\n\n add a linear constraint dependency record to the working case.\n\nopf_lnceqn_pgen\n\n add a participating active power dispatch variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_qgen\n\n add a participating reactive power dispatch variable of a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_reset\n\n remove all participating variables from a particular OPF linear constraint dependency equation in the working case.\n\nopf_lnceqn_swshunt\n\nopf_lnceqn_swshunt_2\n\n add a participating switched shunt variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_tran\n\n add a participating transformer control variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_vang\n\nopf_lnceqn_vang_2\n\n add a participating bus voltage angle variable to a specified linear constraint dependency equation in the working case.\n\nopf_lnceqn_vmag\n\nopf_lnceqn_vmag_2\n\n add a participating bus voltage magnitude variable to a specified linear constraint dependency equation in the working case.\n\nopf_load_indv\n\n add an individual OPF bus load data record to the working case.\n\nopf_load_subsys\n\n add or modify all OPF bus load data records in a specified subsystem of the working case.\n\nopf_perrsv_gen\n\n add a participating generation reserve unit to a previously defined period reserve constraint in the working case.\n\nopf_perrsv_main\n\n add a period reserve constraint record to the working case.\n\nopf_perrsv_reset\n\n remove all generation reserve units associated with a particular period reserve constraint in the working case.\n\npurge_all_opf_data\n\n purge and re-initialize all OPF data records in the working case.\n\npurge_opf_adjbrx_indv\n\n purge an individual adjustable branch reactance data record from the working case.\n\npurge_opf_adjbrx_subsys\n\n purge all OPF branch reactance data records from a specified subsystem of the working case.\n\npurge_opf_adjload_tbl\n\n purge an individual adjustable bus load table from the working case.\n\npurge_opf_adjvar_indv\n\npurge_opf_adjvar_indv_3\n\n purge an individual OPF adjustable bus shunt data record from the working case.\n\npurge_opf_adjvar_subsys\n\n purge all OPF adjustable bus shunt records from a specified subsystem of the working case.\n\npurge_opf_apdsp_tbl\n\n purge an individual active power dispatch table record from the working case.\n\npurge_opf_brflw_3wt\n\n purge an individual flow constraint record of a three-winding transformer from the working case.\n\npurge_opf_brflw_brn\n\n purge an individual branch or two-winding transformer flow constraint record from the working case.\n\npurge_opf_brflw_subsys\n\n purge all branch flow data records in a specified subsystem in the working case.\n\npurge_opf_bus_indv\n\npurge_opf_bus_indv_3\n\n purge (re-initialize) OPF bus voltage magnitude data for an individual bus or bus section record in the working case.\n\npurge_opf_bus_subsys\n\n purge (re-initialize) OPF bus attribute data for all records in a specified subsystem of the working case.\n\npurge_opf_csttbl_lin\n\n purge an optimal power flow linear cost curve record from the working case.\n\npurge_opf_csttbl_poly\n\n purge an optimal power flow polynomial and exponential cost curve record from the working case.\n\npurge_opf_csttbl_quad\n\n purge an optimal power flow quadratic cost curve record from the working case.\n\npurge_opf_gen_rcap_indv\n\n purge an individual OPF generation reactive capability data record from the working case.\n\npurge_opf_gen_rcap_subsys\n\n purge all OPF generator reactive capability records in a specified subsystem from the working case.\n\npurge_opf_gendsp_indv\n\n purge generator dispatch data for an individual record from the working case.\n\npurge_opf_gendsp_subsys\n\n purge generator dispatch data for all records from a specified subsystem of the working case.\n\npurge_opf_genrsv_indv\n\n purge an individual optimal power flow generator reserve data record from the working case.\n\npurge_opf_genrsv_subsys\n\n purge all OPF generator reserve records in a specified subsystem from the working case.\n\npurge_opf_intflw\n\n purge an OPF interface flow constraint record, including all of its participating branches, from the working case.\n\npurge_opf_intflw_3wt\n\n remove a participating three-winding transformer winding from a specified OPF interface flow constraint in the working case.\n\npurge_opf_intflw_brn\n\n remove a participating branch from a specified OPF interface flow constraint in the working case.\n\npurge_opf_lnceqn\n\n purge an OPF linear constraint dependency record, including all of its participating variables, from the working case.\n\npurge_opf_lnceqn_adjload\n\n remove a participating adjustable bus load variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_adjvar\n\n remove a participating adjustable bus shunt variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_brflow\n\n remove a participating branch flow variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_intflow\n\n remove a participating interface flow constraint variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_pgen\n\n remove a participating active power dispatch variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_qgen\n\n remove a participating reactive power dispatch variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_swshunt\n\npurge_opf_lnceqn_swshunt_2\n\n remove a participating switched shunt variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_tran\n\n remove a participating transformer control variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_vang\n\npurge_opf_lnceqn_vang_2\n\n remove a participating bus voltage angle variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_lnceqn_vmag\n\npurge_opf_lnceqn_vmag_2\n\n remove a participating bus voltage magnitude variable from a specified OPF linear constraint dependency equation in the working case.\n\npurge_opf_load_indv\n\n purge (re-initialize) an individual OPF bus load data record from the working case.\n\npurge_opf_load_subsys\n\n purge (re-initialize) all OPF bus load data records in a specified subsystem of the working case.\n\npurge_opf_perrsv\n\n purge an OPF period reserve constraint record and its association with participating reserve units from the working case.\n\npurge_opf_perrsv_gen\n\n remove a participating period reserve unit from a specified OPF period reserve constraint.\n\n--- Optimal Power Flow Operation \u2014 .txt ---\n\nOptimal Power Flow Operation \u2014 \n\nOptimal Power Flow Operation\u00b6\n\nadd_details_to_opf_log\n\n specify or return the value of the OPF solution option to add details of the sensitivity values and Lagrange multipliers to the OPF Output Log file.\n\napply_alternate_step_size\n\n specify or return the value of the OPF solution option for applying an alternate lambda mismatch step size.\n\napply_automatic_scaling\n\n specify or return the value of the OPF solution option to apply automatic scaling of the objective coefficients and derivatives to improve convergence of the OPF solution.\n\nbad_iter_coarse_limit\n\n specify or return the number of bad iterations allowed when the barrier coefficient is greater than 011 (mu greater then -2) before the solution progress is terminated as being infeasible.\n\nbad_iter_fine_limit\n\n specify or return the the bad iteration limit when the barrier coefficient is less than, or equal to 011 (mu less than or equal to -2) before the solution progress is terminated as being infeasible.\n\nclamp_nonoptimized_gens\n\n specify or return the value of the OPF solution option to apply the clamp equation to non-optimized generators.\n\nconstrain_interface_flows\n\n specify or return the value of the OPF option to constrain interface flows.\n\nfinal_opf_barrier_coeff\n\n specify or return the value of the final coefficient value that the barrier function is attempting to attain.\n\nimport_ecdi\n\n import data from an Economics Dispatch Data File, as prepared for use in activity ECDI, into the OPF working data.\n\ninitial_opf_barrier_coeff\n\n specify or return the value of the initial OPF barrier coefficient.\n\ninterface_flow_cost_coeff\n\n specify or return the value of the coefficient for the interface flow objective.\n\nlsto\n\n list OPF working case data in a form suitable for data documentation.\n\nminimize_adj_bus_shunts\n\n specify or return the value of the OPF minimize adjustable bus shunts (var compensation) objective function option.\n\nminimize_fuel_cost\n\n specify or return the value of the OPF minimize fuel cost objective option.\n\nminimize_interface_flows\n\n specify or return the value of the OPF minimize interface flows objective option.\n\nminimize_load_adjustments\n\n specify or return the value of the OPF minimize adjustable bus load objective option.\n\nminimize_p_losses\n\n specify or return the value of the OPF minimize active power loss objective option.\n\nminimize_p_slack\n\n specify or return the value of the OPF minimize active power slack objective option.\n\nminimize_q_losses\n\n specify or return the value of the OPF minimize reactive power loss objective option.\n\nminimize_q_slack\n\n specify or return the value of the OPF minimize reactive power slack objective option.\n\nminimize_reactive_reserve\n\n specify or return the value of the OPF minimize reactive reserve objective option.\n\nminimize_series_comp\n\n specify or return the value of the OPF minimize series compensation (adjustable branch reactance) objective option.\n\nnopf\n\n run the Optimal Power Flow solution.\n\nopen_bus_voltage_limits\n\n specify or return the value of the OPF solution option to automatically adjust bus voltage limits, making them more open for initial feasibility.\n\nopf_barrier_step_length\n\n specify or return the value of the barrier function step length setting.\n\nopf_clamp_decay_factor\n\n specify or return the value of the clamp equation decay factor.\n\nopf_final_clamp_tol\n\n specify or return the value of the final clamp tolerance.\n\nopf_fix_all_generators\n\n specify or return the value of the OPF option to treat all generators as nonoptimized (fixed).\n\nopf_fix_phase_shifters\n\n specify or return the value of the OPF option to fix transformer phase shift angle settings.\n\nopf_fix_switched_shunts\n\n specify or return the value of the OPF option to fix switched shunt settings.\n\nopf_fix_tap_ratios\n\n specify or return the value of the OPF option to fix transformer tap ratio settings.\n\nopf_fixed_voltage_penalty\n\n specify or return the value of the penalty for fixed voltage excursions.\n\nopf_initial_clamp_tol\n\n specify or return the value of the initial clamp tolerance.\n\nopf_interior_shift_factor\n\n specify or return the value of the interior shift factor multiplier.\n\nopf_lambda_tolerance\n\n specify or return the value of the Lagrange multiplier blow-up tolerance during an optimal power flow solution.\n\nopf_lf_control_penalty\n\n specify or return the value of the quadratic penalty for loadflow controls.\n\nopf_max_tap_ratio_step\n\n specify or return the value of the maximum transformer tap ratio step.\n\nopf_min_tap_ratio_step\n\n set or return the value of the minimum transformer tap ratio step.\n\nopf_regulate_area_int\n\n set or return the value of the OPF option to regulate area interchange.\n\nopf_round_switched_shunts\n\n set or return the value of the OPF solution option to discretize switched shunts.\n\nopf_round_tap_ratios\n\n set or return the value of the OPF solution option to round transformer tap ratio settings.\n\nopf_scale_qgen_limits\n\n set or return the value of the OPF option to scale reactive generation limits in the clamped constraint equation.\n\nopf_step_length_tolerance\n\n set or return the value of the OPF minimum barrier step length tolerance.\n\nopf_use_generator_vsched\n\n set or return the value of the OPF option to employ the generator scheduled voltage.\n\nopto\n\nPlease use the individual OPF option setting API\u2019s described in this section.\n\np_losses_cost_coeff\n\n set or return the value of the coefficient for the active power loss objective (OPF Solution Options).\n\nproduce_opf_log_file\n\n set or return the value of the OPF solution option to produce an OPF solution log file, and if so, the name of the log file.\n\nq_losses_cost_coeff\n\n set or return the value of the coefficient for the reactive power loss objective.\n\nreactive_resv_cost_coeff\n\n set or return the value of the coefficient for the reactive reserve objective.\n\nropf\n\n read an Optimal Power Flow Raw Data File.\n\nrwop\n\n replicate the OPF data contained in the working case in the form of an Optimal Power Flow Data File.\n\nset_opf_report_subsystem\n\n define the subsystem to be used when producing the opf output report.\n\nuse_dual_criteria\n\n set or return the value of the OPF solution option to apply the power flow mismatch tolerance to the dual variable problem.\n\nuse_emergency_flow_limits\n\n set or return the value of the OPF solution option to impose the emergency flow limits instead of the normal flow limits.\n\nuse_emergency_volt_limits\n\n set or return the value of the OPF solution option to impose the emergency bus voltage limits instead of the normal bus voltage limits.\n\nwrite_opf_options_file\n\n save the PSSE OPF solution option settings to the PSSOPF.OPT file.\n\n--- Owner Data \u2014 .txt ---\n\nOwner Data \u2014 \n\nOwner Data\u00b6\n\naownerchar\n\n return an array of character values for subsystem owners.\n\naownercount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the owner data family.\n\naownercplx\n\n return an array of complex values for subsystem owners.\n\naownerint\n\n return an array of integer values for subsystem owners.\n\naownerreal\n\n return an array of real values for subsystem owners.\n\naownertypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the owner data family (aOwnerInt, aOwnerReal, aOwnerCplx and aOwnerChar).\n\n--- Owner Subsystems \u2014 .txt ---\n\nOwner Subsystems \u2014 \n\nOwner Subsystems\u00b6\n\nosys\n\n define an owner subsystem.\n\nosysdef\n\n set the definition of an owner subsystem.\n\nosysinit\n\n initialize or re-initialize an owner subsystem.\n\n--- Plant Bus Data \u2014 .txt ---\n\nPlant Bus Data \u2014 \n\nPlant Bus Data\u00b6\n\nagenbuschar\n\n return an array of character values for subsystem buses.\n\nagenbuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the plant bus data family.\n\nagenbuscplx\n\n return an array of complex values for subsystem buses.\n\nagenbusint\n\n return an array of integer values for subsystem buses.\n\nagenbusreal\n\n return an array of real values for subsystem buses.\n\nagenbustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the plant bus data family (aGenBusInt, aGenBusReal, aGenBusCplx and aGenBusChar).\n\n--- Plant Related Models \u2014 .txt ---\n\nPlant Related Models \u2014 \n\nPlant Related Models\u00b6\n\nadd_plant_model\n\n add a plant related model of a designated type to a specified machine.\n\nchange_plmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of a designated plant related model at a specified machine.\n\nchange_plmod_con\n\n change the value of a CON of a designated plant related model at a specified machine.\n\nchange_plmod_data\n\nchange_plmod_icon\n\n change the value of an integer ICON of a designated plant related model at a specified machine.\n\nchange_plmod_var\n\n change the value of a VAR of a designated plant related model at a specified machine.\n\ngmb_add_plant_model\n\n add a plant related GMB model to a specified machine.\n\nplmod_consistency\n\n check consistency among the plant related models referenced at each machine.\n\nplmod_pack\n\n remove entries that are marked as unused from the plant model connection tables and the plant model array allocation tables.\n\nplmod_remove\n\n remove a plant related model of a designated type from a specified machine.\n\nplmod_status\n\n change the status of a plant related model of a designated type at a specified machine.\n\nplmod_unconnected\n\n list or remove from dynamics working memory those plant related models that are assigned to machines that are not present in the current power flow working case (unconnected).\n\nplmod_user\n\n list user-written plant model definitions or to remove user-written plant model definitions that are not assigned to any machines (unused) from the user model definition tables.\n\n--- Power Flow Data \u2014 .txt ---\n\nPower Flow Data \u2014 \n\nPower Flow Data\u00b6\n\narea_data\n\n modify area data in the working case (see PSSE Program Operation Manual, Areas, Zones and Owners).\n\nbranch_chng\n\nbranch_chng_3\n\nUse this API routine to modify the data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\n\nbranch_data\n\nbranch_data_3\n\n modify the data of an existing non-transformer branch in the working case or to add a new non-transformer branch to the working case (see PSSE Program Operation Manual, Non- Transformer Branch Data).\n\nbus_chng_3\n\nUse this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).\n\nbus_chng_4\n\nUse this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).\n\nbus_data\n\nbus_data_2\n\nbus_data_3\n\nbus_data_4\n\nUse this API routine to modify the data of an existing bus in the working case, or to add a new bus to the working case (see PSSE Program Operation Manual, Bus Data).\n\nbus_number\n\n change the bus number of an existing bus in the working case.\n\ncase_title_data\n\n change the two line case title in the working case (see PSSE Program Operation Manual, Case Identification Data).\n\ncasolution_parameters\n\n modify the contingency analysis solution parameters.\n\ncasolution_parameters_2\n\n modify the contingency analysis solution parameters.\n\ncasolution_parameters_3\n\n modify the contingency analysis solution parameters.\n\nextr\n\n purge specified buses and all branches connected to them from the working case (activity EXTR).\n\nfacts_chng_2\n\nfacts_chng_3\n\nUse this API routine to modify the data of an existing FACTS device in the working case (see PSSE Program Operation Manual, FACTS Device Data).\n\nfacts_data\n\nfacts_data_2\n\nfacts_data_3\n\n modify the data of an existing FACTS device in the working case, or to add a new FACTS device to the working case (see PSSE Program Operation Manual, FACTS Device Data).\n\ngne_chng\n\nUse this API routine to modify the data of an existing GNE device in the working case (see PSSE Program Operation Manual, GNE Device Data).\n\ngne_data\n\nUse this API routine to run the GNE device data specification function.\n\nimpedance_correction_data\n\nimpedance_correction_data_3\n\n modify the data of an existing transformer impedance correction table in the working case or to add a new transformer impedance correction table to the working case (see PSSE Program Operation Manual, Transformer Impedance Correction Table Data).\n\ninduction_machine_chng\n\nUse this API routine to modify the data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Data).\n\ninduction_machine_data\n\nUse this API routine to modify the data of an existing induction machine in the working case, or to add a new induction machine to the working case (see PSSE Program Operation Manual, Induction Machine Data).\n\nload_chng_4\n\nload_chng_5\n\nload_chng_6\n\nUse this API routine to modify the data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).\n\nload_data\n\nload_data_3\n\nload_data_4\n\nload_data_5\n\nload_data_6\n\nUse this API routine to modify the data of an existing load in the working case, or to add a new load to the working case (see PSSE Program Operation Manual, Load Data).\n\nlong_title_data\n\n change the sixteen line long title in the working case (see PSSE Program Operation Manual, activity CHTI).\n\nmachine_cap_curve_chng\n\nUse this API routine to modify the capability curve data of an existing machine in the working case.\n\nmachine_cap_curve_data\n\nUse this API routine to specify or modify the capability curve data of an existing machine in the working case.\n\nmachine_chng_2\n\nmachine_chng_3\n\nUse this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).\n\nmachine_chng_4\n\nUse this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).\n\nmachine_data\n\nmachine_data_2\n\nmachine_data_3\n\n modify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).\n\nmachine_data_4\n\n modify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).\n\nmbid2dc\n\n change the name of the specified two-terminal dc line.\n\nmbid3wnd\n\n change the identifier of the specified three-winding transformer.\n\nmbidatrn\n\n change the identifier of the specified inter-area transfer.\n\nmbidbrn\n\n change the identifier of the specified non-transformer branch or two-winding transformer.\n\nmbidfacts\n\n change the name of the specified FACTS device.\n\nmbidgne\n\nUse this API routine to change the GNE device name of the specified GNE device.\n\nmbidindmac\n\nUse this API routine to change the identifier of the specified induction machine.\n\nmbidload\n\n change the identifier of the specified load.\n\nmbidmac\n\n change the identifier of the specified machine.\n\nmbidmdc\n\n change the name of the specified multi-terminal dc line.\n\nmbidmsl\n\n change the identifier of the specified multi-section line.\n\nmbidshunt\n\n change the identifier of the specified fixed bus shunt.\n\nmbidswshunt\n\n change the identifier of the specified switched bus shunt.\n\nmbidvd\n\n change the voltage droop control name of the specified voltage droop control in the working case.\n\nmbidvsc\n\n change the VSC dc line name of the specified VSC dc line.\n\nmulti_section_line_data\n\n modify the definition of an existing multi-section line grouping in the working case or to add a new multi-section line grouping to the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).\n\nmulti_section_line_edit\n\n modify the status and/or metered end designation of an existing multi-section line grouping in the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).\n\nmulti_term_dc_bus_data\n\n modify the data of a dc bus of an existing multi-terminal dc line in the working case or to add a new dc bus to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\n\nmulti_term_dc_convr_data\n\n modify the data of a dc converter of an existing multi-terminal dc line in the working case or to add a new converter to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\n\nmulti_term_dc_line_chng\n\nUse this API routine to modify the control mode and mode switch voltage of an existing multi- terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\n\nmulti_term_dc_line_data\n\n modify the control mode and mode switch voltage of an existing multi-terminal dc line in the working case or to add a new multi-terminal dc line to the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\n\nmulti_term_dc_link_data\n\n modify the data of a dc link of an existing multi-terminal dc line in the working case or to add a new dc link to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\n\nowner_data\n\n modify owner data in the working case (see PSSE Program Operation Manual, Interarea Transfer Data).\n\npbus_add_mod\n\n add or modify transaction event participating bus data.\n\npbus_delete\n\n remove a bus from the set of buses that are participating in a transaction event.\n\nplant_chng\n\nplant_chng_3\n\nplant_chng_4\n\nUse this API routine to modify the data of an existing plant that is part of a substation in the working case.\n\nplant_data\n\nplant_data_3\n\nplant_data_4\n\n modify the data of an existing plant in the working case, or to add a new plant to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\n\npurg\n\nUse this API routine to delete specified outaged equipment items from the working case.\n\npurg2dc\n\n delete the specified two-terminal dc line from the working case.\n\npurg3wnd\n\n delete the specified three-winding transformer from the working case.\n\npurg_voltage_droop\n\n delete an existing voltage droop control from the working case.\n\npurgarea\n\n delete areas with no equipment assigned to them from the working case.\n\npurgatrn\n\n delete the specified inter-area transfer from the working case.\n\npurgbrn\n\n delete the specified non-transformer branch or two-winding transformer from the working case.\n\npurgcapcurve\n\n delete the specified machine\u2019s capability curve from the working case.\n\npurge_multi_term_dc_bus\n\n delete the specified dc bus from the specified multi-terminal dc line in the working case.\n\npurge_multi_term_dc_convr\n\n delete the specified converter from the specified multi-terminal dc line in the working case.\n\npurge_multi_term_dc_link\n\n delete the specified dc link from the specified multi-terminal dc line in the working case.\n\npurgfacts\n\n delete the specified FACTS device from the working case.\n\npurggne\n\nUse this API routine to delete the specified GNE device from the working case.\n\npurgindmac\n\nUse this API routine to delete the specified induction machine from the working case.\n\npurgindmacs\n\nUse this API routine to delete all induction machines from the specified bus in the working case.\n\npurgload\n\n delete the specified load from the working case.\n\npurgloads\n\n delete all loads from the specified bus in the working case.\n\npurgmac\n\n delete the specified machine from the working case.\n\npurgmdc\n\n delete the specified multi-terminal dc line from the working case.\n\npurgmsl\n\n delete the specified multi-section line grouping from the working case.\n\npurgmut\n\n delete the specified zero sequence mutual coupling from the working case.\n\npurgowner\n\n delete owners with no equipment assigned to them from the working case.\n\npurgplnt\n\n delete the plant and machine data at the specified bus from the working case.\n\npurgshunt\n\n delete the specified fixed bus shunt from the working case.\n\npurgshunts\n\n delete all fixed shunts from the specified bus in the working case.\n\npurgsws\n\n delete all switched shunts from the specified bus in the working case.\n\npurgswshunt\n\n delete the specified switched bus shunt from the working case.\n\npurgvsc\n\n delete the specified VSC dc line from the working case.\n\npurgzone\n\n delete zones with no equipment assigned to them from the working case.\n\nratingsettextdata\n\n change the column and descriptions for a particular rating set used in reporting.\n\nshunt_chng\n\nUse this API routine to modify the data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\n\nshunt_data\n\n modify the data of an existing fixed bus shunt in the working case or to add a new fixed bus shunt to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\n\nsolution_parameters\n\nsolution_parameters_2\n\nsolution_parameters_3\n\nsolution_parameters_4\n\nsolution_parameters_5\n\n modify the power flow solution parameters in the working case (see PSSE Program Operation Manual, Sections 6.3.13, 6.3.18, 6.5.1 and 11.7).\n\nswitched_shunt_chng_3\n\nswitched_shunt_chng_4\n\nswitched_shunt_chng_5\n\nUse this API routine to modify the data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Switched Shunt Data).\n\nswitched_shunt_data\n\nswitched_shunt_data_3\n\nswitched_shunt_data_4\n\nswitched_shunt_data_5\n\n modify the data of an existing switched shunt in the working case or to add a new switched shunt to the working case (see PSSE Program Operation Manual, Switched Shunt Data).\n\nthree_winding_data\n\nthree_wnd_imped_chng_3\n\nthree_wnd_imped_chng_4\n\nUse this API routine to modify the impedance data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\n\nthree_wnd_imped_data_3\n\nthree_wnd_imped_data_4\n\nUse this API routine to modify the impedance data of an existing three-winding transformer in the working case, or to add a new three-winding transformer to the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\n\nthree_wnd_impedance_data\n\nthree_wnd_winding_data\n\nthree_wnd_winding_data_3\n\nthree_wnd_winding_data_4\n\nthree_wnd_winding_data_5\n\n modify the data of one winding of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\n\ntransaction_add_mod\n\n add or modify transaction event data in PSSE working memory.\n\ntransaction_delete\n\n delete a transaction event from PSSE working memory.\n\ntransfer_chng\n\nUse this API routine to modify the data of an inter-area transfer in the working case (see PSSE Program Operation Manual, Zone Data).\n\ntransfer_data\n\nUse this API routine to modify the data of an inter-area transfer in the working case, or to add a new inter-area transfer to the working case (see PSSE Program Operation Manual, Zone Data).\n\ntwo_term_dc_converter_data_3\n\n modify the data of a dc converter of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).\n\ntwo_term_dc_convr_data\n\ntwo_terminal_dc_line_chng\n\nUse this API routine to modify the link data of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).\n\ntwo_terminal_dc_line_data\n\nUse this API routine to modify the link data of an existing two-terminal dc line in the working case, or to add a new two-terminal dc line and its link data to the working case (see PSSE Program Operation Manual, Area Interchange Data).\n\ntwo_winding_chng_4\n\ntwo_winding_chng_5\n\ntwo_winding_chng_6\n\nUse this API routine to modify the data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Owner Data).\n\ntwo_winding_data\n\ntwo_winding_data_3\n\ntwo_winding_data_4\n\ntwo_winding_data_5\n\ntwo_winding_data_6\n\n modify the data of an existing two-winding transformer in the working case, or to add a new two-winding transformer to the working case (see PSSE Program Operation Manual, Owner Data).\n\nvoltage_droop_chng\n\nUse this API routine to modify the voltage droop control in the working case(see PSSE Program Operation Manual.\n\nvoltage_droop_data\n\nUse this API routine to modify the voltage droop control in the working case, or to add a new voltage droop control to the working case (see PSSE Program Operation Manual.\n\nvsc_dc_converter_data\n\nvsc_dc_converter_data_3\n\n modify the data of a dc converter of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\n\nvsc_dc_line_chng\n\nUse this API routine to modify the link data of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\n\nvsc_dc_line_data\n\nUse this API routine to modify the link data of an existing VSC dc line in the working case, or to add a new VSC dc line to the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\n\nzone_data\n\n modify zone data in the working case (see PSSE Program Operation Manual, Zone Data).\n\n--- Power Flow Operation \u2014 .txt ---\n\nPower Flow Operation \u2014 \n\nPower Flow Operation\u00b6\n\naccc\n\naccc_2\n\naccc_multiple_merge\n\n merge a number of AC contingency solution files (acc files) into one acc file.\n\naccc_multiple_run_report\n\naccc_multiple_run_report_2\n\n report the results of up to twenty two executions of the AC Contingency Calculation function.\n\naccc_parallel\n\naccc_parallel_2\n\nUse this API routine to run the second release of the parallel implementation of the AC contingency calculation function (use ACCC_WITH_DSP_3 to run AC contingency calculation function serially).\n\naccc_single_run_report\n\naccc_single_run_report_2\n\naccc_single_run_report_3\n\naccc_single_run_report_4\n\naccc_single_run_report_5\n\naccc_single_run_report_6\n\nThis API is the sixth release of the AC Contingency Report function.\n\naccc_trip_cor\n\naccc_trip_cor_2\n\naccc_trip_cor_3\n\nThis API is the third release of the function to run AC contingency analysis with tripping simulation and corrective actions.\n\naccc_with_cor\n\naccc_with_cor_2\n\naccc_with_cor_3\n\nThis API is the third release of function to run AC contingency analysis with corrective actions.\n\naccc_with_dsp\n\naccc_with_dsp_2\n\naccc_with_dsp_3\n\n run the second release of AC contingency calculation function (ACCC, ACCC_WITH_DSP).\n\naccc_with_trip\n\naccc_with_trip_2\n\n run the second version of AC contingency calculation function with a post- contingency tripping function.\n\naccc_with_trip_parallel\n\n run the parallel version of AC contingency calculation function with a post- contingency tripping function (use ACCC_WITH_TRIP_2 to run the function sequentially).\n\naccor\n\naccor_2\n\naccor_3\n\nThis API is the third release of corrective action function.\n\nalert_output\n\n specify the alert device.\n\nallow_pssuserpf\n\n specify or return the option to allow or disallow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf).\n\nalph\n\n print an alphabetically sorted table of all buses in a specified subsystem of the working case (activity ALPH).\n\nappend_accc\n\n replicate system conditions of a contingency case solution, as contained in a designated Saved Case File, in the form of a Contingency Solution Output File.\n\napply_var_limits\n\n specify or return the option for the default VAR limits setting; either apply automatically, apply immediately, ignore, or apply on a specific iteration\n\narea\n\narea_2\n\n tabulate area totals by area, as well as the desired area net interchange (activity AREA).\n\narea_zone\n\n tabulate area totals by area, along with subtotals by zone.\n\narnm\n\narnm_2\n\nThis API routine is the second release of the area renumbering function.\n\nbase_frequency\n\n specify or return the value of the base frequency option setting.\n\nbgen\n\n convert the mismatch at boundary buses to equivalent load and/or generation (activity BGEN).\n\nbrch\n\nbrch_2\n\n tabulate those branches where impedances or other characteristics are such that they may be detrimental to the rate of convergence of one or more of the power flow solution activities.\n\nbsnm\n\n change the bus numbers of specified network buses in the working case and retain a tabulation, in file form, of bus number changes made (activity BSNM).\n\nbus_input\n\n specify or return the bus input option setting, for either numbers or names.\n\nbus_output\n\n specify or return the bus output option setting, for either numbers or names.\n\nbus_size_level\n\n specify or return the value of the PSSE size level option setting to a multiple of 1,000 between 1,000 and 200,000.\n\nbusn\n\n tabulate unused bus numbers within a specified bus number range (activity BUSN).\n\nca_iterations\n\n specify or return the contingency iterations limit setting.\n\ncase\n\n open a PSSE Saved Case file and transfers its data into the PSSE working case.\n\ncheck_powerflow_data\n\nUse this API routine to perform data checks on the selected categories of powerflow data for all buses in the working case or for all buses in a specified subsystem.\n\ncheckvoltagelimits\n\n tabulate those buses where voltage magnitude is beyond their normal or emergency voltage limits.\n\nchkcntduplicon\n\nCheck duplicate labels in Contingengy (CON) file.\n\nchkcntduplidfx\n\nCheck duplicate labels in DFAX file.\n\nclose_powerflow\n\nRemoves the current powerflow working case from PSSE\u2019s working memory.\n\nclose_report\n\nSets the report output device to the standard output and sets the command line to request device selection for individual reporting activities (Activity CLOS).\n\ncmpr\n\n tabulate certain case totals, as contained in the working case, with those of a designated Saved Case (activity CMPR).\n\ncntb\n\n tabulate the voltage setpoints and desired voltage bands of voltage-controlling equipment in the working case (activity CNTB).\n\ncong\n\n convert generators from their power flow representation in preparation for switching studies and dynamic simulations (activity CONG).\n\nconl\n\n convert the constant MVA load for a specified grouping of network loads to a specified mixture of the constant MVA, constant current, and constant admittance load characteristics (activity CONL).\n\nconnectivity_check\n\n specify or return the option to enable or disable the solution connectivity checking option setting.\n\ncontrol_area_interchange\n\n to specify or return the area interchange control option setting to disabled, or enabled with tie lines only, or enabled with tie lines and loads.\n\ncsv_to_rawx\n\n import a rawx (extended raw data) data table from a CSV (comma-separated values) file.\n\ncsv_to_rawx_with_metamodel\n\n import a rawx (extended raw data) data table from a CSV (comma-separated values) file with metamodel.\n\ndc_tap_adjustment\n\n specify or return the option to enable or disable the dc tap adjustment option setting.\n\ndccc\n\ndccc_2\n\n run contingency case solutions using a linear network (dc) model (activity DCCC).\n\ndccor\n\n apply corrective actions to the base case using linear programming methods.\n\ndccor_2\n\n apply corrective actions to the base case using linear programming methods.\n\ndclf\n\ndclf_2\n\nUse this API routine to apply the dc analogy network solution algorithm to the network modeled in the working case (activity DCLF).\n\ndcpscopf\n\nThis API is the DC based Preventive Security Constrained Optimal Power Flow solution (DCPSCOPF).\n\ndeltmpfiles\n\nDelete closed temporary files.\n\ndfax\n\ndfax_2\n\n construct a Distribution Factor Data File (activity DFAX).\n\ndfax_contingency\n\n combine one contingency in the first Distribution Factor file with one contingency in the second Distribution Factor file and so on, till specified contingency level is reached, to create multiple event contingencies and then export resulting contingencies to user defined report device.\n\ndfti\n\n compare tie lines, as contained in the working case, with those of a designated Saved Case (activity DFTI).\n\ndiff\n\n compare specified power flow data and solution results, as contained in the working case, with those of a designated Saved Case (activity DIFF).\n\ndscn\n\n electrically disconnect a bus (activity DSCN).\n\nduplicate_cntlabel_check\n\n specify or return the option to enable or disable the duplicated contingency labels check     when Distribution Factor Data File (.dfx) or Contingency Description Data File (.con) files are used.\n\necdi\n\n place machines in a specified subsystem on- or off-line to satisfy a given subsystem minimum capacity; the in-service machines in the subsystem are then dispatched on the basis of incremental cost to meet a specified total subsystem generation (activity ECDI).\n\necho\n\n enable or disable response echoing (activity ECHO).\n\neeqv\n\n construct an electrical equivalent of a specified subsystem of the working case (activity EEQV).\n\neqrd\n\n build an electrical equivalent of radial and, optionally, two-point Type 1 buses in a specified subsystem of the working case (activity EQRD).\n\nexam\n\n tabulate all power flow data pertaining to a specified bus (activity EXAM).\n\nfact\n\n factorize the network admittance matrix in preparation for switching studies and dynamic simulations (activity FACT).\n\nfdns\n\n apply the fixed slope decoupled Newton-Raphson power flow calculation (activity FDNS).\n\nfile_overwrite\n\n specify or return the option to set the file overwrite option setting to either ask first or overwrite.\n\nfind\n\n tabulate a list of buses matching a partial extended bus name (activity FIND).\n\nflat_start\n\n specify or return the option to enable or disable the voltage flat start option setting.\n\nfnsl\n\n apply the Newton-Raphson power flow calculation (activity FNSL).\n\ngcap\n\ngcap_2\n\n print a report of machine loading and reactive power limit data (activity GCAP).\n\ngdif\n\n calculate differences between the working case and a designated Saved Case (activity GDIF).\n\ngendsp\n\n impose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.\n\ngendsp_2\n\n impose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.\n\ngens\n\n tabulate the loading and voltage conditions at plant buses (activity GENS).\n\ngeol\n\n tabulate the loading and voltage conditions at the generator terminals for online machines at Type 2 and 3 buses in the working case (activity GEOL).\n\ngetcontingencysavedcase\n\nUse this API routine to place the working case in the form of a specified system condition as calculated during a previous run of one of the members of the the AC contingency calculation family.\n\ngic_pf\n\nAdd activity GIC calculated Mvar Qloss in scaled manner to the working case to arrive at the converged power flow solution.\n\ngnestatus\n\n specify or return the status of a GNE device.\n\ngnet\n\n change in-service generation to negative MVA load at all Type 2 and 3 buses in the subsystem specified by the user.\n\nimnet\n\nUse this API routine to change the status of induction machines that are in-service to out-of- service, and to replace the power flowing from the network into the machine with constant power load.\n\nimoutage\n\nUse this API routine to change the status of induction machines that are in-service, but that have been set to the \u201cstalled\u201d (for motors) or \u201ctripped\u201d (for generators) state by the power flow solution, to out-of-service.\n\nimpc\n\n calculate the impact of transaction events on MW flows using a linear network (dc) model.\n\nimplement_transfer\n\nimplement_transfer_2\n\nUse this API routine to apply a specified transfer using the same transfer dispatch methods that are available in the PV analysis calculation engine.\n\ninlf\n\ninlf_2\n\nUse this API routine to run the second release of the inertial and governor response power flow calculation.\n\ninta\n\n summarize tie flows between an interchange area and all other areas in the working case.\n\nintz\n\n summarize tie flows between each zone and all other zones in the working case.\n\nisolate_levels\n\n specify or return the maximum number of levels to go outward when isolating an element by breaker.\n\njoin\n\nThe API combines two buses into a single bus.\n\nlamp\n\n print power flow solution output, including loadings in amps, in a traditional power flow report format.\n\nline_shunt_reporting\n\n specify or return the option to enable or disable the line shunt reporting.\n\nlines_per_page\n\n specify or return the page length limits for the four output devices; also retrieve device names.\n\nlines_per_page_one_device\n\n specify or return the page length limit and device name for one of the four output devices.\n\nlist\n\nUse this API routine to tabulate the power flow working case in a form suitable for problem data documentation.\n\nlistcontingencysavedcases\n\nUse this API routine to obtain a report listing some or all of the system conditions preserved in a ZIP Archive Output File that was created during a previous run of one of the members of the the AC contingency calculation family.\n\nllrf\n\n apply the line loading relief calculation using a linear network (dc) model.\n\nload_reduction\n\n tabulate the amount of load reduction in a specified subsystem due to the voltage at the bus to which the load is connected being below PQBRAK (for constant MVA load) or 0.5 (for constant current load.\n\nlout\n\n print the power flow solution results in a traditional power flow report format.\n\nltap\n\n insert a bus at a designated location along a line.\n\nmaccc\n\nmaccc_2\n\n run the second release of multiple level contingency analysis.\n\nmaccc_3\n\n run the third release of multiple level contingency analysis.\n\nmaccc_parallel\n\n run the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nmaccc_parallel_2\n\n run the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nmaccc_trip_cor\n\nmaccc_trip_cor_2\n\nmaccc_trip_cor_3\n\nThis API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.\n\nmaccc_trip_cor_4\n\nThis API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.\n\nmaccc_with_cor\n\nmaccc_with_cor_2\n\nmaccc_with_cor_3\n\nThis API is the third release of function to run multiple AC contingency analysis with corrective actions.\n\nmaccc_with_cor_4\n\nThis API is the third release of function to run multiple AC contingency analysis with corrective actions.\n\nmaccc_with_trip\n\nmaccc_with_trip_2\n\n run the second version of multiple level contingency analysis with tripping simulation.\n\nmaccc_with_trip_3\n\n run the second version of multiple level contingency analysis with tripping simulation.\n\nmaccc_with_trip_parallel\n\n run the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nmaccc_with_trip_parallel_2\n\n run the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nmatrix_growth_factor\n\n specify or return the value of the matrix growth factor option setting.\n\nmcre\n\n read a Machine Impedance Data File and add the data specified in it to the working case.\n\nmodr\n\n uniformly increase or decrease the line resistances of in-service nontransformer branches.\n\nmov_alpha\n\n specify or return the value of the MOV iteration ALPHA option setting.\n\nmov_iterations\n\n specify or return the value of the maximum MOV iterations option setting.\n\nmov_tolerance\n\n specify or return the value of the MOV iteration tolerance option setting.\n\nmove3wnd\n\n disconnect the third bus of a specified three-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmovebrn\n\n disconnect the to bus of a specified non-transformer branch or two-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveindmac\n\nUse this API routine to disconnect the specified induction machine from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveindmacs\n\nUse this API routine to disconnect all of the induction machines at the specified bus, and reconnect them to a designated bus.\n\nmoveload\n\n disconnect the specified load from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveloads\n\n disconnect all of the load from the specified bus, and reconnect it to a designated bus.\n\nmovemac\n\n disconnect the specified machine from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveplnt\n\n disconnect all of the machines from the specified bus, and reconnect it to a designated bus.\n\nmoveshunt\n\n disconnect the specified fixed shunt from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveshunts\n\n disconnect all of the fixed shunts from the specified bus and reconnect them to a designated bus.\n\nmovesws\n\nmoveswshunt\n\n disconnect the specified switched shunt from the bus to which it is currently connected, and reconnect it to a designated bus.\n\nmoveswshunts\n\n disconnect all of the switched shunts from the specified bus and reconnect them to a designated bus.\n\nmslv\n\n apply the modified Gauss-Seidel power flow calculation.\n\nmsum\n\n print a summary of mileage by owner.\n\nmtdc\n\n produce a report of bus voltages and flows for each in-service multi-terminal dc line.\n\nmultisection_reporting\n\n specify or return the option to enable or disable multi-section line reporting.\n\nmwmi\n\n apply the MAPP MW-mile calculation .\n\nmwomwmsf\n\n tabulate generation (MW) on MW-mile shift factors for a specified transaction event.\n\nmwomwosf\n\n tabulate generation (MW) on MW-ohm shift factors for a specified transaction event.\n\nn11_accc\n\nn11_accc_2\n\nThis API is the second release of N-1-1 contingency analysis solution.\n\nn11_accc_3\n\nThis API is the second release of N-1-1 contingency analysis solution.\n\nn11_accc_parallel\n\n run the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nn11_accc_parallel_2\n\n run the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\n\nn11_accc_pscopf\n\nn11_accc_pscopf_2\n\nThe API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).\n\nn11_accc_pscopf_3\n\nThe API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).\n\nnetg\n\n change the in-service generation to negative MVA load at all Type 2 and 3 buses except those in the subsystem specified by the user.\n\nnew_dimension\n\n reset PSSE to an increased bus size level.\n\nnewcas\n\nnewcase_2\n\nThis API is the second release of the function used to initialize a new power flow case.\n\nnewton_tolerance\n\n specify or return the value of the default Newton-Raphson convergence tolerance.\n\nnon_divergent\n\n specify or return the option to specify or return the option to enable or disable the non-divergent Newton power flow solution.\n\nnon_trans_percent_units\n\n set the non-transformer branch percent units option setting to either MVA or current expressed as MVA.\n\nnsol\n\n apply the decoupled Newton-Raphson power flow calculation.\n\nnumber_threads\n\n specify or return the number of processors available for parallel operations.\n\nordr\n\n calculate a sparsity preserving ordering of buses in preparation for the processing of network matrices.\n\notdf\n\n tabulate vectors of distribution factors using a linear network (dc) model.\n\noutput_y_matrix\n\n display the network admittance matrix for a subsystem of the working case in the form of a list of matrix terms.\n\nouts\n\n tabulate those components in the working case that are removed from service.\n\nownm\n\nownm_2\n\nownm_3\n\nThis API routine is the third release of the owner renumbering function.\n\nownr\n\n tabulate owner totals by owner.\n\npath\n\n specify a directory pathname.\n\nphase_shift_adjustment\n\n specify or return the option to enable or disable the phase shift adjustment.\n\npoly\n\n calculate interchange limits of a study system against two opposing systems using a linear network (dc) model.\n\npout\n\n print the power flow solution results with boundary condition and flow information on the left side of the report and other information on the right side.\n\npower_output\n\n specify or return the option to display power output in either MVA or kVA.\n\npp_accc\n\n report the results of the AC contingency calculation function.\n\npp_accc_multi_case\n\nprint_outaged_branches\n\n specify or return the option to enable or disable whether to print out-of- service branches.\n\nprint_winding_buses\n\n specify or return the option to enable or disable whether to print winding \u201cto\u201d buses of three-winding transformers.\n\nprogress_output\n\n specify the progress output device.\n\nprompt_output\n\n specify the prompt output device.\n\nprti\n\n print the 16 line long title.\n\npscopf\n\npscopf_2\n\nThis API is the second release of Preventive Security Constrained Optimal Power Flow solution (PSCOPF).\n\npseb\n\n convert a PSEB command file into a PSSE response file.\n\npssehalt\n\npssehalt_2\n\n end the operation of PSSE, closes all associated files and returns to the calling application.\n\npv_engine\n\npv_engine_1a\n\npv_engine_2\n\npv_engine_3\n\npv_engine_4\n\npv_engine_5\n\npv_engine_6\n\nUse this API routine to run the PV analysis calculation engine.\n\nqv_engine\n\nqv_engine_2\n\nqv_engine_3\n\nqv_engine_4\n\nUse this API routine to run the QV analysis calculation engine.\n\nrank\n\n estimate the severity of designated single branch outage contingencies and builds a contingency solution output file with contingencies specified in decreasing order of their estimated severities.\n\nrank_brn_and_mac\n\n estimate the severity of designated single element outage contingencies and builds a contingency description data file with contingencies specified in decreasing order of their estimated severities.\n\nrate\n\nrate_2\n\n check branch loadings.\n\nrating_set\n\n specify or return the current rating set, from 1 to 12.\n\nrawd\n\nrawd_2\n\n replicate the working case in the form of a power flow raw data file.\n\nrawdx\n\nrawx_to_csv\n\n export rawx (extended raw data) table to a CSV (comma-separated values) file.\n\nrdch\n\n read power flow change data into the working case.\n\nrdchrawversion\n\n read a Power Flow Change Raw Data File into the working case.\n\nrdeq\n\n build an electrical equivalent of radial and, optionally, two-point Type 1 buses outside of a specified subsystem of the working case.\n\nread\n\n read a power flow raw data file and add all the data specified in it to the working case.\n\nreadcapcurves\n\n read data contained in a Machine Capability Curve Data File into the working case.\n\nreadrawversion\n\n read a power flow raw data file and add all the data specified in it to the working case.\n\nreadrawx\n\n read an extended raw data file and add all the data specified to the working case.\n\nreadsub\n\n read a power flow raw data file and add subsystem data specified in it to the working case.\n\nreadsubrawversion\n\n read a power flow raw data file and add subsystem data specified in it to the working case.\n\nreadx\n\nrecn\n\n electrically reconnect a bus.\n\nregb\n\n tabulate those buses where voltages are controlled by generation, switched shunts, and/or other voltage controlling equipment.\n\nrelind\n\nrelind_2\n\n run probabilistic reliability assessment for transmission systems.\n\nremm\n\n read transaction event data from a transactions raw data file and add it to PSSE working memory.\n\nreport_output\n\n specify the report output device.\n\nresq\n\n read sequence data from a sequence data file and add it to the working case.\n\nresqversion\n\n read a network sequence data file and add all the data specified in it to the working case.\n\nresult_table_output\n\n get and set the default tabular output.\n\nreti\n\n read the long title from an input file into the working case.\n\nretry_pssuserpf\n\n allow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf) after a failure.\n\nrev29_names\n\n set the extended bus name input format to either the PSSE-29 or PSSE-30 format.\n\nrnfi\n\n reproduce the results of a working case bus renumbering operation in auxiliary data input files.\n\nrsol\n\n perform a robust power flow solution (activity RSOL).\n\nrunlastsolution\n\n run the last known power flow solution.\n\nrwcm\n\n replicate the working case in IEEE common tape format.\n\nrwma\n\n replicate machine parametric data from the working case in the form of a machine impedance data file.\n\nrwmm\n\n replicate transaction event data in the form of a transactions data file.\n\nrwsq\n\nrwsq_2\n\n replicate the sequence data contained in the working case in the form of a sequence data file.\n\nsave\n\n save the PSSE working case in a saved case file.\n\nscal\n\nscal_2\n\nscal_3\n\nscal_4\n\nUse this API routine to uniformly increase or decrease any or all specified bus quantities for a specified group of buses.\n\nsensitivity_flow\n\nThis API is used to calculate sensitivity factors of a branch flow to MW power at buses, MW power at generator buses, MW at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts:\n\nsensitivity_flows\n\nThis API is used to calculate sensitivity factors of flows on the branches in a subsystem to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\n\nsensitivity_interface\n\nThis API is used to calculate sensitivity factors of  an interface flow to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap position of tap changing transformers as well as admittance of switched shunts.\n\nsensitivity_voltage\n\nThis API is used to calculate sensitivity factors of a bus voltage to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\n\nsensitivity_voltages\n\nThis API is used to calculate sensitivity factors of  bus voltages in a subsystem to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\n\nset_input_dev\n\n set the terminal input device to a file.\n\nset_progress_verbose\n\n to set the option progress message verbose value.\n\nshnt\n\n tabulate fixed and/or switched bus shunts contained in the working case.\n\nshort_circuit_coordinates\n\n specify or return the option to set the fault analysis voltage and current output coordinates to either rectangular or polar coordinates.\n\nshort_circuit_modeling\n\n specify or return the option for the fault analysis modeling setting; either normal three-phase or center tapped two-phase.\n\nshort_circuit_units\n\n specify or return the option to set the fault analysis voltage and current output units to either per unit or physical units.\n\nshort_circuit_warning\n\n specify or return the option to enable or disable the fault analysis warning option setting.\n\nshort_circuit_z_coordinates\n\n specify or return the option to set the fault analysis output impedance coordinates to either rectangular or polar coordinates.\n\nshort_circuit_z_units\n\n specify or return the option to set the fault analysis output impedance units to either per unit or ohms.\n\nshow\n\n tabulate summaries of Saved Case and/or Snapshot Files.\n\nshowtable\n\nDirects a report table to output console.\n\nshowtablebyindex\n\nThis API routine was first introduced in release 35.\n\nsize\n\n obtain a summary of the number of components in the working case (activity SIZE).\n\nsolv\n\n apply the Gauss-Seidel power flow calculation.\n\nspcb\n\n calculate positive sequence equivalents of branch unbalances.\n\nspil\n\n calculate transmission interchange limits using a linear network (dc) model.\n\nsplt\n\n add a bus to the working case and place a zero impedance line between bus BUS and the new bus.\n\nsqli\n\n tabulate the sequence data in a form suitable for problem data documentation.\n\nsraind\n\n run the substation reliability analysis.\n\nstop\n\nstop_2\n\n end the operation of PSSE.\n\nsubs\n\n summarize conditions in the working case by tabulating the conditions at each swing system bus, conditions at each area slack area bus, number of components, generation/ load/shunt totals, and loss/line shunt/charging totals by voltage levels.\n\nswitched_shunt_adjustment\n\n specify or return the option to enable or disable switched shunt adjustment.\n\ntap_adjustment\n\n specify or return the option for the default tap adjustment setting; either disabled, stepping or direct.\n\ntext\n\nThis API does nothing.\n\ntflg\n\n set or reset the adjustment control mode flags for all automatically adjustable transformers contained in the specified subsystem.\n\nties\n\n tabulate the flows on all area tie lines, with tie flows grouped by area.\n\ntiez\n\n tabulate the flows on all zone tie lines, with tie flows grouped by zone.\n\ntime\n\n tabulate timing statistics.\n\ntlst\n\n tabulate those transformers in the working case where off-nominal turns ratio or phase shift angle may be adjusted by the power flow solution activities.\n\ntltg\n\n calculate transmission interchange limits using a linear network (dc) model.\n\ntpch\n\n check the adjustment data associated with voltage or flow controlling transformers.\n\ntransformer_percent_units\n\n specify or return the option to set the transformer percent units to either MVA or current expressed as MVA.\n\ntransmission_line_units\n\n to specify or return the option set the transmission line units to either per unit or ohms.\n\ntree\n\n check for the existence of in-service ac islands that do not contain a Type 3 (swing) bus.\n\ntspfprofilecurvevalue\n\n return real parameters of Time Series Power Flow profile data.\n\ntysl\n\n run switching study network solutions.\n\nuser\n\n run the user-written activity, subroutine USERAC.\n\nvamm\n\n tabulate the vector absolute MW-mile report.\n\nvamo\n\n tabulate the vector absolute MW-ohm report.\n\nvchk\n\n tabulate those buses where voltage magnitude is outside a specified range.\n\nvoltage_input\n\n specify or return the voltage input option setting; either per unit or kV.\n\nvoltage_output\n\n specify or return the voltage output option setting; either per unit or kV.\n\nvsmo\n\n tabulate the vector MW-ohm report.\n\nwrite_options_file\n\n save the present values of the PSSE-25 program option settings to the file psse.opt.\n\nwritecapcurves\n\n write the capability curve data in the working case in the form of a Capability Curve Raw Data File.\n\nwriterawversion\n\n replicate the working case in the form of power flow raw data file compatible with PSSE 15 or later.\n\nwriterawx\n\n write an extended raw data file from data in the current working case.\n\nwriterawxsubsys\n\n write an extended raw data file from data in the current working case, specifying a subsystem.\n\nwriteseqversion\n\nwriteseqversion_2\n\n replicate the working case in the form of a network sequence data file compatible with PSSE 27 or later.\n\nxeqv\n\n build an electrical equivalent of the portion of the working case outside of a specified subsystem of the working case.\n\nzone\n\nzone_2\n\n tabulate zone totals by zone.\n\nzone_area\n\n tabulate zone totals by zone, along with subtotals by area.\n\nzonm\n\nzonm_2\n\nUse this API routine to reassign the buses, loads and/or induction machines in a specified subsystem of the working case from their original zone to a designated zone.\n\n--- Scenarios \u2014 .txt ---\n\nScenarios \u2014 \n\nScenarios\u00b6\n\nclosescenariofile\n\nnewscenariofile\n\nopenscenariofile\n\nsavescenariofile\n\nscenarioclose\n\n close the currently open Scenario.\n\nscenariocopyfile\n\n copy a file from one group to another group.\n\nscenariofileadd\n\n add a file to the specified group.\n\nscenariofilecount\n\n retrieve the number of files in a specified group in the Scenario.\n\nscenariofilegetattrs\n\n retrieve the attributes of the specified file.\n\nscenariofilegetcomments\n\n retrieve the comments for the specified file.\n\nscenariofilelengthcomments\n\n determine the buffer size needed to hold the comments for the specified file.\n\nscenariofilelist\n\n retrieve the list of files in the specified group.\n\nscenariofileremove\n\n remove a file from the specified group.\n\nscenariofilerename\n\n rename one of the files in the Scenario.\n\nscenariofilesetattrs\n\n modify the attributes of the specified file.\n\nscenariofilesetcomments\n\n define or modify the comments for the specified file.\n\nscenariogetattrs\n\n retrieve the attributes of the Scenario.\n\nscenariogetcomments\n\n retrieve the Scenario comments.\n\nscenariogetopt\n\n retrieve the Scenario options.\n\nscenariogroupadd\n\n add a group to the Scenario.\n\nscenariogroupcount\n\n retrieve the number of groups in the Scenario.\n\nscenariogroupgetcomments\n\n retrieve the comments for the specified group.\n\nscenariogrouplengthcomments\n\n determine the buffer size needed to hold the comments for the specified group.\n\nscenariogrouplist\n\n retrieve the list of groups in the Scenario.\n\nscenariogroupopen\n\n add a group to the Scenario.\n\nscenariogroupremove\n\n remove a group from the Scenario.\n\nscenariogrouprename\n\n rename one of the groups in the Scenario.\n\nscenariogroupsetcomments\n\n define or modify the comments for the specified group.\n\nscenarioisdirty\n\n determine if there are any unsaved changes in the current Scenario.\n\nscenarioisvalid\n\n determine if there is a valid Scenario in memory.\n\nscenariolengthcomments\n\n determine the buffer size needed to hold the current Scenario comments.\n\nscenariomodelgroup\n\n create a new group that is identical to another group.\n\nscenariomovefile\n\n move a file from one group to another group.\n\nscenarionew\n\n create a new Scenario.\n\nscenarioopen\n\n open a previously created Scenario.\n\nscenariosave\n\n save the currently open Scenario.\n\nscenariosetattrs\n\n modify the root path and startup group attributes of the Scenario.\n\nscenariosetcomments\n\n define or modify the Scenario comments.\n\nscenariosetopt\n\n modify the Scenario options.\n\nscenariotrackfileadd\n\n add the files currently being tracked.\n\nscenariotrackfilelist\n\n retrieve the list of files being tracked.\n\nscenariotrackfilenum\n\n retrieve the current number of files being tracked.\n\nscenariounzip\n\n unzip a zipped Scenario.\n\nscenariounzipproblems\n\n retrieve the problems that occurred during the last unzip attempt.\n\nscenariounzipsolutions\n\n submit potential solutions to the problems that occurred during the last unzip attempt.\n\nscenariozip\n\n zip up the current Scenario.\n\nscenariozipactive\n\n determine if the Scenario is currently in Zip Mode.\n\nscenariozipopen\n\n open a zipped Scenario.\n\nscenariozipsave\n\nThis API routine was first introduced in release 33.2.\n\n--- Set Disturbance Definition \u2014 .txt ---\n\nSet Disturbance Definition \u2014 \n\nSet Disturbance Definition\u00b6\n\ndist_def_3phase_bus_fault\n\n define a three phase fault at a bus in dynamic simulations.\n\ndist_def_3wind_fault\n\n define a fault at the IBUS end of a three-winding transformer in dynamic simulations.\n\ndist_def_branch_fault\n\n define a fault at the IBUS end of a non-transformer branch or a two-winding transformer in dynamic simulations.\n\ndist_def_scmu_fault_3\n\n define an unbalanced fault at a bus in dynamic simulations.\n\ndist_def_spcb_fault_2\n\nUse this API routine to define a branch unbalance in dynamic simulations.\n\n--- Set Disturbance \u2014 .txt ---\n\nSet Disturbance \u2014 \n\nSet Disturbance\u00b6\n\ndist_3phase_bus_fault\n\n apply a three phase fault at a bus during dynamic simulations.\n\ndist_3wind_close\n\n set a three-winding transformer to in-service during dynamic simulations.\n\ndist_3wind_fault\n\n apply a fault at the IBUS end of a three-winding transformer during dynamic simulations.\n\ndist_3wind_trip\n\n set a three-winding transformer to out-of-service during dynamic simulations.\n\ndist_branch_close\n\n set a non-transformer branch or a two-winding transformer to in-service during dynamic simulations.\n\ndist_branch_fault\n\n apply a fault at the IBUS end of a non-transformer branch or a two-winding transformer during dynamic simulations.\n\ndist_branch_trip\n\n set a non-transformer branch or a two-winding transformer to out-of-service during dynamic simulations.\n\ndist_bus_fault\n\ndist_bus_fault_2\n\ndist_bus_fault_3\n\n apply an unbalanced fault at a bus during dynamic simulations.\n\ndist_bus_trip\n\n disconnect a bus during dynamic simulations.\n\ndist_clear_fault\n\n clear a fault during dynamic simulations.\n\ndist_machine_trip\n\n set a machine to out-of-service during dynamic simulations.\n\ndist_scmu_fault\n\ndist_scmu_fault_2\n\ndist_scmu_fault_3\n\n calculate an unbalanced fault and apply the equivalent positive sequence fault admittance at a bus during dynamic simulations.\n\ndist_spcb_fault\n\ndist_spcb_fault_2\n\nUse this API routine to run the second release of the dynamics branch unbalance function.\n\n--- Single Element Data \u2014 .txt ---\n\nSingle Element Data \u2014 \n\nSingle Element Data\u00b6\n\napierrstr\n\n return the message string associated with a specific error code returned from a recordable PSSE API routine.\n\nardat\n\n return area totals.\n\naredat\n\n return real area data items.\n\nareint\n\n return integer area data items.\n\narenam\n\n return the area name.\n\narenum\n\n return the area number.\n\nareuse\n\n indicate if an area is in use.\n\naritoj\n\n return the interchange between two areas.\n\nbrncur\n\nbrndat\n\n return real branch parameters.\n\nbrndt2\n\n return complex positive and zero sequence parameters for non-transformer branches, and complex positive sequence parameters for transformer branches.\n\nbrnflo\n\n return the complex branch flow (P+jQ) as calculated at IBUS.\n\nbrnint\n\n return integer branch parameters.\n\nbrnmsc\n\n return real branch flow values.\n\nbrnmva\n\nbrnnam\n\n return the name of an AC branch.\n\nbrnstt\n\nbsysisdef\n\n check whether a bus subsystem has been defined for a given subsystem ID.\n\nbusdat\n\n return real bus values.\n\nbusdt1\n\n return complex bus parameters as MVA.\n\nbusdt2\n\n return complex bus parameters.\n\nbusexs\n\n check for the existence of a specified bus.\n\nbusint\n\n return integer bus parameters.\n\nbusmsm\n\n return complex bus mismatch.\n\nbusordpos\n\n return the ordinal position of the specified bus or bus section in the numerically ordered list of non-star point buses (i.e., star point buses are excluded).\n\nbussectdat\n\nUse this API routine to return real bus section values.\n\nbussectdt1\n\nUse this API routine to return complex bus section parameters as MVA.\n\nbussectdt2\n\nUse this API routine to return complex bus section parameters.\n\nbussectexs\n\nUse this API routine to check for the existence of a specified bus section.\n\nbussectint\n\nUse this API routine to return real bus section values.\n\ncctmdlnam_2dco\n\n return model name of CCT 2-terminal dc line other models.\n\ncctmdlnam_2wtd\n\n return model name of the CCT 2-winding transformer device model.\n\ncctmdlnam_3wtd\n\n return model name of the CCT 3-winding transformer device model.\n\ncctmdlnam_brnd\n\n return model name of the CCT branch device model.\n\ncctmdlnam_brno\n\n return model name of the CCT branch other model.\n\ncctmdlnam_buso\n\n return model name of CCT Bus other models.\n\ncctmdlnam_mcno\n\n return model name of the CCT machine other models.\n\ncctmdlnam_mcnp\n\n return model name of the CCT machine protection models.\n\ncctmdlnam_msco\n\n return model name of the CCT Miscellaneous other model.\n\ncctmdlnam_swso_2\n\n return model name of the CCT switched shunt other type models.\n\ncctmind_2dco\n\n return starting array indices and status of CCT 2-terminal dc line other models.\n\ncctmind_2wtd\n\n return starting array indices and status of CCT 2-winding transformer device models.\n\ncctmind_3wtd\n\n return starting array indices and status of CCT 3-winding transformer device models.\n\ncctmind_brnd\n\n return starting array indices and status of CCT branch device models.\n\ncctmind_brno\n\n return starting array indices and status of CCT branch other models.\n\ncctmind_buso\n\n return starting array indices and status of CCT Bus other models.\n\ncctmind_mcno\n\n return starting array indices and status of CCT machine other models.\n\ncctmind_mcnp\n\n return starting array indices and status of CCT machine protection models.\n\ncctmind_msco\n\n return starting array indices and status of CCT Miscellaneous other models.\n\ncctmind_swso\n\ncctmind_swso_2\n\n return starting array indices and status of CCT Switched Shunt other models.\n\nchktre\n\n check for Type 4 (or greater) buses with in-service branches connected to them.\n\nchnval\n\n return the present value of the simulation variable assigned to a specified output channel.\n\ndc2auxmind\n\n return the starting array indices and status of auxiliary signal model associated with 2-terminal dc line for the specified signal index.\n\ndc2auxmnam\n\n return the auxiliary signal model name associated with a 2-terminal dc line for the specified auxiliary signal index.\n\ndc2dat\n\ndc2dat_2\n\nThis API is the second release of the API that returns real two-terminal dc line quantities.\n\ndc2int\n\ndc2int_2\n\nThis API is the second release of the API that returns integer two-terminal dc line quantities.\n\ndc2mind\n\n return 2-terminal dc line model starting array indices and status.\n\ndc2mnam\n\n return 2-terminal dc line model name.\n\ndcnauxmind\n\n return the starting array indices and status of auxiliary signal model associated with N-terminal dc line for the specified signal index.\n\ndcnauxmnam\n\n return the auxiliary signal model name associated with a N-terminal dc line for the specified auxiliary signal index.\n\ndcncin\n\ndcncin_2\n\nThis API is the second release of the API that returns integer multi-terminal dc line converter quantities.\n\ndcndat\n\ndcndat_2\n\nThis API is the second release of the API that returns real multi-terminal dc line quantities.\n\ndcnint\n\ndcnint_2\n\nThis API is the second release of the API that returns integer multi-terminal dc line quantities.\n\ndcnmind\n\n return N-terminal dc line model starting array indices and status.\n\ndcnmnam\n\n return N-terminal dc line model name.\n\ndscval\n\n return dynamics character array values.\n\ndsival\n\n return dynamics integer array values.\n\ndsrval\n\n return dynamics real values.\n\nfcdauxmind\n\n return the starting array indices and status of auxiliary signal model associated with FACTS device for the specified signal index.\n\nfcdauxmnam\n\n return the auxiliary signal model name associated with a FACTS device for the specified auxiliary signal index.\n\nfcddat\n\nfcddat_2\n\nThis API is the second release of the API that returns FACTS device real quantities.\n\nfcdint\n\nfcdint_2\n\nThis API is the second release of the API that returns FACTS device integer quantities.\n\nfcdmind\n\n return FACTS device model starting array indices and status.\n\nfcdmnam\n\n return FACTS device model name.\n\nfxsdt1\n\n return the magnitude of a specified fixed bus shunt.\n\nfxsdt2\n\n return complex fixed bus shunt.\n\nfxsint\n\n return integer quantities of the specified fixed bus shunt.\n\ngencnv\n\n return a flag indicating whether generators are converted.\n\ngendat\n\n return plant total power output.\n\ngendt1\n\nReturns total plant power output in MVA.\n\ngensectdat\n\nUse this API routine to return a bus section\u2019s plant total power output.\n\ngensectdt1\n\nUse this API routine to return a bus section\u2019s total plant power output in MVA.\n\nget_mstate\n\n return the MSTATE value.\n\ngethomepath\n\n retrieve a user\u2019s HOMEPATH directory.\n\ngnechr\n\nUse this API routine to return character quantities of a specified GNE device.\n\ngnedat\n\nUse this API routine to return real quantities of a specified GNE device.\n\ngneint\n\nUse this API routine to return integer quantities of a specified GNE device.\n\ninddt1\n\nUse this API routine to return real induction machine quantities.\n\ninddt2\n\nUse this API routine to return complex induction machine quantities.\n\nindint\n\nUse this API routine to return integer induction machine quantities.\n\nini2dc\n\nInitializes the two-terminal dc line fetching routine \u2018NXT2DC\u2019 for retrieving two-terminal dc lines in dc line name alphabetical order.\n\ninibrn\n\nInitializes the branch fetching routine \u2018NXTBRN\u2019 or \u2018NXTBRN3\u2019 for returning branches connected to IBUS.\n\ninibrn_2\n\nInitializes the branch fetching routine \u2018NXTBRN_2\u2019 or \u2018NXTBRN3_2\u2019 for returning branches connected to bus sections described by IBUS and INODE.\n\ninibrx\n\nInitializes the branch fetching routine, \u2018NXTBRN\u2019 or \u2018NXTBRN3\u2019 for returning branches connected to IBUS.\n\ninibrx_2\n\nInitializes the branch fetching routine, \u2018NXTBRN_2\u2019 or \u2018NXTBRN3_2\u2019 for returning branches connected to IBUS.\n\ninibus\n\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending numerical order.\n\ninibus_2\n\nInitializes the bus fetching routine \u2018NXTBUS_2\u2019 for retrieving buses in ascending numerical order.\n\ninibux\n\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending numerical order.\n\ninifax\n\nInitializes the FACTS device fetching routine \u2018NXTFAX\u2019 for retrieving FACTS devices in FACTS device name alphabetical order.\n\ninifxs\n\nInitializes the fixed bus shunt fetching routine \u2018NXTFXS\u2019 for returning fixed shunts attached to bus IBUS.\n\niniind\n\nInitializes induction machine fetching routine \u2018NXTIND\u2019 for returning induction machines attached to IBUS.\n\ninilod\n\nInitializes load fetching routine \u2018NXTLOD\u2019 for returning loads attached to IBUS.\n\ninimac\n\nInitializes machine fetching routine \u2018NXTMAC\u2019 for returning machines attached to IBUS.\n\ninimdc\n\nInitializes the multi-terminal dc line fetching routine \u2018NXTMDC\u2019 for retrieving multi-terminal dc lines in dc line name alphabetical order.\n\ninimsl\n\nInitializes the multi-section line member fetching routine \u2018NXTMSL\u2019 for retrieving lines that are sections of the specified multi-section line from IBUS to JBUS.\n\nininam\n\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending alphabetical order.\n\nininam_2\n\nInitializes the bus fetching routine \u2018NXTBUS_2\u2019 for retrieving buses in ascending alphabetical order.\n\nininax\n\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending alphabetical order.\n\ninistabussect\n\nUse this API routine to initialize the bus section fetching routine \u2018NXTSTABUSSECT\u2019 for retrieving the bus sections in a substation.\n\ninistanode\n\nUse this API routine to initialize the node fetching routine \u2018NXTSTANODE\u2019 for retrieving the nodes in a sub-station.\n\ninistaswdev\n\nUse this API routine to initialize the switching device fetching routine \u2018NXTSTASWDEV\u2019 for retrieving the switching devices in a substation.\n\ninisws\n\nInitializes the switched shunt fetching routine \u2018NXTSWS\u2019 for returning switched shunts attached to bus IBUS.\n\ninitie\n\nInitializes the tie branch fetching routine \u2018NXTTIE\u2019 or \u2018NXTTIE3\u2019 for returning tie branches from area IAR.\n\ninitix\n\nInitializes the tie branch fetching routine \u2018NXTTIE\u2019 or \u2018NXTTIE3\u2019 for returning tie branches from area IAR.\n\ninivsc\n\nInitializes the VSC dc line fetching routine \u2018NXTVSC\u2019 for retrieving VSC dc lines in dc line name alphabetical order.\n\nisland\n\nTrips in-service branches connected to Type 4 (or greater) buses, and disconnects islands not containing a swing bus.\n\niterat\n\n return the number of iterations used in the last solution attempt.\n\nlmodind\n\nReturns load-related model starting array indices and status.\n\nlmodnam\n\nReturns load-related model name.\n\nlodcnv\n\nThis obsolete API always returns a 0.\n\nloddt1\n\nReturns load quantities in MVA.\n\nloddt2\n\n return complex load quantities.\n\nlodind\n\n return the load array index.\n\nlodint\n\n return integer load quantities.\n\nlodtype\n\n return the load type character string.\n\nmacchr\n\n return character machine quantities.\n\nmacdat\n\n return real machine quantities.\n\nmacdt2\n\n return complex machine quantities.\n\nmacind\n\n return the machine array index.\n\nmacint\n\n return integer machine quantities.\n\nmacstt\n\n return the machine status value.\n\nmaxmsm\n\n return the complex bus mismatch at the bus with the largest MVA mismatch.\n\nmdlind\n\n return plant-related model starting array indices and status.\n\nmdllibcnt\n\n return the number of libraries in the list to be searched for dynamics library models.\n\nmdlnam\n\n return plant-related model name.\n\nmdlpgmcnt\n\n returns the number of model programs loaded from dynamics model libraries.\n\nnatono\n\n return the bus number for a specified 18-character extended bus name.\n\nnotona\n\n return the bus 18-character extended bus name for a specified bus number.\n\nnotonasect\n\n return the bus 18-character extended bus name for a specified bus section.\n\nnxt2dc\n\nReturns the next two-terminal dc line in dc line name alphabetical order.\n\nnxtbrn\n\nReturns the next branch connected to a bus, excluding three-winding transformers.\n\nnxtbrn3\n\nReturns the next branch connected to a bus, including three-winding transformers.\n\nnxtbrn3_2\n\nReturns the next branch connected to a bus section, including three-winding transformers.\n\nnxtbrn_2\n\nReturns the next branch connected to a bus, excluding three-winding transformers.\n\nnxtbus\n\nReturns the next bus in ordered sequence.\n\nnxtbus_2\n\nReturns the next bus in ordered sequence.\n\nnxtfax\n\nReturns the next FACTS device in FACTS device name alphabetical order.\n\nnxtfxs\n\n return the identifier of the next fixed shunt connected to a bus.\n\nnxtind\n\nUse this API routine to return the identifier of the next induction machine connected to a bus.\n\nnxtlod\n\n return the identifier of the next load connected to a bus.\n\nnxtmac\n\n return the identifier of the next machine connected to a bus.\n\nnxtmdc\n\nReturns the next multi-terminal dc line in dc line name alphabetical order.\n\nnxtmsl\n\n return the next multi-section line member branch.\n\nnxtstabussect\n\nUse this API routine to retrieve the next bus section in the specified substation.\n\nnxtstanode\n\nUse this API routine to retrieve the next node in the specified substation.\n\nnxtstaswdev\n\nUse this API routine to retrieve the next switching device in the specified substation.\n\nnxtsws\n\n return the identifier of the next switched shunt connected to a bus.\n\nnxttie\n\n return the next tie branch from an area, excluding three-winding transformers.\n\nnxttie3\n\n return the next tie branch from an area, including three-winding transformers.\n\nnxtvsc\n\nReturns the next VSC dc line in dc line name alphabetical order.\n\nokstrt\n\nRoutine which may be called after activity STRT or MSTR to indicate the presence of INITIAL CONDITIONS SUSPECT errors (for activity STRT) or at least one MODEL NOT AVAILABLE IN MSTR/MRUN message (for MSTR).\n\nopenun\n\nConnects an IPLAN unit number to the Fortran unit used by activity OPEN and returns that IPLAN unit number.\n\nordbus\n\nThis API routine returns the bus number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-hidden buses (i.e., star point buses and topological buses are excluded).\n\nordbussect\n\nThis API routine returns the bus number and section number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-star point buses (i.e., star point buses are excluded).\n\nowndat\n\nReturns the data associated with an owner (\u2018LOAD\u2019 gets loads at buses of owner \u2018IAR\u2019, \u2018LOADLD\u2019 gets loads assigned to owner \u2018IAR\u2019).\n\nownnam\n\nReturns the owner name for a specified owner number.\n\nownnum\n\nReturns the owner number for a specified owner name.\n\nownuse\n\n indicate whether an owner is in use.\n\nprmdat\n\nUse this API routine to return real-valued solution parameters.\n\nprmint\n\nUse this API routine to return integer-valued solution parameters.\n\nratchr\n\n get rating set parameters.\n\nrmodind\n\nReturns the branch relay model starting array indices and status.\n\nrmodnam\n\nReturns the branch relay model name.\n\nsbsgtbkv\n\n get previously defined bus subsystem voltage limits.\n\nsc3wnd\n\nReturns the three-winding transformer short circuit currents arriving at IBUS following activity SCMU.\n\nscbrn2\n\nReturns the branch short circuit currents arriving at IBUS following activity SCMU.\n\nscbus2\n\nReturns complex bus voltages and currents following activity SCMU.\n\nscdone\n\n restore the working case after \u2018SCINIT\u2019.\n\nscinit\n\n initialize the short-circuit data retrieval APIs.\n\nscmac2\n\n return the machine short circuit currents following activity SCMU.\n\nselctr\n\n return the activity selector indicator.\n\nsethomepath\n\n set a user\u2019s HOMEPATH directory.\n\nsfiles\n\n return the current Saved Case and Snapshot filenames.\n\nslmodind\n\n return the subsystem load-related model starting array indices and status.\n\nslmodnam\n\n return the subsystem load-related model name.\n\nsolstr\n\n return a string indicating the result of the last solution attempt.\n\nsolved\n\n check whether the last solution attempt reached tolerance.\n\nsolved_ca\n\n check whether the last corrective action solution attempt reached tolerance.\n\nstadat\n\nUse this API routine to return real substation values.\n\nstaint\n\nUse this API routine to return integer substation values.\n\nstaname\n\nUse this API routine to return a substation\u2019s name.\n\nstanodeint\n\nUse this API routine to return integer substation values.\n\nstanodename\n\nUse this API routine to return the name of a substation node.\n\nstarea\n\n restrict \u2018NXTBUS\u2019 to a single area.\n\nstaswdevdat\n\nUse this API routine to return real substation switching device values.\n\nstaswdevint\n\nUse this API routine to return integer substation switching device values.\n\nstaswdevname\n\nUse this API routine to return the name of a substation switching device.\n\nstbskv\n\n restrict \u2018NXTBUS\u2019 to a single base voltage level.\n\nstzone\n\n restrict \u2018NXTBUS\u2019 to a single zone.\n\nswsblk\n\nswsblk_2\n\n return data for a specified block of a specified switched shunt.\n\nswsblz\n\nswsblz2\n\nswsdat\n\nswsdat_2\n\n return switched shunt real data.\n\nswsdt1\n\nswsint\n\nswsint_2\n\n return switched shunt integer parameters.\n\nswsmind\n\nswsmind_2\n\n return switched shunt model starting array indices and status.\n\nswsmnam\n\nswsmnam_2\n\n return switched shunt model name.\n\nsysmsm\n\n return the total system MVA mismatch.\n\nsysmva\n\n return the system base MVA.\n\nsystot\n\n return complex system-wide values.\n\ntitldt\n\n return the two line case title.\n\ntotbus\n\n return the total number of buses in the working case.\n\ntr3dat\n\n return three-winding transformer real values.\n\ntr3dt2\n\n return three-winding transformer complex values.\n\ntr3int\n\n return three-winding transformer integer values.\n\ntr3nam\n\n return three-winding transformer name.\n\ntrndat\n\ntrxdat\n\n return the inter-area transfer MW.\n\ntspfprofilechr\n\n return string parameters of Time Series Power Flow profile.\n\ntspfprofilecurvechr\n\n return string parameters of Time Series Power Flow profile curve.\n\ntspfprofilecurveint\n\n return integer parameters of Time Series Power Flow profile curve.\n\ntspfprofilecurvereal\n\n return real parameters of Time Series Power Flow profile curve.\n\ntspfprofileint\n\n return integer parameters of Time Series Power Flow profile.\n\ntspfprofilereal\n\n return real parameters of Time Series Power Flow profile.\n\nvoltagedroopdata\n\n return voltage droop control real parameters.\n\nvoltagedroopint\n\n return voltage droop control integer parameters.\n\nvscauxmind\n\n return the starting array indices and status of auxiliary signal model associated with VSC dc line for the specified signal index.\n\nvscauxmnam\n\n return the auxiliary signal model name associated with a VSC dc line for the specified auxiliary signal index.\n\nvsccdt\n\n return VSC dc line real parameters.\n\nvsccin\n\n return VSC dc line converter integer parameters.\n\nvscint\n\n return VSC dc line integer parameters.\n\nvscmind\n\n return VSC dc line model starting array indices and status.\n\nvscmnam\n\n return VSC dc line model name.\n\nwindmind\n\n return wind model starting array indices and status.\n\nwindmnam\n\n return wind model name.\n\nwnddat\n\n return three-winding transformer real values for winding connected to bus IBUS.\n\nwnddt2\n\n return three-winding transformer complex values for winding connected to bus IBUS.\n\nwndint\n\n return three-winding transformer integer values for winding connected to bus IBUS.\n\nxfrdat\n\n return two-winding transformer real parameters.\n\nxfrint\n\n return two-winding transformer integer parameters.\n\nxfrnam\n\n return two-winding transformer name.\n\nzndat\n\n return zone totals.\n\nznitoj\n\n return the interchange between two zones.\n\nzonnam\n\n return the zone name.\n\nzonnum\n\n return the zone number.\n\nzonuse\n\n indicate whether a zone is in use.\n\n--- Substation Data \u2014 .txt ---\n\nSubstation Data \u2014 \n\nSubstation Data\u00b6\n\nastationchar\n\n return an array of character values for subsystem substations.\n\nastationcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the substation data family.\n\nastationint\n\n return an array of integer values for subsystem substations.\n\nastationreal\n\n return an array of real values for subsystem substations.\n\nastationtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation data family (aStationInt, aStationReal and aStationChar).\n\n--- Substation Node Data \u2014 .txt ---\n\nSubstation Node Data \u2014 \n\nSubstation Node Data\u00b6\n\nanodechar\n\n return an array of character values for subsystem substation nodes.\n\nanodecount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the substation node data family.\n\nanodeint\n\n return an array of integer values for subsystem substation nodes.\n\nanodereal\n\n return an array of real values for subsystem substation nodes.\n\nanodetypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation node data family (aNodeInt and aNodeChar).\n\n--- Substation Switching Device Data \u2014 .txt ---\n\nSubstation Switching Device Data \u2014 \n\nSubstation Switching Device Data\u00b6\n\nastaswdevchar\n\n return an array of character values for subsystem substation switching devices.\n\nastaswdevcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the substation switching device data family.\n\nastaswdevcplx\n\n return an array of complex values for subsystem substation switching devices.\n\nastaswdevint\n\n return an array of integer values for subsystem substation switching devices.\n\nastaswdevreal\n\n return an array of real values for subsystem substation switching devices.\n\nastaswdevtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation switching device data family (aStaSwDevInt, aStaSwDevReal, aStaSwDevCplx and aStaSwDevChar).\n\n--- Substation Terminal Data \u2014 .txt ---\n\nSubstation Terminal Data \u2014 \n\nSubstation Terminal Data\u00b6\n\naterminalchar\n\n return an array of integer values for subsystem substation terminals.\n\naterminalcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the substation terminal data family.\n\naterminalint\n\n return an array of integer values for subsystem substation terminals.\n\naterminaltypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation terminal data family (aTerminalInt and aTerminalChar).\n\n--- Switched Shunt Bus Data \u2014 .txt ---\n\nSwitched Shunt Bus Data \u2014 \n\nSwitched Shunt Bus Data\u00b6\n\naswshuntbuschar\n\n return an array of character values for subsystem buses.\n\naswshuntbuscount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt bus data family.\n\naswshuntbuscplx\n\n return an array of complex values for subsystem buses.\n\naswshuntbusint\n\n return an array of integer values for subsystem buses.\n\naswshuntbusreal\n\n return an array of real values for subsystem buses.\n\naswshuntbustypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt bus data family (aSwShntBusInt, aSwShntBusReal, aSwShntBusCplx and aSwShntBusChar).\n\n--- Switched Shunt Data \u2014 .txt ---\n\nSwitched Shunt Data \u2014 \n\nSwitched Shunt Data\u00b6\n\naswshchar\n\n return an array of character values for subsystem switched shunts.\n\naswshcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt data family.\n\naswshcplx\n\n return an array of complex values for subsystem switched shunts.\n\naswshint\n\n return an array of integer values for subsystem switched shunts.\n\naswshreal\n\n return an array of real values for subsystem switched shunts.\n\naswshtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt data family (aSwshInt, aSwshReal, aSwshCplx and aSwshChar).\n\n--- Switched Shunt Models \u2014 .txt ---\n\nSwitched Shunt Models \u2014 \n\nSwitched Shunt Models\u00b6\n\nadd_swshunt_model\n\nadd_swshunt_model_2\n\n add a switched shunt model to the specified switched shunt device.\n\nchange_swsmod_chricn\n\nchange_swsmod_chricn_2\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of the switched shunt model of a specified switched shunt device.\n\nchange_swsmod_con\n\nchange_swsmod_con_2\n\n change the value of a CON of the switched shunt model of a specified switched shunt device.\n\nchange_swsmod_icon\n\nchange_swsmod_icon_2\n\n change the value of an integer ICON (i.e., an element of the ICON array) of the switched shunt model of a specified switched shunt device.\n\nchange_swsmod_var\n\nchange_swsmod_var_2\n\n change the value of a VAR of the switched shunt model of a specified switched shunt device.\n\ngmb_add_swshunt_model\n\ngmb_add_swshunt_model_2\n\n add a GMB switched shunt model to the specified switched shunt device.\n\nswsmod_pack\n\n remove entries that are marked as unused from the switched shunt model connection tables and the switched shunt model array allocation tables.\n\nswsmod_remove\n\nswsmod_remove_2\n\n remove the switched shunt model from a specified switched shunt.\n\nswsmod_status\n\nswsmod_status_2\n\n change the status of the switched shunt model at a specified switched shunt device.\n\nswsmod_unconnected\n\n list or remove from dynamics working memory those switched shunt models that are assigned to switched shunt that are not present in the current power flow working case (unconnected).\n\nswsmod_user\n\n list user-written switched shunt model definitions or to remove user-written switched shunt model definitions that are not assigned to any switched shunt devices (unused) from the user model definition tables.\n\n--- Three-Winding Transformer Data \u2014 .txt ---\n\nThree-Winding Transformer Data \u2014 \n\nThree-Winding Transformer Data\u00b6\n\natr3char\n\n return an array of character values for subsystem three-winding transformers.\n\natr3count\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer data family.\n\natr3cplx\n\n return an array of complex values for subsystem three-winding transformers.\n\natr3int\n\n return an array of integer values for subsystem three-winding transformers.\n\natr3real\n\n return an array of real values for subsystem three-winding transformers.\n\natr3types\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer data family (aTr3Int, aTr3Real, aTr3Cplx and aTr3Char).\n\n--- Three-Winding Transformer Winding Data \u2014 .txt ---\n\nThree-Winding Transformer Winding Data \u2014 \n\nThree-Winding Transformer Winding Data\u00b6\n\nawndchar\n\n return an array of character values for subsystem three-winding transformer windings.\n\nawndcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer winding data family.\n\nawndcplx\n\n return an array of complex values for subsystem three-winding transformer windings.\n\nawndint\n\n return an array of integer values for subsystem three-winding transformer windings.\n\nawndreal\n\n return an array of real values for subsystem three-winding transformer windings.\n\nawndtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer winding data family (aWndInt, aWndReal, aWndCplx and aWndChar).\n\n--- Time Series Power Flow Data \u2014 .txt ---\n\nTime Series Power Flow Data \u2014 \n\nTime Series Power Flow Data\u00b6\n\npurge_tspf_channel\n\n delete all Time Series Power Flow profiles for an element.\n\npurge_tspf_channel_all\n\n remover all time series power flow channels for a selected element.\n\npurge_tspf_profile\n\n delete Time Series Power Flow profile by profile name.\n\npurge_tspf_profilecurve\n\n delete Time Series Power Flow profile curve by curvesetid and curvecol and index.\n\npurge_tspf_profilecurveset\n\n delete Time Series Power Flow profile curve set by profile curvesetid.\n\npurge_tspf_profiledata\n\n delete Time Series Power Flow profile data by curvesetid and curvecol and index.\n\ntspf_channel_chng\n\n select time series power flow Cchannels.\n\ntspf_channel_data\n\n select time series power flow Cchannels.\n\ntspf_profile_chng\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile.\n\ntspf_profile_data\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile, or to add a new Time Series Power Flow profile.\n\ntspf_profilecurveset_chng\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve set.\n\ntspf_profilecurveset_data\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve set, or to add a new Time Series Power Flow profile curve set.\n\ntspf_profiledata_chng\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve value.\n\ntspf_profiledata_data\n\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve value, or to add a new Time Series Power Flow profile curve value.\n\n--- Time Series Power Flow Operation \u2014 .txt ---\n\nTime Series Power Flow Operation \u2014 \n\nTime Series Power Flow Operation\u00b6\n\nimposeprofile\n\n impose generation/load at the given time point on profile curves.\n\ntspf\n\n run the time series power flow solution.\n\ntspf_output_pmatrix\n\n output the profile curves within one profile set in the matrix format.\n\ntspf_output_pmatrix_2\n\n output the profile curves within one profile set in the matrix format.\n\n--- Two-Terminal Dc Line Converter Data \u2014 .txt ---\n\nTwo-Terminal Dc Line Converter Data \u2014 \n\nTwo-Terminal Dc Line Converter Data\u00b6\n\na2trmdcconvchar\n\n return an array of character values for subsystem two-terminal dc line converters.\n\na2trmdcconvcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line converter data family.\n\na2trmdcconvcplx\n\n return an array of complex values for subsystem two-terminal dc line converters.\n\na2trmdcconvint\n\n return an array of integer values for subsystem two-terminal dc line converters.\n\na2trmdcconvreal\n\n return an array of real values for subsystem two-terminal dc line converters.\n\na2trmdcconvtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (a2TrmDcConvInt, a2TrmDcConvReal, a2TrmDcConvCplx and a2TrmDcConvChar).\n\n--- Two-Terminal Dc Line Data \u2014 .txt ---\n\nTwo-Terminal Dc Line Data \u2014 \n\nTwo-Terminal Dc Line Data\u00b6\n\na2trmdcchar\n\n return an array of character values for subsystem two-terminal dc lines.\n\na2trmdccount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line data family.\n\na2trmdccplx\n\n return an array of complex values for subsystem two-terminal dc lines.\n\na2trmdcint\n\n return an array of integer values for subsystem two-terminal dc lines.\n\na2trmdcreal\n\n return an array of real values for subsystem two-terminal dc lines.\n\na2trmdctypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line data family (a2TrmDcInt, a2TrmDcReal, a2TrmDcCplx and a2TrmDcChar).\n\n--- Two-Winding Transformer Data \u2014 .txt ---\n\nTwo-Winding Transformer Data \u2014 \n\nTwo-Winding Transformer Data\u00b6\n\natrnchar\n\n return an array of character values for subsystem two-winding transformers.\n\natrncount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the two-winding transformer data family.\n\natrncplx\n\n return an array of complex values for subsystem two-winding transformers.\n\natrnint\n\n return an array of integer values for subsystem two-winding transformers.\n\natrnreal\n\n return an array of real values for subsystem two-winding transformers.\n\natrntypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-winding transformer data family (aTrnInt, aTrnReal, aTrnCplx and aTrnChar).\n\n--- Using The Vendor Neutral Contingency And Ras Auxiliary File \u2014 .txt ---\n\nUsing The Vendor Neutral Contingency And Ras Auxiliary File \u2014 \n\nUsing The Vendor Neutral Contingency And Ras Auxiliary File\u00b6\n\naccc_ras\n\naccc_ras_2\n\n run AC contingency calculation function with RAS model.\n\nadd2windingconditionelement\n\nAdd 2WindingConditionElement to RAS memory model\n\nadd2windingcontingencyelement\n\nAdd 2WindingContingencyElement to RAS memory model\n\nadd2windingremedialactionelement\n\nAdd 2WindingRemedialActionElement to RAS memory model\n\nadd3windingconditionelement\n\nAdd 3WindingConditionElement to RAS memory model\n\nadd3windingcontingencyelement\n\nAdd 3WindingContingencyElement to RAS memory model\n\nadd3windingremedialactionelement\n\nAdd 3WindingRemedialActionElement to RAS memory model\n\naddaclineconditionelement\n\nAdd AclineConditionElement to RAS memory model\n\naddaclinecontingencyelement\n\nAdd AclineContingencyElement to RAS memory model\n\naddaclineremedialactionelement\n\nAdd AclineRemedialActionElement to RAS memory model\n\naddbusconditionelement\n\nAdd BusConditionElement to RAS memory model\n\naddbuscontingencyelement\n\nAdd BusContingencyElement to RAS memory model\n\naddbusremedialactionelement\n\nAdd BusRemedialActionElement to RAS memory model\n\naddcondition\n\nAdd Condition to RAS memory model\n\naddconditionelement\n\nAdd ConditionElement to RAS memory model\n\naddcontingency\n\nAdd Contingency to RAS memory model\n\naddcontingencyelement\n\nAdd ContingencyElement to RAS memory model\n\nadddcconvconditionelement\n\nAdd DcconvConditionElement to RAS memory model\n\nadddcconvcontingencyelement\n\nAdd DcconvContingencyElement to RAS memory model\n\nadddcconvremedialactionelement\n\nAdd DcconvRemedialActionElement to RAS memory model\n\nadddclineconditionelement\n\nAdd DclineConditionElement to RAS memory model\n\nadddclinecontingencyelement\n\nAdd DclineContingencyElement to RAS memory model\n\nadddclineremedialactionelement\n\nAdd DclineRemedialActionElement to RAS memory model\n\naddfixshuntconditionelement\n\nAdd FixshuntConditionElement to RAS memory model\n\naddfixshuntcontingencyelement\n\nAdd FixshuntContingencyElement to RAS memory model\n\naddfixshuntremedialactionelement\n\nAdd FixshuntRemedialActionElement to RAS memory model\n\naddgenconditionelement\n\nAdd GenConditionElement to RAS memory model\n\naddgencontingencyelement\n\nAdd GenContingencyElement to RAS memory model\n\naddgenremedialactionelement\n\nAdd GenRemedialActionElement to RAS memory model\n\naddloadconditionelement\n\nAdd LoadConditionElement to RAS memory model\n\naddloadcontingencyelement\n\nAdd LoadContingencyElement to RAS memory model\n\naddloadremedialactionelement\n\nAdd LoadRemedialActionElement to RAS memory model\n\naddnestedcondition\n\nAdd NestedCondition to RAS memory model\n\naddpythonconditionelement\n\nAdd PythonConditionElement to RAS memory model\n\naddpythoncontingencyelement\n\nAdd PythonContingencyElement to RAS memory model\n\naddpythonremedialactionelement\n\nAdd PythonRemedialActionElement to RAS memory model\n\naddremedialaction\n\nAdd RemedialAction to RAS memory model\n\naddremedialactionelement\n\nAdd RemedialActionElement to RAS memory model\n\naddsubconditionelement\n\nAdd SubConditionElement to RAS memory model\n\naddsubcontingencyelement\n\nAdd SubContingencyElement to RAS memory model\n\naddsubremedialactionelement\n\nAdd SubRemedialActionElement to RAS memory model\n\naddvscdcconditionelement\n\nAdd VscdcConditionElement to RAS memory model\n\naddvscdccontingencyelement\n\nAdd VscdcContingencyElement to RAS memory model\n\naddvscdcremedialactionelement\n\nAdd VscdcRemedialActionElement to RAS memory model\n\nappend_ras\n\n read a Contingency Definition and Remedial Actions auxiliary file, adding to definitions in memory, if present.\n\nread_ras\n\n read a Contingency Definition and Remedial Actions auxiliary file into memory.\n\nvalidate_ras\n\n validate Contingency and Remedial Actions definitions in memory.\n\nwrite_ras\n\n write a Contingency Definition and Remedial Actions auxiliary file from memory.\n\n--- Vsc Dc Line Converter Data \u2014 .txt ---\n\nVsc Dc Line Converter Data \u2014 \n\nVsc Dc Line Converter Data\u00b6\n\navscdcconvchar\n\n return an array of character values for subsystem VSC dc line converters.\n\navscdcconvcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line converter data family.\n\navscdcconvcplx\n\n return an array of complex values for subsystem VSC dc line converters.\n\navscdcconvint\n\n return an array of integer values for subsystem VSC dc line converters.\n\navscdcconvreal\n\n return an array of real values for subsystem VSC dc line converters.\n\navscdcconvtypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line converter data family (aVscDcConvInt, aVscDcConvReal, aVscDcConvCplx and aVscDcConvChar).\n\n--- Vsc Dc Line Data \u2014 .txt ---\n\nVsc Dc Line Data \u2014 \n\nVsc Dc Line Data\u00b6\n\navscdcchar\n\n return an array of character values for subsystem VSC dc lines.\n\navscdccount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line data family.\n\navscdccplx\n\n return an array of complex values for subsystem VSC dc lines.\n\navscdcint\n\n return an array of integer values for subsystem VSC dc lines.\n\navscdcreal\n\n return an array of real values for subsystem VSC dc lines.\n\navscdctypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line data family (aVscDcInt, aVscDcReal, aVscDcCplx and aVscDcChar).\n\n--- Wind Related Models \u2014 .txt ---\n\nWind Related Models \u2014 \n\nWind Related Models\u00b6\n\nadd_wind_model\n\n add a renewable related model of a designated type to a specified renewable machine.\n\nchange_wnmod_chricn\n\n change the value of a character ICON (i.e., an element of the CHRICN array) of a designated renewable related model at a specified renewable machine.\n\nchange_wnmod_con\n\n change the value of a CON of a designated renewable machine related model at a specified renewable machine.\n\nchange_wnmod_icon\n\n change the value of an integer ICON of a designated renewable machine related model at a specified renewable machine.\n\nchange_wnmod_var\n\n change the value of a VAR of a designated renewable machine related model at a specified renewable machine.\n\nwnmod_consistency\n\n check consistency among the renewable machine related models referenced at each machine.\n\nwnmod_pack\n\n remove entries that are marked as unused from the wind model connection tables and the renewable machine model array allocation tables.\n\nwnmod_remove\n\n remove a renewable machine related model of a designated type from a specified renewable machine.\n\nwnmod_status\n\n change the status of a renewable machine related model of a designated type at a specified renewable machine.\n\nwnmod_unconnected\n\n list or remove from dynamics working memory those renewable machine related models that are assigned to renewable machines that are not present in the current power flow working case (unconnected).\n\nwnmod_user\n\n list user-written renewable machine model definitions or to remove user-written renewable machine model definitions that are not assigned to any renewable machines (unused) from the user model definition tables.\n\n--- Zero Sequence Mutuals Data \u2014 .txt ---\n\nZero Sequence Mutuals Data \u2014 \n\nZero Sequence Mutuals Data\u00b6\n\nazmutchar\n\n return an array of character values for subsystem zero sequence mutual branches.\n\nazmutcount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the branch zero sequence mutual data family.\n\nazmutcplx\n\n return an array of complex values for subsystem zero sequence mutual branches.\n\nazmutint\n\n return an array of integer values for subsystem zero sequence mutual branches.\n\nazmutreal\n\n return an array of real values for subsystem zero sequence mutual branches.\n\nazmuttypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch zero sequence mutual data family (aZmutInt, aZmutReal, aZmutCplx and aZmutChar).\n\n--- Zone Data \u2014 .txt ---\n\nZone Data \u2014 \n\nZone Data\u00b6\n\nazonechar\n\n return an array of character values for subsystem zones.\n\nazonecount\n\n return the number of array entries required to accommodate the data to be returned by the remaining members of the zone data family.\n\nazonecplx\n\n return an array of complex values for subsystem zones.\n\nazoneint\n\n return an array of integer values for subsystem zones.\n\nazonereal\n\n return an array of real values for subsystem zones.\n\nazonetypes\n\n return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the zone data family (aZoneInt, aZoneReal, aZoneCplx and aZoneChar).\n\n--- Zone Subsystems \u2014 .txt ---\n\nZone Subsystems \u2014 \n\nZone Subsystems\u00b6\n\nzsys\n\n define a zone subsystem.\n\nzsysdef\n\n set the definition of an zone subsystem.\n\nzsysinit\n\n initialize or re-initialize a zone subsystem.\n#[accc_reports.py]  GET ACCC SOLUTION IN ARRAYS and CREATE CUSTOM REPORTS\n#"
  },
  {
    "id": 1,
    "text": "'''\nThis is an example file showing how to use ACCC Solution Array fetch APIs\nfrom Python to generate custom accc solution reports.\n\nFollowing ACCC solutions can be retrieved:\n    - post-contingency solution,\n    - post-tripping solution, or\n    - post-corrective action solution\n\nThese ACCC solutions can be obtained in Python lists for:\n    - single contingency,\n    - multiple contingencies, or\n    - all contingencies\n\nThe APIs used in this program are part of python \"arrbox.accc_pp\" module.\n    accobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)\n    Following methods are defined for accobj.\n    - accobj.summary and accobj.solution methods return ACCC solution\n      in python object, which can be used to create custom reports, or\n    - accobj.summary_report, accobj.solution_report or accobj.violations_report\n      methods can be used to get pre-defined reports.\n\nGet more info on as:\n    help(arrbox.accc_pp.CONTINGENCY_PP)"
  },
  {
    "id": 5,
    "text": "def create_accc_reports(accfile, rptfile):\n\n    import psspy, arrbox.accc_pp\n\n    if not os.path.exists(accfile):\n        prgmsg = \" Error: Input accfile '{0}' does not exist\".format(accfile)\n        print(prgmsg)\n        return\n\n    if rptfile:\n        p, nx = os.path.split(rptfile)\n        n, x = os.path.splitext(nx)\n        if not x:\n            x = '.txt'\n            nx = n + x\n        if p:\n            rptfile = os.path.join(p, nx)\n        else:\n            rptfile = os.path.join(os.getcwd(), nx)\n\n        rptfpath, rptext = os.path.splitext(rptfile)\n\n    #"
  },
  {
    "id": 9,
    "text": "# (3) ACCC post contingency solution report\n    accobj.solution_options(stype=stype_cnt,busmsm=busmsm,sysmsm=sysmsm,rating=rating,flowlimit=flowlimit)\n    cntsolnfile = None\n    if rptfile:  cntsolnfile = rptfpath + '_solution_cnt' + rptext\n    accobj.solution_report(colabels=None,rptfile=cntsolnfile)\n\n    #"
  },
  {
    "id": 10,
    "text": "# (4) ACCC post tripping solution report\n    trpsolnfile = None\n    if rptfile:  trpsolnfile = rptfpath + '_solution_trp' + rptext\n    accobj.solution_options(stype=stype_trp)    # changed only solution type, other options remain same\n    accobj.solution_report(colabels=None,rptfile=trpsolnfile)\n\n    #"
  },
  {
    "id": 11,
    "text": "# (5) ACCC post corrective action solution report\n    cactsolnfile = None\n    if rptfile:  cactsolnfile = rptfpath + '_solution_cact' + rptext\n    accobj.solution_options(stype=stype_cact)    # changed only solution type, other options remain same\n    accobj.solution_report(colabels=None,rptfile=cactsolnfile)\n\n    #"
  },
  {
    "id": 15,
    "text": "# (9) Getting summary arrays and printing contingency lables in PSS(R)E progress window\n    smryobj = accobj.summary()\n        # note: returned \"smryobj\" is used in the following (10) to (16) examples of this program.\n    psspy.progress('\\n Contingency Labels:\\n')\n    for each in smryobj.colabel:\n        psspy.progress('    '+each+'\\n')\n\n    #"
  },
  {
    "id": 16,
    "text": "# (10) Getting solution arrays for one contingency and printing monitored element MVA and AMP flows\n    #      in PSS(R)E progress window\n    idx   = random.sample(list(range(len(smryobj.colabel))),1)   # select one contingency randomly\n    colbl = smryobj.colabel[idx[0]]\n    accobj.solution_options(stype=stype_cnt)\n    solnobj  = accobj.solution(colabel=colbl)\n    if solnobj!=None:        # contingency solution found/error, proceed\n        rating = rating.strip().lower()\n        try:\n            rate = smryobj.rating.rating\n        except:\n            rate = smryobj.rating.a\n\n        psspy.progress(\"\\n Monitored Element Flows for contingency '%12s':\\n\" % colbl)\n        psspy.progress(\"<"
  },
  {
    "id": 18,
    "text": "> <RATING> <MVAFLOW> \\\n    <AMPFLOW> <PCTFLOW>\\n\")\n        for i in range(len(solnobj.mvaflow)):\n            elmt    = \"%54s\" % smryobj.melement[i]\n            mvaflow = \"%9.2f\" % solnobj.mvaflow[i]\n            if i < smryobj.acccsize.nmline:\n                ampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\n                pctflow = abs(solnobj.ampflow[i])\n            else:\n                ampflow = 9*' '                 # for interfaces, no AMP flow\n                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\n\n            if rate[i]:\n                elmt_rate = \"%8.2f\" % rate[i]\n                pctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\n            else:   # if rating is not provided, don't calculate %flow\n                elmt_rate = 8*' '\n                pctflow   = 9*' '\n\n            txtstr = \"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars()\n            psspy.progress(txtstr)\n\n    #"
  },
  {
    "id": 19,
    "text": "# (11) Getting solution arrays for three contingency and printing monitored element MVA and AMP flows\n    #      in PSS(R)E progress window for converged contingencies\n\n    # select upto maximum of 3 contingencies randomly\n    idx    = random.sample(list(range(len(smryobj.colabel))),min(len(smryobj.colabel),3))\n    colbls = [smryobj.colabel[x] for x in idx]\n\n    rating = rating.strip().lower()\n    try:\n        rate = smryobj.rating.rating\n    except:\n        rate = smryobj.rating.a\n\n    for lbl in colbls:\n        solnobj  = accobj.solution(colabel=lbl)\n        if solnobj==None: continue          # contingency solution not found, move to next\n        if not solnobj.cnvflag: continue    # contingency solution not converged, move to next\n        psspy.progress(\"\\n Monitored Element Flows for contingency '%12s':\\n\" % lbl)\n        psspy.progress(\"<"
  },
  {
    "id": 21,
    "text": "> <RATING> <MVAFLOW> \\\n<AMPFLOW> <PCTFLOW>\\n\")\n        for i in range(len(solnobj.mvaflow)):\n            elmt    = \"%54s\" % smryobj.melement[i]\n            mvaflow = \"%9.2f\" % solnobj.mvaflow[i]\n\n            if i < smryobj.acccsize.nmline:\n                ampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\n                pctflow = abs(solnobj.ampflow[i])\n            else:\n                ampflow = 9*' '                 # for interfaces, no AMP flow\n                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\n\n            if rate[i]:\n                elmt_rate = \"%8.2f\" % rate[i]\n                pctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\n            else:   # if rating is not provided, don't calculate %flow\n                elmt_rate = 8*' '\n                pctflow   = 9*' '\n\n            txtstr = \"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars()\n            psspy.progress(txtstr)\n        psspy.progress('\\n')\n\n    #"
  },
  {
    "id": 22,
    "text": "# (12) Creating Overload report (similar to PSS(R)E ACCC Spreadsheet Overload Report) in\n    #      PSS(R)E progress window\n\n    rating = rating.strip().lower()\n    try:\n        rate = smryobj.rating.rating\n    except:\n        rate = smryobj.rating.a\n\n    psspy.progress(\"\\n OVERLOAD Report\\n\")\n    for lbl in smryobj.colabel:\n        solnobj  = accobj.solution(colabel=lbl)\n        if solnobj==None: continue         # contingency solution not found, move to next\n        if not solnobj.cnvflag: continue   # contingency solution not converged, move to next\n        psspy.progress(\" Monitored Element Flows above %g%% for contingency '%12s':\\n\" % (flowlimit,lbl))\n        psspy.progress(\"<"
  },
  {
    "id": 24,
    "text": "> <RATING> <MVAFLOW> \\\n<AMPFLOW> <PCTFLOW>\\n\")\n        for i in range(len(solnobj.mvaflow)):\n            elmt    = \"%54s\" % smryobj.melement[i]\n            mvaflow = \"%9.2f\" % solnobj.mvaflow[i]\n\n            if i < smryobj.acccsize.nmline:\n                ampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\n                pctflow = abs(solnobj.ampflow[i])\n            else:\n                ampflow = 9*' '                 # for interfaces, no AMP flow\n                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\n\n            if rate[i]:\n                elmt_rate = \"%8.2f\" % rate[i]\n                pctflow_v = pctflow*100.0/rate[i]\n                pctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\n            else:   # if rating is not provided, don't calculate %flow\n                elmt_rate = 8*' '\n                pctflow   = 9*' '\n                pctflow_v = 0\n\n            if pctflow_v >= flowlimit:\n                psspy.progress(\"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars())\n        psspy.progress('\\n')\n\n    #"
  },
  {
    "id": 25,
    "text": "# (13) Creating Voltage Violations report in Text file, if provided\n\n    if rptfile:  sumfile = rptfpath + '_summary' + rptext\n    if rptfile:\n        vviofpath, vviofext = os.path.splitext(rptfile)\n        if not vviofext: vviofext = '.txt'\n        vviofile   = vviofpath + '_vvio' + vviofext\n        vviofile_h = open(vviofile,'w')\n        report     = vviofile_h.write\n    else:\n        psspy.beginreport()\n        report = psspy.report\n\n    report(\"\\n Post Contingency VOLTAGE VIOLATIONS Report\\n\")\n\n    # get base case solution\n    solnobj_basecase = accobj.solution(colabel=\"BASE CASE\")\n\n    if solnobj_basecase==None or not solnobj_basecase.cnvflag:\n        report(\"    BASE CASE not converged\\n\")\n    else:\n        # remaining contingencies\n        for lbl in smryobj.colabel[1:]:   # skipped \"BASE CASE\"\n            solnobj  = accobj.solution(colabel=lbl)\n            if solnobj==None: continue          # contingency solution not found, move to next\n            if not solnobj.cnvflag: continue    # contingency solution not converged, move to next\n            vvio_exists = False\n            for r in range(len(solnobj.volts)):\n                if solnobj.volts[r] == 0.0: continue # disconnected bus, move to next\n                if smryobj.mvrectype[r]=='RANGE':\n                    if smryobj.mvrecmin[r] and solnobj.volts[r] < smryobj.mvrecmin[r]:\n                        vvio = solnobj.volts[r] - smryobj.mvrecmin[r]\n                    elif smryobj.mvrecmax[r] and solnobj.volts[r] > smryobj.mvrecmax[r]:\n                        vvio = solnobj.volts[r] - smryobj.mvrecmax[r]\n                    else:\n                        vvio = 0\n                else: # DEVIATION\n                    delta = solnobj.volts[r] - solnobj_basecase.volts[r]\n                    if delta < 0:\n                        if smryobj.mvrecmin[r] and abs(delta) > smryobj.mvrecmin[r]:\n                            vvio =  delta + smryobj.mvrecmin[r]\n                        else:\n                            vvio = 0\n                    else:\n                        if smryobj.mvrecmax[r] and delta > smryobj.mvrecmax[r]:\n                            vvio = delta - smryobj.mvrecmax[r]\n                        else:\n                            vvio = 0\n                if vvio:\n                    if not vvio_exists:\n                        report(\" Voltage Violations for contingency '%12s':\\n\" % (lbl))\n                        report(\"<-----MONITORED BUS-----> <--MONITOR LABEL---> <--TYPE-> <-VMIN-> <-VMAX-> <-VINIT-> \\\n<-VOLT--> <-VVIO-->\\n\")\n                        vvio_exists = True\n                    mvbuslabel     = smryobj.mvbuslabel[r]\n                    mvreclabel     = smryobj.mvreclabel[r]\n                    mvrectype      = smryobj.mvrectype[r]\n                    if smryobj.mvrecmin[r]:\n                        mvrecmin   = \"%8.5f\" % smryobj.mvrecmin[r]\n                    else:\n                        mvrecmin   = '   --   '\n                    if smryobj.mvrecmax[r]:\n                        mvrecmax   = \"%8.5f\" % smryobj.mvrecmax[r]\n                    else:\n                        mvrecmax   = '   --   '\n                    mvrecvolts_init= solnobj_basecase.volts[r]\n                    mvrecvolts     = solnobj.volts[r]\n                    report(\"%(mvbuslabel)25s %(mvreclabel)20s %(mvrectype)9s %(mvrecmin)s \\\n%(mvrecmax)s %(mvrecvolts_init)9.5f %(mvrecvolts)9.5f %(vvio)9.5f \\n\" %  vars())\n\n            if vvio_exists: report('\\n')\n\n    if rptfile:\n        vviofile_h.close()\n        print('\\n Voltage Violations Report saved to file %s' % vviofile)\n    else:\n        print('\\n Voltage Violations Report created in Report window.')\n\n    #"
  },
  {
    "id": 26,
    "text": "# (14) Creating Post-Contingency Solution Load Shedding report in progress\n\n    report = psspy.progress\n    load_curtailment_exists = False\n    report('\\n Post-Contingency LOAD CURTAILMENTS Report\\n')\n    stype = stype_cnt\n    for lbl in smryobj.colabel:\n        solnobj  = accobj.solution(colabel=lbl)\n        if solnobj==None: continue              # contingency solution not found, move to next\n        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next\n        if not len(solnobj.lshedbus): continue  # no load shedding, move to next\n        report(\"\\n Load Curtailments for contingency '%12s':\\n\" % (lbl))\n        if not load_curtailment_exists:\n            if stype=='contingency' or stype=='tripping':\n                report(\"<"
  },
  {
    "id": 30,
    "text": "> <INITLD(MW)>  <LDSHED(MW)> <CONTINGENCY>\\n\")\n            load_curtailment_exists = True\n\n        for c in range(len(solnobj.lshedbus)):\n            if stype=='contingency' or stype=='tripping':\n                report(\"%25s %12.2f %-12s\\n\" % (solnobj.lshedbus[c],solnobj.loadshed[c],lbl))\n            else:\n                report(\"%25s %12.2f %12.2f %-12s\\n\" % (solnobj.lshedbus[c],solnobj.loadshed[0][c],\n                                                       solnobj.loadshed[1][c],lbl))\n    if not load_curtailment_exists:\n        report('    None\\n')\n\n    #"
  },
  {
    "id": 31,
    "text": "# (15) Creating Corrective Action Solution Generation Dispatch report in progress\n\n    accobj.solution_options(stype=stype_cact)\n\n    report = psspy.progress\n    gen_disp_exists = False\n    report('\\n Corrective Action GENERATION DISPATCH  Report\\n')\n\n    for lbl in smryobj.colabel:\n        solnobj  = accobj.solution(colabel=lbl)\n        if solnobj==None: continue              # contingency solution not found, move to next\n        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next\n        if not len(solnobj.gdispbus): continue  # no generation dispatch, move to next\n        if not gen_disp_exists:\n            report(\"<"
  },
  {
    "id": 33,
    "text": "> <INITGEN(MW)>  <GENDISP(MW)> <CONTINGENCY>\\n\")\n            gen_disp_exists = True\n        for c in range(len(solnobj.gdispbus)):\n            report(\"%25s %9.2f %s %9.2f %s %-12s\\n\" % (solnobj.gdispbus[c],solnobj.gendisp[0][c],4*' ',\n                                                      solnobj.gendisp[1][c],3*' ',lbl))\n\n    if not gen_disp_exists:\n        report('    None\\n')\n\n    #"
  },
  {
    "id": 34,
    "text": "# (16) Creating Corrective Action Solution Phase Shifter Angle report in progress\n\n    accobj.solution_options(stype=stype_cact)\n\n    report = psspy.progress\n    phsftr_exists = False\n    report('\\n Corrective Action PHASE SHIFTER ANGLE Report\\n')\n\n    for lbl in smryobj.colabel:\n        solnobj  = accobj.solution(colabel=lbl)\n        if solnobj==None: continue              # contingency solution not found, move to next\n        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next\n        if not len(solnobj.phsftr): continue    # no generation dispatch, move to next\n        if not phsftr_exists:\n            report(\"<-------FROM BUS"
  },
  {
    "id": 36,
    "text": "ID> <INITANG(deg)> <NEWANG(deg)> \\\n<CONTINGENCY>\\n\")\n            phsftr_exists = True\n        for c in range(len(solnobj.phsftr)):\n            report(\"%54s %9.2f %s %9.2f %s %-12s\\n\" % (solnobj.phsftr[c],solnobj.phsftrang[0][c],5*' ',\n                                                       solnobj.phsftrang[1][c],3*' ',lbl))\n    if not phsftr_exists:\n        report('    None\\n')\n\n#"
  },
  {
    "id": 37,
    "text": "def check_psse_example_folder(rptfile):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n    rptpath, rptfnam = os.path.split(rptfile)\n    if not rptpath:\n        rptpath = os.getcwd()\n        cwd = rptpath.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n        else:\n            outdir = os.getcwd()\n        rptfile  = os.path.join(outdir, rptfnam)\n\n    return rptfile\n\n#"
  },
  {
    "id": 42,
    "text": "'''There are three different ways to calculate faults using ASCC.\n1) Using activity ASCC (psspy.ascc_3)\n   Runs all types of faults, creates text reports, but no access to results from Python script.\n\n2) Using Python module arrbox.ascc.ascc_currents\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain both phase and sequence fault currents.\n       b) contain faults currents for bus faults only.\n       c) does not contain faults currents for linout and linend faults.\n\n3) Using Python module arrbox.fault.FAULT_SUMMARY\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain only total fault currents for faults calculated.\n       b) contain faults currents for bus, linout and linend faults.\n\nThis is an example file showing how to run ASCC fault calculations using either of these methods."
  },
  {
    "id": 43,
    "text": "How to use this file?\n\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\n    import psse35\n\nB) This file contain following functions that uses savnw.sav file run ASCC calculations.\n    run_ascc_3_savnw(..)\n    run_ascc_currents_savnw_txtrpt(..)\n    run_ascc_currents_savnw_xls(..)\n    run_fault_summary_ascc_savnw(..)\n\n    Run either of these functions under  __main__ to see how they work.\n\nC) Create similar functions for the network case and faults you want to run.\n\n'''\n#"
  },
  {
    "id": 44,
    "text": "#\n\"\"\"\nUse any of these keywords to run psspy.ascc or arrbox.ascc.ascc_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default      Description\n                       # STATUS array\nfltlg     = 0          # 1  0=>omit, 1=>include\nlinout    = 0          # 2  0=>omit, 1=>include\nlinend    = 0          # 3  0=>omit, 1=>include\nvoltop    = 0          # 4  0=>from PF, 1=>at specified for all buses, 2=>at specified faulted bus\ngenxop    = 0          # 5  0=>X'' 1=>X', 2=>Xs\nrptop     = -1         # 6  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl    = 0          # 7  number of contribution levels\ntpunty    = 0          # 8  0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged, 3=>N unchanged and phi=0\ndcload    = 1          # 9  0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec    = 1          # 10 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\nflt3ph    = 0          # 11 0=>omit, 1=>include\nfltllg    = 0          # 12 0=>omit, 1=>include\nfltll     = 0          # 13 0=>omit, 1=>include\nlnchrg    = 0          # 14 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop    = 0          # 15 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\nloadop    = 0          # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\nmachpq    = 0          # 17 0=>from PF, 1=>0.0 (generator/motor PQ output)\n                       # VALUES array\nvolts     = 1.0        # 1  specified bus voltage, used when voltop=1 or 2\n                       # File args\nrelfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n#"
  },
  {
    "id": 45,
    "text": "import sys, os, time, math\n\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n             'owners':[], 'zones':[]}\n\ndef fault_bsys(sid, **kwds):\n    import psspy\n\n    if sid==0: return\n\n    actv_kwds = {}  # activity keywords\n    for k, v in bsys_kwds.items():\n        if k in kwds:\n            actv_kwds[k] = kwds[k]\n        else:\n            actv_kwds[k] = v\n\n    actv_kwds['sid']      = sid\n    actv_kwds['numarea']  = len(actv_kwds['areas'])\n    actv_kwds['numbus']   = len(actv_kwds['buses'])\n    actv_kwds['numowner'] = len(actv_kwds['owners'])\n    actv_kwds['numzone']  = len(actv_kwds['zones'])\n\n    ierr = psspy.bsys(**actv_kwds)\n\n    return ierr\n\n#"
  },
  {
    "id": 49,
    "text": "def _frmted_z(self, cnum):\n        r=cnum.real\n        x=cnum.imag\n        csign='+j'\n        if x<0:\n            csign='-j'\n            x=abs(x)\n\n        if r==0:\n            rstr=''\n        else:\n            rstr=\"%9.6f\" % r\n\n        if x==0:\n            xstr=''\n            csign=''\n        else:\n            xstr=\"%9.6f\" % x\n\n        zstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\n\n        return zstr\n\n    #"
  },
  {
    "id": 52,
    "text": "def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\n        if scfmt=='rectangular':\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n            crnt = abs(crnt)\n        else:\n            cval = cval.real\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n\n        mva  = math.sqrt(3.0)*basekv*crnt/1000.0\n\n        return crnt, mva\n\n    #"
  },
  {
    "id": 55,
    "text": "def run_fault_summary(self, sid, allbus, **kwds):\n        import psspy, arrbox.fault\n\n        fltobj = arrbox.fault.FAULT_SUMMARY('ASCC', sid, allbus, **kwds)\n\n        if fltobj.ierr!=0:\n            raise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\n\n        return fltobj\n\n    #"
  },
  {
    "id": 56,
    "text": "def report_ascc_currents(self, rlst, rptfile=''):\n        import psspy\n\n        if rlst.ierr: return\n\n        if rptfile:\n            p, nx = os.path.split(rptfile)\n            n, x = os.path.splitext(nx)\n            if not x:\n                x = '.txt'\n                nx = n + x\n            if p:\n                rptfile = os.path.join(p, nx)\n            else:\n                rptfile = os.path.join(os.getcwd(), nx)\n            rptfile_h = open(rptfile,'w')\n            report    = rptfile_h.write\n        else:\n            psspy.beginreport()\n            report = psspy.report\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        nfbus=len(rlst.fltbus)\n\n        txtlst = []\n        if not rptfile: txtlst.append('')\n\n        ttlstr=\"PSS(R)E ASCC SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\n        ln1str,ln2str=psspy.titldt()\n        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))\n        txtlst.append(ttlstr.center(maxlen))\n        txtlst.append(ln1str.center(maxlen))\n        txtlst.append(ln2str.center(maxlen))\n        txtlst.append('')\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        scunit = rlst.scunit\n        scfmt  = rlst.scfmt\n\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        if scunit == 'pu':\n            units = 'PU'\n        else:\n            units = 'AMP'\n        unitstr   = units.center(10)\n        clnhdr    = \"   BUS     \" + 6*unitstr\n\n        for i in range(nfbus):\n            txtlst = []\n            txtlst.append('')\n            txtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\n            txtlst.append(clnhdr)\n            fbus   = rlst.fltbus[i]\n            if flt3ph:\n                ttxt   = \"%6d\" % fbus\n                spc    = '3PH'\n                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltlg:\n                if flt3ph:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = ' LG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltllg:\n                if flt3ph or fltlg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = 'LLG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltll:\n                if flt3ph or fltlg or fltllg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc     = ' LL'\n                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            txtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\n\n            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\n            z1str =\"Z1: \" + z1str\n            if fltlg or fltllg or fltll:\n                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\n                z2str =\"Z2: \" + z2str\n                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\n                z0str =\"Z0: \" + z0str\n                tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n            else:\n                tmptxt=\"%(z1str)s\" % vars()\n            txtlst.append(tmptxt)\n\n            if scunit_z!='pu':\n                txtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\n                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\n                z1str =\"Z1: \" + z1str\n                if fltlg or fltllg or fltll:\n                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\n                    z2str =\"Z2: \" + z2str\n                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\n                    z0str =\"Z0: \" + z0str\n                    tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n                else:\n                    tmptxt=\"%(z1str)s\" % vars()\n                txtlst.append(tmptxt)\n\n            tmptxt=110*'-'\n            txtlst.append(tmptxt)\n            txtlst.append('')\n\n            txtall = \"\\n\".join(txtlst)\n            report(txtall)\n\n        # Maximum Fault Currents\n        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\n        unitstr   = units.center(11)\n        unitstr = ''\n        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\n            t = each+'('+units+')'\n            t = ' ' + t.center(9) + ' '\n            unitstr += t\n\n        txtlst = []\n        txtlst.append('')\n\n        clnhdr    = \"   BUS  \" + unitstr + \"  Description\"\n        txtlst.append(\"BREAKER DUTY CURRENTS\")\n        txtlst.append(clnhdr)\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        for i in range(nfbus):\n            fbus   = rlst.fltbus[i]\n            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\n            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\n            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\n            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\n            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\n            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\n            dsc    = rlst.maxfltdsc[i]\n            if rptfile: report('\\n')\n            tmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\n            report(tmptxt)\n\n        #"
  },
  {
    "id": 58,
    "text": "def excel_ascc_currents(self, rlst, faults_applied, xlsfile=''):\n        import psspy\n        import excelpy\n\n        if rlst.ierr: return\n\n        # bus data\n        sid  = -1   # consider subsystem of all buses\n        flag = 1    # consider only in-service buses\n        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\n        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\n        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\n        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\n\n        bus_data = {}\n        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\n            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        scunit   = rlst.scunit\n        scfmt    = rlst.scfmt\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        nfbus=len(rlst.fltbus)\n\n        xlswbk = excelpy.workbook(xlsfile)\n        xlswbk.show()\n\n        savfile, snpfile = psspy.sfiles()\n        line1, line2 = psspy.titldt()\n\n        ttl      = r\"PSSE Short Circuit Calculations Using ASCC\"\n        ttl      = ttl + 5*' ' + time.ctime()\n        ttl_file = savfile\n        ttl_line1= line1.strip()\n        ttl_line2= line2.strip()\n\n        cln_mrglst = []\n        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\n        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\n        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\n            if fltok:\n                cln_mrglst.append(len(cln_heads_r1)+1)\n                cln_heads_r1.extend([clnnam, ''])\n                cln_heads_r2.extend(['MVA', 'AMP'])\n\n        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\n        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\n\n        colheads = [cln_heads_r1, cln_heads_r2]\n\n        row = 7\n        cln = 1\n\n        sbase = psspy.sysmva()\n\n        for i in range(nfbus):\n            rowdata = []\n            fbus    = rlst.fltbus[i]\n            basekv  = bus_data[fbus]['basekv']\n            prefltv = bus_data[fbus]['prefltv']\n\n            rowdata.append(fbus)\n            rowdata.append(bus_data[fbus]['name'])\n            rowdata.append(basekv)\n            rowdata.append(basekv*abs(prefltv))\n\n            if flt3ph:\n                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            if fltlg:\n                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltllg:\n                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltll:\n                cval = rlst.fltll[i].ib   # Ifault=Ib\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            zpos  = rlst.thevzpu[i].z1\n            zneg  = rlst.thevzpu[i].z2\n            zzero = rlst.thevzpu[i].z0\n\n            s_zpos  = self._frmted_z(zpos)\n            s_zneg  = self._frmted_z(zneg)\n            s_zzero = self._frmted_z(zzero)\n\n            rowdata.extend([s_zpos, s_zneg, s_zzero])\n\n            brow,rcln = xlswbk.set_range(row,cln,rowdata)\n            row = brow + 1\n\n        xlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\n        xlswbk.autofit_columns((6,9,brow,rcln))\n        xlswbk.align((6,9,brow,rcln),'right')\n\n        # headings and column titles\n        xlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n        xlswbk.merge((1,1,1,rcln))\n\n        xlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((2,1,2,rcln))\n\n        xlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((3,1,3,rcln))\n\n        xlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((4,1,4,rcln))\n\n        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\n\n        xlswbk.merge((5,1,5,2))\n        for cln in cln_mrglst:\n            xlswbk.merge((5,cln,5,cln+1))\n        xlswbk.merge((5,rcln-2,5,rcln))\n\n        xlswbk.align((1,1),'h_center')\n        xlswbk.align_rows((1,1,6,1),'h_center')\n\n        if xlsfile: xlswbk.save(xlsfile)\n\n#"
  },
  {
    "id": 59,
    "text": "def run_ascc_3_savnw(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile = 'savnw.sav'\n    sid, allbus = 3, 0\n    buses = [153, 154]\n    rptfile = ''\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_savnw_ascc_3_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\n\n    set_prg_rpt(rptfile=rptfile)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    asccobj = ASCC_DEMO()\n    asccobj.run_ascc_api(sid, allbus, **kwds)\n\n    reset_prg_rpt()\n\n#"
  },
  {
    "id": 60,
    "text": "def run_ascc_currents_savnw_txtrpt(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile = 'savnw.sav'\n    sid, allbus = 3, 0\n    buses = [153, 154]\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_savnw_ascc_currents_{}.txt\".format(nam_unt[unt])\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    asccobj = ASCC_DEMO()\n    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)\n    asccobj.report_ascc_currents(rlst, rptfile)\n\n#"
  },
  {
    "id": 61,
    "text": "def run_ascc_currents_savnw_xls(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile = 'savnw.sav'\n    sid, allbus = 3, 0\n    buses = [153, 154]\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    xlsfile = \"z_savnw_ascc_currents_{}\".format(nam_unt[unt])\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    asccobj = ASCC_DEMO()\n    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)\n    asccobj.excel_ascc_currents(rlst, xlsfile)\n\n#"
  },
  {
    "id": 62,
    "text": "def run_fault_summary_ascc_savnw(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile = 'savnw.sav'\n    sid, allbus = 3, 0\n    buses = [153, 154]\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_savnw_ascc_fault_summary_{}.txt\".format(nam_unt[unt])\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    asccobj = ASCC_DEMO()\n    fltobj = asccobj.run_fault_summary(sid, allbus, **kwds)\n    fltobj.text_report(rptfile)\n\n#"
  },
  {
    "id": 63,
    "text": "def _temp():\n    # Run either of these functions under  __main__ to see how they work.\n    run_ascc_3_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n\n    run_ascc_currents_savnw_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\n    run_ascc_currents_savnw_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\n\n    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\n    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\n\n#"
  },
  {
    "id": 65,
    "text": "'''\nThis is an example file showing how to use \"ascc_currents\" function from pssarrays module.\n\nASCC_CURRENTS function returns ASCC short circuit currents for each faulted bus and\neach type of fault applied. They are:\n    ia1   = Positive Sequence Current\n    ia2   = Negative Sequence Current\n    ia0   = Zero Sequence Current\n    ia    = Phase A current\n    ib    = Phase B current\n    ic    = Phase C current\n\nThe APIs used in this program are part of python \"pssarrays\" module."
  },
  {
    "id": 66,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psse35\n\n- call function\n    run_ascc_report()\n\n    You may want to change inputs specified in this function.\n    run_ascc_report(savfile, fltbuses, rptfile)\n    Defaults:\n        savfile  = 'savnw.sav'\n        fltbuses = [151,154]\n        rptfile  = 'ascc_report_savnw.txt'\n                   When this script is called from PSSE's Example Folder,\n                   report is created in subfolder 'Output_Pyscript'\n'''\n\n#"
  },
  {
    "id": 68,
    "text": "def encode_complex_number_xbyr(cnum):\n    r=cnum.real\n    x=cnum.imag\n    csign='+j'\n    if x<0:\n        csign='-j'\n        x=abs(x)\n\n    if r==0:\n        rstr=''\n        xbyr=''\n    else:\n        rstr=\"%9.6f\" % r\n        xbyr=\"%9.6f\" % (x/r)\n\n    if x==0:\n        xstr=''\n        csign=''\n    else:\n        xstr=\"%9.6f\" % x\n\n    cstr=\"%(rstr)s%(csign)s%(xstr)s, %(xbyr)s\" % vars()\n\n    return cstr\n\n#"
  },
  {
    "id": 70,
    "text": "def create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,\n                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,\n                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):\n\n    import psspy, arrbox.ascc\n\n    # open case\n    if savfile: psspy.case(savfile)\n\n    # Save pre-fault voltages\n    sid  = -1\n    flag = 2\n    ierr, (buslst,)           = psspy.abusint(sid,  flag, ['NUMBER'])\n    ierr, (busvltlst_preflt,) = psspy.abuscplx(sid, flag, ['VOLTAGE'])\n    ierr, (busvltlst_base,)   = psspy.abusreal(sid, flag, ['BASE'])\n    busdata_dict = {}\n    for n, vpf, vnm in zip(buslst, busvltlst_preflt, busvltlst_base):\n        busdata_dict[n] = {'prefltv': vpf, 'basekv': vnm}\n\n    # set sc units and format\n    psspy.short_circuit_units(1)         # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(0)   # 0=rectangular, 1=polar\n\n    sid = 3\n    if fltbuses:\n        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])\n        busall = 0\n    else:\n        busall = 1\n\n    # call pssarrays routine\n    rlst = arrbox.ascc.ascc_currents(sid, busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,\n           fltll=fltll, linout=linout, linend=linend, voltop=voltop, genxop=genxop, tpunty=tpunty,\n           dcload=dcload, zcorec= zcorec, lnchrg=lnchrg, shntop=shntop, loadop=loadop, machpq=machpq,\n           volts=volts, relfile=relfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)\n\n    if rlst.ierr!=0:\n        raise Exception(\"arrbox.ascc.ascc_currents error= %d\\n\" % rlst.ierr)\n\n    if rptfile:\n        p, nx = os.path.split(rptfile)\n        n, x = os.path.splitext(nx)\n        if not x:\n            x = '.txt'\n            nx = n + x\n        if p:\n            rptfile = os.path.join(p, nx)\n        else:\n            rptfile = os.path.join(os.getcwd(), nx)\n        rptfile_h = open(rptfile,'w')\n        report    = rptfile_h.write\n    else:\n        psspy.beginreport()\n        report = psspy.report\n\n    nfbus=len(rlst.fltbus)\n\n    ttlstr=\"PSS(R)E ASCC SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\n    ln1str,ln2str=psspy.titldt()\n    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))\n    report(ttlstr.center(maxlen))\n    report(\"\\n\")\n    report(ln1str.center(maxlen))\n    report(\"\\n\")\n    report(ln2str.center(maxlen))\n    report(\"\\n\\n\")\n\n    sbase  = psspy.sysmva()\n\n    scunit = rlst.scunit\n    scfmt  = rlst.scfmt\n\n    if scunit == 'pu':\n        units = 'PU'\n    else:\n        units = 'AMP'\n    unitstr   = units.center(10)\n    clnhdr    = \"   BUS     \" + 6*unitstr + \"\\n\"\n\n    for i in range(nfbus):\n        report(\"           <-SCMVA-> <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\\n\")\n        report(clnhdr)\n        fbus   = rlst.fltbus[i]\n        basekv = busdata_dict[fbus]['basekv']\n        baseamp = (1000.0 * sbase) / (math.sqrt(3.0) * basekv)\n\n        if flt3ph:\n            ttxt   = \"%6d\" % fbus\n            spc    = '3PH'\n\n            ia1    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia1)\n            ia2    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia2)\n            ia0    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia0)\n            ia     = get_cplx_mag(scfmt,rlst.flt3ph[i].ia)\n            ib     = get_cplx_mag(scfmt,rlst.flt3ph[i].ib)\n            ic     = get_cplx_mag(scfmt,rlst.flt3ph[i].ic)\n\n            scmva  = math.sqrt(3.0) * basekv * rlst.flt3ph[i].ia1 / 1000.0\n            if scunit == 'pu': scmva = scmva*baseamp\n            scmva  = get_cplx_mag(scfmt,scmva)\n\n            tmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltlg:\n            if flt3ph:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc    = ' LG'\n            ia1    = get_cplx_mag(scfmt,rlst.fltlg[i].ia1)\n            ia2    = get_cplx_mag(scfmt,rlst.fltlg[i].ia2)\n            ia0    = get_cplx_mag(scfmt,3*rlst.fltlg[i].ia0)\n            ia     = get_cplx_mag(scfmt,rlst.fltlg[i].ia)\n            ib     = get_cplx_mag(scfmt,rlst.fltlg[i].ib)\n            ic     = get_cplx_mag(scfmt,rlst.fltlg[i].ic)\n\n            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltlg[i].ia0 / 1000.0\n            if scunit == 'pu': scmva = scmva*baseamp\n            scmva  = get_cplx_mag(scfmt,scmva)\n\n            tmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltllg:\n            if flt3ph or fltlg:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc    = 'LLG'\n            ia1    = get_cplx_mag(scfmt,rlst.fltllg[i].ia1)\n            ia2    = get_cplx_mag(scfmt,rlst.fltllg[i].ia2)\n            ia0    = get_cplx_mag(scfmt,3*rlst.fltllg[i].ia0)\n            ia     = get_cplx_mag(scfmt,rlst.fltllg[i].ia)\n            ib     = get_cplx_mag(scfmt,rlst.fltllg[i].ib)\n            ic     = get_cplx_mag(scfmt,rlst.fltllg[i].ic)\n\n            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltllg[i].ia0 / 1000.0\n            if scunit == 'pu': scmva = scmva*baseamp\n            scmva  = get_cplx_mag(scfmt,scmva)\n\n            tmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltll:\n            if flt3ph or fltlg or fltllg:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc     = ' LL'\n            ia1    = get_cplx_mag(scfmt,rlst.fltll[i].ia1)\n            ia2    = get_cplx_mag(scfmt,rlst.fltll[i].ia2)\n            ia0    = get_cplx_mag(scfmt,rlst.fltll[i].ia0)\n            ia     = get_cplx_mag(scfmt,rlst.fltll[i].ia)\n            ib     = get_cplx_mag(scfmt,rlst.fltll[i].ib)\n            ic     = get_cplx_mag(scfmt,rlst.fltll[i].ic)\n\n            scmva  = math.sqrt(3.0) * basekv * rlst.fltll[i].ib / 1000.0\n            if scunit == 'pu': scmva = scmva*baseamp\n            scmva  = get_cplx_mag(scfmt,scmva)\n\n            tmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        report(\"\\nTHEVENIN IMPEDANCE (pu), X/R\\n\")\n        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)\n        z1str =\"Z1: \" + z1str\n        if fltlg or fltllg or fltll:\n            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)\n            z2str =\"Z2: \" + z2str\n            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)\n            z0str =\"Z0: \" + z0str\n            tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\n        else:\n            tmptxt=\"%(z1str)s\\n\" % vars()\n        report(tmptxt)\n\n        if scunit != 'pu':\n            report(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\\n\")\n            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)\n            z1str =\"Z1: \" + z1str\n            if fltlg or fltllg or fltll:\n                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)\n                z2str =\"Z2: \" + z2str\n                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)\n                z0str =\"Z0: \" + z0str\n                tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\n            else:\n                tmptxt=\"%(z1str)s\\n\" % vars()\n            report(tmptxt)\n\n        tmptxt=110*'-'\n        report(tmptxt)\n        report(\"\\n\")\n\n    # Maximum Fault Currents\n    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\n    unitstr   = units.center(11)\n    unitstr = ''\n    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\n        t = each+'('+units+')'\n        t = ' ' + t.center(9) + ' '\n        unitstr += t\n\n    clnhdr    = \"   BUS  \" + unitstr + \"  Description\\n\"\n    report(\"\\nBREAKER DUTY CURRENTS\\n\")\n    report(clnhdr)\n    for i in range(nfbus):\n        fbus   = rlst.fltbus[i]\n        ia1    = get_cplx_mag(scfmt,rlst.maxflt[i].ia1)\n        ia2    = get_cplx_mag(scfmt,rlst.maxflt[i].ia2)\n        ia0    = get_cplx_mag(scfmt,rlst.maxflt[i].ia0)\n        ia     = get_cplx_mag(scfmt,rlst.maxflt[i].ia)\n        ib     = get_cplx_mag(scfmt,rlst.maxflt[i].ib)\n        ic     = get_cplx_mag(scfmt,rlst.maxflt[i].ic)\n        dsc    = rlst.maxfltdsc[i]\n        tmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\\n\" % vars()\n        report(tmptxt)\n\n    #"
  },
  {
    "id": 72,
    "text": "def check_psse_example_folder(rptfile):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n    rptpath, rptfnam = os.path.split(rptfile)\n    if not rptpath:\n        rptpath = os.getcwd()\n        cwd = rptpath.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n        else:\n            outdir = os.getcwd()\n        rptfile  = os.path.join(outdir, rptfnam)\n\n    return rptfile\n\n#"
  },
  {
    "id": 73,
    "text": "def run_ascc_report(savfile=\"savnw.sav\", fltbuses=[151,154], rptfile='ascc_report_savnw.txt'):\n\n    import psspy\n\n    psspy.psseinit()\n\n    # Inputs, change as required\n\n    flt3ph  = 1       #\n    fltlg   = 1       #\n    fltllg  = 1       #\n    fltll   = 1       #\n    linout  = 0       #\n    linend  = 0       #\n    voltop  = 0       #\n    genxop  = 0       #\n    tpunty  = 0       #\n    dcload  = 1       #\n    zcorec  = 1       #\n    lnchrg  = 0       #\n    shntop  = 0       #\n    loadop  = 0       #\n    machpq  = 0       #\n\n    volts   = 1.0     #\n\n    rptfile = check_psse_example_folder(rptfile)\n\n    relfile = \"\"\n    fcdfile = \"\"\n    scfile  = \"\"\n\n    rprtyp  = -1      # no report\n    rprlvl  = 0       # number of contribution levels\n\n    create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,\n                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,\n                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)\n\n#"
  },
  {
    "id": 78,
    "text": "def OpenFile():\n    \"\"\"Opens the BPA file specified in prompt.\"\"\"\n\n    psspy.prompt(\"Enter the BPA file path, followed by its name:\\n\")\n    ierr, fnamestr = psspy.userin()\t\t#User types in the path name\n\n    if ierr != 0: return\n\n    fpath, fext = os.path.splitext(fnamestr)\n    if not fext: fnamestr = fpath + '.dat'\t#To add the extension if left blank\n\n    if os.path.isfile(fnamestr) == False:\n        psspy.alert(\"The specified path or file name is invalid\\n\")\n        return\n\n    bpa_file = open(fnamestr, 'r')\t\t#Opens the file in read mode\n\n    return bpa_file\n\n#"
  },
  {
    "id": 79,
    "text": "def GetMVA(bpa_file, bpa_str):\n    \"\"\"Gets the base MVA in the BPA file.\"\"\"\n\n    pos = string.find(bpa_str, \"MVA_BASE\")\n\n    if pos != -1:\n        bpa_file.seek(pos)\n        bpa_file.readline()\t\t\t#Just to position on to the next line\n        mva_base_str = bpa_file.readline()\n        mva_base_str = mva_base_str.replace(' ', '')\t#To delete any spaces\n        mva_base_str = mva_base_str.strip()\t#To remove trailing and leading whitespaces\n        mva_base_str = mva_base_str[10:]\t#To remove the \"/MVA_BASE=\" part\n        basemva = float(mva_base_str[:-1])\n\n    else:\n        basemva = 100.0\t\t\t\t#The default base MVA in BPA is 100 MVA\n\n    return basemva\n\n#"
  },
  {
    "id": 80,
    "text": "def GetTitles(bpa_file, bpa_str):\n    \"\"\"Gets the titles from the BPA file.\"\"\"\n\n    pos = string.find(bpa_str, \"CASEID\")\t#To find title1\n\n    if pos != -1:\n        bpa_file.seek(pos)\n        title_data = bpa_file.readline()\n        pos1 = string.find(title_data, '=')\n        pos2 = string.find(title_data, ',')\n        case_id = title_data[pos1 + 1 : pos2]\n        case_id = case_id.strip()\t\t#To remove trailing and leading whitespaces\n\n    else:\n        case_id = \"\"\t\t\t\t#Title1 is blank by default\n\n    pos = string.find(bpa_str, \"PROJECT\")\t#To find title2\n\n    if pos != -1:\n        bpa_file.seek(pos)\n        title_data = bpa_file.readline()\n        pos1 = string.find(title_data, '=')\n        pos2 = string.find(title_data, ',')\t\n        if pos2 == -1:\t\t\t\t#If there are no other parameters, the line finishes with ')'\n            pos2 = string.find(title_data, ')')\n\n        project_id = title_data[pos1 + 1 : pos2]\n        project_id = project_id.strip()\t\t#To remove trailing and leading whitespaces\n\n    else:\n        project_id = \"\"\t\t\t\t#Title2 is blank by default\n\n    return case_id, project_id\n\n#"
  },
  {
    "id": 81,
    "text": "def GetPCard(bpa_str_ar):\n    \"\"\"Gets the scale data from the BPA file.\"\"\"\n\n    scale_str = []\n\n    for line in bpa_str_ar:\t\t\t#Loop over every line of the BPA file\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t\t#To continue if it is a blank line\n\n        if line[0] == 'P' and line[2] == ' ':\t#If the line is a P card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n            scale_str.append(line)\n\n    return scale_str\t\t\t\t#Returns an array of P cards\n\n#"
  },
  {
    "id": 82,
    "text": "def GetScaleData(scale_str, owner_name, zone_name, type_code):\n    \"\"\"Gets the scale factors for each load and generator.\"\"\"\n\n    scale_ar = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\t\t#Default factors are unit factors\n\n    for line in scale_str:\t\t\t\t\t#For each P card\n        if line[1] == 'O' and line[3:6].strip() == owner_name:\n            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\n            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\n            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\n            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\n                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\n                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\n\n                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\n                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\n                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t#Generation Q factor is generation P factor\n\n        elif line[1] == 'Z' and line[3:5].strip() == zone_name or line[1] == 'N' and line[3:5].strip() == zone_name and type_code == 'N':\n            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\n            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\n            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\n                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\n                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\n\n                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\n                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\n                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t#Generation Q factor is generation P factor\n\n        elif line[1] == 'A':\n            if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\n            if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\n            elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\n\n            if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\n            if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\n            elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t\t#Generation Q factor is generation P factor\n\n        elif line[1] == 'B' and type_code == 'X' and line[3:6].strip() == owner_name:\n            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\n            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\n            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\n            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])\t\t#Constant current load P factor\n                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])\t\t#Constant current load Q factor\n                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])\t\t#Constant current load Q factor is load P factor\n\n                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\n                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\n                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\n\n        elif line[1] == 'B' and type_code == 'Y' and line[3:6].strip() == owner_name:\n            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\n            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\n            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\n            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\n                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\n                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\n\n        elif line[1] == 'C' and type_code == 'X' and line[3:5].strip() == zone_name:\n            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\n            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\n            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])\t\t#Constant current load P factor\n                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])\t\t#Constant current load Q factor\n                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])\t\t#Constant current load Q factor is load P factor\n\n                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\n                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\n                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\n\n        elif line[1] == 'C' and type_code == 'Y' and line[3:5].strip() == zone_name:\n            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\n            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\n            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\n\n                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\n                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\n                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\n\n    return scale_ar\t\t#Returns the scale factors\n \n#"
  },
  {
    "id": 83,
    "text": "def CheckICard(bpa_str_ar, area_name):\n    \"\"\"To check if there is an I card with the specified area name.\"\"\"\n\n    for line in bpa_str_ar:\t\t\t#Loop over every line of the BPA file\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t\t#To continue if it is a blank line\n        \n        if line[0] == 'I' and line[2] == ' ':\t#If it is an I card\n            line = line + ' '*(34-len(line))\t#To pad each line with spaces up to 34 records\n            if line[3:13].strip() == area_name or line[14:24].strip() == area_name: return True\t\t#Returns true if the area is found in an I card\n\n    return False\t\t\t#Returns false if the area has not been found in I cards\n\n#"
  },
  {
    "id": 84,
    "text": "def GetXCard(bpa_str_ar, bus_name, Vmax, Vmin, remote_bus_name, RMPCT, remote_bus_nbr, bus_nbr):\n    \"\"\"Gets the switched shunts attached to the specified bus.\"\"\"\n\n    for line in bpa_str_ar:\t\t#This loop is used to get the corresponding switched shunts\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#To continue if it is a blank line"
  },
  {
    "id": 86,
    "text": "intgar = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\n        realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\n\n        if isfloat(line[28:32]): remote_kv = float(line[28:32])\t#The remote bus base voltage\n        else: remote_kv = 0.0\n\n        if line[0] == 'X' and bus_name == (line[6:14].strip() + str(float(line[14:18]))) and remote_bus_name == (line[20:28].strip() + str(remote_kv)):\n            if line[2] == ' ':\t\t\t\t\t#The modification code for a new record\n                line = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\n\n                if isint(line[32]): intgar[0] = int(line[32])\t#Number of steps for block 1\n                if isint(line[38]): intgar[1] = int(line[38])\t#Number of steps for block 2\n                if isint(line[44]): intgar[2] = int(line[44])\t#Number of steps for block 3\n                if isint(line[50]): intgar[3] = int(line[50])\t#Number of steps for block 4\n                if isint(line[56]): intgar[4] = int(line[56])\t#Number of steps for block 5\n                if isint(line[62]): intgar[5] = int(line[62])\t#Number of steps for block 6\n                if isint(line[68]): intgar[6] = int(line[68])\t#Number of steps for block 7\n                if isint(line[74]): intgar[7] = int(line[74])\t#Number of steps for block 8\n\n                if isfloat(line[33:38]): realar[0] = float(line[33:38])\t#Admittance increment for block 1\n                if isfloat(line[39:44]): realar[1] = float(line[39:44])\t#Admittance increment for block 2\n                if isfloat(line[45:50]): realar[2] = float(line[45:50])\t#Admittance increment for block 3\n                if isfloat(line[51:56]): realar[3] = float(line[51:56])\t#Admittance increment for block 4\n                if isfloat(line[57:62]): realar[4] = float(line[57:62])\t#Admittance increment for block 5\n                if isfloat(line[63:68]): realar[5] = float(line[63:68])\t#Admittance increment for block 6\n                if isfloat(line[69:74]): realar[6] = float(line[69:74])\t#Admittance increment for block 7\n                if isfloat(line[75:80]): realar[7] = float(line[75:80])\t#Admittance increment for block 8\n\n                if isfloat(Vmax): realar[8] = float(Vmax)\t#Upper voltage limit\n                if isfloat(Vmin): realar[9] = float(Vmin)\t#Lower voltage limit\n                if isfloat(RMPCT):\n                    realar[11] = float(RMPCT)\t#The RMPCT\n                    if realar[11] > 1.0: realar[11] = realar[11] / 100.0\t#To bring back the RMPCT from percent to unit\n\n                intgar[9] = remote_bus_nbr\n\n                count_nbr = -1\n                for nbr in realar[0:8]:\t\t#This loop is used to get the reactors first in the list for PSS/E to work\n                    count_nbr = count_nbr + 1\n                    if nbr < 0.0 and count_nbr != 0:\t#If the admittance is negative (reactor) and it is not already first in the list\n                        realar.insert(0, nbr)\n                        realar.pop(count_nbr + 1)\n                        intgar.insert(0, intgar[count_nbr])\n                        intgar.pop(count_nbr + 1)\n\n                ierr = psspy.switched_shunt_data(bus_nbr, intgar, realar, '')\t#The API used to load switched shunts in PSS/E\n\n#"
  },
  {
    "id": 87,
    "text": "def GetACard(bpa_str_ar, zone_str, bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr):\n    \"Gets the area data from the BPA file.\"\"\"\n\n    if zone_str != \"\":\t\t\t#Only look for area number if the zone is not blank\n        for line in bpa_str_ar:\t\t#This loop is used to get the corresponding area data\n            line = line.lstrip()\n            line = line.rstrip('\\n')\n            if line == \"\": continue\t#To continue if the line is blank\n            \n            if line[0] == 'A' and line[1] != 'O':\n                if line[2] == ' ':\t\t\t#The modification code for a new record\n                    line = line + ' '*(95-len(line))\t#To pad each line with spaces up to 95 records\n                    if zone_str == line[35:37].strip() or zone_str == line[38:40].strip() or zone_str == line[41:43].strip() or zone_str == line[44:46].strip()\\\n                    or zone_str == line[47:49].strip() or zone_str == line[50:52].strip() or zone_str == line[53:55].strip() or zone_str == line[56:58].strip()\\\n                    or zone_str == line[59:61].strip() or zone_str == line[62:64].strip() or zone_str == line[65:67].strip() or zone_str == line[68:70].strip()\\\n                    or zone_str == line[71:73].strip() or zone_str == line[74:76].strip() or zone_str == line[77:79].strip() or zone_str == line[80:82].strip()\\\n                    or zone_str == line[83:85].strip() or zone_str == line[86:88].strip() or zone_str == line[89:91].strip() or zone_str == line[92:94].strip():\n\n                        if line[13:21].strip() + str(float(line[21:25])) not in bus_str:\t#If the bus is not in the list, add it\n                            bus_nbr = bus_nbr + 1\n                            bus_str[line[13:21].strip() + str(float(line[21:25]))] = bus_nbr\t#A new dictionnary entry\n                            bus_flag = True\t\t\t\t\t\t\t#True if the bus number has been incremented\n                        else:\n                            bus_nbr = bus_str[line[13:21].strip() + str(float(line[21:25]))]\t#Get the bus number\n                            bus_flag = False\t\t\t\t\t\t\t#False if the bus number hasn't been incremented\n\n                        if isfloat(line[26:34]):\t\t\t\t\t#If the value of interchange is specified\n                            if CheckICard(bpa_str_ar, line[3:13].strip()):\t\t#If there is an I card, do not include interchange given\n                                if (line[3:13].strip(), 0.0) not in area_str:\t#If the area is not in the list, add it\n                                    area_nbr = area_nbr + 1\n                                    area_str[(line[3:13].strip(), 0.0)] = area_nbr\n                                    area_slack_nbr.append(bus_nbr)\t\t\t#An array with slack bus numbers for each area\n                                else:\n                                    area_nbr = area_str[(line[3:13].strip(), 0.0)]\t#Get the area number\n                            else:\t\t\t\t\t\t\t#If there is no I card, include the interchange value given\n                                if (line[3:13].strip(),float(line[26:34])) not in area_str:\t#If the area is not in the list, add it\n                                    area_nbr = area_nbr + 1\n                                    area_str[(line[3:13].strip(), float(line[26:34]))] = area_nbr\n                                    area_slack_nbr.append(bus_nbr)\t\t\t#Add the corresponding slack bus number\n                                else:\n                                    area_nbr = area_str[(line[3:13].strip(),float(line[26:34]))]\t#Get the area number\n\n                        else:\t\t\t\t#If there is no value of interchange specified\n                            if (line[3:13].strip(), 0.0) not in area_str:\t\t#If the area is not in the list, add it\n                                area_nbr = area_nbr + 1\n                                area_str[(line[3:13].strip(), 0.0)] = area_nbr\n                                area_slack_nbr.append(bus_nbr)\t\t\t\t#Add the corresponding slack bus number\n                            else:\n                                area_nbr = area_str[(line[3:13].strip(), 0.0)]\t\t#Get the area number\n\n                        area_flag = True\t\t#True if the zone name has a corresponding area card\n\n                        return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr\n\n    area_flag = False\t\t#The zone name has no corresponding area card\n    bus_flag = False\t\t#The bus number hasn't changed\n\n    return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr\n\n#"
  },
  {
    "id": 88,
    "text": "def GetBCard(bpa_str_ar, base_mva, scale_str):\n    \"\"\"Gets the AC bus data from the BPA file.\"\"\"\n\n    bus_data_str = []\t\t\t#The array to contain all AC bus lines\n    bus_str = {}\t\t\t#A dictionnary with bus names and the corresponding bus numbers\n    bus_owner_nbr = [0]\t\t\t#An array with the owner number for each bus\n    bus_zone_str = [\"0\"]\t\t#An array with the zone of each bus\n    load_id_ar = [0]\t\t\t#An array used to determine the load CKT for each bus\n    machine_id_ar = [0]\t\t\t#An array used to determine the machine CKT for each bus\n    owner_str = {'DEFAULT': 1}\t\t#The default owner\n    zone_str = {'DEFAULT': 1}\t\t#The default zone\n    area_str = {(\"DEFAULT\", 0.0): 1}\t#The default area is used for zones without A cards or for data without zones\n    area_slack_nbr = [0]\t\t#An array with the slack bus of each area\n    bus_nbr = 0\t\t\t\t#The bus number\n    owner_nbr = 1\t\t\t#The owner number\n    zone_nbr = 1\t\t\t#The zone number\n    area_nbr = 1\t\t\t#The area number\n\n    for line in bpa_str_ar:\t\t#This loop is used to fill the bus data array with each line of bus data\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n        if line[0] == 'B':\t\t#If it is a bus\n            if line[1] != 'D' and line[1] != 'M':\t#But not a DC bus\n                bus_data_str.append(line)\t\t#Add the line to the array\n\n    for line in bus_data_str:\n        line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 90,
    "text": "bus_intgar = [1, 0, 1, 0]\n        load_intgar = [1, 1, 1, 1]\n        machine_intgar = [0, 0, 0, 0, 0]\n        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]\n        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\n        plant_realar = [1.0, 1.0]\n        remote_bus_nbr = 0\n        remote_kv = 0.0\n\n        if line[2] == ' ':\t\t\t#The modification code for a new record\n            if line[1] == ' ' or line[1] == 'T' or line[1] == 'C' or line[1] == 'V' or line[1] == 'F' or line[1] == 'J' or line [1] == 'X':\n                bus_intgar[0] = 1\t\t#The bus type code for a PQ bus\n            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G' or line[1] == 'K' or line[1] == 'L':\n                bus_intgar[0] = 2\t\t#The bus type code for a PV bus\n            elif line[1] == 'S':\n                bus_intgar[0] = 3\t\t#The bus type code for a swing bus\n\n            if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\n                owner_nbr = owner_nbr + 1\n                owner_str[line[3:6].strip()] = owner_nbr\n                bus_intgar[3] = owner_nbr\t\t\t#The owner number\n            elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                bus_intgar[3] =  owner_str[line[3:6].strip()]\t#Get the owner number\n            elif line[3:6] == \"   \":\n                bus_intgar[3] = 1\t\t\t\t#The default owner number\n\n            bus_namear = line[6:14].strip()\t\t#The bus name\n            bus_realar[2] = float(line[14:18])\t\t#The bus base voltage in kV\n\n            if bus_namear + str(bus_realar[2]) not in bus_str:\t#If the bus is not in the list, add it (the bus could be in the list if assigned as a remote for another bus)\n                bus_nbr = bus_nbr + 1\n                bus_str[bus_namear + str(bus_realar[2])] = bus_nbr\t#A new dictionnary entry\n            else:\n                bus_nbr = bus_str[bus_namear + str(bus_realar[2])]\t#Get the bus number\n\n            bus_owner_nbr.insert(bus_nbr + 1, bus_intgar[3])\t\t#Insert the corresponding owner of the bus\n\n            load_id_ar.append(0)\t#To initialize the load CKT number\n            machine_id_ar.append(0)\t#To initialize the machine CKT number\n\n            if line[18:20] != \"  \":\t#If the zone is not blank\n                if line[18:20].strip() not in zone_str:\t#If the zone is not in the list, add it\n                    zone_nbr = zone_nbr + 1\n                    zone_str[line[18:20].strip()] = zone_nbr\n                    bus_intgar[2] = zone_nbr\t\t#The zone number\n                else:\n                    bus_intgar[2] =  zone_str[line[18:20].strip()]\t#Get the zone number\n\n            bus_zone_str.insert(bus_nbr + 1, line[18:20].strip())\t#Insert the corresponding zone of the bus\n\n            if isfloat(line[20:25]): load_realar[0] = float(line[20:25])\t#Load P in MW\n            if isfloat(line[25:30]): load_realar[1] = float(line[25:30])\t#Load Q in Mvar\n\n            if isfloat(line[30:34]): bus_realar[0] = float(line[30:34])\t\t#Fixed bus shunt active load\n            if isfloat(line[34:38]): bus_realar[1] = float(line[34:38])\t\t#Fixed bus shunt reactive load\n\n            if isfloat(line[38:42]): machine_realar[4] = float(line[38:42])\t#Maximum active power generation\n            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])\t#Actual active power generation\n\n            if line[1] != ' ' and line[1] != 'C' and line[1] != 'T' and line[1] != 'V':\t#If not a PQ bus\n                if isfloat(line[47:52]): machine_realar[2] = float(line[47:52])\t#Machine reactive upper limit\n                if isfloat(line[52:57]): machine_realar[3] = float(line[52:57])\t#Machine reactive lower limit\n\n            if line[1] == ' ' or line[1] == 'C' or line[1] == 'T' or line[1] == 'V':\t#If it is a PQ bus\n                if isfloat(line[47:52]): \n                    machine_realar[2] = float(line[47:52])\t#Machine reactive upper limit\n                    machine_realar[3] = machine_realar[2]\t#Machine reactive lower limit\n                    machine_realar[1] = machine_realar[2]\t#Machine reactive power output\n\n            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G':\t\t#If it is a PV bus\n                if isfloat(line[57:61]): \n                    plant_realar[0] = float(line[57:61])\t\t\t#Scheduled voltage\n                    bus_realar[3] = float(line[57:61])\t\t\t\t#Bus voltage magnitude\n\n            elif line[1] == 'S':\t\t\t\t\t\t#If it is a swing bus\n                if isfloat(line[57:61]):\n                    plant_realar[0] = float(line[57:61])\t\t\t#Scheduled voltage\n                    bus_realar[3] = float(line[57:61])\t\t\t\t#Bus voltage magnitude\n                if isfloat(line[61:65]): bus_realar[4] = float(line[61:65])\t#The voltage phase angle\n\n            if line[65:73] != \"        \":\t\t\t\t\t#If there is a remote bus\n                remote_kv = float(line[73:77])\t\t\t\t\t#The remote bus base voltage\n                if line[65:73].strip() + str(remote_kv) not in bus_str:\t#If the remote bus name is not in the list, add it\n                    remote_bus_nbr = bus_nbr + 1\n                    bus_str[line[65:73].strip() + str(remote_kv)] = remote_bus_nbr\n                else:\n                    remote_bus_nbr = bus_str[line[65:73].strip() + str(remote_kv)]\t#Get the remote bus number\n\n            if isfloat(line[77:80]):\n                plant_realar[1] = float(line[77:80])\t#The RMPCT\n                if plant_realar[1] > 1.0: plant_realar[1] = plant_realar[1] / 100.0\t#To bring back the RMPCT from percent to unit\n\n            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)\n\n            if bus_flag == True: bus_nbr = swing_bus_nbr\t#To change the bus number if it has been incremented\n\n            if area_flag == True:\t\t#To assign the area number to the buses and loads\n                bus_intgar[1] = area_nbr\n                load_intgar[1] = area_nbr\n            else:\t\t\t\t#The default area number\n                bus_intgar[1] = 1\n                load_intgar[1] = 1\n            \n            ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t#Loads the bus data in PSS/E\n\n            if line[1] == 'X': GetXCard(bpa_str_ar, bus_namear + str(bus_realar[2]), line[57:61], line[61:65], line[65:73].strip() + str(remote_kv), line[77:80], remote_bus_nbr, bus_nbr)\n\n            scale_ar = GetScaleData(scale_str, line[3:6].strip(), line[18:20].strip(), 'N')\t#To get the scale factors\n\n            load_realar[0] = load_realar[0] * scale_ar[0]\t\t#To scale the load P\n            load_realar[1] = load_realar[1] * scale_ar[1]\t\t#To scale the load Q\n            machine_realar[0] = machine_realar[0] * scale_ar[6]\t\t#To scale the machine P\n            machine_realar[1] = machine_realar[1] * scale_ar[7]\t\t#To scale the machine Q\n\n            if load_realar[0] != 0.0 or load_realar[1] != 0.0: \t\t\t#If there is a load\n                load_intgar[2] = bus_intgar[2]\t\t#The zone number\n                load_intgar[3] = bus_intgar[3]\t\t#The owner number\n                load_id_ar[bus_nbr] = 1\t\t\t#The load CKT number is now 1\n                ierr = psspy.load_data(bus_nbr, '1', load_intgar, load_realar)\t#Loads the load data in PSS/E\n\n            if machine_realar[0] != 0.0:\t\t#If there is a generator\n                machine_intgar[0] = 1\t\t\t#The machine status\n                machine_intgar[1] = bus_intgar[3]\t#The owner number\n                machine_id_ar[bus_nbr] = 1\t\t#The machine CKT number is now 1\n                ierr = psspy.plant_data(bus_nbr, remote_bus_nbr, plant_realar)\t#First load the plant data\n                ierr = psspy.machine_data(bus_nbr, '1', machine_intgar, machine_realar)\t#After add the generator data\n\n            if remote_bus_nbr == bus_nbr + 1: bus_nbr = bus_nbr + 1\t#To change the actual bus number\n\n    return area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str\n\n#"
  },
  {
    "id": 93,
    "text": "#Only the returned values are useful\n    intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\n    realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'R' and line[1] != 'Z':\t#If it is a R card but not RZ\n            if line[2] == ' ' and from_bus == (line[6:14].strip() + str(float(line[14:18]))) and to_bus == (line[19:27].strip() + str(float(line[27:31]))):\n                line = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\n\n                if line[33:41] != \"        \": intgar[9] = bus_str[line[33:41].strip() + str(float(line[41:45]))]\t#Controlled bus number\n                if isfloat(line[45:50]): realari[17] = float(line[45:50])\t#Winding one ratio/angle high limit\n                if isfloat(line[50:55]): realari[18] = float(line[50:55])\t#Winding one ratio/angle low limit\n                if isint(line[55:57]): intgar[6] = int(line[55:57])\t\t#Number of tap positions\n\n                if line[1] == ' ':\t#If it is a R card\n                    intgar[11] = 1\t#Control mode = 1\n                elif line[1] == 'V':\t#If it is a RV card\n                    intgar[11] = 1\t#Control mode = 1\n \n                elif line[1] == 'Q':\t#If it is a RQ card\n                    intgar[11] = 2\t#Control mode = 2\n                elif line[1] == 'N':\t#If it is a RN card\n                    intgar[11] = 2\t#Control mode = 2\n                    if isfloat(line[57:62]): realari[19] = float(line[57:62])\t#Voltage or flow upper limit\n                    else: realari[19] = 0.0\t\t\t\t\t#Default\n                    if isfloat(line[62:67]): realari[20] = float(line[62:67])\t#Voltage or flow lower limit\n                    else: realari[20] = 0.0\t\t\t\t\t#Default\n\n                elif line[1] == 'P':\t#If it is a RP card\n                    intgar[11] = 3\t#Control mode = 3\n                elif line[1] == 'M':\t#If it is a RM card\n                    intgar[11] = 3\t#Control mode = 3\n                    if isfloat(line[57:62]): realari[19] = float(line[57:62])\t#Voltage or flow upper limit\n                    else: realari[19] = 0.0\t\t\t\t\t#Default\n                    if isfloat(line[62:67]): realari[20] = float(line[62:67])\t#Voltage or flow lower limit\n                    else: realari[19] = 0.0\t\t\t\t\t#Default\n\n                return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]\n\n    return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]\n\n#"
  },
  {
    "id": 94,
    "text": "def GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva):\n    \"\"\"To get the multi-section line data from BPA.\n\n    This function is recursive.\n    \"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank"
  },
  {
    "id": 96,
    "text": "bus_intgar = [1, 1, 1, owner_nbr]\n        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]\n        line_intgar = [1, 0, 1, 0, 0, 0]\n        line_realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\n        trans_intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\n        trans_realari = [0.0, 0.0, base_mva, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\n\n        if line[0] == 'L' and line[1] == ' ' and line[2] == ' ' or line[0] == 'E' and line[1] == ' ' and line[2] == ' ':\n            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:\n                line = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\n                section_nbr = section_nbr + 1\t\t\t#To increment the section number\n                dummy_nbr = dummy_nbr + 1\t\t\t#To increment the dummy bus number\n                bus_nbr = bus_nbr + 1\t\t\t\t#To increment the bus number\n                bus_namear = \"DUMMY #\" + str(dummy_nbr)\t\t#The name of the new dummy bus\n                bus_str[bus_namear] = bus_nbr\t\t\t#Add the bus to the dictionnary\n                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)\t#Insert the owner number of that bus\n                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])\t#The bus base voltage\n                multi_intgar[section_nbr - 2] = bus_nbr\t\t#The bus number of the dummy bus\n                from_bus = bus_nbr\t\t\t\t#To remember the value of the from bus before recalling this function\n\n                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t\t#Loads the bus data in PSS/E\n\n                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)\t#Recursive function\n\n                if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\n                    owner_nbr = owner_nbr + 1\n                    owner_str[line[3:6].strip()] = owner_nbr\t\t#A new dictionnary entry\n                    line_intgar[2] = owner_nbr\t\t\t\t#The new owner number\n                elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                    line_intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\n                elif line[3:6] == \"   \":\n                    line_intgar[2] = 1\t\t\t#The default owner\n\n                line_intgar[1] = from_bus\t\t#Every section of the line is set as metered from (default)\n\n                if isfloat(line[33:37]) and isfloat(line[14:18]): line_realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0\t#The Rate A in MVA\n\n                if line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\n                else: ckt = '1'\t\t\t#If none is mentionned, the default is 1\n\n                if isfloat(line[38:44]): line_realar[0] = float(line[38:44])\t\t\t#Nominal branch resistance\n                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: line_realar[1] = float(line[44:50])\t#Nominal branch reactance\n\n                if line[0] == 'L':\t\t#If it is an L card\n                    if isfloat(line[50:56]):\n                        line_realar[6] = float(line[50:56])/2.0\t\t\t\t\t#Real line shunt at bus IARG end\n                        line_realar[8] = line_realar[6]\t\t\t\t\t\t#Real line shunt at bus JARG end\n                    if isfloat(line[56:62]): line_realar[2] = float(line[56:62])*2.0\t\t#Total line charging\n                    if isfloat(line[62:66]): line_realar[10] = float(line[62:66])\t\t#Line's length in miles\n\n                else:\t\t\t\t#If it is an E card\n                    if isfloat(line[50:56]): line_realar[6] = float(line[50:56])\t\t#Real line shunt at bus IARG end\n                    if isfloat(line[56:62]): line_realar[7] = float(line[56:62])\t\t#Reactive line shunt at bus IARG end\n                    if isfloat(line[62:68]): line_realar[8] = float(line[62:68])\t\t#Real line shunt at bus JARG end\n                    if isfloat(line[68:74]): line_realar[9] = float(line[68:74])\t\t#Reactive line shunt at bus JARG end\n\n                #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual\n                #if line[77:80] != \"   \": line_intgar[0] = 0\t\t#If there is an out of service date, the status is offline\n\n                ierr = psspy.branch_data(from_bus, to_bus, ckt, line_intgar, line_realar)\t#The API to load branch data in PSS/E\n\n                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\n\n        if line[0] == 'T' and line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:\n            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:\n                line = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\n                section_nbr = section_nbr + 1\t\t\t#To increment the section number\n                dummy_nbr = dummy_nbr + 1\t\t\t#To increment the dummy bus number\n                bus_nbr = bus_nbr + 1\t\t\t\t#To increment the bus number\n                bus_namear = \"DUMMY #\" + str(dummy_nbr)\t\t#The name of the dummy bus\n                bus_str[bus_namear] = bus_nbr\t\t\t#A new dictionnary entry\n                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)\t#Insert the owner of this bus\n                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])\t#The bus base voltage\n                multi_intgar[section_nbr - 2] = bus_nbr\t\t#The bus number of the dummy bus\n                from_bus = bus_nbr\n\n                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t#Loads the bus data in PSS/E\n\n                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)\t#Recursive function\n\n                if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\n                    owner_nbr = owner_nbr + 1\n                    owner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\n                    trans_intgar[2] = owner_nbr\t\t\t#The new owner number\n                elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                    trans_intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\n                elif line[3:6] == \"   \":\n                    trans_intgar[2] = 1\t\t\t#The default owner\n\n                trans_intgar[1] = from_bus\t\t#Every section of the line is set as metered from (default)\n\n                trans_intgar[8] = from_bus\t\t#The winding one side\n\n                if isfloat(line[14:18]): trans_realari[4] = float(line[14:18])\t\t#Winding one nominal voltage\n\n                if isfloat(line[27:31]): trans_realari[7] = float(line[27:31])\t\t#Winding two nominal voltage\n\n                if isfloat(line[33:37]): trans_realari[8] = float(line[33:37])\t\t#The Rate A in MVA\n\n                if line[31] != ' ': ckt = line[31]\t#The circuit identifier\n                else: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\n\n                if isfloat(line[38:44]): trans_realari[0] = float(line[38:44])\t#Nominal transformer resistance\n                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: trans_realari[1] = float(line[44:50])\t#Nominal transformer reactance\n\n                if isfloat(line[50:56]): trans_realari[15] = float(line[50:56])\t\t#The magnetizing conductance\n\n                if isfloat(line[56:62]): trans_realari[16] = float(line[56:62])\t\t#The magnetization susceptance\n\n                if line[1] == ' ':\n                    if isfloat(line[62:67]): trans_realari[3] = float(line[62:67])\t\t#The winding one ratio/voltage\n                    if isfloat(line[67:72]): trans_realari[6] = float(line[67:72])\t\t#The winding one ratio/voltage\n\n                else:\t\t#For the phase shifting transformer\n                    if isfloat(line[62:67]): trans_realari[5] = float(line[62:67])\t\t#The winding one phase shift angle\n                    trans_realari[3] = trans_realari[4]\n                    trans_realari[6] = trans_realari[7]\n\n                #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual\n                #if line[77:80] != \"   \": trans_intgar[0] = 0\t\t#If there is an out of service date, the status is offline\n\n                trans_intgar[11], trans_intgar[9], trans_realari[17], trans_realari[18], trans_intgar[6], trans_realari[19], trans_realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)\n\n                ierr, realaro  = psspy.two_winding_data(from_bus, to_bus, ckt, trans_intgar, trans_realari, \"\")\t#The API to load transformer data in PSS/E\n\n                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\n\n    return jarg, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\n\n#"
  },
  {
    "id": 97,
    "text": "def GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, base_mva):\n    \"\"\"Gets the symmetrical and asymmetrical lines from BPA.\"\"\"\n\n    line_str = []\t#An array to contain all AC line data\n    dummy_nbr = 0\t#The dummy bus number for multi-section lines\n\n    for line in bpa_str_ar:\t\t#This loop is used to fill the branch data array with each line of branch data\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n        if line[0] == 'L' and line[1] == ' ' or line[0] == 'E' and line[1] == ' ': line_str.append(line)\n\n    for line in line_str:\n        line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 99,
    "text": "intgar = [1, 0, 1, 0, 0, 0]\n        realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\n\n        if line[2] == ' ':\t\t\t#The modification code for a new record\n\n            if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\n                owner_nbr = owner_nbr + 1\n                owner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\n                intgar[2] = owner_nbr\t\t\t\t#The new owner number\n            elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\n            elif line[3:6] == \"   \":\n                intgar[2] = 1\t\t\t\t\t#The default owner\n\n            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#From bus\n            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]\t\t#To bus\n\n            if line[18] == '1': intgar[1] = iarg\t#The metered end is IARG\n            elif line[18] == '2': intgar[1] = jarg\t#The metered end is JARG\n            elif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\n                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg\t\t#If both ends have the same owner, IARG is the metered end\n                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg\t\t\t#Else the end that has a different owner from the line is the metered end\n                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg\n\n            if isfloat(line[33:37]) and intgar[1] == iarg and isfloat(line[14:18]): realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0\t#The Rate A in MVA\n            elif isfloat(line[33:37]) and intgar[1] == jarg and isfloat(line[27:31]): realar[3] = sqrt(3)*float(line[33:37])*float(line[27:31])/1000.0\t#The Rate A in MVA\n\n            if line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\n            else: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\n\n            if isfloat(line[38:44]): realar[0] = float(line[38:44])\t\t\t#Nominal branch resistance\n            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realar[1] = float(line[44:50])\t#Nominal branch reactance\n\n            if line[0] == 'L':\t\t#If it is an L card\n                if isfloat(line[50:56]):\n                    realar[6] = float(line[50:56])/2.0\t\t\t\t\t#Real line shunt at bus IARG end\n                    realar[8] = realar[6]\t\t\t\t\t\t#Real line shunt at bus JARG end\n                if isfloat(line[56:62]): realar[2] = float(line[56:62])*2.0\t\t#Total line charging\n                if isfloat(line[62:66]): realar[10] = float(line[62:66])\t\t#Line's length in miles\n\n            else:\t\t\t#If it is an E card\n                if isfloat(line[50:56]): realar[6] = float(line[50:56])\t\t#Real line shunt at bus IARG end\n                if isfloat(line[56:62]): realar[7] = float(line[56:62])\t\t#Reactive line shunt at bus IARG end\n                if isfloat(line[62:68]): realar[8] = float(line[62:68])\t\t#Real line shunt at bus JARG end\n                if isfloat(line[68:74]): realar[9] = float(line[68:74])\t\t#Reactive line shunt at bus JARG end\n\n            #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual\n            #if line[77:80] != \"   \": intgar[0] = 0\t\t#If there is an out of service date, the status is offline\n\n            if line[32] == ' ': ierr = psspy.branch_data(iarg, jarg, ckt, intgar, realar)\t#The API to load branch data in PSS/E\n\n            elif line[32] == '1':\t#If the branch is the section number 1\n                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]\n                section_nbr = 2\t\t#To search for a section number 2\n                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)\n\n                intgar[1] = iarg\t#The metered end is IARG\n                ierr = psspy.branch_data(iarg, to_bus, ckt, intgar, realar)\t#The API to load branch data in PSS/E\n                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, \"&\" + ckt, multi_intgar)\t#The API to load the multi-section line data in PSS/E\t\n\n    return owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr\n\n#"
  },
  {
    "id": 100,
    "text": "def GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, base_mva):\n    \"\"\"Gets the two-winding transformer data from BPA.\"\"\"\n\n    transformer_str = []\t#An array to contain all lines with two-winding transformers connecting AC buses\n\n    for line in bpa_str_ar:\t\t#This loop is used to fill the transformer data array with each line of transformer data\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n        if line[0] == 'T' and line[1] == ' ' or line[0] == 'T' and line[1] == 'P': transformer_str.append(line)\n\n    for line in transformer_str:\n        line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 102,
    "text": "intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\n        realari = [0.0, 0.0, basemva, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\n\n        if line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:\n\n            if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\n                owner_nbr = owner_nbr + 1\n                owner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\n                intgar[2] = owner_nbr\t\t\t\t#The new owner number\n            elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\n            elif line[3:6] == \"   \":\n                intgar[2] = 1\t\t\t\t\t#The default owner\n\n            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#From bus\n            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]\t\t#To bus\n\n            intgar[8] = iarg\t\t\t\t\t\t#The winding one side\n\n            if isfloat(line[14:18]): realari[4] = float(line[14:18])\t#Winding one nominal voltage\n\n            if line[18] == '1': intgar[1] = iarg\t#The metered end is IARG\n            elif line[18] == '2': intgar[1] = jarg\t#The metered end is JARG\n            elif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\n                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg\t\t#If both ends have the same owner, IARG is the metered end\n                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg\t\t\t#Else the end that has a different owner from the line is the metered end\n                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg\n\n            if isfloat(line[27:31]): realari[7] = float(line[27:31])\t#Winding two nominal voltage\n\n            if isfloat(line[33:37]): realari[8] = float(line[33:37])\t#The Rate A in MVA\n\n            if line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\n            else: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\n\n            if isfloat(line[38:44]): realari[0] = float(line[38:44])\t\t\t#Nominal transformer resistance\n            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realari[1] = float(line[44:50])\t#Nominal transformer reactance\n\n            if isfloat(line[50:56]): realari[15] = float(line[50:56])\t\t#The magnetizing conductance\n\n            if isfloat(line[56:62]): realari[16] = float(line[56:62])\t\t#The magnetizing susceptance\n\n            if line[1] == ' ':\n                if isfloat(line[62:67]): realari[3] = float(line[62:67])\t#The winding one ratio/voltage\n                if isfloat(line[67:72]): realari[6] = float(line[67:72])\t#The winding two ratio/voltage\n\n            else:\n                if isfloat(line[62:67]): realari[5] = float(line[62:67])\t#The winding one phase shift angle\n                realari[3] = realari[4]\t\t\t\t\t\t#The winding one ratio/voltage\n                realari[6] = realari[7]\t\t\t\t\t\t#The winding two ratio/voltage\n\n            #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual\n            #if line[77:80] != \"   \": intgar[0] = 0\t\t#If there is an out of service date, the status is offline\n\n            intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)\n\n            if line[32] == ' ': ierr, realaro  = psspy.two_winding_data(iarg, jarg, ckt, intgar, realari, \"\")\t#The API to load transformer data in PSS/E\n\n            elif line[32] == '1':\t#If the transformer is section number 1\n                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]\n                section_nbr = 2\t\t#To search for section number 2\n                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)\n\n                intgar[1] = iarg\t#The metered end is IARG\n                ierr, realaro  = psspy.two_winding_data(iarg, to_bus, ckt, intgar, realari, \"\")\t\t#The API used to load two-winding data in PSS/E\n                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, \"&\" + ckt, multi_intgar)\t#The API used to load multi-section line in PSS/E\n\n    return owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr\n\n#"
  },
  {
    "id": 103,
    "text": "def GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, base_mva, scale_str, bus_zone_str):\n    \"\"\"Gets the bus supplement data from BPA.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank"
  },
  {
    "id": 105,
    "text": "load_intgar = [1, 1, 1, 1]\n        machine_intgar = [0, 0, 0, 0, 0]\n        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\n        plant_realar = [1.0, 1.0]\n\n        if line[0] == '+' and line[2] == ' ':\t#If it is a + card\n            line = line + ' '*(77-len(line))\t#To pad each line with spaces up to 77 records\n\n            if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\n                owner_nbr = owner_nbr + 1\n                owner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\n                load_intgar[3] = owner_nbr\t\t\t#The new owner number\n            elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                load_intgar[3] =  owner_str[line[3:6].strip()]\t#Get the owner number\n            elif line[3:6] == \"   \":\n                load_intgar[3] = 1\t\t\t\t#The default owner\n\n            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t#The from bus number\n\n            if line[18:20] == \"*I\" or line[18:20] == \"01\":\t\t\t#If it is a constant current load\n                if isfloat(line[20:25]): load_realar[2] = float(line[20:25])\t#Constant current load P\n                if isfloat(line[25:30]): load_realar[3] = float(line[25:30])\t#Constant current load Q\n            elif line[18:20] == \"*P\" or line[18:20] == \"02\":\t\t\t#If it is a constant power load\n                if isfloat(line[20:25]): load_realar[0] = float(line[20:25])\t#Constant power load P\n                if isfloat(line[25:30]): load_realar[1] = float(line[25:30])\t#Constant power load Q\n\n            if isfloat(line[30:34]): load_realar[4] = float(line[30:34])\t#Constant impedance load P\n            if isfloat(line[34:38]): load_realar[5] = float(line[34:38])\t#Constant impedance load Q\n\n            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])\t#Generation P\n            if isfloat(line[47:52]): machine_realar[1] = float(line[47:52])\t#Generation Q\n\n            if line[1] != 'A' and line[1] != 'F' and line[1] != 'I' and line[1] != 'P': type_code = 'N'\t#Non-industrial load or generation\n            elif line[1] == 'F' or line[1] == 'I' or line[1] == 'P': type_code = 'I'\t\t\t#Industrial load\n            elif line[1] == 'A' and line[18:20] == \"*I\" or line[18:20] == \"01\": type_code = 'X'\t\t#If it is a +A card with constant current load\n            elif line[1] == 'A' and line[18:20] == \"*P\" or line[18:20] == \"02\": type_code = 'Y'\t\t#If is is a +A card with constant power load\n\n            scale_ar = GetScaleData(scale_str, line[3:6].strip(), bus_zone_str[iarg], type_code)\t#To get the scale factors\n\n            load_realar[0] = load_realar[0] * scale_ar[0]\t\t#To scale the constant power load P\n            load_realar[1] = load_realar[1] * scale_ar[1]\t\t#To scale the constant power load Q\n            load_realar[2] = load_realar[2] * scale_ar[2]\t\t#To scale the constant current load P\n            load_realar[3] = load_realar[3] * scale_ar[3]\t\t#To scale the constant current load Q\n            load_realar[4] = load_realar[4] * scale_ar[4]\t\t#To scale the constant impedance load P\n            load_realar[5] = load_realar[5] * scale_ar[5]\t\t#To scale the constant impedance load Q\n            machine_realar[0] = machine_realar[0] * scale_ar[6]\t\t#To scale the generation P\n            machine_realar[1] = machine_realar[1] * scale_ar[7]\t\t#To scale the generation Q\n\n            if load_realar[0] != 0.0 or load_realar[1] != 0.0 or load_realar[2] != 0.0 or load_realar[3] != 0.0 or load_realar[4] != 0.0 or load_realar[5] != 0.0:\n                load_id_ar[iarg] = load_id_ar[iarg] + 1\t\t#To increment the load CKT\n                ierr = psspy.load_data(iarg, str(load_id_ar[iarg]), load_intgar, load_realar)\t#Loads the load data in PSS/E\n\n            if machine_realar[0] != 0.0 or machine_realar[1] != 0.0:\t#If there is a generator\n                machine_id_ar[iarg] = machine_id_ar[iarg] + 1\t\t#To increment the machine CKT\n                machine_intgar[0] = 1\t\t\t\t\t#The machine status\n                machine_intgar[1] = owner_nbr\t\t\t\t#The owner number\n                if machine_id_ar[iarg] == 1:\t\t\t\t#If it is the first generator on this bus\n                    ierr = psspy.plant_data(iarg, 0, plant_realar)\t#First load the plant data\n                ierr = psspy.machine_data(iarg, str(machine_id_ar[iarg]), machine_intgar, machine_realar)\t#After add the generator data\n\n    return owner_str, owner_nbr\n\n#"
  },
  {
    "id": 106,
    "text": "def GetICard(bpa_str_ar, area_str, area_slack_nbr):\n    \"\"\"Gets the inter-area transfer data from BPA.\"\"\"\n\n    inter_nbr = 48\t\t\t#In order to start to the character '1' in the transfer ID\n\n    for line in bpa_str_ar:\t\t#This loop is used to get the inter-area transfer data\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if it is a blank line"
  },
  {
    "id": 108,
    "text": "ia = 1\t\t\t\t#Default area number\n        ja = 1\t\t\t\t#Default area number\n        realar = [0.0]\t\t\t#Default transfer\n\n        if line[0] == 'I' and line[2] == ' ':\t\t#If it is an I card\n            line = line + ' '*(34-len(line))\t\t#To pad each line with spaces up to 34 records\n            for (x,y), z in area_str.items():\n                if x == line[3:13].strip(): ia = z\t#The 'from' area number\n                if x == line[14:24].strip(): ja = z\t#The 'to' area number\n\n            if isfloat(line[26:34]): realar[0] = float(line[26:34])\t#The amount of MW in the transfer\n\n            inter_nbr = inter_nbr + 1\t#To increment the transfer ID\n\n            if inter_nbr == 123:\t#After the 'Z' character, PSS/E do not accept the other ASCII characters\n                psspy.alert(\" WARNING: MAXIMUM NUMBER OF INTER-AREA TRANSFERS REACHED\\n\")\n                return\n\n            ierr = psspy.transfer_data(1, ia, ja, chr(inter_nbr), realar[0])\t#The transfer data API\n\n#"
  },
  {
    "id": 109,
    "text": "def GetRZCard(bpa_str_ar):\n    \"\"\"Gets the line series compensation from BPA.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'R' and line[1] == 'Z':\t#If it is an RZ card\n            line = line + ' '*(60-len(line))\t#To pad each line with spaces up to 60 records\n\n            #Found no equivalent way to model this series compensation device in PSS/E\n            psspy.alert(\" WARNING: THE RZ CARD GOING FROM BUS [\" + line[6:18] + \"] TO BUS [\" + line[19:31] + \"] CANNOT BE IMPORTED\\n\")\n\n#"
  },
  {
    "id": 110,
    "text": "def GetZCard(bpa_str_ar, zone_str):\n    \"\"\"Gets the renamed zone names from BPA.\"\"\"\n\n    zone_str_temp = {}\t\t#A dictionnary containing the modified zone names\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\n\n        if line[0] == 'Z':\n            line = line + ' '*(77-len(line))\t#To pad each line with spaces up to 77 records\n\n            for x, y in zone_str.items():\n                if x == line[3:5].strip(): zone_str_temp[line[5:7].strip()] = y\n                elif x == line[8:10].strip(): zone_str_temp[line[10:12].strip()] = y\n                elif x == line[13:15].strip(): zone_str_temp[line[15:17].strip()] = y\n                elif x == line[18:20].strip(): zone_str_temp[line[20:22].strip()] = y\n                elif x == line[23:25].strip(): zone_str_temp[line[25:27].strip()] = y\n                elif x == line[28:30].strip(): zone_str_temp[line[30:32].strip()] = y\n                elif x == line[33:35].strip(): zone_str_temp[line[35:37].strip()] = y\n                elif x == line[38:40].strip(): zone_str_temp[line[40:42].strip()] = y\n                elif x == line[43:45].strip(): zone_str_temp[line[45:47].strip()] = y\n                elif x == line[48:50].strip(): zone_str_temp[line[50:52].strip()] = y\n                elif x == line[53:55].strip(): zone_str_temp[line[55:57].strip()] = y\n                elif x == line[58:60].strip(): zone_str_temp[line[60:62].strip()] = y\n                elif x == line[63:65].strip(): zone_str_temp[line[65:67].strip()] = y\n                elif x == line[68:70].strip(): zone_str_temp[line[70:72].strip()] = y\n                elif x == line[73:75].strip(): zone_str_temp[line[75:77].strip()] = y\n                else: zone_str_temp[x] = y\n\n            zone_str.clear()\t\t\t#To clear the dictionnary\n            zone_str.update(zone_str_temp)\t#To copy the contents of the temporary dictionnary\n\n    return zone_str\n\n#"
  },
  {
    "id": 111,
    "text": "def GetDZCard(bpa_str_ar, zone_str):\n    \"\"\"Gets the deleted zone names from BPA and remove connected buses and equipment.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'D' and line[1] == 'Z':\t#If it is a DZ card\n            line = line + ' '*(5-len(line))\t#To pad each line with spaces up to 5 records\n            if line[3:5].strip() in zone_str:\n                ierr = psspy.bsys(0, 0, [0.0,0.0], 0, [], 0, [], 0, [], 1, [zone_str[line[3:5].strip()]])\t#A bus subsystem of this zone\n                ierr = psspy.extr(0, 0, [1, 0])\t\t\t\t\t\t#To delete this subsystem\n                ierr = psspy.bsys(0, 1, [0.0, 9999.], 0, [], 0, [], 0, [], 0, [])\t#To bring back the original unfiltered view\n                del zone_str[line[3:5].strip()]\t\t\t\t\t\t#To delete the zone\n\n            else: psspy.alert(\" WARNING: THE ZONE [\" +  line[3:5].strip() + \"] SPECIFIED IN THE DZ CARD CANNOT BE FOUND\\n\")\t#If the zone is not found\n\n    return zone_str\n\n#"
  },
  {
    "id": 112,
    "text": "def GetDCOwners(bpa_str_ar, from_bus, to_bus):\n    \"\"\"Gets the owners of the DC buses for the two-terminal DC lines in BPA.\"\"\"\n\n    owner_1 = \"\"\t#The owner of bus 'converter 1'\n    owner_2 = \"\"\t#The owner of bus 'converter 2'\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':\t#If it is a BD card\n            if from_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_1 = line[3:6].strip()\n            elif to_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_2 = line[3:6].strip()\n\n    return owner_1, owner_2\n\n#"
  },
  {
    "id": 115,
    "text": "intgar_1 = [0, 0, 0, 0, 0]\n    realari_1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    intgar_2 = [0, 0, 0, 0, 0]\n    realari_2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t\t#Continue if the line is blank\n\n        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':\t#If it is a BD card\n            line = line + ' '*(62-len(line))\t#To pad each line with spaces up to 62 records\n\n            if from_bus == line[6:14].strip() + str(float(line[14:18])):\t#If the bus is converter 1\n                if flow_flag: cnvflg_1 = 1\t#If the flow is positive, the converter 1 is a rectifier\n                else: cnvflg_1 = 2\t\t#If the flow is negative, the converter 1 is an inverter\n\n                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_1[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter 1 bus number\n\n                if isint(line[23:25]): intgar_1[1] = int(line[23:25])\t\t#Number of bridges in series\n                if isfloat(line[30:35]): realari_1[0] = float(line[30:35])\t#Minimum firing angle\n                if isfloat(line[35:40]): realari_1[1] = float(line[35:40])\t#Maximum firing angle\n\n            elif to_bus == line[6:14].strip() + str(float(line[14:18])):\t#If the bus is converter 2\n                if flow_flag: cnvflg_2 = 2\t#If the flow is positive, the converter 2 is an inverter\n                else: cnvflg_2 = 1\t\t#If the flow is negative, the converter 2 is a rectifier\n\n                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_2[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter 2 bus number\n\n                if isint(line[23:25]): intgar_2[1] = int(line[23:25])\t\t#Number of bridges in series\n                if isfloat(line[30:35]): realari_2[0] = float(line[30:35])\t#Minimum firing angle\n                if isfloat(line[35:40]): realari_2[1] = float(line[35:40])\t#Maximum firing angle\n\n        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a T card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n\n            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[38:44]): realari_1[2] = float(line[38:44])\t#Commutating resistance\n                if isfloat(line[44:50]): realari_1[3] = float(line[44:50])\t#Commutating reactance\n\n                realari_1[4] = float(line[14:18])\t\t\t\t#Primary base voltage\n\n                if isfloat(line[67:72]): realari_1[5] = float(line[67:72])\t#Transformer ratio\n                if isfloat(line[62:67]): realari_1[6] = float(line[62:67])\t#Tap setting\n\n            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[38:44]): realari_2[2] = float(line[38:44])\t#Commutating resistance\n                if isfloat(line[44:50]): realari_2[3] = float(line[44:50])\t#Commutating reactance\n\n                realari_2[4] = float(line[14:18])\t\t\t\t#Primary base voltage\n\n                if isfloat(line[67:72]): realari_2[5] = float(line[67:72])\t#Transformer ratio\n                if isfloat(line[62:67]): realari_2[6] = float(line[62:67])\t#Tap setting\n\n        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a R card\n            line = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\n\n            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[45:50]): realari_1[7] = float(line[45:50])\t#Maximum tap setting\n                if isfloat(line[50:55]): realari_1[8] = float(line[50:55])\t#Minimum tap setting\n                if isint(line[55:57]) and int(line[55:57]) != 0: realari_1[9] = (realari_1[7] - realari_1[8])/int(line[55:57])\t#Tap step\n\n            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[45:50]): realari_2[7] = float(line[45:50])\t#Maximum tap setting\n                if isfloat(line[50:55]): realari_2[8] = float(line[50:55])\t#Minimum tap setting\n                if isint(line[55:57]) and int(line[55:57]) != 0: realari_2[9] = (realari_2[7] - realari_2[8])/int(line[55:57])\t#Tap step\n\n    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_1, dc_line_nbr, intgar_1, realari_1, \"\")\t#To load the converter 1 in PSS/E\n    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_2, dc_line_nbr, intgar_2, realari_2, \"\")\t#To load the converter 2 in PSS/E\n\n#"
  },
  {
    "id": 116,
    "text": "def GetTwoTermLine(bpa_str_ar, bus_str):\n    \"\"\"Gets the two-terminal DC line data from BPA.\"\"\"\n\n    dc_line_nbr = 0\t#The two-terminal DC line number\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'L' and line[1] == 'D' and line[2] == ' ':\t#If it is a LD card\n            line = line + ' '*(78-len(line))\t#To pad each line with spaces up to 78 records"
  },
  {
    "id": 118,
    "text": "intgar = [1, 0]\n            realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\n            dc_line_nbr = dc_line_nbr + 1\t#To increment the DC line number\n\n            if isfloat(line[56:61]): realari[0] = float(line[56:61])\t#Scheduled power demand\n            if isfloat(line[61:66]): realari[1] = float(line[61:66])\t#Scheduled DC voltage\n            if isfloat(line[37:43]): realari[4] = float(line[37:43])\t#DC line resistance\n\n            if line[55] == 'I': realari[5] = 0\t\t\t#Compounding resistance = 0 if Vdc is controlled at the inverter\n            elif line[55] == 'R': realari[5] = realari[4]\t#Compounding resistance = Rdc if Vdc is controlled at the rectifier\n\n            if line[18] == '1':\t\t\t\t#If the metered side is converter 1\n                if realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\n                else: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\n\n            elif line[18] == '2':\t\t\t#If the metered side is converter 2\n                if realari[0] >= 0.0: metrar = 'I'\t#The metered side is the inverter if the flow is positive\n                else: metrar = 'R'\t\t\t#The metered side is the rectifier if the flow is negative\n\n            elif line[18] == ' ':\t\t\t#If the metered side is left blank, BPA chooses\n                owner_1, owner_2 = GetDCOwners(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])))\n                if owner_1 == owner_2:\t\t#If both DC buses have the same owner\n                    if realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\n                    else: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\n                elif owner_1 == line[3:6].strip():  #If the owner of converter 1 is the same as the line\n                    if realari[0] >= 0.0: metrar = 'I'\t#The metered side is the inverter if the flow is positive\n                    else: metrar = 'R'\t\t\t#The metered side is the rectifier if the flow is negative\n                elif owner_2 == line[3:6].strip():  #If the owner of converter 2 is the same as the line\n                    if realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\n                    else: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\n\n            ierr, realaro = psspy.two_terminal_dc_line_data(dc_line_nbr, intgar, realari, metrar)\t#The API to load two-terminal DC line in PSS/E\n\n            GetTwoTermConv(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), dc_line_nbr, realari[0] >= 0.0, bus_str)\t#To get the 2 converters data\n\n#"
  },
  {
    "id": 119,
    "text": "def GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, bus_name):\n    \"\"\"Gets the T and R card corresponding to the converter bus specified.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':\t#If it is a T card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n\n            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[67:72]): conv_realari[3] = float(line[67:72])\t#Transformer ratio\n                if isfloat(line[38:44]): conv_realari[4] = float(line[38:44])\t#Commutating resistance\n                if isfloat(line[44:50]): conv_realari[5] = float(line[44:50])\t#Commutating reactance\n\n                conv_realari[6] = float(line[14:18])\t\t\t\t#Winding one base voltage\n\n                if isfloat(line[62:67]): conv_realari[7] = float(line[62:67])\t#Tap setting\n\n        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a R card\n            line = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\n\n            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):\n                if isfloat(line[45:50]): conv_realari[8] = float(line[45:50])\t#Maximum tap setting\n                if isfloat(line[50:55]): conv_realari[9] = float(line[50:55])\t#Minimum tap setting\n                if isint(line[55:57]) and int(line[55:57]) != 0: conv_realari[10] = (conv_realari[8] - conv_realari[9])/int(line[55:57])\t#Tap step\n\n    return conv_intgar, conv_realari\n\n#"
  },
  {
    "id": 120,
    "text": "def GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr):\n    \"\"\"Gets the converter data for multi-terminal lines and creates DC buses.\"\"\"\n\n    dc_bus_nbr = 0\t\t#The DC bus number for multi-terminal lines\n    dc_bus_str = {}\t\t#The dictionnary to contain DC bus names and numbers\n    dc_bus_owner = [\"DEFAULT\"]\t#An array of the owners of each DC bus\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'B' and line[1] == 'M' and line[2] == ' ':\t#If it is a BM card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 122,
    "text": "conv_intgar = [0, 0, 0, 0]\n            conv_realari = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.5, 0.51, 0.00625, 0.0, 1.0]\n            bus_intgar = [0, 0, 0, 0, 0]\n            bus_realari = 0.0\n\n            if line[6:14].strip() + str(float(line[14:18])) not in dc_bus_str:\t\t#If the bus is not in the list, add it\n                dc_bus_nbr = dc_bus_nbr + 1\n                dc_bus_str[line[6:14].strip() + str(float(line[14:18]))] = dc_bus_nbr\t\t#A new dictionnary entry\n            else:\n                dc_bus_nbr = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#Get the bus number\n\n            if line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\n                owner_nbr = owner_nbr + 1\n                owner_str[line[3:6].strip()] = owner_nbr\t\t#A new dictionnary entry\n                bus_intgar[3] = owner_nbr\t\t\t\t#The new owner number\n            elif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\n                bus_intgar[3] =  owner_str[line[3:6].strip()]\t\t#Get the owner number\n            elif line[3:6] == \"   \":\n                bus_intgar[3] = 1\t\t\t\t\t#The default owner\n\n            dc_bus_owner.insert(dc_bus_nbr + 1, line[3:6].strip())\t#Insert the owner number of this bus\n\n            if line[18:20] != \"  \":\n                if line[18:20].strip() not in zone_str:\t\t#If the zone is not in the list, add it\n                    zone_nbr = zone_nbr + 1\n                    zone_str[line[18:20].strip()] = zone_nbr\t\t#A new dictionnary entry\n                    bus_intgar[2] = zone_nbr\t\t\t\t#The new zone number\n                else:\n                    bus_intgar[2] =  zone_str[line[18:20].strip()]\t#Get the zone number\n\n            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)\n\n            if area_flag == True:\t\t#To assign the area number to the DC buses\n                bus_intgar[1] = area_nbr\n            else:\t\t\t\t#The default area number\n                bus_intgar[1] = 1\n\n            if line[62] != ' ':\t\t\t#If it is not a passive DC bus\n                conv_intgar[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter bus number\n                bus_intgar[0] = conv_intgar[0]\t\t\t\t\t\t#Converter bus number\n\n                if isint(line[23:25]): conv_intgar[1] = int(line[23:25])\t\t#Number of bridges in series\n                if isfloat(line[69:75]):\n                    if float(line[69:75]) != 0.0: conv_realari[0] = float(line[69:75])\t#Scheduled power\n                    elif isfloat(line[75:80]): conv_realari[0] = float(line[75:80])\t#Scheduled voltage\n\n                if line[62] == 'R' and isfloat(line[30:35]): conv_realari[1] = float(line[30:35])\t#Minimum firing angle\n\n                elif line[62] == 'I' and isfloat(line[66:69]) or line[62] == 'M' and isfloat(line[66:69]):\n                    conv_realari[1] = float(line[66:69])\t\t\t#Minimum extinction angle\n\n                if isfloat(line[35:40]): conv_realari[2] = float(line[35:40])\t#Maximum firing angle\n\n                conv_intgar, conv_realari = GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, line[6:14].strip() + str(float(line[14:18])))\t#To get the corresponding T and R parameters\n\n                ierr,realaro = psspy.multi_term_dc_convr_data(1, conv_intgar, conv_realari)\t#The API to load multi-terminal DC line converter data in PSS/E\n\n            ierr,realaro = psspy.multi_term_dc_bus_data(1, dc_bus_nbr, bus_intgar, bus_realari, line[6:14].strip())\t#The API to load multi-terminal DC line bus data in PSS/E\n\n    return dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr\n\n#"
  },
  {
    "id": 123,
    "text": "def GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner):\n    \"\"\"Gets the multi-terminal link data from the BPA file.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':\t#If it is a LM card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 125,
    "text": "intgar = 0\n            realar = [0.0, 0.0]\n\n            ibus = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]\t#The from bus\n            jbus = dc_bus_str[line[19:27].strip() + str(float(line[27:31]))]\t#The to bus\n\n            if line[18] == '1': intgar = ibus\t\t#The metered end is IBUS\n            elif line[18] == '2': intgar = jbus\t\t#The metered end is JBUS\n            elif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\n                if dc_bus_owner[ibus] == dc_bus_owner[jbus]: intgar = ibus\t#If both ends have the same owner, IBUS is the metered end\n                elif dc_bus_owner[ibus] == line[3:6].strip(): intgar = jbus\t#Else the end that has a different owner from the line is the metered end\n                elif dc_bus_owner[jbus] == line[3:6].strip(): intgar = ibus\n\n            if isfloat(line[37:43]): realar[0] = float(line[37:43])\t#DC link resistance\n            if isfloat(line[43:49]): realar[1] = float(line[43:49])\t#DC link inductance\n\n            ierr = psspy.multi_term_dc_link_data(1, ibus, jbus, '1', intgar, realar)\t#The API used to load multi-terminal DC line link data in PSS/E\n\n#"
  },
  {
    "id": 126,
    "text": "def GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr):\n    \"\"\"Gets the multi-terminal lines from the BPA file.\"\"\"\n\n    for line in bpa_str_ar:\n        line = line.lstrip()\n        line = line.rstrip('\\n')\n        if line == \"\": continue\t\t#Continue if the line is blank\n\n        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':\t#If it is a LM card\n            line = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records"
  },
  {
    "id": 128,
    "text": "intgari = 1\n            realar = 0.0\n\n            ierr, intgaro = psspy.multi_term_dc_line_data(1, intgari, realar)\t#The API used to load multi-terminal DC line data in PSS/E\n\n            #To get the converter, DC bus and DC link data\n            dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr)\n            GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner)\n\n            return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr\n\n    return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr\n\n#"
  },
  {
    "id": 129,
    "text": "bpa_file = OpenFile()\n\nif bpa_file:\t\t\t\t\t#If the file opened successfully\n\n    psspy.progress(\"\\n\\nFile opened successfully, starting the conversion:\\n\")\n\n    bpa_str = bpa_file.read()\t\t\t#The string containing the text file, to use the find() function\n    bpa_file.seek(- bpa_file.tell(), 1)\t\t#To position back at the beginning\n    bpa_str_ar = bpa_file.readlines()\t\t#The array that is containing all the lines of the BPA file\n\n    basemva = GetMVA(bpa_file, bpa_str)\t\t#To get the MVA base\n    psspy.progress(\"\\n-Base MVA: \" + str(basemva))\n\n    titl1, titl2 = GetTitles(bpa_file, bpa_str)\t#To get the title data\n    psspy.progress(\"\\n-Title 1: \" + titl1)\n    psspy.progress(\"\\n-Title 2: \" + titl2 + \"\\n\")\n\n    ierr = psspy.newcas(basemva, titl1, titl2)\t#To create the new case\n\n    scale_str = GetPCard(bpa_str_ar)\t\t#To get the P cards for scaling\n\n    area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str = GetBCard(bpa_str_ar, basemva, scale_str)\n\n    owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr = GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, basemva)\n\n    owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr = GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, basemva)\n\n    owner_str, owner_nbr = GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, basemva, scale_str, bus_zone_str)\n\n    GetTwoTermLine(bpa_str_ar, bus_str)\n    zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr)\n\n    zone_str = GetZCard(bpa_str_ar, zone_str)\t#To get Z cards\n    zone_str = GetDZCard(bpa_str_ar, zone_str)\t#To get DZ cards\n\n    for x, y in zone_str.items():\n        ierr = psspy.zone_data(y, x)\t#The API used to load zone data in PSS/E\n\n    for (x,y), z in area_str.items():\n        ierr = psspy.area_data(z, area_slack_nbr[z - 1], [y, 0.0], x)\t#The API used to load zone data in PSS/E\n\n    GetICard(bpa_str_ar, area_str, area_slack_nbr)\t#To get the I cards\n\n    for x, y in owner_str.items():\n        ierr = psspy.owner_data(y, x)\t#The API used to load owner data in PSS/E\n\n    GetRZCard(bpa_str_ar)\t#To get RZ cards\n\n    psspy.progress(\"\\n\\nConversion completed\\n\")\n\n    bpa_file.close()\t#To close the BPA file\n#[brnflows_csv.py]  Export BRANCH FLOWS to COMMA SEPARATED FILE (CSV)\n#"
  },
  {
    "id": 130,
    "text": "'''\nThis is an example file showing how to use \"subsystem data retrieval APIs\nfrom Python to save branch flows to Comma Separated File.\n    Input : Solved PSS(R)E saved case file name\n    Output: CSV file name to save\n    When 'savfile' is provided, FNSL with default options is used to solve the case.\n    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.\n    When 'csvfile' is provided, branch flows is saved in ASCII text file 'csvfile'.\n    When 'csvfile' is not provided, it produces report in PSS(R)E report window.\n\nThe subsystem data retrieval APIs return values as List of Lists. For example:\nWhen \"abusint\" API is called with \"istrings\" as defined below:\n    istrings = ['number','type','area','zone','owner','dummy']\n    ierr, idata = psspy.abusint(sid, flag_bus, istrings)\nThe returned list will have format:\n    idata=[[list of 'number'],[list of 'type'],[],[],[],[list of 'dummy']]\n\nThis example is written such that, such returned lists are converted into dictionary with\nkeys as strings specified in \"istrings\". This makes it easier to refer and use these lists.\n    ibuses = array2dict(istrings, idata)\n\nSo ibuses['number'] gives the bus numbers returned by \"abusint\"."
  },
  {
    "id": 134,
    "text": "def busindexes(busnum, busnumlist):\n    '''Find indexes of a bus in list of buses.\n    Returns list with indexes of 'busnum' in 'busnumlist'.\n    '''\n    busidxes = []\n    startidx = 0\n    buscounts = busnumlist.count(busnum)\n    if buscounts:\n        for i in range(buscounts):\n            tmpidx = busnumlist.index(busnum,startidx)\n            busidxes.append(tmpidx)\n            startidx = tmpidx+1\n    return busidxes\n\n#"
  },
  {
    "id": 135,
    "text": "def splitstring_commaspace(tmpstr):\n    '''Split string first at comma and then by space. Example:\n    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\n    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n    '''\n    strlst = []\n    commalst = tmpstr.split(',')\n    for each in commalst:\n        eachlst = each.split()\n        if eachlst:\n            strlst.extend(eachlst)\n        else:\n            strlst.extend(' ')\n\n    return strlst\n\n#"
  },
  {
    "id": 136,
    "text": "def brnflows_csv(savfile,csvfile):\n    '''Generates power flow result report.\n    When 'savfile' is provided, FNSL with default options is used to solve the case.\n    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.\n    When 'csvfile' is provided, report is saved in ASCII text file 'csvfile'.\n    When 'csvfile' is not provided, it produces report in PSS(R)E report window.\n    '''\n\n    import psspy\n    psspy.psseinit()\n\n    # Set Save and CSV files according to input file names\n    if savfile:\n        ierr = psspy.case(savfile)\n        if ierr != 0: return\n        fpath, fext = os.path.splitext(savfile)\n        if not fext: savfile = fpath + '.sav'\n    else:   # saved case file not provided, check if working case is in memory\n        ierr, nbuses = psspy.abuscount(-1,2)\n        if ierr != 0:\n            print('\\n No working case in memory.')\n            print(' Either provide a Saved case file name or open Saved case in PSSE.')\n            return\n        savfile, snapfile = psspy.sfiles()\n\n    if csvfile:  # open CSV file to write\n        csvfile_h = open(csvfile,'w')\n        report    = csvfile_h.write\n    else:        # send results to PSS(R)E report window\n        psspy.beginreport()\n        report = psspy.report\n\n    #"
  },
  {
    "id": 139,
    "text": "# Branch Flow Data\n    # Branch Flow Data - Integer\n    istrings = ['fromnumber','tonumber','status','nmeternumber','owners','own1','own2','own3','own4']\n    ierr, idata = psspy.aflowint(sid, owner_brflow, ties_brflow, flag_brflow, istrings)\n    if ierr != 0: return\n    iflow = array2dict(istrings, idata)\n    # Branch Flow Data - Real\n    rstrings = ['amps','pucur','pctrate','pctratea','pctrateb','pctratec','pctmvarate',\n                'pctmvaratea','pctmvarateb',#'pctmvaratec','fract1','fract2','fract3',\n                'fract4','rate','ratea','rateb','ratec',\n                'p','q','mva','ploss','qloss',\n                'o_p','o_q','o_mva','o_ploss','o_qloss'\n                ]\n    ierr, rdata = psspy.aflowreal(sid, owner_brflow, ties_brflow, flag_brflow, rstrings)\n    if ierr != 0: return\n    rflow = array2dict(rstrings, rdata)\n    # Branch Flow Data - Complex\n    xstrings = ['pq','pqloss','o_pq','o_pqloss']\n    ierr, xdata = psspy.aflowcplx(sid, owner_brflow, ties_brflow, flag_brflow, xstrings)\n    if ierr != 0: return\n    xflow = array2dict(xstrings, xdata)\n    # Branch Flow Data - Character\n    cstrings = ['id','fromname','fromexname','toname','toexname','nmetername','nmeterexname']\n    ierr, cdata = psspy.aflowchar(sid, owner_brflow, ties_brflow, flag_brflow, cstrings)\n    if ierr != 0: return\n    cflow = array2dict(cstrings, cdata)\n\n    #"
  },
  {
    "id": 141,
    "text": "report(\"Branch flows from Saved case: %s\\n\" %savfile)\n\n    clnttls = \"%6s,%18s,%6s,%18s,%3s,%3s,%9s,%9s,%9s,%6s,%8s,%8s\\n\" %('FRMBUS',\n             'FROMBUSEXNAME','TOBUS','TOBUSEXNAME','CKT','STS','MW','MVAR','MVA','%I','MWLOSS','MVARLOSS')\n    report(clnttls)\n    for i in range(len(iflow['fromnumber'])):\n        fromnum    = iflow['fromnumber'][i]\n        fromexname = cflow['fromexname'][i]\n        tonum      = iflow['tonumber'][i]\n        toexname   = cflow['toexname'][i]\n        ckt        = cflow['id'][i]\n        status     = iflow['status'][i]\n        p          = rflow['p'][i]\n        q          = rflow['q'][i]\n        mva        = rflow['mva'][i]\n        ploss      = rflow['ploss'][i]\n        qloss      = rflow['qloss'][i]\n        pcti       = rflow['pctrate'][i]\n        report(\"%(fromnum)6d,%(fromexname)18s,%(tonum)6d,%(toexname)18s,%(ckt)3s,%(status)3d,\\\n%(p)9.2F,%(q)9.2F,%(mva)9.2F,%(pcti)6.2F,%(ploss)8.2F,%(qloss)8.2F\\n\" %vars())\n    #"
  },
  {
    "id": 143,
    "text": "def check_psse_example_folder(csvfile):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n    rptpath, rptfnam = os.path.split(csvfile)\n    if not rptpath:\n        rptpath = os.getcwd()\n        cwd = rptpath.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n        else:\n            outdir = os.getcwd()\n        csvfile  = os.path.join(outdir, rptfnam)\n\n    return csvfile\n\n#"
  },
  {
    "id": 148,
    "text": "'''\n'dyntools' module provide access to data in PSS(R)E Dynamic Simulation Channel Output file.\nThis module has functions:\n- to get channel data in Python scripts for further processing\n- to get channel information and their min/max range\n- to export data to text files, excel spreadsheets\n- to open multiple channel output files and post process their data using Python scripts\n- to plot selected channels\n- to plot and insert plots in word document\n\nThis is an example file showing how to use various functions available in dyntools module.\n\nOther Python modules 'matplotlib', 'numpy' and 'python win32 extension' are required to be\nable to use 'dyntools' module.\nSelf installation EXE files for these modules are available at:\n   PSSE User Support Web Page and follow link 'Python Modules used by PSSE Python Utilities'.\n\n- This version of the dyntools module is developed and tested using these open source modules.\n  Python 3.7.3 [64 bit]\n  matplotlib-3.1.1\n  numpy-1.16.4\n  pywin32-224\n\n  Versions later than these may work."
  },
  {
    "id": 149,
    "text": "How to use this file?\n- Open Python IDLE (or any Python Interpreter shell)\n- Open this file\n- run (F5)\n\nNote: Do NOT run this file from PSS(R)E GUI. The 'xyplots' function from dyntools can\nsave plots to eps, png, pdf or ps files. However, creating only 'eps' files from inside\nPSS(R)E GUI works. This is because different backends matplotlib uses to create different\nplot types.\nWhen run from any Python interpreter (outside PSS(R)E GUI) plots can be saved to any of\nthese four (eps, png, pdf or ps) file types.\n\nGet information on functions available in dyntools as:\nimport dyntools\nhelp(dyntools)"
  },
  {
    "id": 150,
    "text": "How to use PSSE and Python modules like numpy, matplotlib together?\n(a) In your python script, call following function before any of these modules are imported.\n    psspy.set_fpcw_py()\n(b) Call following function before exiting your python script.\n    psspy.set_fpcw_psse()\nTo get details why this is needed, get help(..) on either of these functions.\nRefer function test2_subplots_one_trace(..) in this script for usage of these functions.\n\n'''\n\nimport os, sys, collections\n\n#"
  },
  {
    "id": 151,
    "text": "def get_demotest_file_names(outdir, outvrsn):\n\n    if outvrsn==0:\n        extn = '.out'\n        prgfile  = os.path.join(outdir,'progress.txt')\n    else:\n        extn = '.outx'\n        prgfile  = os.path.join(outdir,'progressX.txt')\n\n    outfile1 = os.path.join(outdir,'bus154_fault{}'.format(extn))\n    outfile2 = os.path.join(outdir,'bus3018_gentrip{}'.format(extn))\n    outfile3 = os.path.join(outdir,'brn3005_3007_trip{}'.format(extn))\n\n    return outfile1, outfile2, outfile3, prgfile\n\n#"
  },
  {
    "id": 153,
    "text": "# Run Dynamic simulation on SAVNW to generate .out files\n\ndef run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn):\n\n    import psspy\n    psspy.psseinit()\n\n    examdir = get_example_folder()\n\n    savfile = 'savcnv.sav'\n    snpfile = 'savnw.snp'\n\n    if not datapath: datapath = get_example_folder()\n\n    savfile = os.path.join(datapath, savfile)\n    snpfile = os.path.join(datapath, snpfile)\n\n    psspy.lines_per_page_one_device(1,10000000)\n    psspy.progress_output(2,prgfile,[0,0])\n\n    ierr = psspy.case(savfile)\n    if ierr:\n        psspy.progress_output(1,\"\",[0,0])\n        print(\" psspy.case Error\")\n        return\n    ierr = psspy.rstr(snpfile)\n    if ierr:\n        psspy.progress_output(1,\"\",[0,0])\n        print(\" psspy.rstr Error\")\n        return\n\n    psspy.set_chnfil_type(outvrsn)\n\n    psspy.strt(0,outfile1)\n    psspy.run(0, 1.0,1000,1,0)\n    psspy.dist_bus_fault(154,1, 230.0,[0.0,-0.2E+10])\n    psspy.run(0, 1.05,1000,1,0)\n    psspy.dist_clear_fault(1)\n    psspy.run(0, 5.0,1000,1,0)\n\n    psspy.case(savfile)\n    psspy.rstr(snpfile)\n    psspy.strt(0,outfile2)\n    psspy.run(0, 1.0,1000,1,0)\n    psspy.dist_machine_trip(3018,'1')\n    psspy.run(0, 5.0,1000,1,0)\n\n    psspy.case(savfile)\n    psspy.rstr(snpfile)\n    psspy.strt(0,outfile3)\n    psspy.run(0, 1.0,1000,1,0)\n    psspy.dist_branch_trip(3005,3007,'1')\n    psspy.run(0, 5.0,1000,1,0)\n\n    psspy.lines_per_page_one_device(2,10000000)\n    psspy.progress_output(1,\"\",[0,0])\n\n#"
  },
  {
    "id": 154,
    "text": "# 0. Run savnw dynamics simulation to create .out files\n\ndef test0_run_simulation(datapath=None, outpath=None, outvrsn=0):\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n    run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn)\n\n    print(\" Test0:Done SAVNW dynamics simulation\")\n\n#"
  },
  {
    "id": 155,
    "text": "# 1. Data extraction/information\n\ndef test1_data_extraction(outpath=None, show=True, outvrsn=0, prg2file=True):\n\n    import psspy\n    import dyntools\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n\n    # create object\n    chnfobj = dyntools.CHNF(outfile1, outvrsn=outvrsn)\n\n    if chnfobj.ierr: return\n\n    if prg2file:\n        p, nx = os.path.split(outfile1)\n        n, x  = os.path.split(nx)\n        rptnam = \"{}_test1_output.txt\".format(n)\n        if outpath:\n            rptfile = os.path.join(outpath, rptnam)\n        else:\n            rptfile = os.path.join(p, rptnam)\n        rptfile_h = open(rptfile,'w')\n        report = rptfile_h.write\n    else:\n        report = sys.stdout.write\n\n    report('\\n Test1:Testing call to get_data\\n')\n    #sh_ttl, ch_id, ch_data = chnfobj.get_data()\n    sh_ttl, ch_id, ch_data = chnfobj.get_data(['time', 4, 5, 55])\n    #sh_ttl, ch_id, ch_data = chnfobj.get_data('')\n    #sh_ttl, ch_id, ch_data = chnfobj.get_data([4, 5, 55])\n    s_in = [str(ch) for ch in ch_data.keys()]\n    s_ch = ', '.join(s_in)\n    report(sh_ttl)\n    report(\"{}\".format(ch_id))\n    report(\" Test1:Data extracted for Channels = {}\\n\".format(s_ch))\n\n    report('\\n Test1:Testing call to get_id\\n')\n    sh_ttl, ch_id = chnfobj.get_id()\n    report(sh_ttl)\n    report(\"{}\".format(ch_id))\n    report('\\n')\n\n    report('\\n Test1:Testing call to get_range\\n')\n    ch_range = chnfobj.get_range()\n    report(\"{}\".format(ch_range))\n    report('\\n')\n\n    report('\\n Test1:Testing call to get_scale\\n')\n    ch_scale = chnfobj.get_scale()\n    report(\"{}\".format(ch_scale))\n    report('\\n')\n\n    if not prg2file:\n        report('\\n Test1:Testing call to print_scale\\n')\n        chnfobj.print_scale()\n        report('\\n')\n\n    pn, x = os.path.splitext(outfile1)\n\n    report('\\n Test1:Testing call to txtout\\n')\n    chnfobj.txtout(channels=[1,4], txtfile=pn)\n    report('\\n')\n\n    report('\\n Test1:Testing call to csvout\\n')\n    chnfobj.csvout(channels=[1,4,41,5], csvfile=pn)\n    report('\\n')\n\n    report('\\n Test1:Testing call to xlsout\\n')\n    try:\n        chnfobj.xlsout(channels=[2,3,4,7,8,10], show=show, xlsfile=pn)\n    except:\n        pass\n\n    if prg2file:\n        rptfile_h.close()\n        txt = ' Test1_data_extraction report saved to file:\\n    {}\\n'.format(rptfile)\n        print(txt)\n\n#"
  },
  {
    "id": 156,
    "text": "# 2. Multiple subplots in a figure, but one trace in each subplot\n#    Channels specified with normal dictionary\n\n# See how \"set_plot_legend_options\" method can be used to place and format legends\n\ndef test2_subplots_one_trace(outpath=None, show=True, outvrsn=0):\n\n    import psspy\n    import dyntools\n    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n\n    chnfobj = dyntools.CHNF(outfile1, outfile2, outvrsn=outvrsn)\n\n    chnfobj.set_plot_page_options(size='letter', orientation='portrait')\n    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n                             'circle', 'star', 'hexagon1')\n    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\n    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\n\n    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':True, 'showoutfnam':True, 'showlogo':True,\n                'legendtype':1, 'addmarker':True}\n\n    optnchn1 = {1:{'chns':6,                'title':'Ch#6,bus154_fault, P(pu)'},\n                2:{'chns':[6, 'v*100'],     'title':'Ch#6,bus154_fault, P(MW)'},\n                3:{'chns':11,               'title':'Ch#11,bus154_fault'},\n                4:{'chns':40,               'title':'Ch#40,bus154_fault'},\n                5:{'chns':26,               'title':'Ch#26,bus154_fault, Frequency (pu)'},\n                6:{'chns':[26, '(1+v)*60'], 'title':'Ch#26,bus154_fault, Frequency (Hz)'},\n                }\n    pn,x     = os.path.splitext(outfile1)\n    pltfile1 = pn+'.pdf'\n\n    optnchn2 = {1:{'chns':{outfile2:6},                'title':'Channel 6 from bus3018_gentrip, P(pu)'},\n                2:{'chns':{outfile2:[6, 'v*100']},     'title':'Channel 6 from bus3018_gentrip, P(MW)'},\n                3:{'chns':{outfile2:11}},\n                4:{'chns':{outfile2:16}},\n                5:{'chns':{outfile2:26},               'title':'Ch#26,bus3018_gentrip, Frequency (pu)'},\n                6:{'chns':{outfile2:[26, '(1+v)*60']}, 'title':'Ch#26,bus3018_gentrip, Frequency (Hz)'},\n                }\n    pn,x     = os.path.splitext(outfile2)\n    pltfile2 = pn+'.png'\n\n    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)\n\n    chnfobj.set_plot_legend_options(loc='lower center', borderpad=0.2, labelspacing=0.5,\n                                    handlelength=1.5, handletextpad=0.5, fontsize=8, frame=False)\n\n    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n                'legendtype':2, 'addmarker':False}\n\n    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)\n\n    if figfiles1 or figfiles2:\n        txt = ' Test2:Plot files saved:\\n'\n        if figfiles1: txt += \"     {}\\n\".format(figfiles1[0])\n        if figfiles2: txt += \"     {}\\n\".format(figfiles2[0])\n        print(txt)\n\n    if show:\n        chnfobj.plots_show()\n    else:\n        chnfobj.plots_close()\n\n    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n\n#"
  },
  {
    "id": 157,
    "text": "# 3. Multiple subplots in a figure and more than one trace in each subplot\n#    Channels specified with normal dictionary\n\ndef test3_subplots_mult_trace(outpath=None, show=True, outvrsn=0):\n\n    import psspy\n    import dyntools\n    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n\n    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\n\n    chnfobj.set_plot_page_options(size='letter', orientation='portrait')\n    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n                             'circle', 'star', 'hexagon1')\n    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\n    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\n\n    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n                'legendtype':2, 'addmarker':True}\n\n    optnchn1 = {1:{'chns':[1]},2:{'chns':[2]},3:{'chns':[3]},4:{'chns':[4]},5:{'chns':[5]}}\n    pn,x     = os.path.splitext(outfile1)\n    pltfile1 = pn+'.png'\n\n    optnchn2 = {1:{'chns':{outfile2:1}},\n                2:{'chns':{'v82_test1_bus_fault.out':3}},\n                3:{'chns':4},\n                4:{'chns':[5]}\n               }\n    pn,x     = os.path.splitext(outfile2)\n    pltfile2 = pn+'.pdf'\n\n    optnchn3 = {1:{'chns':{outfile1:1}},\n                2:{'chns':{outfile2:[1,5]}},\n                3:{'chns':{outfile3:3}},\n                4:{'chns':[4,'v-v0',5,'v-v0']},  # arbitrary function\n               }\n    pn,x     = os.path.splitext(outfile3)\n    pltfile3 = pn+'.png'\n\n    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)\n    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)\n    figfiles3 = chnfobj.xyplots(optnchn3,optnfmt,pltfile3)\n\n    figfiles = figfiles1[:]\n    figfiles.extend(figfiles2)\n    figfiles.extend(figfiles3)\n    if figfiles:\n        txt = ' Test3:Plot files saved:\\n'\n        for f in figfiles:\n            txt += \"    {}\\n\".format(f)\n        print(txt)\n\n    if show:\n        chnfobj.plots_show()\n    else:\n        chnfobj.plots_close()\n\n    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n\n#"
  },
  {
    "id": 158,
    "text": "# 4. Multiple subplots in a figure, but one trace in each subplot\n#    Channels specified with Ordered dictionary\n\ndef test4_subplots_mult_trace_OrderedDict(outpath=None, show=True, outvrsn=0):\n\n    import psspy\n    import dyntools\n    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n\n    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\n\n    chnfobj.set_plot_page_options(size='letter', orientation='portrait')\n    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n                             'circle', 'star', 'hexagon1')\n    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\n    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\n\n    optnfmt  = {'rows':2,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n                'legendtype':2, 'addmarker':True}\n\n    optnchn  = {1:{'chns':collections.OrderedDict([(outfile1,26), (outfile2,26), (outfile3,26)]),\n                   'title':'Frequency(pu)'},\n                2:{'chns':collections.OrderedDict([(outfile1,[26, '(1+v)*60']),\n                                                   (outfile2,[26, '(1+v)*60']),\n                                                   (outfile3,[26, '(1+v)*60'])]),\n                   'title':'Frequency(Hz)'}\n               }\n    p,nx     = os.path.split(outfile1)\n    pltfile  = os.path.join(p, 'plot_chns_ordereddict.png')\n\n    figfiles = chnfobj.xyplots(optnchn,optnfmt,pltfile)\n\n    if figfiles:\n        txt = ' Test4:Plot files saved:\\n'\n        for f in figfiles:\n            txt += \"    {}\\n\".format(f)\n        print(txt)\n\n    if show:\n        chnfobj.plots_show()\n    else:\n        chnfobj.plots_close()\n\n    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n\n#"
  },
  {
    "id": 159,
    "text": "# 5. Do XY plots and insert them into word file\n# Does not work because win32 API to Word does not work.\n\ndef test5_plots2word(outpath=None, show=True, outvrsn=0):\n\n    import psspy\n    import dyntools\n    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\n\n    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n\n    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\n\n    p,nx       = os.path.split(outfile1)\n    docfile    = os.path.join(p,'savnw_response')\n    overwrite  = True\n    caption    = True\n    align      = 'center'\n    captionpos = 'below'\n    height     = 0.0\n    width      = 0.0\n    rotate     = 0.0\n\n    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':True}\n\n    optnchn  = {1:{'chns':{outfile1:1,  outfile2:1,  outfile3:1} },\n                2:{'chns':{outfile1:[7,'v*100'],  outfile2:[7,'v*100'],  outfile3:[7,'v*100']} },\n                3:{'chns':{outfile1:17, outfile2:17, outfile3:17} },\n                4:{'chns':[1,2,3,4,5]},\n                5:{'chns':{outfile2:[26,'(1+v)*60',27,'(1+v)*60',28,'(1+v)*60',29,'(1+v)*60']},\n                   'title':'Frequency(Hz)'},\n                6:{'chns':{outfile3:[1,2,3,4,5]} },\n               }\n    ierr, docfile = chnfobj.xyplots2doc(optnchn,optnfmt,docfile,show,overwrite,caption,align,\n                        captionpos,height,width,rotate)\n\n    if not ierr:\n        txt  = ' Test5:Plots saved to file:\\n    {}'.format(docfile)\n        print(txt)\n    else:\n        txt  = ' Test5:Error saving plots to Word = {}'.format(ierr)\n        print(txt)\n\n    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n\n#"
  },
  {
    "id": 161,
    "text": "def run_tests(which, outvrsn, show, datapath=None, prg2file=True):\n\n    import psspy\n\n    datapath = datapath\n\n    outdnam  = \"dyntools_demo_output_outvrn{}\".format(outvrsn)\n    outpath  = os.path.join(os.getcwd(), outdnam)\n    if not os.path.exists(outpath): os.mkdir(outpath)\n\n    if which in [0, 'all']:\n        print(\" <<<<<< Begin TEST=0 >>>>>>\")\n        test0_run_simulation(datapath, outpath, outvrsn)\n        print(\" Output files folder:{}\".format(outpath))\n\n    if which in [1, 'all']:\n        print(\" <<<<<< Begin TEST=1 >>>>>>\")\n        test1_data_extraction(outpath=outpath, show=show, outvrsn=outvrsn, prg2file=prg2file)\n\n    if which in [2, 'all']:\n        print(\" <<<<<< Begin TEST=2 >>>>>>\")\n        test2_subplots_one_trace(outpath, show, outvrsn)\n\n    if which in [3, 'all']:\n        print(\" <<<<<< Begin TEST=3 >>>>>>\")\n        test3_subplots_mult_trace(outpath, show, outvrsn)\n\n    if which in [4, 'all']:\n        print(\" <<<<<< Begin TEST=4 >>>>>>\")\n        test4_subplots_mult_trace_OrderedDict(outpath, show, outvrsn)\n\n    if which in [5, 'all']:\n        print(\" <<<<<< Begin TEST=5 >>>>>>\")\n        try:\n            test5_plots2word(outpath, show, outvrsn)\n        except:\n            pass\n\n#"
  },
  {
    "id": 162,
    "text": "if __name__ == '__main__':\n\n    import psse35\n\n    show = True     # True  --> create, save and show Excel spreadsheets and Plots when done\n                    # False --> create, save but do not show Excel spreadsheets and Plots when done\n\n                    # Channel file format\n    outvrsn = 0     # =0, for no Extended Channel output file type (.out)\n                    # =1, for Extended Channel output file type (.outx) (default)\n\n    prg2file = False\n\n    #(a) Run one test a time\n    #\n    # 1) which=0\n    # Need to run \"test0_run_simulation(..)\" before running other tests.\n    #\n    # 2)\n    # which = 1 or 2 or 3 or 4 or 5\n    # After running \"test0_run_simulation(..)\", run other tests one at a time with\n\n    # which = 0\n    # run_tests(which, outvrsn, show, prg2file)\n\n    #(b) Run all tests\n    #    Just uncomment next line to run all tests in this file.\n    #run_all_tests(outvrsn)\n\n#"
  },
  {
    "id": 165,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psseXX\n    where XX is PSSE version number like 34, 35, 3500, 3501.\n    \n- call funtion\n    run_export(qvfile)\n    or\n    run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd())\n\nExcel file is saved to a file name derived from qvfile name.\n'''\n\nimport os\n\nshtlst = ['bus voltage', 'summary', 'generator dispatch', 'mismatch']\n\n#"
  },
  {
    "id": 166,
    "text": "def qv_summary(xlsobj,sheet,smry):\n    '''\n    Use this to create ->\n    QV worksheet: 'Summary'\n    '''\n    xlsobj.set_active_sheet(sheet)\n    row, col = 1, 1\n    xlsobj.set_cell((row,col),\"QV SOLUTION RESULTS\",fontStyle=\"bold\",fontSize=14, fontColor=\"blue\")\n\n    tmplst=[\n        smry.casetitle.line1,\n        smry.casetitle.line2,\n        'QV output file                             = %s' % smry.file.qv,\n        'Saved Case file                            = %s' % smry.file.sav]\n\n    if smry.file.thr:\n        tmplst.append('Load throwover file                        = %s' % smry.file.thr)\n\n    tlst = [\n        'DFAX file                                  = %s' % smry.file.dfx,\n        'Subsystem file                             = %s' % smry.file.sub,\n        'Monitored Element file                     = %s' % smry.file.mon,\n        'Contingency Description file               = %s' % smry.file.con]\n\n    tmplst.extend(tlst)\n\n    if smry.file.inl:\n        tmplst.append('Inertia and Governor Response file         = %s' % smry.file.inl)\n    if smry.file.zip:\n        tmplst.append('Incremental Save Case Archive file         = %s' % smry.file.zip)\n\n    tlst = [\n        ' ',                                                                       # blank row\n        'Number of Contingencies+Base Case          = %d' % smry.qvsize.ncase,\n        'Number of Monitored Generators(Plants)     = %d' % smry.qvsize.nmgnbus,\n        'Number of Voltage Monitored Buses          = %d' % smry.qvsize.nmvbus,\n        'Number of Voltage Monitored Records        = %d' % smry.qvsize.nmvrec,\n        'Number of maximum voltage setpoint changes = %d' % smry.qvsize.nmxvstp,\n        ]\n\n    tmplst.extend(tlst)\n\n    row_optn_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+opt ttl\n    jnklst=[' ', 'QV Solution Options:']\n    for i in range(len(smry.options)):\n        j=smry.options[i]\n        ti=str(i+1).rjust(2)\n        tj=str(j)\n        t1=arrbox.qv_pp._QV_INT_OPTIONS_NAMES[i]\n        if (i+1)==arrbox.qv_pp._QV_INT_OPTIONS_STUDY_BUS_INDEX:\n            jnklst.append(\"option(%(ti)s): %(t1)s =%(tj)s\" % vars())\n        else:\n            t2=arrbox.qv_pp._QV_INT_OPTIONS_LIST[i][j]\n            jnklst.append(\"option(%(ti)s): %(t1)s =%(tj)s =%(t2)s\" % vars())\n\n    tmplst.extend(jnklst)\n    row_vals_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+val ttl\n\n    jnklst=[' ', 'QV Solution Values:']\n    for i in range(len(smry.realvalues)):\n        ti=str(i+1)\n        tn=arrbox.qv_pp._QV_REAL_VALUES_NAMES[i]\n        tv=\"%g\" % smry.realvalues[i]\n        jnklst.append(\"value(%(ti)s): %(tn)s =%(tv)s\" % vars())\n\n    tmplst.extend(jnklst)\n    del jnklst\n\n    row += 2\n    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True)\n    xlsobj.font_color((row,col,row+1,col),'brown')\n    xlsobj.font_color((row_optn_ttl,col),'red')\n    xlsobj.font_color((row_vals_ttl,col),'red')\n\n    if smry.qvsize.ncase:\n        row = bottomRow+2\n        xlsobj.set_cell((row,col),\"QV Contingencies\",fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n\n        conlst = [['CON#', 'LABEL', 'Min Vstp', 'Max Vstp', 'Min MVAR', 'Max MVAR',\n                   'Max Mismatch', 'DESCRIPTION']]\n        # determine rows for which QV is failed maxmsm>smry.realvalues[0]\n        rfrm = row+1\n        rto  = row+1\n        failrows = []\n        for i in range(smry.qvsize.ncase):\n            rfrm += 1\n            rto  += 1\n            if i==0:\n                srnum = ' '\n            else:\n                srnum = str(i)\n            nam  = smry.colabel[i]\n            minvstp = smry.minvstp[i]\n            maxvstp = smry.maxvstp[i]\n            minmvar = smry.minmvar[i]\n            maxmvar = smry.maxmvar[i]\n            maxmsm  = smry.maxmsm[i]\n            for j in range(len(smry.codesc[i])):\n                dsc = smry.codesc[i][j]\n                if j==0:\n                    conlst.append([srnum,nam,minvstp,maxvstp,minmvar,maxmvar,maxmsm,dsc])\n                else:\n                    conlst.append(['' ,'' ,'' ,'' ,'' ,'' ,'' ,dsc])\n                    rto += 1\n            if maxmsm>smry.realvalues[0]:\n                failrows.append([rfrm, rto])\n            else:\n                failrows.append([0, 0])\n            rfrm = rto\n\n        row += 1\n        bottomRow,rightCol = xlsobj.set_range(row,col,conlst)\n        xlsobj.font_color((row,col,row,rightCol), \"dgreen\")\n        xlsobj.font((row,col+2,bottomRow,col+3),numberFormat='0.00')  # Min Vstp and Max Vstp\n        xlsobj.font((row,col+4,bottomRow,col+6),numberFormat='0.000') # Min MVAR, Max MVAR and Max MSM\n        xlsobj.align((row,col),'right')\n        xlsobj.font((row,col,row,rightCol),fontStyle=('Bold',))\n        xlsobj.autofit_columns((row,col+1,row,rightCol))\n        for each in failrows:\n            r1 = each[0]\n            r2 = each[1]\n            if r1 and r2:\n                xlsobj.font((r1,col,r2,rightCol),fontColor=\"cyan\",fontStyle='bold')\n    else:\n        xlsobj.set_cell((row,col),\"No Contingencies..\",fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n\n#"
  },
  {
    "id": 167,
    "text": "def qv_mismath(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,mvaworst,mvatotal,cnvflag,cnvcond):\n    '''\n    Use this to create ->\n    QV worksheet: 'Mismatch'\n    '''\n    \n    # assemble data in columns: 1st=MW Transfer, 2nd=MVAWORST and 3rd=MVATOTAL\n    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label\n    cnvyesno = []\n    noclns   = []\n    i = 1\n    for each in cnvflag:\n        i += 1\n        if each:\n            cnvyesno.append('YES')\n            noclns.append(0)\n        else:\n            cnvyesno.append('NO')\n            noclns.append(i)\n\n    tmplst = [ rowttl ]\n    for i in range(len(mwtransfer)):\n        tmplst.append([mwtransfer[i],mvaworst[i],mvatotal[i],cnvyesno[i],cnvcond[i]])\n\n    xlsobj.set_active_sheet(sheet)\n    col = 1\n    # added 1 to row in violation check for 'contitle' row\n    xlsobj.set_cell((row,col+1),contitle,fontStyle='bold',fontSize=12,fontColor=\"dgreen\")\n    row += 1\n    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True,numberFormat=\"0.00000\")\n    xlsobj.font((row,col,row,rightCol),fontColor=\"red\",fontStyle='bold',numberFormat=\"0.000\")\n    xlsobj.align((row,col,row,rightCol),'h_center')\n    xlsobj.align((row+3,col,row+3,rightCol),'h_center')\n    xlsobj.align((row,col,bottomRow,col),'right')\n    xlsobj.font((row+1,col,bottomRow,col),fontColor=\"blue\",fontStyle='bold')\n    for each in noclns:\n        if each:\n            xlsobj.font((row+3,each,bottomRow,each),fontColor=\"cyan\",fontStyle='bold')\n\n    row = bottomRow + 2 # one blank row\n\n    return row\n\n#"
  },
  {
    "id": 168,
    "text": "def qv_one(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,solnvalue,options,cnvflag=[]):\n    '''\n    Use this to create ->\n    QV worksheets: 'Bus Voltage', 'Generator Dispatch'\n    '''\n\n    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label\n    namesplit = options[0]\n    nttlclns  = options[1]\n    transpose = options[2]\n\n    # determine non-converged solution columns\n    noclns = []\n    i = nttlclns\n    for each in cnvflag:\n        i += 1\n        if each:\n            noclns.append(0)\n        else:\n            noclns.append(i)\n\n    # assemble data in columns: 1st=MW Transfer, rest=solution values\n    t = []\n    for i in range(len(mwtransfer)):\n        t1 = list(solnvalue[i])\n        t1.insert(0,mwtransfer[i])\n        t.append(t1)\n        \n    tmplst = t\n    tmplst.insert(0,rowttl)\n    xlsobj.set_active_sheet(sheet)\n    col = 1\n    xlsobj.set_cell((row,col+nttlclns),contitle,fontStyle='bold',fontSize=12,fontColor=\"dgreen\")\n    row += 1\n    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=transpose)\n    xlsobj.font((row,col+nttlclns-1,row,rightCol),fontColor=\"red\",fontStyle='bold')\n    xlsobj.font((row,col+nttlclns,bottomRow,rightCol),numberFormat=\"0.000\")\n    xlsobj.align((row,col,row,rightCol),'h_center')\n    if namesplit: xlsobj.merge((row,col,row,nttlclns))\n    xlsobj.align((row,col),'right')\n    xlsobj.font((row+1,col,bottomRow,nttlclns),fontColor=\"blue\",fontStyle='bold')\n    for each in noclns:\n        if each:\n            xlsobj.font((row+1,each,bottomRow,each),fontColor=\"cyan\")\n    row = bottomRow + 2 # one blank row\n\n    return row\n\n#"
  },
  {
    "id": 169,
    "text": "def run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd()):\n    import arrbox.qv_pp\n    import excelpy\n    \n    if not os.path.exists(qvfile):\n        msgstr = \" Error - QV file does not exist, no export.\\n     {}.\" .format(qvfile)\n        print(msgstr)\n        return\n        \n    p, nx = os.path.split(qvfile)\n    xlnam, x = os.path.splitext(nx)\n    xlnam = \"{}_qv\".format(xlnam)\n    xlsfile = os.path.join(outpath, xlnam)\n\n    #"
  },
  {
    "id": 170,
    "text": "xlsobj = excelpy.workbook(xlsfile, shtlst[0], overwritesheet=overwritesheet)\n    if show:\n        xlsobj.show()\n    else:\n        xlsobj.hide()\n\n    xlsobj.show_alerts(0) # do not show pop-up alerts\n    xlsfnam = xlsobj.XLSFNAM\n\n    for shtnam in shtlst[1:]:\n        xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)\n    \n    xlsobj.page_format(orientation=\"landscape\",left=1.0,right=1.0,\n                       top=0.5,bottom=0.5,header=0.25,footer=0.25)\n    xlsobj.page_footer(left='page number of page total', right='date, time')\n    xlsobj.page_header(center='file name:sheet name')\n    xlsobj.font_sheet()\n\n    #"
  },
  {
    "id": 171,
    "text": "# Retrive QV data\n    qvobj = arrbox.qv_pp.QV_PP(qvfile)\n    smry = qvobj.summary()\n\n    qv_summary(xlsobj, 'summary', smry)\n\n    row_msm = 1\n    msmlabel = ['VOLTAGE SETPOINT->', 'LARGEST MVA MISMATCH', 'TOTAL MVA MISMATCH', 'CONVERGED', 'CONVERGE CONDITION']\n\n    row_vlt = 1\n    options_vlt = [False,1,True]\n    mvbuslabel = list(smry.mvbuslabel)\n    mvbuslabel.insert(0,'VOLTAGE SETPOINT->')\n\n    row_gen = 1\n    options_gen = [False,1,True]\n    mgenbuslabel = list(smry.mgenbus)\n    mgenbuslabel.insert(0,'VOLTAGE SETPOINT->')\n    \n    ret_ierr = 0\n    for lbl in smry.colabel:\n        soln = qvobj.solution(lbl)\n        if soln==None: continue                 # contingency solution not found, move to next\n        if soln.ierr !=0: ret_ierr = soln.ierr  # return any non-zero ierr\n\n        row_msm = qv_mismath(xlsobj, 'mismatch',lbl,'Mismatch (MVA)',\n                             row_msm,msmlabel,soln.vsetpoint,soln.mvaworst,soln.mvatotal,\n                             soln.cnvflag, soln.cnvcond)\n        \n        row_vlt = qv_one(xlsobj,'bus voltage',lbl,'Voltage (pu)',\n                         row_vlt,mvbuslabel,soln.vsetpoint,soln.volts,options_vlt,soln.cnvflag)\n\n        row_gen = qv_one(xlsobj,'generator dispatch',lbl,'Plant (MVAR)',\n                         row_gen,mgenbuslabel,soln.vsetpoint,soln.mgenmvar,options_gen,soln.cnvflag)\n\n    #"
  },
  {
    "id": 176,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\n    import psseXX\n\n- call function\n    Run various functions from this file as desired.\n    See notes in _run_one_test_api(..) (end of this file).\n'''\n\n\"\"\"\nUse any of these keywords to run GIC_8.\nKeyword               Default          Description\n                                     # INTGOPTNS[]\ntielevels           = 0              #  1  Number of levels of inter-tie buses to add to study subsystem\nstudy_year          = 0              #  2  Year number to scale benchmark event GMD storm. These scaling factors account in the influence of geomagnetic latitude on the estimated geoelectric field magnitude and are provided in NERC TPL-007.\nsid_supp            = 0              #  3  Subsystem sid for supplemental GMD event\nthermal_ana_optn    = 0              #  4  Option for Transformer Thermal Analysis\ndegscan_pf_optn     = 0              #  5  Option to run power flow for each degree scan calculation\nboundary_trn        = 0              #  6  Option to include buses of boundary transformers in study subsystem\nworstcase_trn       = 0              #  7  Option for Transformers to include in worst case determination\nsupp_evt            = 0              #  8  Option for Supplemental event and moving box\nsupp_box_num        = 0              #  9  Option for number of Supplemental event moving boxes. It is not used when intgoptns(8)=0 and intgoptns(8)=4\nbrn_seg_efld        = 0              # 10  Option for treatment of the transmission line that intersect with Supplemental event moving box\n                                     # REALOPTNS[]\nefield_mag          = 8.0            #  1  electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform or supplemental\nefield_deg          = 0              #  2  electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform or supplemental\nsubstation_r        = 0.1            #  3  substation grounding dc resistance in ohms\nbranch_xbyr         = 30             #  4  transmission line X/R ratio, must be > 0, used to calculate branch DC resistance if R=0.0 in network data\ntransformer_xbyr    = 30             #  5  transformer winding X/R ratio, must be > 0, used to calculate winding DC resistance if R=0.0 in network data\nefield_mag_supp     = 12.0           #  6  supplemental event electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform\nefield_deg_supp     = 0.0            #  7  local GMD hot spots electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform\nbranch_rac2rdc      = 1.0            #  8  transmission line AC to DC resistance conversion factor, must be > 0\ntransformer_rac2rdc = 1.0            #  9  transformer winding AC to DC resistance conversion factor, must be > 0\ndegscan_step        = 10.0           # 10  Degree Scan step size, range 1.0 to 180 degrees\nmagscan_step        = 4.0            # 11   Magnitude Scan step size, must be > 1.0 V/km\npf_qpct_step        = 100.0          # 12   Percent GMD Mvar loss step size. Total GMD Mvar losses added incrementally to the base case to obtain power flow solution, must be > 1.0\nmagscan_max         = 20.0           # 13   Magnitude Scan maximum storm strength, must be > 1.0\nsupp_box_ns_km      = 100.0          # 14   Supplemental event moving box North-South length in km, must be > 1.0, used when intgoptns(8)>0\nsupp_box_ew_km      = 500.0          # 15   Supplemental event moving box East-West length in km, must be > 1.0, used when intgoptns(8)>0\nsupp_box_lon_c      = 0.0            # 16   Supplemental event moving box center point longitude in degrees, used only when intgoptns(8)=4\nsupp_box_lat_c      = 0.0            # 17   Supplemental event moving box center point latitude in degrees, used only when intgoptns(8)=4\n                                     # CHAROPTNS[]\nefield_type         = \"uniform\"      #  1  Electric Field Type\nefield_unit         = \"v/km\"         #  2  Units of Electric Field Magnitude\naddfile_optn        = \"rdch\"         #  3  Option to add GIC updates to base case\ngic2mvar_optn       = \"kfactors\"     #  4  Option to select method for GIC to Mvar Calculation\nearth_model_name    = \"\"             #  5  Earth Model Name. A Standard or User defined model name must be provided when Benchmark Event or Non-uniform electric field is to be modeled or Transformer Thermal Analysis is to be performed.\nscan_storm_event    = \"\"             #  6  Option to scan storm event scenarios\npower_flow_optn     = \"\"             #  7 Option to solve Power Flow with GIC losses added to the base case\n                                     # EJETOPTNS[]\nejet_million_amps   = 1.0            #  1  eletrojet current in million amperes, must be > 0\nejet_halfwidth_km   = 200.0          #  2  Cauchy distribution half-width in km, must be > 0\nejet_period_min     = 5.0            #  3  period of variation in minutes, must be > 0\nejet_height_km      = 100.0          #  4  height of current in km, must be > 0\nejet_center_deg     = 54.0           #  5  latitude of center of electrojet in degrees\n                                     # FILEOPTNS[]\naddfile             = \"\"             #  2  GIC updates to Base Case file name (output).\npurgfile            = \"\"             #  3  RDCH file to remove GIC updates from GIC updated case in working memory to set it back to Base Case network condition (output).\nrnwkfile            = \"\"             #  4  GIC dc resistive network raw file. This represents the dc network used to calculate GIC flow (output).\npygicfile           = \"nooutput\"     #  5  GIC Results map data file for given Efield magnitude and degrees OR Efield magnitude and degrees scans which give maximum Var losses when scans are performed (output).  This is used by GICMAPS to plot GIC results on network map.\ngictfile            = \"nooutput\"     #  6  Transformer Thermal Analysis GIC(t) CSV file (output).\n                                     # REPTOPTNS[]\nrptoptn             = -1             #  1  what to report\nrptbrn_indv         = 1              #  2  report induced branch voltages\nrptdc_busv          = 1              #  3  report DC bus voltages\nrptbrn_gic          = 1              #  4  report branch GIC flows\nrpttrn_gic          = 1              #  5  report transformer GIC flows\nrptstn_gic          = 1              #  6  report substation GIC flows\nrpttrn_q            = 1              #  7  report transformer losses\nrpt_sid             = 0              #  8  Subsystem sid for report\n\"\"\"\n\nimport sys, os, time, collections\n\n#"
  },
  {
    "id": 178,
    "text": "def finish_timer(start_time):\n    '''timstr = finish_timer(start_time)\n    Finish timer and return elapsed time as string.\n    where start_time is value returned by start_timer().\n    '''\n    finish_time = time.time()\n    elapsed_sec = finish_time - start_time\n    hr,mn1 = divmod(elapsed_sec,3600)\n    mn,sc  = divmod(mn1,60)\n    timstr = \" Elapsed time: Hours=%d , Minutes=%d, Seconds=%g\\n\" % (hr, mn, sc)\n    return timstr\n\n#"
  },
  {
    "id": 180,
    "text": "def get_output_dir(outpath=''):\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.path.dirname(__file__)\n        outdir = os.path.join(outdir, 'gic_demo_output')\n        if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 182,
    "text": "def run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds):\n\n    import psspy\n\n    _i = psspy.getdefaultint()\n    _f = psspy.getdefaultreal()\n\n    name,major,minor,modlvl,date,stat = psspy.psseversion()\n    vrsn = \"v{}{}{}\".format(major,minor,modlvl)\n\n    if 'efield_type' not in kwds: kwds['efield_type'] = \"benchmark\"\n\n    # add suffix to prg/rpt names (to make them unique, so they are not overwritten.)\n    optn_nam_dict = collections.OrderedDict([\n        ('efield_deg'      , 'deg' ),\n        ('scan_storm_event', ''    ),\n        ('power_flow_optn' , ''    ),\n        ('boundary_trn'    , 'btrn'),\n        ('worstcase_trn'   , 'wtrn'),\n        ('supp_evt'        , 'optnbx' ),\n        ('brn_seg_efld'    , 'brnseg'),\n        ])\n\n    sid_supp, supp_evt, brn_seg = 0, 0, 0\n    if 'sid_supp' in kwds: sid_supp = kwds['sid_supp']\n    if 'supp_evt' in kwds: supp_evt = kwds['supp_evt']\n    if 'supp_box_num' in kwds: supp_box_num = kwds['supp_box_num']\n    if 'supp_box_lon_c' in kwds: supp_box_lon_c = kwds['supp_box_lon_c']\n    if 'supp_box_lat_c' in kwds: supp_box_lat_c = kwds['supp_box_lat_c']\n    if 'brn_seg_efld' in kwds:brn_seg = kwds['brn_seg_efld']\n\n    s_brnseg = ''\n    subdir = ''\n    outfsfx = kwds['efield_type'][0]\n    if (supp_evt==1 and sid_supp>0)             or \\\n       (supp_evt in [2,3,4] and supp_box_num>0) or \\\n       (supp_evt==5 and abs(supp_box_lon_c)>0 and abs(supp_box_lat_c)>0):\n        outfsfx += \"+s\"\n        s_brnseg = \"bseg{}\".format(brn_seg)\n        if supp_evt in [2,3] and supp_box_num>0:\n            subdir = \"supp_opbx{}_numbx{}_brnseg{}\".format(supp_evt, supp_box_num, brn_seg)\n\n    for k, s_nam in optn_nam_dict.items():\n        if k in kwds:\n            vin = kwds[k]\n            if vin:\n                if s_nam:\n                    if supp_evt==1:\n                        outfsfx += \"_sid\"\n                    else:\n                        outfsfx += \"_{}{}\".format(s_nam, vin)\n                else:\n                    outfsfx += \"_{}\".format(vin)\n\n    if s_brnseg:\n        outfsfx += \"_{}\".format(s_brnseg)\n\n    outdir = get_output_dir(outdir)\n    if subdir:\n        outdir = os.path.join(outdir, subdir)\n        if not os.path.exists(outdir): os.mkdir(outdir)\n\n    if prg2file:\n        nam = \"{}_{}_progress.txt\".format(outnam, outfsfx)\n        prgfile = os.path.join(outdir, nam)\n\n    if rpt2file:\n        nam = \"{}_{}_report.txt\".format(outnam, outfsfx)\n        rptfile = os.path.join(outdir, nam)\n\n    # Create output file names when they are not provided\n    for sfx in ['add', 'purg', 'rnwk', 'pygic', 'gict']:\n        k = \"{}file\".format(sfx)\n        if k not in kwds:\n            s0 = sfx\n            if sfx=='pygic': s0 = 'map'\n            fnam = \"{}_{}_{}\".format(outnam, outfsfx, s0)\n            kwds[k] = os.path.join(outdir, fnam)\n\n    # run activity gic_8\n    if prg2file: psspy.progress_output(2,prgfile,[0,0])\n    if rpt2file: psspy.report_output(2,rptfile,[0,0])\n\n    start_time = start_timer()\n    psspy.gic_8(sid, allbus, **kwds)\n    timstr = finish_timer(start_time)\n\n    if prg2file: psspy.progress_output(1,\"\",[0,0])\n    if rpt2file: psspy.report_output(1,\"\",[0,0])\n\n    print(timstr)\n\n    if rpt2file:\n        print(\"  --------- Report saved to: {} \".format(rptfile))\n\n#"
  },
  {
    "id": 183,
    "text": "def run_test_sample(**optns):\n    import psspy\n    psspy.psseinit()\n\n    gicfilevrsn = optns.get('gicfilevrsn', 4)\n\n    if gicfilevrsn>4:\n        savfnam = r'sample_nb.sav'      # SAV file with Node Breaker Modeling\n        gicfnam = r'sample_fv5.gic'     # GIC file version 5\n    else:\n        savfnam = r'sample.sav'         # SAV file with NO Node Breaker Modeling\n        gicfnam = r'sample_fv4.gic'     # GIC file version 4\n\n    examdir = get_example_folder()\n\n    savfile = os.path.join(examdir, savfnam)\n    gicfile = os.path.join(examdir, gicfnam)\n\n    sid      = 0\n    allbus   = 1\n\n    outnam, jnk = os.path.splitext(savfnam)\n\n    outdir   = get_output_dir()\n    prg2file = True\n    rpt2file = True\n\n    study_year = 2019\n    earth_model_name = 'SHIELD'\n\n    kwds = {}\n    kwds['study_year'] = study_year\n    kwds['earth_model_name'] = earth_model_name\n    kwds['addfile']  = ''\n    kwds['purgfile'] = ''\n\n    for k, v in optns.items():\n        if k=='gicfilevrsn': continue\n        kwds[k] = v\n\n    if 'thermal_ana_optn' not in kwds:\n        kwds['thermal_ana_optn'] = -1\n\n    psspy.case(savfile)\n    psspy.gic_read(gicfile)\n\n    if 'sid_supp' in kwds:\n        kwds['sid_supp'] = 4\n        areas = [5]\n        ierr = psspy.bsys(kwds['sid_supp'], numarea=len(areas), areas=areas)\n\n    run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds)\n\n#"
  },
  {
    "id": 184,
    "text": "def run_gicmaps(pygicfile):\n    import arrbox.gicmaps\n\n    outdir   = get_output_dir()\n    fpth, nx = os.path.split(pygicfile)\n    outnam, fxtn = os.path.splitext(nx)\n    if not fpth: pygicfile = os.path.join(outdir, pygicfile)\n\n    outdir_maps = os.path.join(outdir, 'maps')\n    if not os.path.exists(outdir_maps): os.mkdir(outdir_maps)\n\n    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)\n\n    if gicmapsobj.ierr: return\n\n    gicmapsobj.enable_draw_supp_box()\n\n    pngfile = get_output_filename(\"{}_ssflow.png\".format(outnam), outdir_maps)\n\n    sublst = list(gicmapsobj.pygicobj.substation.keys())\n    gicmapsobj.annotate_substations(sublst, color='blue', fontsize=10)\n\n    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(pngfile, markersize=20)\n\n    oufile_seg = get_output_filename(\"{}_brnsegments.txt\".format(outnam), outdir_maps)\n    gicmapsobj.report_supp_box_line_segments(rptfile=oufile_seg)\n\n    oufile_evt = get_output_filename(\"{}_element_events.txt\".format(outnam), outdir_maps)\n    gicmapsobj.report_network_element_events(rptfile=oufile_evt)\n\n    gicmapsobj.plots_show()\n\n#"
  },
  {
    "id": 185,
    "text": "def _template_sample():\n    # 1) Benchmark event\n    #    No storm scan, No supplemental event, No power flow solution\n    run_test_sample(efield_type='benchmark', gicfilevrsn=5)\n\n    # 2) Supplemental event\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='supplemental', gicfilevrsn=5)\n\n    # 3) Benchmark + Supplemental event\n    #    Supplemental event defined by subsystem\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4, gicfilevrsn=5)\n\n    # 4) Benchmark + Supplemental event\n    #    Supplemental event defined by Moving Box,\n    #    Rank substations with maximum GIC flows as center of the moving box\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2, gicfilevrsn=5)\n\n    # 5) Benchmark + Supplemental event\n    #    Supplemental event defined by Moving Box,\n    #    Rank transformers with maximum GIC flows as center of the moving box\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2, gicfilevrsn=5)\n\n    # 6) Benchmark + Supplemental event\n    #    Supplemental event defined by Moving Box,\n    #    Use substation number provided as center of the moving box\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10, gicfilevrsn=5)\n\n    # 7) Benchmark + Supplemental event\n    #    Supplemental event defined by Moving Box,\n    #    Use location provided as center of the moving box\n    #    No storm scan, No power flow solution\n    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0, gicfilevrsn=5)\n\n    # 8) Benchmark + Supplemental event\n    #    Supplemental event defined by Moving Box,\n    #    Rank substations with maximum GIC flows as center of the moving box\n\n    #    Degree Scan with specified settings [step=1 deg, add Qloss in steps of 100%]\n    #    FDNS - run PowerFlow for each scan step\n    #       Number of degree scans = 1+ 180/degscan_step = 181\n    #       Number PF due % Qstep = 100/pf_qpct_step = 5\n    #       Number PF due to moving boxes = supp_box_num = 20\n    #    Number of GIC calculations = 181 (for ranking) + 181*20 (one each supp box) = 3801\n    #    Number of PF solved = 181*20*5 = 18100\n##    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,\n##                    scan_storm_event=\"scan_deg\", power_flow_optn='fdns',\n##                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20,\n##                    gicfilevrsn=5)\n\n    print(\" all done - _template_sample\")\n\n#"
  },
  {
    "id": 186,
    "text": "def _run_one_test_api():\n    # Just run one of these calls as desired.\n\n    run_test_sample(efield_type='benchmark')\n    run_test_sample(efield_type='benchmark', gicfilevrsn=5)\n    run_test_sample(efield_type='benchmark', gicfilevrsn=4)\n    run_test_sample(efield_type='supplemental')\n    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4)\n    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2)\n    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2)\n    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10)\n    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0)\n    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,\n                    scan_storm_event=\"scan_deg\", power_flow_optn='fdns',\n                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20)\n\n    # Creat a function similar to \"run_test_sample(..)\"\n    # - to use any power flow study cases\n    # - define common arguments\n    # - output directory etc\n    # Then use that function to run the GIC study of interest.\n\n#"
  },
  {
    "id": 187,
    "text": "def _run_one_test_maps():\n    # Just run one of these calls as desired.\n    # The 'pygic' files created by tests in \"_run_one_test_api\" serve as input\n    # for these tests.\n\n    run_gicmaps(r\"sample_b+s_sid_bseg0_map(deg)-oldVrsn.pygic\")\n    run_gicmaps(r\"sample_b_map(deg).pygic\")\n    run_gicmaps(r\"sample_s_map(deg).pygic\")\n    run_gicmaps(r\"sample_b+s_sid_bseg0_map(deg).pygic\")\n    run_gicmaps(r\"sample_b+s_optnbx4_bseg0_map(deg).pygic\")\n    run_gicmaps(r\"sample_b+s_optnbx5_bseg0_map(deg).pygic\")\n    run_gicmaps(r\".\\gic_demo_output\\supp_opbx2_numbx2_brnseg0\\sample_b+s_optnbx2_bseg0_map(deg)_supp_box1.pygic\")\n    run_gicmaps(r\".\\gic_demo_output\\supp_opbx2_numbx2_brnseg0\\sample_b+s_optnbx2_bseg0_map(deg)_supp_box2.pygic\")\n    run_gicmaps(r\".\\gic_demo_output\\supp_opbx3_numbx2_brnseg0\\sample_b+s_optnbx3_bseg0_map(deg)_supp_box1.pygic\")\n    run_gicmaps(r\".\\gic_demo_output\\supp_opbx3_numbx2_brnseg0\\sample_b+s_optnbx3_bseg0_map(deg)_supp_box2.pygic\")\n\n#"
  },
  {
    "id": 189,
    "text": "'''This is an example file showing how to:\n- Create GIC data file templates in Excel spreadsheets and create GIC data file from those\n  Excel spredsheets\n- Perform GIC analysis, post process GIC results, create customized GIC analysis reports\n- Perform GIC analysis, post process GIC results, export GIC analysis results to Excel\n- Map GIC results on network maps\n\nPython module \"gicdata\" is used for creating GIC data files.\n    See help(gicdata) for details.\n\nResult retrival Python module \"pssarrays\" is converted to Python package \"arrbox\".\nThis is done to provide object access instead of function access.\n\nUsing Python package \"arrbox\" it is possible to create multiple objects and compare\nPSSE results.\n\nNow Python module 'pssarrays' provide aliases to modules in package \"arrbox\".\n\nGIC related objects 'GIC' and 'GICMAPS' in module 'pssarrays' will work as is (that is\nwithout any code changes in your script). However, better way to access them is from\npackage arrbox as shown in this script.\n\nSee detailed help on GIC related objects in arrbox as:\nimport arrbox.gic;help(arrbox.gic.GIC)\nimport arrbox.gicmaps;help(arrbox.gicmaps.GICMAPS)"
  },
  {
    "id": 190,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psse35\n\n- call funtion\n    Run various functions from this file as desired. See notes in _run_one_test(..) (end of this file).\n\nSee function gic_results_on_network_map_custom(..) to know how you can decorate default plots with\ndata point annotations or any other custom settings."
  },
  {
    "id": 191,
    "text": "How to use PSSE and Python modules like numpy, matplotlib, Basemap together?\n(a) In your python script, call following function before any of these modules are imported.\n    psspy.set_fpcw_py()\n(b) Call following function before exiting your python script.\n    psspy.set_fpcw_psse()\nTo get details why this is needed, get help(..) on either of these functions.\nRefer function gic_results_on_network_map(..) in this script for usage of these functions.\n'''\n\n#"
  },
  {
    "id": 194,
    "text": "def get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n\n    outdir = os.path.join(outdir, 'gic_report_output')\n    if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 196,
    "text": "def _get_outfnam_event(pfx, efield_type, efield_mag, efield_deg, scan_storm_event):\n\n    if efield_type=='nonuniform':\n        outfnam = r\"{}_{}\".format(pfx, efield_type[0])\n    else:\n        if scan_storm_event:\n            outfnam = r\"{}_{}_{:g}(mag)_{:g}(deg)_{}\".format(pfx, efield_type[0], efield_mag, efield_deg, scan_storm_event)\n        else:\n            outfnam = r\"{}_{}_{:g}(mag)_{:g}(deg)\".format(pfx, efield_type[0], efield_mag, efield_deg)\n\n    return outfnam\n\n#"
  },
  {
    "id": 199,
    "text": "def create_gicdata_template_sample(datapath=None, outpath=None, areas=[], showexcel=True):\n    \"\"\" Create GIC data Excel template using sample.sav file from PSSE Example folder.\n\"\"\"\n    import psspy, gicdata\n\n    f_sfx = _get_filenam_sfx(areas)\n\n    savfile   = 'sample.sav'\n    excelfile = 'gicdata_sample_template_{}'.format(f_sfx)\n\n    if not datapath: datapath = get_example_folder()\n\n    savfile = os.path.join(datapath, savfile)\n    excelfile = get_output_filename(outpath, excelfile)\n\n    basekv    = []\n    areas     = areas\n    buses     = []\n    owners    = []\n    zones     = []\n    tielevels = 0\n\n    psspy.psseinit()\n\n    excelfile = gicdata.template_excel(savfile, excelfile, basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\n                           tielevels=tielevels, showexcel=showexcel)\n    return excelfile\n\n#"
  },
  {
    "id": 200,
    "text": "def transfer_gicdata_sample(datapath=None, outpath=None, areas=[], showexcel=True):\n    \"\"\" Transfer GIC data from .gic file into blank GIC data Excel template.\n\"\"\"\n    import psspy, gicdata\n\n    f_sfx = _get_filenam_sfx(areas)\n\n    gicfile_in   = 'sample_fv4.gic'\n    tmplfile_in  = 'gicdata_sample_template_{}.xlsx'.format(f_sfx)\n    excelfile_ou = 'gicdata_sample_{}.xlsx'.format(f_sfx)\n\n    if not datapath: datapath = get_example_folder()\n\n    gicfile_in   = os.path.join(datapath, gicfile_in)\n    tmplfile_in  = get_output_filename(outpath, tmplfile_in)\n    excelfile_ou = get_output_filename(outpath, excelfile_ou)\n\n    showexcel = showexcel\n    dbgout    = False\n    prgfile   = None\n    xlsfile = gicdata.transfer_data(gicfile_in, tmplfile_in, excelfile_ou,\n                    showexcel=showexcel, prgfile=prgfile, dbgout=dbgout)\n\n    return xlsfile\n\n#"
  },
  {
    "id": 201,
    "text": "def gicdata_excel2gicfile(outpath=None, areas=[]):\n    \"\"\" Create GIC data text file (.gic) from GIC data Excel file.\n\"\"\"\n    import gicdata\n\n    f_sfx = _get_filenam_sfx(areas)\n    excelfile = 'gicdata_sample_{}.xlsx'.format(f_sfx)\n    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)\n\n    excelfile = get_output_filename(outpath, excelfile)\n    gicfile = get_output_filename(outpath, gicfile)\n\n    gicdata.excel2gicfile(excelfile, gicfile)\n\n    return gicfile\n\n#"
  },
  {
    "id": 202,
    "text": "def gicdata_gicfile2excel(outpath=None, areas=[], showexcel=True):\n    \"\"\" Create GIC data Excel file from GIC data text file (.gic).\n\"\"\"\n    import gicdata\n\n    f_sfx = _get_filenam_sfx(areas)\n\n    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)\n    excelfile = 'gicdata_sample_{}(txt2xl).xlsx'.format(f_sfx)\n\n    gicfile = get_output_filename(outpath, gicfile)\n    excelfile = get_output_filename(outpath, excelfile)\n\n    gicdata.gicfile2excel(gicfile, excelfile, showexcel=showexcel)\n\n    return gicfile\n\n#"
  },
  {
    "id": 203,
    "text": "def gicdata_merge(outpath=None, showexcel=True):\n    \"\"\" Merge GIC data Excel files into one GIC data Excel file.\n\"\"\"\n    import gicdata\n\n    flist = ['gicdata_sample_123.xlsx', 'gicdata_sample_456.xlsx']\n    xl_list = []\n    for fnam in flist:\n        fou = get_output_filename(outpath, fnam)\n        xl_list.append(fou)\n\n    outxlnam   = \"merged_sample.xlsx\"\n    prgfnam    = \"merged_sample_progress.txt\"\n\n    outexcel = get_output_filename(outpath, outxlnam)\n    prgfile  = get_output_filename(outpath, prgfnam)\n    dbgout   = False\n\n    #Allowed kwds: outexcel='', showexcel=False, prgfile=None, dbgout=False\n    xlsfile = gicdata.merge_data_excel(*xl_list, outexcel=outexcel, showexcel=showexcel,\n                                       prgfile=prgfile, dbgout=dbgout)\n\n    return xlsfile\n\n#"
  },
  {
    "id": 204,
    "text": "def run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):\n    \"\"\" Use IEEE GIC Test Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.\nReturns results in gicboj.\n\"\"\"\n    import psspy\n    import arrbox.gic\n\n    savfile = 'ieee_gic_test_case.sav'\n    gicfile = 'ieee_gic_test_case.gic'\n\n    if not datapath: datapath = get_example_folder()\n\n    savfile = os.path.join(datapath, savfile)\n    gicfile = os.path.join(datapath, gicfile)\n\n    outdir = get_output_dir(outpath)\n\n    if efield_type=='benchmark':\n        efield_mag = 8.0\n    else:\n        efield_mag = 1.0\n\n    efield_deg = 0.0\n\n    outfnam   = _get_outfnam_event(\"ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    prgfile   = os.path.join(outdir, outfnam+'progress.txt')\n    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')\n    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')\n\n    ejet_million_amps = 1.0\n    ejet_halfwidth_km = 200.0\n    ejet_period_min   = 5.0\n    ejet_height_km    = 100.0\n    ejet_center_deg   = 54.0\n\n    earth_model_name = 'shield'\n\n    efield_unit      = 'V/km'\n    substation_r     = 0.1\n    branch_xbyr      = 30.0\n    transformer_xbyr = 30.0\n    addfile          = ''\n    addfile_optn     = 'rdch'\n    purgfile         = ''\n    rnwkfile         = ''\n\n    basekv    = []  # specify subsystem options\n    areas     = []\n    buses     = []\n    owners    = []\n    zones     = []\n    tielevels = 0\n\n    power_flow_optn  = ''   # specify power flow solution options\n    pf_itmxn   = 100\n    pf_toln    = 0.1\n    pf_tap     = 0\n    pf_area    = 0\n    pf_phshft  = 0\n    pf_dctap   = 1\n    pf_swsh    = 1\n    pf_flat    = 0\n    pf_varlmt  = 99\n    pf_nondiv  = 0\n\n    psspy.psseinit()\n\n    psspy.lines_per_page_one_device(1,10000000)\n    psspy.progress_output(2,prgfile,[0,0])\n    psspy.alert_output(2,prgfile,[0,0])\n\n    psspy.case(savfile)\n    psspy.gic_read(gicfile)\n    sid = 0\n    busall = 1\n\n    # run gic analysis\n    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,\n        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,\n        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,\n        efield_mag_local=0.0, efield_deg_local=0.0,\n        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,\n        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,\n        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,\n        power_flow_optn=power_flow_optn,\n        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,\n        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,\n        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,\n        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\n        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],\n        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,\n        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,\n        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,\n        pf_nondiv=pf_nondiv,\n        )\n\n    psspy.lines_per_page_one_device(2,10000000)\n    psspy.progress_output(1,\"\",[0,0])\n    psspy.alert_output(1,\"\",[0,0])\n\n    return gicobj\n\n#"
  },
  {
    "id": 205,
    "text": "def run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):\n    \"\"\" Use sample Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.\nReturns results in gicboj.\n\"\"\"\n    import psspy\n    import arrbox.gic\n\n    savfile = 'sample.sav'\n    gicfile = 'sample_fv4.gic'\n\n    outdir = get_output_dir(outpath)\n\n    if not datapath: datapath = get_example_folder()\n\n    savfile = os.path.join(datapath, savfile)\n    gicfile = os.path.join(datapath, gicfile)\n\n    if efield_type=='benchmark':\n        efield_mag = 8.0\n    else:\n        efield_mag = 1.0\n\n    efield_deg = 0.0\n\n    outfnam   = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    prgfile   = os.path.join(outdir, outfnam+'progress.txt')\n    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')\n    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')\n\n    ejet_million_amps = 1.0\n    ejet_halfwidth_km = 200.0\n    ejet_period_min   = 5.0\n    ejet_height_km    = 100.0\n    ejet_center_deg   = 54.0\n\n    earth_model_name = 'shield'\n\n    efield_unit      = 'V/km'\n    substation_r     = 0.1\n    branch_xbyr      = 30.0\n    transformer_xbyr = 30.0\n    addfile          = ''\n    addfile_optn     = 'rdch'\n    purgfile         = ''\n    rnwkfile         = ''\n\n    basekv    = []  # specify subsystem options\n    areas     = []\n    buses     = []\n    owners    = []\n    zones     = []\n    tielevels = 0\n\n    pf_itmxn   = 100    # specify power flow solution options\n    pf_toln    = 0.1\n    pf_tap     = 0\n    pf_area    = 0\n    pf_phshft  = 0\n    pf_dctap   = 1\n    pf_swsh    = 1\n    pf_flat    = 0\n    pf_varlmt  = 99\n    pf_nondiv  = 0\n\n    psspy.psseinit()\n\n    psspy.lines_per_page_one_device(1,10000000)\n    psspy.progress_output(2,prgfile,[0,0])\n\n    print(savfile)\n    print(gicfile)\n\n    psspy.case(savfile)\n    psspy.gic_read(gicfile)\n    sid = 0\n    busall = 1\n\n    # run gic analysis\n    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,\n        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,\n        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,\n        efield_mag_local=0.0, efield_deg_local=0.0,\n        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,\n        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,\n        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,\n        power_flow_optn=power_flow_optn,\n        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,\n        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,\n        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,\n        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\n        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],\n        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,\n        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,\n        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,\n        pf_nondiv=pf_nondiv,\n        )\n\n    psspy.lines_per_page_one_device(2,10000000)\n    psspy.progress_output(1,\"\",[0,0])\n\n    return gicobj\n\n#"
  },
  {
    "id": 206,
    "text": "def run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):\n    \"\"\" Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and create text report.\n\"\"\"\n\n    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\n\n    if gicobj.ierr: return\n\n    outdir = get_output_dir(outpath)\n    rptnam = _get_outfnam_event(\"ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\n\n    rptfile  = os.path.join(outdir, rptnam+'.txt')\n    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')\n\n    gicobj.text_report(rptfile)\n    gicobj.qtotal_report(qrptfile)\n\n    msg = \" Report created in file: {:s}\".format(rptfile)\n    print(msg)\n\n#"
  },
  {
    "id": 207,
    "text": "def run_gic_ieee_text_report_DIY(datapath=None, outpath=None):\n    \"\"\" Run GIC Analysis on IEEE GIC Test Case provided in PSSE Example folder and create customized report.\n\"\"\"\n    global _BIGREL\n\n    import psspy\n    _BIGREL = psspy.getdefaultreal()     # Largest real value\n\n    efield_mag = 1.0\n    efield_deg = 0.0\n    efield_type = 'uniform'\n    scan_storm_event = ''\n\n    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\n\n    if gicobj.ierr: return\n\n    outdir = get_output_dir(outpath)\n    rptnam = _get_outfnam_event(\"DIY_ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    rptfile = os.path.join(outdir, rptnam+'.txt')\n\n    rptfobj = open(rptfile, 'w')\n    report  = rptfobj.write\n\n    elecfld_mag = \"{:10.2f}\".format(gicobj.misc.efield_mag)\n    elecfld_mag = elecfld_mag.strip()\n\n    elecfld_unt = gicobj.misc.efield_unit\n\n    elecfld_deg = \"{:10.2f}\".format(gicobj.misc.efield_deg)\n    elecfld_deg = elecfld_deg.strip()\n\n    txt  = \"\\n GMD Event: Uniform Electric Field, {} {}, {} deg\\n\".format(elecfld_mag, elecfld_unt, elecfld_deg)\n\n    txt += \"\\n GIC data file: {}\\n\".format(gicobj.gicfile)\n    txt += \" Power flow data file: {}\\n\".format(gicobj.savfile)\n\n    if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:\n        txt += \"\\n Subsystem used for GIC studiies is defined as:\\n\"\n        if gicobj.basekv: txt += \"     Voltage = {}\\n\".format(str(gicobj.basekv))\n        if gicobj.areas:  txt += \"     Areas   = {}\\n\".format(str(gicobj.areas))\n        if gicobj.buses:  txt += \"     Buses   = {}\\n\".format(str(gicobj.buses))\n        if gicobj.owners: txt += \"     Owners  = {}\\n\".format(str(gicobj.owners))\n        if gicobj.zones:  txt += \"     Zones   = {}\\n\".format(str(gicobj.zones))\n        txt += \"     Subsystem Inter tie Levels = {}\\n\".format(gicobj.tielevels)\n    else:\n        txt += \"\\n Subsystem used for GIC studiies comprises entire network.\\n\"\n\n    txt += \"\\n Number of buses in study subsystem        = {}\\n\".format(gicobj.misc.nbus_study)\n    txt += \" Number of substations in study subsystem  = {}\\n\".format(gicobj.misc.nsubstation_study)\n    txt += \" Number of branches in study subsystem     = {}\\n\".format(gicobj.misc.nbranch_study)\n    txt += \" Number of transformers in study subsystem = {}\\n\".format(gicobj.misc.ntransformer_study)\n    report(txt)\n\n    txt  = '\\n Bus DC Voltages\\n'\n    txt += \"    Bus Substation DC Voltage(V)\\n\"\n    report(txt)\n\n    buslist = list(gicobj.bus.keys())\n    buslist.sort()\n    for eachbus in buslist:\n        # all of these work, shows how to use them\n        #print \"attr lower-->\", eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts\n        #print \"dict lower-->\", eachbus, gicobj.bus[eachbus]['substation'], gicobj.bus[eachbus]['dcvolts']\n        #print \"attr mixed-->\", eachbus, gicobj.bus[eachbus].suBSTation, gicobj.bus[eachbus].dcVolts\n        #print \"dict mixed-->\", eachbus, gicobj.bus[eachbus]['subStation'], gicobj.bus[eachbus]['DCvolts']\n        txt = \" {:6d}     {:6d}  {:12.5f}\\n\".format(eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts)\n        report(txt)\n\n    txt  = '\\n Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground\\n'\n    txt += \" Substation Name         Latitude(deg) Longitude(deg) DC Voltage(V)    GIC(Amps)\\n\"\n    report(txt)\n\n    sslist = list(gicobj.substation.keys())\n    sslist.sort()\n    for ss in sslist:\n        txt = \"     {:6d} {:12s}  {:12.6f}   {:12.6f}  {:12.5f} {:12.5f}\\n\".format(ss, gicobj.substation[ss].name,\n                            gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,\n                            gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic)\n        report(txt)\n\n    # Non-Transformer Branches\n    txt  = '\\n GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus\\n'\n    txt += \" FromBus  ToBus Ckt  Distance(km) per-Phase(A)   3-Phase(A)\\n\"\n    report(txt)\n\n    brnlist = list(gicobj.branch.keys())\n    brnlist.sort()\n    for brn in brnlist:\n        txt = \"  {:6d} {:6d}  {:2s}  {:12.5f} {:12.5f} {:12.5f}\\n\".format(brn[0], brn[1], brn[2],\n                            gicobj.branch[brn].distance, gicobj.branch[brn].gic,\n                            3*gicobj.branch[brn].gic)\n        report(txt)\n\n    # Transformers\n    trnlist = list(gicobj.transformer.keys())\n    trnlist.sort()\n\n    no_2wdg_nrml = \"\\n     No two winding transformers in GIC studied network.\\n\"\n    no_2wdg_auto = \"\\n     No two winding auto transformers in GIC studied network.\\n\"\n    no_3wdg_nrml = \"\\n     No three winding transformers in GIC studied network.\\n\"\n    no_3wdg_auto = \"\\n     No three winding auto transformers in GIC studied network.\\n\"\n\n    # Two Winding Transformers - normal\n    txt  = '\\n Two Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\n    txt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\n    txt += \"   Ibus   Jbus Ckt       Igic(A)      Jgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\n    report(txt)\n\n    for trn in trnlist:\n        kbus  = trn[2]\n        if kbus: continue\n\n        autoi = gicobj.transformer[trn].wdg1_auto\n        autoj = gicobj.transformer[trn].wdg2_auto\n        if (autoi or autoj): continue\n\n        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\n        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\n        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\n        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\n\n        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\n\n        txt = \" {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(trn[0], trn[1], trn[3], igic, jgic, effgic,\n                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)\n        report(txt)\n        if no_2wdg_nrml: no_2wdg_nrml=''\n\n    if no_2wdg_nrml: report(no_2wdg_nrml)\n\n    # Two Winding Transformers - auto\n    txt  = '\\n Two Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\n    txt += \" Reactive power loss, represented as constant current load on Series Winding bus in power flow\\n\"\n    txt += \" Common Series Ckt Common gic(A) Series gic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\n    report(txt)\n    for trn in trnlist:\n        kbus  = trn[2]\n        if kbus: continue\n\n        autoi = gicobj.transformer[trn].wdg1_auto\n        autoj = gicobj.transformer[trn].wdg2_auto\n        if ( (not autoi) or (not autoj) ): continue\n        if autoi==1:\n            ibus = trn[0]\n            jbus = trn[1]\n        else:\n            ibus = trn[1]\n            jbus = trn[0]\n\n        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\n        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\n        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\n        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\n\n        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\n\n        txt = \" {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(ibus, jbus, trn[3], igic, jgic, effgic,\n                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)\n        report(txt)\n        if no_2wdg_auto: no_2wdg_auto=''\n\n    if no_2wdg_auto: report(no_2wdg_auto)\n\n    # Three Winding Transformers - normal\n    txt  = '\\n Three Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\n    txt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\n    txt += \"   Ibus   Jbus   Kbus Ckt       Igic(A)      Jgic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\n    report(txt)\n\n    for trn in trnlist:\n        kbus  = trn[2]\n        if not kbus: continue\n\n        autoi = gicobj.transformer[trn].wdg1_auto\n        autoj = gicobj.transformer[trn].wdg2_auto\n        autok = gicobj.transformer[trn].wdg3_auto\n        if (autoi or autoj or autok): continue\n\n        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\n        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\n        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)\n        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\n        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\n\n        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\n\n        txt = \" {:6d} {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(trn[0], trn[1], trn[2], trn[3], igic, jgic, kgic, effgic,\n                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)\n        report(txt)\n        if no_3wdg_nrml: no_3wdg_nrml=''\n\n    if no_3wdg_nrml: report(no_3wdg_nrml)\n\n    # Three Winding Transformers - auto\n    txt  = '\\n Three Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\n    txt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\n    txt += \" Common Series   Kbus Ckt Common gic(A) Series gic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\n    report(txt)\n    for trn in trnlist:\n        kbus  = trn[2]\n        if not kbus: continue\n\n        autoi = gicobj.transformer[trn].wdg1_auto\n        autoj = gicobj.transformer[trn].wdg2_auto\n        if ( (not autoi) or (not autoj) ): continue\n        if autoi==1:\n            ibus = trn[0]\n            jbus = trn[1]\n        else:\n            ibus = trn[1]\n            jbus = trn[0]\n\n        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\n        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\n        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)\n        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\n        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\n\n        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\n\n        txt = \" {:6d} {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic,\n                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)\n        report(txt)\n        if no_3wdg_auto: no_3wdg_auto=''\n\n    if no_3wdg_auto: report(no_3wdg_auto)\n\n    # Total Qloss\n    if no_2wdg_nrml:\n        qwdg2_nrml = '        None'\n    else:\n        qwdg2_nrml = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg2_normal)\n    if no_2wdg_auto:\n        qwdg2_auto = '        None'\n    else:\n        qwdg2_auto = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg2_auto)\n    if no_3wdg_nrml:\n        qwdg3_nrml = '        None'\n    else:\n        qwdg3_nrml = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg3_normal)\n    if no_3wdg_auto:\n        qwdg3_auto = '        None'\n    else:\n        qwdg3_auto = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg3_auto)\n    txt  = '\\n Transformer Reactive Power Loss Summary\\n'\n    txt += ' Two Winding Transformers        = {:s}\\n'.format(qwdg2_nrml)\n    txt += ' Two Winding Auto Transformers   = {:s}\\n'.format(qwdg2_auto)\n    txt += ' Three Winding Transformers      = {:s}\\n'.format(qwdg3_nrml)\n    txt += ' Three Winding Auto Transformers = {:s}\\n'.format(qwdg3_auto)\n    txt += '                           Total = {:12.5f} Mvar\\n'.format(gicobj.qtotal.total)\n    report(txt)\n\n    # done - close report file\n    if rptfile:\n        rptfobj.close()\n        txt = \"\\n GIC analysis output report saved to file: {:s}\\n\".format(rptfile)\n        sys.stdout.write(txt)\n\n#"
  },
  {
    "id": 208,
    "text": "def run_gic_ieee_excel_export_DIY(datapath=None, outpath=None, show=True):\n    \"\"\" Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.\n\"\"\"\n    import psspy\n    import excelpy\n\n    _BIGREL = psspy.getdefaultreal()     # Largest real value\n\n    efield_mag = 1.0\n    efield_deg = 0.0\n    efield_type = 'uniform'\n    scan_storm_event = ''\n\n    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\n\n    if gicobj.ierr: return\n\n    outdir = get_output_dir(outpath)\n    rptnam = _get_outfnam_event(\"DIY_ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    xlsfile = os.path.join(outdir, rptnam)\n\n    # What to export?\n    overwritesheet = True\n    do_sheets = ['optn', 'bus', 'sub', 'brn', 'trn']\n\n    _EXPORT_QTY_GIC   = {\n    'optn': 'options'     ,\n    'bus' : 'bus'         ,\n    'sub' : 'substation'  ,\n    'brn' : 'branch'      ,\n    'trn' : 'transformer' ,\n    }\n\n    _WORKSHT_SEQ_GIC = ['optn','bus','sub','brn','trn']\n\n    _WORKSHT_COLUMN_LABELS_GIC = {\n        'bus': ['Bus', 'Substation', 'DC Voltage(V)'],\n        'sub': ['Substation', 'Name', 'Latitude(deg)', 'Longitude(deg)', 'DC Voltage(V)', 'GIC(Amps)'],\n        'brn': ['FromBus', 'ToBus', 'Ckt', 'Distance(km)', 'per-Phase(A)', '3-Phase(A)'],\n        'trn_nrml': ['Ibus', 'Jbus', 'Kbus', 'Ckt', 'Igic(A)', 'Jgic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],\n        'trn_auto': ['Common', 'Series', 'Kbus', 'Ckt', 'Common gic(A)', 'Series gic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],\n        }\n\n    _WORKSHT_INFO_TXT_GIC = {\n        'bus': ['Bus DC Voltages'],\n        'sub': ['Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground'],\n        'brn': ['GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus'],\n        'trn_nrml': ['Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',\n                     'Reactive power loss, represented as constant current load on highest voltage bus in power flow'],\n        'trn_auto': ['Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',\n                     'Reactive power loss, represented as constant current load on Series Winding bus in power flow'],\n        }\n\n    gicshts = []\n    for each in _WORKSHT_SEQ_GIC:\n        if each in do_sheets:\n            if each=='trn':\n                gicshts.extend( [ _EXPORT_QTY_GIC[each], 'auto '+_EXPORT_QTY_GIC[each] ] )\n            else:\n                gicshts.append(_EXPORT_QTY_GIC[each])\n\n    for i, shtnam in enumerate(gicshts):\n        if i==0:\n            xlsobj = excelpy.workbook(xlsfile, shtnam, overwritesheet=overwritesheet)\n            if show:\n                xlsobj.show()\n            else:\n                xlsobj.hide()\n\n            xlsobj.show_alerts(0) # do not show pop-up alerts\n            xlsfnam = xlsobj.XLSFNAM\n        else:\n            xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)\n        xlsobj.page_format(orientation=\"landscape\",left=1.0,right=1.0,\n                           top=0.5,bottom=0.5,header=0.25,footer=0.25)\n        xlsobj.page_footer(left='page number of page total', right='date, time')\n        xlsobj.page_header(center='file name:sheet name')\n        xlsobj.font_sheet()\n\n    if not xlsobj:\n        print(\"Excel file and worksheets not created.\\n\")\n\n    # Options\n    do_key = 'optn'\n    if do_key in do_sheets:\n\n        elecfld_mag = \"{:10.2f}\".format(gicobj.misc.efield_mag)\n        elecfld_mag = elecfld_mag.strip()\n\n        elecfld_unt = gicobj.misc.efield_unit\n\n        elecfld_deg = \"{:10.2f}\".format(gicobj.misc.efield_deg)\n        elecfld_deg = elecfld_deg.strip()\n\n        txt  = \"\\n GMD Event: Uniform Electric Field, {:s} {:s}, {:s} deg\\n\".format(elecfld_mag, elecfld_unt, elecfld_deg)\n\n        txt += \"\\n GIC data file: {:s}\\n\".format(gicobj.gicfile)\n        txt += \" Power flow data file: {:s}\\n\".format(gicobj.savfile)\n\n        if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:\n            txt += \"\\n Subsystem used for GIC studies is defined as:\\n\"\n            if gicobj.basekv: txt += \"     Voltage = {:s}\\n\".format(str(gicobj.basekv))\n            if gicobj.areas:  txt += \"     Areas   = {:s}\\n\".format(str(gicobj.areas))\n            if gicobj.buses:  txt += \"     Buses   = {:s}\\n\".format(str(gicobj.buses))\n            if gicobj.owners: txt += \"     Owners  = {:s}\\n\".format(str(gicobj.owners))\n            if gicobj.zones:  txt += \"     Zones   = {:s}\\n\".format(str(gicobj.zones))\n            txt += \"     Subsystem Inter tie Levels = {:d}\\n\".format(gicobj.tielevels)\n        else:\n            txt += \"\\n Subsystem used for GIC studies comprises entire network.\\n\"\n\n        txt += \"\\n Number of buses in study subsystem        = {:d}\\n\".format(gicobj.misc.nbus_study)\n        txt += \" Number of substations in study subsystem  = {:d}\\n\".format(gicobj.misc.nsubstation_study)\n        txt += \" Number of branches in study subsystem     = {:d}\\n\".format(gicobj.misc.nbranch_study)\n        txt += \" Number of transformers in study subsystem = {:d}\\n\".format(gicobj.misc.ntransformer_study)\n\n        optnlist = txt.split(\"\\n\")\n\n        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\n        br, rc = 1, 1\n        br, rc = xlsobj.set_range(br, rc, optnlist, transpose=True)\n\n    # DC Bus voltages\n    do_key = 'bus'\n    if do_key in do_sheets:\n        buslist = list(gicobj.bus.keys())\n        buslist.sort()\n        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\n        for eachbus in buslist:\n            tlst = [eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts]\n            rowdata.append(tlst)\n\n        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\n        br0, rc0 = 3, 1\n        br, rc = xlsobj.set_range(br0, rc0, rowdata)\n        del rowdata\n        xlsobj.autofit_columns((br0,rc0,br0,rc))\n        xlsobj.font_color((br0,rc0,br0,rc),\"red\")\n        xlsobj.align_rows((br0, rc0),alignv='right')    #label row\n        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n\n    # Substation\n    do_key = 'sub'\n    if do_key in do_sheets:\n        sslist = list(gicobj.substation.keys())\n        sslist.sort()\n        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\n        for ss in sslist:\n            tlst = [ss, gicobj.substation[ss].name, gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,\n                    gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic]\n            rowdata.append(tlst)\n\n        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\n        br0, rc0 = 3, 1\n        br, rc = xlsobj.set_range(br0, rc0, rowdata)\n        del rowdata\n        xlsobj.autofit_columns((br0,rc0,br0,rc))\n        xlsobj.font_color((br0,rc0,br0,rc),\"red\")\n        xlsobj.align_rows((br0, rc0),alignv='right')    #label row\n        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n\n    # Non-Transformer Branches\n    do_key = 'brn'\n    if do_key in do_sheets:\n        brnlist = list(gicobj.branch.keys())\n        brnlist.sort()\n        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\n        for brn in brnlist:\n            tlst = [brn[0], brn[1], brn[2], gicobj.branch[brn].distance, gicobj.branch[brn].gic,3*gicobj.branch[brn].gic]\n            rowdata.append(tlst)\n\n        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\n        br0, rc0 = 3, 1\n        br, rc = xlsobj.set_range(br0, rc0, rowdata)\n        del rowdata\n        xlsobj.autofit_columns((br0,rc0,br0,rc))\n        xlsobj.font_color((br0,rc0,br0,rc),\"red\")\n        xlsobj.align_rows((br0, rc0),alignv='right')    #label row\n        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n\n    # Transformers\n    do_key = 'trn'\n    if do_key in do_sheets:\n        do_key_nrml = 'trn_nrml'\n        do_key_auto = 'trn_auto'\n\n        trnlist = list(gicobj.transformer.keys())\n        trnlist.sort()\n\n        rowdata_nrml = [_WORKSHT_COLUMN_LABELS_GIC[do_key_nrml]]\n        rowdata_auto = [_WORKSHT_COLUMN_LABELS_GIC[do_key_auto]]\n\n        for trn in trnlist:\n            kbus  = trn[2]\n            igic  = gicobj.transformer[trn].wdg1_gic\n            jgic  = gicobj.transformer[trn].wdg2_gic\n            if kbus:\n                kgic = gicobj.transformer[trn].wdg3_gic\n            else:\n                kgic = None\n\n            effgic  = gicobj.transformer[trn].eff_gic\n            qloss   = gicobj.transformer[trn].qloss\n            kftr    = gicobj.transformer[trn].kfactor\n            kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\n\n            autoi = gicobj.transformer[trn].wdg1_auto\n            autoj = gicobj.transformer[trn].wdg2_auto\n            if autoi or autoj:\n                if autoi==1:\n                    ibus = trn[0]\n                    jbus = trn[1]\n                else:\n                    ibus = trn[1]\n                    jbus = trn[0]\n            else:\n                ibus = trn[0]\n                jbus = trn[1]\n\n            if igic:\n                if igic>=_BIGREL: igic = ''\n            else:\n                igic = ''\n\n            if jgic:\n                if jgic>=_BIGREL: jgic = ''\n            else:\n                jgic = ''\n\n            if kgic:\n                if kgic>=_BIGREL: kgic = ''\n            else:\n                kgic = ''\n\n            if effgic:\n                if effgic>=_BIGREL: effgic = ''\n            else:\n                effgic = ''\n\n            if qloss:\n                if qloss>=_BIGREL: qloss = ''\n            else:\n                qloss = ''\n\n            tlst = [ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic, kftr, kftrtyp, qloss]\n            if autoi or autoj:\n                rowdata_auto.append(tlst)\n            else:\n                rowdata_nrml.append(tlst)\n\n        # Total Qloss\n        txt  = ' Transformer Reactive Power Loss Summary\\n'\n        txt += ' Two Winding Transformers        = {:g} Mvar\\n' .format(gicobj.qtotal.wdg2_normal)\n        txt += ' Two Winding Auto Transformers   = {:g} Mvar\\n' .format(gicobj.qtotal.wdg2_auto)\n        txt += ' Three Winding Transformers      = {:g} Mvar\\n' .format(gicobj.qtotal.wdg3_normal)\n        txt += ' Three Winding Auto Transformers = {:g} Mvar\\n' .format(gicobj.qtotal.wdg3_auto)\n        txt += '                           Total = {:g} Mvar'   .format(gicobj.qtotal.total)\n        qlosslist = txt.split(\"\\n\")\n\n        # normal transformers\n        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\n        br0, rc0 = 4, 1\n        br, rc = xlsobj.set_range(br0, rc0, rowdata_nrml)\n        del rowdata_nrml\n        xlsobj.autofit_columns((br0,rc0,br0,rc))\n        xlsobj.font_color((br0,rc0,br0,rc),\"red\")\n        xlsobj.align_rows((br0, rc0),alignv='right')    #label row\n        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][1],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n\n        br, rc = br+2, 1\n        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)\n\n        # auto transformers\n        xlsobj.set_active_sheet('auto '+_EXPORT_QTY_GIC[do_key])\n        br0, rc0 = 4, 1\n        br, rc = xlsobj.set_range(br0, rc0, rowdata_auto)\n        del rowdata_auto\n        xlsobj.autofit_columns((br0,rc0,br0,rc))\n        xlsobj.font_color((br0,rc0,br0,rc),\"red\")\n        xlsobj.align_rows((br0, rc0),alignv='right')    #label row\n        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][1],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n\n        br, rc = br+2, 1\n        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)\n\n    # done exporting\n    xlsobj.save(xlsfile)\n\n    if not show:\n        txt = \"\\n GIC analysis output report saved to file: \\n    {0}\\n\".format(xlsobj.XLSFNAM)\n        xlsobj.close()\n        sys.stdout.write(txt)\n\n#"
  },
  {
    "id": 209,
    "text": "def run_gic_sample_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):\n    \"\"\" Use sample Case provided in PSSE Example folder, run GIC calculations and create text report.\n\"\"\"\n\n    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)\n\n    if gicobj.ierr: return\n\n    outdir = get_output_dir(outpath)\n    rptnam = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    if power_flow_optn:  rptnam += '_pf'\n\n    rptfile  = os.path.join(outdir, rptnam+'.txt')\n    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')\n\n    gicobj.text_report(rptfile)\n    gicobj.qtotal_report(qrptfile)\n\n    msg = \"\\n Report created in file: {:s}\".format(rptfile)\n    print(msg)\n\n#"
  },
  {
    "id": 210,
    "text": "def run_gic_sample_excel_export(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, show=True,\n                                datapath=None, outpath=None):\n    \"\"\" Use sample Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.\n\"\"\"\n    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)\n\n    if gicobj.ierr: return\n\n    outdir = get_output_dir(outpath)\n    rptnam = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\n    if power_flow_optn:  rptnam += '_pf'\n\n    xlfile = os.path.join(outdir, rptnam)\n    string = ''\n    overwritesheet = True\n    xlfile = gicobj.excel_export(string, xlfile, show, overwritesheet)\n\n    msg = \"\\n Spreadsheet created in file:\\n    {0}\".format(xlfile)\n    print(msg)\n\n#"
  },
  {
    "id": 211,
    "text": "def gic_results_on_network_map(pygicfile, outpath=None, outfext='.pdf', show=True):\n    \"\"\" Plot GIC results on map.\n\"\"\"\n    import collections\n    import psspy\n\n    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\n    import arrbox.gicmaps\n\n    outdir = get_output_dir(outpath)\n\n    p, nx = os.path.split(pygicfile)\n    pyfnam, x = os.path.splitext(nx)\n\n    if not p:\n        if not os.path.exists(pygicfile):\n            pygicfile = os.path.join(outdir, pygicfile)\n\n    pltfiles = collections.OrderedDict()\n    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',\n              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:\n        if outfext=='.pdf':\n            pltfiles[k] = None\n        else:\n            fnam = \"{}_{}{}\".format(pyfnam, k, outfext)\n            pltfiles[k] = os.path.join(outdir, fnam)\n\n    gicmapsobj  = arrbox.gicmaps.GICMAPS(pygicfile)\n\n    if gicmapsobj.ierr: return\n\n    if outfext=='.pdf':\n        fnam = \"{}_allplots{}\".format(pyfnam, outfext)\n        pdffile = os.path.join(outdir, fnam)\n        gicmapsobj.pdf_open(pdffile)\n\n    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_base'], case='base', limit='min', markersize=100)\n\n    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_gic'], case='gic', limit='min', markersize=100)\n\n    # combine substations GICs flowing in and out on one legend\n    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic1'], markersize=20)\n\n    # separate substations GICs flowing in and out on two legends\n    gicmapsobj.set_legend_options_ss_gic_values(loc=None)\n    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic2'], markersize=20)\n\n    gicmapsobj.plot_branch_gicflows(figfile=pltfiles['brngic'])\n\n    gicmapsobj.plot_qtotal(figfile=pltfiles['qtline'])\n\n    gicmapsobj.plot_qtotal_barchart(figfile=pltfiles['qtbar'])\n\n    gicmapsobj.plot_effgic(figfile=pltfiles['effgic'], gicmax=False)\n\n    gicmapsobj.plot_effgic(figfile=pltfiles['effgicmax'], gicmax=True)\n\n    if show:\n        gicmapsobj.plots_show()\n    else:\n        gicmapsobj.plots_close()\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf_close()\n\n    if outfext=='.pdf':\n        msg  = \"\\n GIC analysis custom plots saved in file:\\n    {}\\n\".format(pdffile)\n    else:\n        msg  = \"\\n GIC analysis custom plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\n\n    print(msg)\n    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n\n#"
  },
  {
    "id": 212,
    "text": "def gic_results_on_network_map_custom(pygicfile, outpath=None, outfext='.pdf', show=True):\n    \"\"\" Plot GIC results on map with custom legends, annotations.\n\"\"\"\n    import collections\n    import psspy\n\n    psspy.set_fpcw_py()\n    import arrbox.gicmaps\n\n    outdir = get_output_dir(outpath)\n\n    p, nx = os.path.split(pygicfile)\n    pyfnam, x = os.path.splitext(nx)\n\n    if not p:\n        if not os.path.exists(pygicfile):\n            pygicfile = os.path.join(outdir, pygicfile)\n\n    outnam  = '{}_custom'.format(pyfnam)\n\n    pltfiles = collections.OrderedDict()\n    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',\n              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:\n        if outfext!='.pdf':\n            fnam = \"{}_{}{}\".format(outnam, k, outfext)\n            pltfiles[k] = os.path.join(outdir, fnam)\n\n    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)\n\n    if gicmapsobj.ierr: return\n\n    if outfext=='.pdf':\n        fnam = \"{}_allplots{}\".format(outnam, outfext)\n        pdffile = os.path.join(outdir, fnam)\n        pdf2fobj = gicmapsobj.pdf2_open(pdffile)  # open pdf2 object to save custom plots to pdf file\n\n    gicmapsobj.set_figure_size(6,4.8)\n\n    gicmapsobj.set_state_boundary_options(show=True, color='#CCCCCC', linewidth=1.0)\n    gicmapsobj.set_latitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 1], fontsize=10)\n    gicmapsobj.set_longitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 3], fontsize=10)\n\n    gicmapsobj.annotate_substations([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], color='blue', fontsize=10)\n\n    # Plot1 - GIC case bus voltage\n    pf_flag = gicmapsobj.pygicobj.power_flow_solution_flag\n    if pf_flag==0:\n        case = 'gic'\n        if outfext!='.pdf': figfile = pltfiles['busvpu_gic']\n        ttl = 'Bus Voltages - GIC Case'\n    else:\n        case = 'base'\n        if outfext!='.pdf': figfile = pltfiles['busvpu_base']\n        ttl = 'Bus Voltages - Base Case'\n    ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None, case=case, limit='min', markersize=100,\n                                 title=ttl)\n    if ax is None:\n        if outfext=='.pdf':\n            gicmapsobj.pdf_close()\n        return\n\n    # data point annotation\n    anptobj.set_options(xytext=(-15,-40), textcoords='offset points')\n    anptobj.set_annote_from_key(5)                          # use SS number as key\n    #anptobj.set_annote_from_key('ss05_mississippi')        # use SS name as key\n    anptobj.set_options(xytext=(-40,-100), textcoords='offset points')\n    anptobj.set_annote_from_key(7)                          # use SS number as key\n    #anptobj.set_annote_from_key('ss07_yukon')\n    anptobj.set_options(xytext=(-20,25), textcoords='offset points')\n    anptobj.set_annote_from_key(13)                         # use SS number as key\n    #anptobj.set_annote_from_key('ss13_oxus')               # use SS number as key\n    anptobj.set_options(xytext=(-40,25), textcoords='offset points')\n    #anptobj.set_annote_from_key(15)                        # use SS number as key\n    anptobj.set_annote_from_key('ss15_heilong')             # use SS number as key\n\n    # custom annotation\n    gicmapsobj.annotate_text('LabelLeft', -89, 30.2, ax, basemap, xycoords='long_lat', color='cyan', fontsize=15)\n    x, y = gicmapsobj.datapoint_xy_from_longitude_latiude(basemap, -84, 30.2)\n    gicmapsobj.annotate_text('LabelRight', x, y, ax, basemap, xycoords='data', color='magenta', fontsize=15)\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)               # add custom plot to pdf file\n    else:\n        fig.savefig(figfile, dpi=300, bbox_inches='tight')   # save custom plot to file\n\n    # Plot2 - Base case bus voltage\n    if pf_flag==0:\n        ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None,  case='base', limit='min', markersize=100,\n                                     title='Bus Voltages - Base Case')\n        anptobj.set_options(xytext=(-50,-50), textcoords='offset points')\n        anptobj.set_annote_from_key(15)\n\n        if outfext=='.pdf':\n            gicmapsobj.pdf2_add_figure(pdf2fobj, fig)\n        else:\n            fig.savefig(pltfiles['busvpu_base'], dpi=300, bbox_inches='tight')\n\n    # Plot3 - substations GICs (combine GICs flowing in and out on one legend)\n    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)\n\n    anptobj.set_options(xytext=(-65,40), textcoords='offset points')\n    anptobj.set_annote_from_key('ss01_nile')\n    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')\n    anptobj.set_annote_from_key('ss02_yangtze')\n    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')\n    anptobj.set_annote_from_key('ss03_arkansas')\n    anptobj.set_options(xytext=(-20,-35), textcoords='offset points')\n    anptobj.set_annote_from_key('ss09_indus')\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)\n    else:\n        fig.savefig(pltfiles['ssgic1'], dpi=300, bbox_inches='tight')\n\n    # Plot4 - substations GICs (separate GICs flowing in and out on two legends)\n    gicmapsobj.set_legend_options_ss_gic_values(loc=None)\n    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)\n    anptobj.set_options(xytext=(-50,-50), textcoords='offset points')\n    anptobj.set_annote_from_key(1)\n    anptobj.set_annote_from_key(3)\n    anptobj.set_annote_from_key(8)\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)\n    else:\n        fig.savefig(pltfiles['ssgic2'], dpi=300, bbox_inches='tight')\n\n    # Plot5 - Effective GIC\n    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=False)\n    anptobj.set_options(xytext=(-30,-30), textcoords='offset points')\n    anptobj.set_annote_from_key('catdog_xmer')          # use transformer name as key\n    anptobj.set_annote_from_key((3018, 3008, '11'))     # use transformer id tuple: (wdg1bus, wdg2bus, 'ckt')\n                                                        # or (wdg1bus, wdg2bus, wdg3bus, 'ckt')\n    anptobj.set_options(xytext=(-65,30), textcoords='offset points')\n    anptobj.set_annote_from_key((203, 202, 't7'))\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)\n    else:\n        fig.savefig(pltfiles['effgic'], dpi=300, bbox_inches='tight')\n\n    # Plot6 - Maximum Effective GIC\n    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=True)\n    anptobj.set_options(xytext=(-30,-40), textcoords='offset points')\n    anptobj.set_annote_from_key('catdog_xmer')\n    anptobj.set_options(xytext=(-30,-60), textcoords='offset points')\n    anptobj.set_annote_from_key(('urb tx'))\n    anptobj.set_options(xytext=(-10,20), textcoords='offset points')\n    anptobj.set_annote_from_key(('mid ltc'))\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)\n    else:\n        fig.savefig(pltfiles['effgicmax'], dpi=300, bbox_inches='tight')\n\n    if show:\n        gicmapsobj.plots_show()\n    else:\n        gicmapsobj.plots_close()\n\n    if outfext=='.pdf':\n        gicmapsobj.pdf2_close(pdf2fobj)\n\n    if outfext=='.pdf':\n        msg  = \"\\n GIC analysis custom plots saved in file:\\n    {}\\n\".format(pdffile)\n    else:\n        msg  = \"\\n GIC analysis custom plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\n\n    print(msg)\n    psspy.set_fpcw_psse()\n\n#"
  },
  {
    "id": 213,
    "text": "def gict_result_plots(gictfile, outpath=None, top_trn=10, nrows=2, ncols=2, outfext='.pdf', show=True):\n    \"\"\" Plot GIC Thermal results.\ntop_trn - plot so many transformers with maximum GICs\nnrows   - numbers of rows in plot figure\nncols   - numbers of columns in plot figure\nnrows X ncols subplots are drawn on one figure.\n\"\"\"\n    import collections\n    import psspy\n\n    psspy.set_fpcw_py()\n    import arrbox.gicthermal\n\n    outdir = get_output_dir(outpath)\n\n    p, nx = os.path.split(gictfile)\n    pyfnam, x = os.path.splitext(nx)\n\n    if not p:\n        if not os.path.exists(gictfile):\n            gictfile = os.path.join(outdir, gictfile)\n\n    outnam  = '{}'.format(pyfnam)\n\n    pltfiles = collections.OrderedDict()\n    for k in ['evt','trn']:\n        if outfext=='.pdf':\n            pltfiles[k] = None\n        else:\n            fnam = \"{}_{}{}\".format(outnam, k, outfext)\n            pltfiles[k] = os.path.join(outdir, fnam)\n\n    thermalobj = arrbox.gicthermal.GICTHERMAL(gictfile)\n\n    if thermalobj.ierr: return\n\n    if outfext=='.pdf':\n        fnam = \"{}_allplots{}\".format(outnam, outfext)\n        pdffile = os.path.join(outdir, fnam)\n        thermalobj.pdf_open(pdffile)\n\n    evtnamlst, figdict, axdict = thermalobj.plot_events(figfile=pltfiles['evt'], show=show)\n\n    figlst, axdict = thermalobj.plot_transformer_gict(figfile=pltfiles['trn'], top=top_trn, nrows=nrows, ncols=ncols, show=show)\n\n    if show:\n        thermalobj.plots_show()\n    else:\n        thermalobj.plots_close()\n\n    if outfext=='.pdf':\n        thermalobj.pdf_close()\n\n    if outfext=='.pdf':\n        msg  = \"\\n GIC Transformer Thermal GICT(t) profile plots saved in file:\\n    {}\\n\".format(pdffile)\n    else:\n        msg  = \"\\n GIC Transformer Thermal GICT(t) profile plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\n\n    print(msg)\n    psspy.set_fpcw_psse()\n\n#"
  },
  {
    "id": 214,
    "text": "def run_all_tests(datapath=None, outpath=None, efields='ubn', scan='d', pf='fdns', outfext='.pdf'):\n\n    outdir = get_output_dir(outpath)\n\n    efield_type_lst = []\n    scan_lst = []\n    pf_lst = []\n\n    if efields:\n        s_efld = efields.lower()\n        if 'u' in s_efld: efield_type_lst.append('uniform')\n        if 'b' in s_efld: efield_type_lst.append('benchmark')\n        if 'n' in s_efld: efield_type_lst.append('nonuniform')\n\n    if scan:\n        s_scan = scan.lower()\n        if 'd' in s_scan: scan_lst.append('scan_deg')\n        if 'm' in s_scan: scan_lst.append('scan_mag')\n        if 'd_m' in s_scan: scan_lst.append('scan_d_m')\n\n    if pf:\n        pf_lst.append(pf)\n\n    if not efield_type_lst: efield_type_lst = ['uniform']\n    if not scan_lst: scan_lst = ['']\n    if not pf_lst: pf_lst = ['']\n\n    #"
  },
  {
    "id": 215,
    "text": "print (\"\\n >>>>>>>>>>>>> Running create_gicdata_template_sample\")\n    excelfile = create_gicdata_template_sample(datapath, outpath, showexcel=False)\n\n    print (\"\\n >>>>>>>>>>>>> Running excel2gicfile\")\n    gicdata_excel2gicfile(outpath)\n\n    efield_mag = 1.0\n    efield_deg = 0.0\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_text_report\")\n    for efield_type in efield_type_lst:\n        for scan_storm_event in scan_lst:\n            run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event,datapath, outpath)\n            break\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_sample_text_report\")\n    for efield_type in efield_type_lst:\n        for scan_storm_event in scan_lst:\n            for power_flow_optn in pf_lst:\n                run_gic_sample_text_report(efield_mag, efield_deg, efield_type,\n                                           scan_storm_event, power_flow_optn, datapath, outpath)\n                break\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_text_report_DIY\")\n    run_gic_ieee_text_report_DIY(datapath, outpath)\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_excel_export_DIY\")\n    run_gic_ieee_excel_export_DIY(datapath, outpath, show=False)\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, no scan, no powerflow\")\n    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='',\n                                power_flow_optn='',     show=False, datapath=datapath, outpath=outpath)\n\n    print (\"\\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, scan_deg, fdns\")\n    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='scan_deg',\n                                power_flow_optn='fdns', show=False, datapath=datapath, outpath=outpath)\n\n    pygicfile = ''\n    for fnam in os.listdir(outdir):\n        n, x = os.path.splitext(fnam)\n        if x=='.pygic':\n            i = n.find('sample')\n            if i>=0:\n                pygicfile = os.path.join(outdir, fnam)\n                break\n\n    print (\"\\n >>>>>>>>>>>>> Running gic_results_on_network_map\")\n    if pygicfile:\n        gic_results_on_network_map(pygicfile, outpath, outfext=outfext, show=False)\n    else:\n        print (\"    mapdata file does not exist.\\n    {}\\n\".format(pygicfile))\n\n    print (\"\\n >>>>>>>>>>>>> Running gic_results_on_network_map_custom\")\n    if pygicfile:\n        gic_results_on_network_map_custom(pygicfile, outpath, outfext=outfext, show=False)\n    else:\n        print (\"    mapdata file does not exist.\\n    {}\\n\".format(pygicfile))\n\n    gictfile = ''\n    for fnam in os.listdir(outdir):\n        n, x = os.path.splitext(fnam)\n        if x=='.csv':\n            i = n.find('sample')\n            if i>=0:\n                gictfile = os.path.join(outdir, fnam)\n                break\n\n    print (\"\\n >>>>>>>>>>>>> Running gicthermal\")\n    if gictfile:\n        gict_result_plots(gictfile, outpath, outfext=outfext, show=False)\n    else:\n        print (\"    GIC results gict CSV file does not exist.\\n\")\n\n#"
  },
  {
    "id": 216,
    "text": "def run_gicdata_templates(outpath=None):\n    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[], showexcel=True)\n    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[1,2,3], showexcel=False)\n    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[4,5,6], showexcel=False)\n\n#"
  },
  {
    "id": 217,
    "text": "def run_gicdata_transfer(outpath=None):\n    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[], showexcel=False)\n    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[1,2,3], showexcel=False)\n    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[4,5,6], showexcel=False)\n\n#"
  },
  {
    "id": 219,
    "text": "def run_gicdata_gicfile2excel(outpath=None):\n    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[], showexcel=False)\n    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[1,2,3], showexcel=False)\n    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[4,5,6], showexcel=False)\n\n#"
  },
  {
    "id": 222,
    "text": "def _run_one_test():\n\n    # Run these one by one in __main__ (just copy each line in __main__ and run).\n    #\n    # - Function create_gicdata_template_sample() must be run before running gicdata_excel2gicfile().\n    # - Functions run_gic_ieee_text_report(..) and run_gic_sample_text_report(..) return pygicfile name.\n    #   Use that as input to gic_results_on_network_map(..) and gic_results_on_network_map_custom(..).\n\n    # GIC data tests\n    run_gicdata_templates()\n    run_gicdata_transfer()\n    run_gicdata_excel2gicfile()\n    run_gicdata_gicfile2excel()\n    run_gicdata_merge()\n\n    # GIC calculation tests\n    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='')\n    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg')\n    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='')\n    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg')\n    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='')\n    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg')    # scan not allowed, so does not scan\n\n    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='',         power_flow_optn='')\n    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg', power_flow_optn='fdns')\n    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='',         power_flow_optn='')\n    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg', power_flow_optn='fdns')\n    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_mag', power_flow_optn='fdns')\n    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_d_m', power_flow_optn='fdns')\n    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='',         power_flow_optn='')\n    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg', power_flow_optn='fdns') # scan not allowed, so does not scan\n\n    run_gic_ieee_text_report_DIY()\n    run_gic_ieee_excel_export_DIY(show=True)\n\n    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',   scan_storm_event='',         power_flow_optn='',     show=True)\n    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_deg', power_flow_optn='fdns', show=True)\n    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_d_m', power_flow_optn='fdns', show=True)\n\n    pygicfile = r\"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic\"\n    gic_results_on_network_map(pygicfile, show=False)\n\n    pygicfile = r\"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic\"\n    gic_results_on_network_map_custom(pygicfile, show=False)\n\n    #"
  },
  {
    "id": 226,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\n    import psseXX\n\n- call function\n    Run various functions from this file as desired.\n    Refer test1(..) ... functions towards end of this file.\n'''\n\n\"\"\"\nUse any of these keywords to run har_analysis_2.\nKeyword     Default     Description\n                      # INTGAR[]\nfscanoptn   = 1       # 1 frequency scan option: 0 no; =1 yes\ndstnoptn    = 1       # 2 distortion calculations option: 0 no; =1 yes\n\nlinmdl      = 0       # 3 line model option:  =0 nominal pi; =1 long line with skin effect;\n                      #                       =2 long line but no skin effect\ndstnbuop    = 0       # 4 bus option in dstn: =0 all buses; =1 only study subsystem buses\ndstnrptop   = 0       # 5 bus option in dstn: =0 only THDs; =1 THDs + contributions\nimachimpop  = 0       # 6 induction machine impedance option =0 from power flow data; =1 from sequene data\ndcimpop     = 0       # 7 2TDC, VSCDC and MTDC equivalent impedance option in fscan =0 block; 1=consider\ntriplenop   = 0       # 8 Triplen Harmonics Option in distortion calculations =0 ignore; =1 consider\ngenimpop    = 0       # 9 generatir impedance option:  =0 Use ZSORCE impedance from power flow data\n                      #                                =1 Use subtransient impedance from sequence data\n                      #                                =2 Use transient impedance from sequence data\n                      #                                =3 Use synchronous impedance from sequence data\n                      #                                =4 Use negative sequence impedance from sequence data\nmdltypop    = 0       # 10 harmonics Model Type Option, allowed 0 or 1\nload_mdltyp = 0       # 11 load model type\ngen_mdltyp  = 0       # 12 gen model type\nbrnsh_mdltyp= 0       # 13 branch shunt model type\ntrn_mdltyp  = 0       # 14 trn model type\nfctsh_mdltyp= 0       # 15 facts shunt model type\nfctse_mdltyp= 0       # 16 facts series model type\nimach_mdltyp= 0       # 17 induction machine model type\n\n                      # REALAR[]\nhord_min    =  0.1    # 1 Minimum Harmonic Order\nhord_max    = 50.0    # 2 Maximum Harmonic Order\nhord_stp    =  0.1    # 3 Harmonic Order Step\n                      # FILEAR[]\nhrsfile     = ''      # 1 Binary Results File Name (.hrs)\ndstnfile    = ''      # 2 Distortion Calculation Report File Name (.txt)\nresnfile    = ''      # 3 Frequency Scan Resonance Report File Name (.txt)\n\"\"\"\n\nimport sys, os, math, traceback, textwrap\n\n_COLOR_PREFERENCE = ['orange', 'green', 'blue', 'red']\n_COLOR_PREFERENCE_BUS = ['red', 'blue']\n_ALLOWED_FIG_FILE_TYPES = ['eps', 'jpeg', 'jpg', 'pdf', 'pgf', 'png', 'ps', 'raw', 'rgba', 'svg', 'svgz', 'tif', 'tiff']\n\n#"
  },
  {
    "id": 227,
    "text": "# This data is from file CASE1TB.XLS of IEEE Task Force on Harmonics Modeling & Simulation\n# Frequency Scan Thevenin Impedance\n# Distributed Line Model: ZRdist, ZXdist, Zdist\n# Pi Line Model: Zpi\n\n#    HORD       , ZRdist        ,  ZXdist       , Zdist , Zpi\n_ieee_tf_scan_results = [\n    [1.00\t, 0.0534\t, 0.2197\t, 0.226\t, 0.226  ],\n    [1.33\t, 0.0793\t, 0.3239\t, 0.334\t, 0.334  ],\n    [1.67\t, 0.1371\t, 0.4711\t, 0.491\t, 0.492  ],\n    [2.00\t, 0.2075\t, 0.5667\t, 0.603\t, 0.606  ],\n    [2.33\t, 0.5381\t, 0.9926\t, 1.129\t, 1.136  ],\n    [2.67\t, 1.7230\t, 1.1320\t, 2.062\t, 2.081  ],\n    [3.00\t, 2.0150\t, -0.9333\t, 2.221\t, 2.217  ],\n    [3.33\t, 0.7628\t, -1.0731\t, 1.317\t, 1.312  ],\n    [3.67\t, 0.3951\t, -0.7590\t, 0.856\t, 0.855  ],\n    [4.00\t, 0.3626\t, -0.5387\t, 0.649\t, 0.652  ],\n    [4.33\t, 0.3141\t, -0.7507\t, 0.814\t, 0.806  ],\n    [4.67\t, 0.0891\t, -0.5594\t, 0.566\t, 0.564  ],\n    [5.00\t, 0.0570\t, -0.4405\t, 0.444\t, 0.443  ],\n    [5.33\t, 0.0460\t, -0.3673\t, 0.370\t, 0.370  ],\n    [5.67\t, 0.0430\t, -0.3170\t, 0.320\t, 0.320  ],\n    [6.00\t, 0.0378\t, -0.2885\t, 0.291\t, 0.291  ],\n    [6.33\t, 0.0219\t, -0.2551\t, 0.256\t, 0.256  ],\n    [6.67\t, 0.0166\t, -0.2223\t, 0.223\t, 0.224  ],\n    [7.00\t, 0.0144\t, -0.1957\t, 0.196\t, 0.197  ],\n    [7.33\t, 0.0131\t, -0.1732\t, 0.174\t, 0.175  ],\n    [7.67\t, 0.0122\t, -0.1537\t, 0.154\t, 0.155  ],\n    [8.00\t, 0.0116\t, -0.1364\t, 0.137\t, 0.138  ],\n    [8.33\t, 0.0112\t, -0.1211\t, 0.122\t, 0.123  ],\n    [8.67\t, 0.0105\t, -0.1076\t, 0.108\t, 0.109  ],\n    [9.00\t, 0.0091\t, -0.0949\t, 0.095\t, 0.096  ],\n    [9.33\t, 0.0077\t, -0.0823\t, 0.083\t, 0.084  ],\n    [9.67\t, 0.0072\t, -0.0702\t, 0.071\t, 0.071  ],\n    [10.00\t, 0.0071\t, -0.0593\t, 0.060\t, 0.060  ],\n    [10.33\t, 0.0067\t, -0.0498\t, 0.050\t, 0.050  ],\n    [10.67\t, 0.0051\t, -0.0409\t, 0.041\t, 0.041  ],\n    [11.00\t, 0.0029\t, -0.0311\t, 0.031\t, 0.031  ],\n    [11.33\t, 0.0014\t, -0.0207\t, 0.021\t, 0.021  ],\n    [11.67\t, 0.0008\t, -0.0105\t, 0.011\t, 0.010  ],\n    [12.00\t, 0.0007\t, -0.0009\t, 0.001\t, 0.001  ],\n    [12.33\t, 0.0007\t, 0.0081\t, 0.008\t, 0.008  ],\n    [12.67\t, 0.0008\t, 0.0168\t, 0.017\t, 0.017  ],\n    [13.00\t, 0.0008\t, 0.0251\t, 0.025\t, 0.025  ],\n    [13.33\t, 0.0009\t, 0.0331\t, 0.033\t, 0.033  ],\n    [13.67\t, 0.0010\t, 0.0410\t, 0.041\t, 0.041  ],\n    [14.00\t, 0.0010\t, 0.0487\t, 0.049\t, 0.049  ],\n    [14.33\t, 0.0010\t, 0.0562\t, 0.056\t, 0.057  ],\n    [14.67\t, 0.0010\t, 0.0636\t, 0.064\t, 0.065  ],\n    [15.00\t, 0.0010\t, 0.0709\t, 0.071\t, 0.072  ],\n    [15.33\t, 0.0010\t, 0.0782\t, 0.078\t, 0.080  ],\n    [15.67\t, 0.0009\t, 0.0855\t, 0.085\t, 0.087  ],\n    [16.00\t, 0.0009\t, 0.0927\t, 0.093\t, 0.095  ],\n    [16.33\t, 0.0009\t, 0.0998\t, 0.100\t, 0.102  ],\n    [16.67\t, 0.0009\t, 0.1070\t, 0.107\t, 0.110  ],\n    [17.00\t, 0.0010\t, 0.1141\t, 0.114\t, 0.117  ],\n    [17.33\t, 0.0010\t, 0.1213\t, 0.121\t, 0.124  ],\n    [17.66\t, 0.0010\t, 0.1285\t, 0.129\t, 0.132  ],\n    [18.00\t, 0.0010\t, 0.1357\t, 0.136\t, 0.139  ],\n    [18.33\t, 0.0011\t, 0.1430\t, 0.143\t, 0.147  ],\n    [18.66\t, 0.0011\t, 0.1504\t, 0.150\t, 0.154  ],\n    [19.00\t, 0.0012\t, 0.1579\t, 0.158\t, 0.162  ],\n    [19.33\t, 0.0012\t, 0.1654\t, 0.165\t, 0.170  ],\n    [19.66\t, 0.0013\t, 0.1732\t, 0.173\t, 0.178  ],\n    [20.00\t, 0.0014\t, 0.1811\t, 0.181\t, 0.186  ],\n    [20.33\t, 0.0015\t, 0.1892\t, 0.189\t, 0.194  ],\n    [20.66\t, 0.0016\t, 0.1975\t, 0.198\t, 0.203  ],\n    [21.00\t, 0.0018\t, 0.2062\t, 0.206\t, 0.211  ],\n    [21.33\t, 0.0019\t, 0.2153\t, 0.215\t, 0.218  ],\n    [21.66\t, 0.0022\t, 0.2247\t, 0.225\t, 0.224  ],\n    [22.00\t, 0.0025\t, 0.2348\t, 0.235\t, 0.229  ],\n    [22.33\t, 0.0029\t, 0.2456\t, 0.246\t, 0.236  ],\n    [22.66\t, 0.0034\t, 0.2573\t, 0.257\t, 0.245  ],\n    [23.00\t, 0.0041\t, 0.2703\t, 0.270\t, 0.254  ],\n    [23.33\t, 0.0052\t, 0.2850\t, 0.285\t, 0.263  ],\n    [23.66\t, 0.0068\t, 0.3023\t, 0.302\t, 0.273  ],\n    [24.00\t, 0.0094\t, 0.3239\t, 0.324\t, 0.282  ],\n    [24.33\t, 0.0142\t, 0.3530\t, 0.353\t, 0.292  ],\n    [24.66\t, 0.0258\t, 0.3988\t, 0.400\t, 0.302  ],\n    [25.00\t, 0.0767\t, 0.4914\t, 0.497\t, 0.313  ],\n    [25.33\t, 0.3804\t, 0.4516\t, 0.590\t, 0.324  ],\n    [25.66\t, 0.2886\t, 0.2076\t, 0.355\t, 0.336  ],\n    [26.00\t, 0.1861\t, 0.1507\t, 0.239\t, 0.350  ],\n    [26.33\t, 0.0983\t, 0.1640\t, 0.191\t, 0.366  ],\n    [26.66\t, 0.0543\t, 0.2017\t, 0.209\t, 0.391  ],\n    [27.00\t, 0.0341\t, 0.2359\t, 0.238\t, 0.384  ],\n    [27.33\t, 0.0239\t, 0.2646\t, 0.266\t, 0.348  ],\n    [27.66\t, 0.0184\t, 0.2898\t, 0.290\t, 0.374  ],\n    [28.00\t, 0.0152\t, 0.3130\t, 0.313\t, 0.392  ],\n    [28.33\t, 0.0133\t, 0.3355\t, 0.336\t, 0.407  ],\n    [28.66\t, 0.0122\t, 0.3581\t, 0.358\t, 0.422  ],\n    [29.00\t, 0.0117\t, 0.3815\t, 0.382\t, 0.437  ],\n    [29.33\t, 0.0118\t, 0.4067\t, 0.407\t, 0.451  ],\n    [29.66\t, 0.0123\t, 0.4343\t, 0.434\t, 0.466  ],\n    [30.00\t, 0.0133\t, 0.4655\t, 0.466\t, 0.481  ],\n    [30.33\t, 0.0151\t, 0.5019\t, 0.502\t, 0.497  ],\n    [30.66\t, 0.0179\t, 0.5456\t, 0.546\t, 0.513  ],\n    [31.00\t, 0.0225\t, 0.6004\t, 0.601\t, 0.530  ],\n    [31.33\t, 0.0301\t, 0.6723\t, 0.673\t, 0.547  ],\n    [31.66\t, 0.0439\t, 0.7735\t, 0.775\t, 0.565  ],\n    [32.00\t, 0.0731\t, 0.9304\t, 0.933\t, 0.583  ],\n    [32.33\t, 0.1517\t, 1.2148\t, 1.224\t, 0.603  ],\n    [32.66\t, 0.5070\t, 1.8932\t, 1.960\t, 0.623  ],\n    [33.00\t, 4.5494\t, 1.5400\t, 4.803\t, 0.645  ],\n    [33.33\t, 0.7725\t, -1.1678\t, 1.400\t, 0.667  ],\n    [33.66\t, 0.2861\t, -0.3206\t, 0.430\t, 0.691  ],\n    [34.00\t, 0.3196\t, 0.1241\t, 0.343\t, 0.716  ],\n    [34.33\t, 0.9273\t, 0.2502\t, 0.960\t, 0.743  ],\n    [34.66\t, 0.5444\t, -0.5749\t, 0.792\t, 0.771  ],\n    [35.00\t, 0.1669\t, -0.3331\t, 0.373\t, 0.801  ],\n    [35.33\t, 0.0812\t, -0.1640\t, 0.183\t, 0.834  ],\n    [35.66\t, 0.0508\t, -0.0578\t, 0.077\t, 0.870  ],\n    [36.00\t, 0.0367\t, 0.0179\t, 0.041\t, 0.909  ],\n    [36.33\t, 0.0293\t, 0.0777\t, 0.083\t, 0.952  ],\n    [36.66\t, 0.0255\t, 0.1291\t, 0.132\t, 1.001  ],\n    [37.00\t, 0.0242\t, 0.1773\t, 0.179\t, 1.058  ],\n    [37.33\t, 0.0257\t, 0.2270\t, 0.228\t, 1.125  ],\n    [37.66\t, 0.0320\t, 0.2852\t, 0.287\t, 1.201  ],\n    [38.00\t, 0.0506\t, 0.3663\t, 0.370\t, 1.266  ],\n    [38.33\t, 0.1213\t, 0.5124\t, 0.527\t, 1.224  ],\n    [38.66\t, 0.6464\t, 0.7361\t, 0.980\t, 1.079  ],\n    [39.00\t, 0.4533\t, -0.3164\t, 0.553\t, 1.047  ],\n    [39.33\t, 0.1071\t, -0.0794\t, 0.133\t, 1.102  ],\n    [39.66\t, 0.0490\t, 0.0401\t, 0.063\t, 1.178  ],\n    [40.00\t, 0.0302\t, 0.1057\t, 0.110\t, 1.260  ],\n    ]\n\n# Reference:\n# \"Test Systems for Harmonics Modeling and Simulation\",\n# IEEE Transactions on Power Delivery, Vol. 11, No. 1, January 1996, Pages 466-474\n#     Bus, Nominal kV,  LF Volts pu, LF Ang deg,  THD%\n_ieee_tf_dstn_pf_thd_results = [\n    [   1,      230.0,       1.0600,       0.00,  1.767 ],\n    [   2,      230.0,       1.0450,      -5.68,  2.177 ],\n    [   3,      230.0,       1.0427,     -15.30,  1.516 ],\n    [   4,      230.0,       1.0282,     -11.41,  0.755 ],\n    [   5,      230.0,       1.0337,      -9.82,  1.462 ],\n    [   6,      115.0,       1.0700,     -15.87,  0.468 ],\n    [   7,      230.0,       1.0193,     -14.47,  0.423 ],\n    [   8,       13.8,       1.0209,     -14.49,  0.522 ],\n    [   9,      115.0,       1.0147,     -16.09,  0.482 ],\n    [  10,      115.0,       1.0168,     -16.33,  0.421 ],\n    [  11,      115.0,       1.0394,     -16.21,  0.394 ],\n    [  12,      115.0,       1.0528,     -16.72,  0.391 ],\n    [  13,      115.0,       1.0458,     -16.73,  0.376 ],\n    [  14,      115.0,       1.0154,     -17.39,  0.343 ],\n    [ 301,       35.4,       1.0417,     -16.18,  9.169 ],\n    [ 302,       35.4,       1.0417,     -16.18,  9.169 ],\n    ]\n\n#   Hord,   %mag,    deg\n_ieee_tf_dstn_cursrc_hvdc = [\n    [  1, 100.00, -49.56 ],\n    [  5,  19.41, -67.77 ],\n    [  7,  13.09,  11.9  ],\n    [ 11,   7.58,  -7.13 ],\n    [ 13,   5.86,  68.57 ],\n    [ 17,   3.79,  46.53 ],\n    [ 19,   3.29, 116.46 ],\n    [ 23,   2.26,  87.47 ],\n    [ 25,   2.41, 159.32 ],\n    [ 29,   1.93, 126.79 ],\n    ]\n\n_ieee_tf_dstn_cursrc_tcr = [\n    [  1, 100.00,   46.92 ],\n    [  5,   7.02, -124.40 ],\n    [  7,   2.50,  -29.87 ],\n    [ 11,   1.36,  -23.75 ],\n    [ 13,   0.75,   71.50 ],\n    [ 17,   0.62,   77.12 ],\n    [ 19,   0.32,  173.43 ],\n    [ 23,   0.43,  178.02 ],\n    [ 25,   0.13,  -83.45 ],\n    [ 29,   0.40,  -80.45 ],\n    ]\n\n#"
  },
  {
    "id": 228,
    "text": "# IEEE 519-2022 and IEEE 519-2014\n#\n# Table 1 - Voltage Distortion Limits\n# All values should be in percent of the rated power frequency voltage at the PCC.\n# Applies to voltage harmonics whose frequencies are integer multiples of the power frequency.\n_ieee519_table1_thd_limits = {\n    1.0  : {'indv': 5.0, 'thd': 8.0},                   # V <= 1.0 kV\n    69.0 : {'indv': 3.0, 'thd': 5.0},                   # 1 kV < V <= 69.0 kV\n    161.0: {'indv': 1.5, 'thd': 2.5},                   # 69.0 kV < V <= 161.0 kV\n    999.0: {'indv': 1.0, 'thd': 1.5, 'thd_hvdc': 2.0},  # 161.0 kV < V\n    }\n\n_ieee519_vlimits = list(_ieee519_table1_thd_limits.keys())\n_ieee519_vlimits.sort()\n\n#"
  },
  {
    "id": 229,
    "text": "def get_ieee_tf_scan_results():\n    \"\"\"Get IEEE Harmonics Task Force Test Case Frequency Scan Results.\n    \"\"\"\n    hord_lst, zcal_lst, zdst_lst, zpi_lst = [], [], [], []\n    for eachlist in _ieee_tf_scan_results:\n        h, zr, zx, z1d, z1pi = eachlist\n        zrx = complex(zr, zx)\n        z = abs(zrx)\n        hord_lst.append(h)\n        zcal_lst.append(z)\n        zdst_lst.append(z1d)\n        zpi_lst.append(z1pi)\n\n    return hord_lst, zcal_lst, zdst_lst, zpi_lst\n\n#"
  },
  {
    "id": 230,
    "text": "def get_ieee_tf_dstn_pf_thd_results():\n    \"\"\"Get IEEE Harmonics Task Force Test Case Distortion Calculation Results.\n    \"\"\"\n    tf_keytup = ('bus', 'basekv', 'vmag', 'vang', 'thd')\n\n    tfresults_pf_thd_dict = {}\n    for row in _ieee_tf_dstn_pf_thd_results:\n        for dk, val in zip(tf_keytup, row):\n            if dk=='bus':\n                bus = val\n                tfresults_pf_thd_dict[bus] = {}\n            else:\n                tfresults_pf_thd_dict[bus][dk] = val\n\n    return tfresults_pf_thd_dict\n\n#"
  },
  {
    "id": 231,
    "text": "def get_ieee_tf_dstn_cursrc():\n    \"\"\"Get IEEE Harmonics Task Force Test Case Harmonic Current Source Spectrum.\n    \"\"\"\n\n    tfresults_cursrc_dict = {'hvdc':{}, 'tcr':{}}\n\n    for eachrow in _ieee_tf_dstn_cursrc_hvdc:\n        hord, imag, iang = eachrow\n        tfresults_cursrc_dict['hvdc'][hord] = {'imag':imag, 'iang':iang}\n\n    tfresults_cursrc_tcr_dict = {}\n    for eachrow in _ieee_tf_dstn_cursrc_tcr:\n        hord, imag, iang = eachrow\n        tfresults_cursrc_dict['tcr'][hord] = {'imag':imag, 'iang':iang}\n\n    return tfresults_cursrc_dict\n\n#"
  },
  {
    "id": 232,
    "text": "def get_resn_legends(peak_lst_h, peak_lst_rx, valley_lst_h=None, valley_lst_rx=None):\n    \"\"\"Get Frequency Scan Resonance legends.\n    \"\"\"\n    txtlst = []\n    txtlst.append(\"\")\n    txtlst.append(\"Parallel (peaks)\")\n    if peak_lst_rx:\n        txtlst.append(\"Hord, Z\")\n        for h, pu in zip(peak_lst_h, peak_lst_rx):\n            txt = \"{:g}, {:g}\".format(h, pu)\n            txtlst.append(txt)\n    else:\n        txt = \" None\"\n        txtlst.append(txt)\n\n    if valley_lst_h:\n        txtlst.append(\"\")\n        txtlst.append(\"Series (valleys)\")\n        if valley_lst_rx:\n            txtlst.append(\"H,  Z\")\n            for h, pu in zip(valley_lst_h, valley_lst_rx):\n                txt = \"{:4.2f}, {:5.3f}\".format(h, pu)\n                txtlst.append(txt)\n        else:\n            txt = \" None\"\n            txtlst.append(txt)\n\n    return txtlst\n\n#"
  },
  {
    "id": 233,
    "text": "def _write_verbose_report(txt, report):\n    if report is not None:\n        report(txt)\n\nclass _SimpleObject(object):\n    \"\"\"Used for creating dummy object and set attributes as needed.\n    \"\"\"\n    pass\n\ndef _set_rsn_object(**kwds):\n    rsnobj = _SimpleObject()\n    for k in ['x1', 'y1', 'x2', 'y2', 'inam', 'hidx', 'rflg']:\n        setattr(rsnobj, k, kwds[k])\n    return rsnobj\n\ndef _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=None, dltn=None):\n    ok1, ok2 = False, False\n\n    ok_pctc1 = pctc>=pctmx1\n    ok_pctc2 = pctc>=pctmx2\n\n    if dltp is not None:\n        ok_dltp1 = dltp>=dpctpn1\n        ok_dltp2 = dltp>=dpctpn2\n\n    if dltn is not None:\n        ok_dltn1 = dltn>=dpctpn1\n        ok_dltn2 = dltn>=dpctpn2\n\n    if dltp is None:\n        ok1 = ok_pctc1 and ok_dltn1\n        ok2 = ok_pctc2 and ok_dltn2\n    elif dltn is None:\n        ok1 = ok_pctc1 and ok_dltp1\n        ok2 = ok_pctc2 and ok_dltp2\n    else:\n        ok1 = ok_pctc1 and (ok_dltp1 or ok_dltn1)\n        ok2 = ok_pctc2 and (ok_dltp2 or ok_dltn2)\n\n    found = ok1 or ok2\n\n    return found\n\ndef _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report):\n\n    resn_pks_hord, resn_pks_zmag = [], []\n\n    txtlst = []\n    txtlst.append(\"\")\n    txtlst.append(\"Parallel (peaks)\")\n\n    if not resn_pkvls:\n        txt = \" None\"\n        txtlst.append(txt)\n\n        txt = \"\\n\".join(txtlst)\n        _write_verbose_report(txt, report)\n\n        return resn_pks_hord, resn_pks_zmag\n\n    #"
  },
  {
    "id": 234,
    "text": "nnlst = len(resn_pkvls)\n\n    txtlst.append(\"   X1,     Y1,     X2,     Y2,  %Ymax,  %dltY,  Found\")\n\n    for ii in range(nnlst):\n\n        pt_crnt = resn_pkvls[ii]\n        inam = pt_crnt.inam\n        if inam!='peak': continue\n\n        ipt_p = False\n        ipt_n = False\n\n        if ii==0:\n            if nnlst>1:\n                ipt_n = True\n                pt_next = resn_pkvls[ii+1]\n        elif ii==nnlst-1:\n            ipt_p = True\n            pt_prev = resn_pkvls[ii-1]\n        else:\n            ipt_p = True\n            ipt_n = True\n            pt_prev = resn_pkvls[ii-1]\n            pt_next = resn_pkvls[ii+1]\n\n        pctc = pt_crnt.y2*100/ymxpk                 # current value in percent of max\n\n        found = False\n        if ii==0:\n            if ipt_n:\n                dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2\n                found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltn=dltn)\n        elif ii==nnlst-1:\n            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2\n            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp)\n        else:\n            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2\n            dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2\n            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp, dltn=dltn)\n\n        if found:\n            resn_pkvls[ii].rflg = 1\n\n        if ipt_p:\n            txt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}\".format(pt_prev.x1, pt_prev.y1, pt_prev.x2, pt_prev.y2, '', dltp)\n            txtlst.append(txt)\n\n        txt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6.2f}, {:6s},  {}\".format(pt_crnt.x1, pt_crnt.y1, pt_crnt.x2, pt_crnt.y2, pctc, '', found)\n        txtlst.append(txt)\n\n        if ipt_n:\n            txt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}\".format(pt_next.x1, pt_next.y1, pt_next.x2, pt_next.y2, '', dltn)\n            txtlst.append(txt)\n\n        txtlst.append(\"\")\n\n    txt = \"\\n\".join(txtlst)\n    _write_verbose_report(txt, report)\n\n    # done filtering\n    for rsnobj in resn_pkvls:\n        inam = rsnobj.inam\n        rflg = rsnobj.rflg\n        if inam=='peak' and rflg==1:\n            resn_pks_hord.append(rsnobj.x2)\n            resn_pks_zmag.append(rsnobj.y2)\n\n    return resn_pks_hord, resn_pks_zmag\n\ndef check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=None):\n    \"\"\"Check and find Frequency Scan Resonances.\n    \"\"\"\n\n    resn_pkvls = []\n    nhord = len(hlst)\n    for hh in range(nhord):\n        hord = hlst[hh]\n        zmag = zlst[hh]\n        if hh==0:\n            x1, y1 = hord, zmag\n            xb, yb = hord, zmag    # beginning point\n            ymxpk  = zmag\n        else:\n            x2, y2 = hord, zmag\n            m2 = (y1-y2)/(x1-x2)\n            if hh>1:\n                if m1>0 and m2<0:           # found peak\n                    inam = 'peak'\n                    if y1>y2:\n                        pt = 0\n                    else:\n                        pt = 1\n                elif m1<0 and m2>0:         # found valley\n                    inam = 'valy'\n                    if y1<y2:\n                        pt = 0\n                    else:\n                        pt = 1\n                else:\n                    inam = 'none'\n\n                if inam!='none':\n                    if pt==0:\n                        xn = x1\n                        yn = y1\n                        hidx = hh-1\n                    else:\n                        xn = x2\n                        yn = y2\n                        hidx = hh\n\n                    if inam=='peak' and yn>ymxpk:\n                        ymxpk = yn\n\n                    rsnobj = _set_rsn_object(x1=xb, y1=yb, x2=xn, y2=yn, inam=inam, hidx=hidx, rflg=0)\n                    resn_pkvls.append(rsnobj)\n\n                    # next segment begin point\n                    xb, yb = xn, yn\n\n            # update and go to next point\n            m1, x1, y1 = m2, x2, y2\n\n    # Filter Peak Resonance Points\n    resn_pks_hord, resn_pks_zmag = _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report)\n    _write_verbose_report('\\n', report)\n\n    return resn_pks_hord, resn_pks_zmag\n\n#"
  },
  {
    "id": 235,
    "text": "def get_fscan_csvdata(csvfile):\n    \"\"\"Get frequency scan Thevenin Impedance data from PSSE results file.\n    \"\"\"\n    import csv\n\n    thevz_dict = {}\n    with open(csvfile, newline='') as fobj:\n        reader = csv.reader(fobj)\n        for row in reader:\n            bus   = row[0]\n            sec   = row[1]\n            nam   = row[2]\n            basekv= row[3]\n            desc  = row[4].strip()\n            if desc=='HORD':\n                thevz_dict['hord'] = [float(v) for v in row[5:]]\n            else:\n                iext = int(bus)\n                try:\n                    isec = int(sec)\n                except:\n                    isec = 0\n                if isec>0:\n                    dkey = (iext, isec)\n                else:\n                    dkey = iext\n                if desc=='pu abs(thevz)':\n                    bnam = nam.strip()\n                    bkv  = float(basekv)\n                    thevz_dict[dkey] = {'basekv': bkv, 'name': bnam}\n                    thevz_dict[dkey]['mag'] = [float(v) for v in row[5:]]\n                elif desc=='deg phase(thevz)':\n                    thevz_dict[dkey]['phase'] = [float(v) for v in row[5:]]\n                else:\n                    txt = \"Reading Harmonics FSCAN CSVFILE error, should not come here.\"\n                    raise Exception(txt)\n\n    return thevz_dict\n\n#"
  },
  {
    "id": 236,
    "text": "def get_hord_thevz_list(thevz_dict, busnum=None):\n    \"\"\"Get frequency scan Thevenin impedance harmonic orders.\n    \"\"\"\n    found = False\n    klst = list(thevz_dict.keys())\n    for k in klst:\n        if k=='hord': continue\n        if busnum is None:\n            busnum = k\n            found = True\n            break\n        else:\n            if k==busnum:\n                found = True\n                break\n\n    if found:\n        hord_lst = thevz_dict['hord'][:]\n        thevz_mag_lst = thevz_dict[busnum]['mag'][:]\n        thevz_phs_lst = thevz_dict[busnum]['phase'][:]\n        ierr = False\n    else:\n        ierr = True\n        hord_lst, thevz_mag_lst, thevz_phs_lst = [], [], []\n\n    return ierr, hord_lst, thevz_mag_lst, thevz_phs_lst\n\n#"
  },
  {
    "id": 237,
    "text": "def get_dstn_csvdata_volt(csvfile):\n    \"\"\"Get Distortion Calculations Bus Voltage THD data from PSSE results file.\n    \"\"\"\n    import csv\n\n    dkeytup = ('hord', 'bus', 'sec', 'basekv', 'vrpu', 'vxpu', 'vmagpu', 'vangdeg', 'thd_indv')\n    dtyptup = ('r'   , 'i'  , 'i'  , 'r'     , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       )\n\n    errmsg0 = \" Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile)\n\n    _NCLNS = len(dkeytup)\n\n    volt_dict = {}\n    with open(csvfile, newline='') as fobj:\n        reader = csv.reader(fobj)\n        nrow = 0\n        for row in reader:\n            nrow += 1\n            if nrow==1: continue # skip column header line\n            nclns = len(row)\n            if nclns!=_NCLNS:\n                txt = \"    ROW {} has {} data items. It should have {} data items.\".format(nrow, nclns, _NCLNS)\n                errmsg = \"{}{}\".format(errmsg0, txt)\n                raise Exception(errmsg)\n            tempdct = {}\n            for dk, dt, v0 in zip(dkeytup, dtyptup, row):\n                if dt=='s':\n                    val = v0\n                elif dt=='i':\n                    if dk=='sec':\n                        try:\n                            val = int(v0)\n                        except:\n                            val = 0\n                    else:\n                        val = int(v0)\n                else:\n                    val = float(v0)\n                tempdct[dk] = val\n\n            hord = tempdct['hord']\n            ibus = tempdct['bus']\n            isec = tempdct['sec']\n            bus_sec = (ibus, isec)\n\n            if bus_sec not in volt_dict:\n                volt_dict[bus_sec] = {}\n\n            if hord not in volt_dict[bus_sec]:\n                volt_dict[bus_sec][hord] = {}\n            else:\n                txt = \"    Duplicate harmonic order={} data found for '{}', at {}\".format(hord, desc, srcktup)\n                errmsg = \"{}{}\".format(errmsg0, txt)\n                raise Exception(errmsg)\n\n            if hord==1.0:\n                kk = 'thd'\n            else:\n                kk = 'indv'\n            volt_dict[bus_sec][hord]['basekv'] = tempdct['basekv']\n            volt_dict[bus_sec][hord]['vmag']   = tempdct['vmagpu']\n            volt_dict[bus_sec][hord]['vang']   = tempdct['vangdeg']\n            # When hord=1.0, pct is THD, else pct is indv\n            volt_dict[bus_sec][hord]['pct']    = tempdct['thd_indv']\n\n    # add this test here\n##    txt = \"    Fundamental harmonic order data not found for bus={}, section={}\".format(ibus, isec)\n##    errmsg = \"{}{}\".format(errmsg0, txt)\n##    raise Exception(errmsg)\n\n    return volt_dict\n\n#"
  },
  {
    "id": 238,
    "text": "def get_dstn_csvdata_cursrc(csvfile):\n    \"\"\"Get Distortion Calculations Harmonic Current Source Spectrum data from PSSE results file.\n    \"\"\"\n    import csv\n\n    dkeytup = ('hord', 'ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec', 'ckt', 'irpu', 'ixpu', 'imagpu', 'iangdeg', 'thd_indv', 'desc')\n    dtyptup = ('r'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 's'  , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       , 's'   )\n\n    errmsg0 = \" Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile)\n\n    _NCLNS = len(dkeytup)\n\n    cursrc_dict = {}\n    with open(csvfile, newline='') as fobj:\n        reader = csv.reader(fobj)\n        nrow = 0\n        for row in reader:\n            nrow += 1\n            if nrow==1: continue # skip column header line\n            nclns = len(row)\n            if nclns!=_NCLNS:\n                txt = \"    ROW {} has {} data items. It should have {} data items.\".format(nrow, nclns, _NCLNS)\n                errmsg = \"{}{}\".format(errmsg0, txt)\n                raise Exception(errmsg)\n            tempdct = {}\n            srcklst = []\n            for dk, dt, v0 in zip(dkeytup, dtyptup, row):\n                if dt=='s':\n                    val = v0.strip().lower()\n                elif dt=='i':\n                    if dk in ['isec', 'jbus', 'jsec', 'kbus', 'ksec']:\n                        try:\n                            val = int(v0)\n                        except:\n                            val = 0\n                    else:\n                        val = int(v0)\n                else:\n                    val = float(v0)\n\n                if dk in ['ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec']:\n                    if val>0:\n                        srcklst.append(val)\n                elif dk in ['ckt']:\n                    if val:\n                        srcklst.append(val)\n                else:\n                    tempdct[dk] = val\n\n            srcktup = tuple(srcklst)\n            hord = tempdct['hord']\n            desc = tempdct['desc']\n\n            if desc not in cursrc_dict:\n                cursrc_dict[desc] = {}\n\n            if srcktup not in cursrc_dict[desc]:\n                cursrc_dict[desc][srcktup] = {}\n\n            if hord not in cursrc_dict[desc][srcktup]:\n                cursrc_dict[desc][srcktup][hord] = {}\n            else:\n                txt = \"    Duplicate harmonic order={} data found for '{}', at {}\".format(hord, desc, srcktup)\n                errmsg = \"{}{}\".format(errmsg0, txt)\n                raise Exception(errmsg)\n\n            if hord==1.0:\n                kk = 'thd'\n            else:\n                kk = 'indv'\n            cursrc_dict[desc][srcktup][hord]['imag'] = tempdct['imagpu']\n            cursrc_dict[desc][srcktup][hord]['iang'] = tempdct['iangdeg']\n            cursrc_dict[desc][srcktup][hord][kk]     = tempdct['thd_indv']\n\n    # add this test here\n##    txt = \"    Fundamental harmonic order data not found for '{}', at {}\".format(desc, srcktup)\n##    errmsg = \"{}{}\".format(errmsg0, txt)\n##    raise Exception(errmsg)\n\n    return cursrc_dict\n\n#"
  },
  {
    "id": 239,
    "text": "def _get_dstn_volt_ieee519_busgrps(volt_dict):\n\n    hord = 1.0  # just consider HORD=1.0 to get bus information\n\n    ierr = 0\n    ieee519_vlmt_dict  = {}\n    case_bus_vlmt_dict = {}\n    for ii, lmtkv in enumerate(_ieee519_vlimits):\n        if ii==0:\n            vmn, vmx = 0, lmtkv\n        else:\n            vmn, vmx = _ieee519_vlimits[ii-1], lmtkv\n\n        if vmn<=0.0:\n            s_lmt = \"kV <= {}\".format(vmx)\n        elif vmx>=999.0:\n            s_lmt = \"{} < kV\".format(vmn)\n        else:\n            s_lmt = \"{} < kV <= {}\".format(vmn, vmx)\n\n        ieee519_vlmt_dict[ii] = {'lmtkv':lmtkv, 'vmin':vmn, 'vmax':vmx, 'lmt_lgd':s_lmt}\n\n    buses_not_added_to_grps = []\n    for bus_sec, vdict in volt_dict.items():\n        buskv = vdict[hord]['basekv']\n        found = False\n        for ii, lmtkv in enumerate(_ieee519_vlimits):\n            if ii==0:\n                vmn, vmx = 0, lmtkv\n            else:\n                vmn, vmx = _ieee519_vlimits[ii-1], lmtkv\n\n            if buskv>vmn and buskv<=vmx:\n                case_bus_vlmt_dict[bus_sec] = ii\n                found = True\n                break\n\n        if not found:\n            buses_not_added_to_grps.append(bus_sec) # should never happen\n\n    if buses_not_added_to_grps:\n        txtlst = []\n        for each in buses_not_added_to_grps:\n            txt = \"{}\".format(each)\n            txtlst.append(txt)\n        txt = \" Error - These (bus, sec) are not added to IEEE 519 Voltage THD Bus Groups:\"\n        print(txt)\n        alltxt = \", \".join(txtlst)\n        tlnlst = textwrap.wrap(alltxt, width=90, initial_indent=\"    \", subsequent_indent=\"    \")\n        tlntxt = \"\\n\".join(tlnlst)\n        print(tlntxt)\n\n    if not case_bus_vlmt_dict:\n        ierr = 1\n\n    return ierr, ieee519_vlmt_dict, case_bus_vlmt_dict\n\n#"
  },
  {
    "id": 240,
    "text": "def get_dstn_volt_study_bus_results(volt_dict, *buses):\n    \"\"\"Return distortion results assembled in arrays for XY plots for specified study buses.\n    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)\n    \"\"\"\n\n    ierr = 0\n    each_bus_xy = {}\n    all_bus_xy = {}\n\n    ierr, ieee519_vlmt_dict, case_bus_vlmt_dict = _get_dstn_volt_ieee519_busgrps(volt_dict)\n    if ierr:\n        return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy\n\n    case_bus_exst_dict = {}\n    for bus_sec, lmtidx in case_bus_vlmt_dict.items():\n        bus, sec = bus_sec\n        case_bus_exst_dict[bus] = 1\n\n    if not buses: buses = [-1]\n\n    stdy_bus_dict = {}\n    if len(buses)==1 and buses[0]==-1:\n        for bus, flag in case_bus_exst_dict.items():\n            stdy_bus_dict[bus] = 1\n    else:\n        for bus in buses:\n            if bus in case_bus_exst_dict:\n                stdy_bus_dict[bus] = 1\n\n    for bus_sec, vdict in volt_dict.items():\n        bus, sec = bus_sec\n        if bus not in stdy_bus_dict: continue\n        if sec:\n            xt = \"{}-{}\".format(bus, sec)\n        else:\n            xt = \"{}\".format(bus)\n\n        idx = case_bus_vlmt_dict[bus_sec]\n\n        # Each bus THD and INDV for all HORD\n        # 'pct' key contains both THD and INDV\n        each_bus_xy[bus_sec] = {'xnam':xt, 'hord':[], 'pct':[], 'lmtidx':idx}\n        for hord, vdct2 in vdict.items():\n            each_bus_xy[bus_sec]['hord'].append(hord)\n            each_bus_xy[bus_sec]['pct'].append(vdct2['pct'])\n\n    # THD and max INDV for all buses\n\n    for kk in ['bus_sec', 'xnam', 'thd', 'indv', 'indv_hord', 'lmtidx']:\n        all_bus_xy[kk] = []\n\n    for bus_sec, vdict in each_bus_xy.items():\n        all_bus_xy['bus_sec'].append(bus_sec)\n        all_bus_xy['xnam'].append(vdict['xnam'])\n        all_bus_xy['lmtidx'].append(vdict['lmtidx'])\n\n        mx_indv = 0.0\n        mx_indv_hord = 0.0\n        for hord, pct in zip(vdict['hord'], vdict['pct']):\n            if hord==1.0:\n                thd = pct\n            else:\n                if pct>mx_indv:\n                    mx_indv = pct\n                    mx_indv_hord = hord\n\n        all_bus_xy['thd'].append(thd)\n        all_bus_xy['indv'].append(mx_indv)\n        all_bus_xy['indv_hord'].append(mx_indv_hord)\n\n##    print(\"\\n each_bus_xy\\n\", each_bus_xy)\n##    print(\"\\n all_bus_xy\\n\",  all_bus_xy)\n\n    return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy\n\n#"
  },
  {
    "id": 241,
    "text": "def compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc):\n    # Compare PSSE Distortion Calculation Results and IEEE Task Force Results\n\n    if not os.path.exists(csvfile_volt):\n        msg0 = \" Distortion Calculation comparison table for IEEE Test case not done.\"\n        msg  = \" File not found.{}\\n    {}\".format(msg0, csvfile_volt)\n        print(msg)\n        return\n\n    # get task force results table in dictionary\n    tfresults_pf_thd_dict = get_ieee_tf_dstn_pf_thd_results()\n    tfresults_cursrc_dict = get_ieee_tf_dstn_cursrc()\n\n    # get distotion bus volts CSV data in dictionary\n    volt_dict   = get_dstn_csvdata_volt(csvfile_volt)\n    cursrc_dict = get_dstn_csvdata_cursrc(csvfile_cursrc)\n\n    # create comparison table\n    errmsg0 = \" Error: Processing Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile_volt)\n\n    hdr1 = \" IEEE Task Force (TF) Harmonics Test Case: TF and PSSE Results Comparison\\n\"\n    hdr2 = \" (1) Power Flow Solution Bus Voltages and Harmonics %THD\\n\"\n    hdr3 = \"    Bus |nominal| IEEE TF| IEEE TF|IEEE TF|  PSSE  |  PSSE  | PSSE  |   DIFF   |   DIFF   |   DIFF   |\"\n    hdr4 = \" Number |  kV   |  V pu  |  V deg | THD % |  V pu  |  V deg | THD % |   V pu   |   V deg  |   THD %  |\\n\"\n\n    oubflst = []\n    oubflst.append(hdr1)\n    oubflst.append(hdr2)\n    oubflst.append(hdr3)\n    oubflst.append(hdr4)\n\n    buslist = list(tfresults_pf_thd_dict.keys())\n    buslist.sort()\n    for bus in buslist:\n        tfdct = tfresults_pf_thd_dict[bus]\n        tf_basekv = tfdct['basekv']\n        tf_mag    = tfdct['vmag']\n        tf_ang    = tfdct['vang']\n        tf_thd    = tfdct['thd']\n\n        sec = 0\n        bus_sec = (bus, sec)\n        dstndct = volt_dict[bus_sec]\n\n        hord = 1.0\n\n        p_basekv = dstndct[hord]['basekv']\n        p_mag    = dstndct[hord]['vmag']\n        p_ang    = dstndct[hord]['vang']\n        p_thd    = dstndct[hord]['pct']\n\n        if p_basekv!=tf_basekv:\n            txt1 = \"    Nominal bus voltage does not match for bus={}\\n\".format(bus)\n            txt2 = \"    Bus voltage (kV)  TF paper={}, PSSE case={}\\n\".format(tf_basekv, p_basekv)\n            errmsg = \"{}{}{}\".format(errmsg0, txt1, txt2)\n            raise Exception(errmsg)\n\n        tf_txt = \"{:6d} | {:5.1f} | {:6.4f} | {:6.2f} | {:5.3f} |\".format(bus, tf_basekv, tf_mag, tf_ang, tf_thd)\n        p_txt  = \"{:6.4f} | {:6.2f} | {:5.3f} |\".format(p_mag, p_ang, p_thd)\n\n        df_mag = tf_mag - p_mag\n        df_ang = tf_ang - p_ang\n        df_thd = tf_thd - p_thd\n        df_txt = \"{:8.5f} | {:8.4f} | {:8.5f} |\".format(df_mag, df_ang, df_thd)\n\n        txt = \" {} {} {}\".format(tf_txt, p_txt, df_txt)\n        oubflst.append(txt)\n\n    hdr1 = \"\\n (2) Harmonic Current Source Spectrum applied for Distortion Calculations\\n\"\n    hdr2 = \" Hord |    Bus |  IEEE TF |  IEEE TF |   PSSE   |   PSSE   |   DIFF   |\"\n    hdr3 = \"      | Number |   %I     |   I deg  |   %I     |   I deg  |   %I     |\\n\"\n\n    oubflst.append(hdr1)\n    oubflst.append(hdr2)\n    oubflst.append(hdr3)\n\n    p_keylist = list(cursrc_dict['load'].keys())\n    buslist.sort()\n\n    tf_hord_list = list(tfresults_cursrc_dict['hvdc'].keys())\n    p_elmt = 'load'\n\n    for hord in tf_hord_list:\n        for srcktup in p_keylist:\n            ibus = srcktup[0]\n            if ibus==8:\n                tfk = 'tcr'\n            else:\n                tfk = 'hvdc'\n\n            p_imag  = cursrc_dict[p_elmt][srcktup][hord]['imag']\n            p1_imag = cursrc_dict[p_elmt][srcktup][1.0]['imag']\n            p_pct   = p_imag*100/p1_imag\n\n            p_iang  = cursrc_dict[p_elmt][srcktup][hord]['iang']\n\n            tf_imag = tfresults_cursrc_dict[tfk][hord]['imag']\n            tf_iang = tfresults_cursrc_dict[tfk][hord]['iang']\n\n            df_pct  = tf_imag - p_pct\n\n            txt = \" {:4.1f} | {:6d} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.5f} |\".format(hord, ibus, tf_imag, tf_iang, p_pct, p_iang, df_pct)\n            oubflst.append(txt)\n\n    #\n    txt1 = \"\\n For multiple harmonic sources, the phase angles of harmonic current injections are\"\n    txt2 = \" re-calculated considering power flow solution phase angle, spectrum phase angles and\"\n    txt3 = \" harmonic order. Hence TF spectrum phase angles and PSSE phase angles are different.\"\n    oubflst.extend([txt1, txt2, txt3])\n\n    # write to output file\n    pth, nx  = os.path.split(csvfile_volt)\n    nam, xtn = os.path.splitext(nx)\n    oufname = \"{}_tf_THD_compare.txt\".format(nam)\n    outfile = os.path.join(outpath, oufname)\n    outfobj = open(outfile, 'w')\n\n    oubflst.append(\"\")\n    alltxt = \"\\n\".join(oubflst)\n    outfobj.write(alltxt)\n    outfobj.close()\n\n    msg = \" IEEE Task Force Harmonics Test Case: TF and PSSE Results Comparison saved to file:\\n    {}\\n\".format(outfile)\n    print(msg)\n\n#"
  },
  {
    "id": 242,
    "text": "def plot_main_fscan_ieee_test_and_tf(outpath, **kwds):\n    \"\"\"Plot IEEE Test Case frequency scan impedance.\n    Results from PSSE and IEEE Task Force are plotted.\n    \"\"\"\n\n    import matplotlib.pyplot as plt\n    from matplotlib.backends.backend_pdf import PdfPages\n\n    filetyp = kwds.get('filetyp', 'png')\n    verbose = kwds.get('verbose', False)\n    pctmx1  = kwds.get('pctmx1',  60.0)\n    dpctpn1 = kwds.get('dpctpn1', 75.0)\n    pctmx2  = kwds.get('pctmx2',  20.0)\n    dpctpn2 = kwds.get('dpctpn2', 85.0)\n\n    flag_show = kwds.get('flag_show', True)\n\n    casnam = \"ieee_tf_psse\"\n    busnum = 3\n\n    hmajor = []\n    for ii in range(0, 41, 5):\n        hmajor.append(ii)\n\n    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n\n    csv_dict = {\n        1: {'nam': \"ieee_testcase_linmdl=0_fscan.csv\", 'ttl': \"nominal PI\"},\n        2: {'nam': \"ieee_testcase_linmdl=1_fscan.csv\", 'ttl': \"long line distibuted with skin effect\"},\n        3: {'nam': \"ieee_testcase_linmdl=2_fscan.csv\", 'ttl': \"long line distibuted but no skin effect\"},\n        }\n\n    csv_exists_dict = {}\n    for k, vdict in csv_dict.items():\n        nam = vdict['nam']\n        csvfile = os.path.join(outpath, nam)\n        if os.path.exists(csvfile):\n            csv_exists_dict[k] = vdict\n\n    if not csv_exists_dict:\n        msg = \"\\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n    # PSSE results\n    ierr_pi, ierr_dst_skin, ierr_dst = True, True, True\n    ii = 0\n    for k, vdict in csv_exists_dict.items():\n        nam = vdict['nam']\n        ttl = vdict['ttl']\n        csvfile = os.path.join(outpath, nam)\n        thevz_dict = get_fscan_csvdata(csvfile)\n        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\n        if not ierr:\n            if ii==0:\n                hlst_pi = hlst[:]\n                zlst_pi = zlst[:]\n                ttl_pi = ttl\n                ierr_pi = False\n            elif ii==1:\n                hlst_dst_skin = hlst[:]\n                zlst_dst_skin = zlst[:]\n                ttl_dst_skin = ttl\n                ierr_dst_skin = False\n            elif ii==2:\n                hlst_dst = hlst[:]\n                zlst_dst = zlst[:]\n                ttl_dst  = ttl\n                ierr_dst = False\n        ii += 1\n\n    if ierr_pi or ierr_dst:\n        print(\" Error -- PSSE getting results data\")\n        return\n\n    tf_hlst, tf_zlst_cal, tf_zlst_dst, tf_zlst_pi = get_ieee_tf_scan_results()\n\n    peak_lst_h, peak_lst_rx = check_resonance(hlst_dst, zlst_dst, pctmx1, dpctpn1, pctmx2, dpctpn2)\n    resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\n    resn_lgd_lst.insert(0, \"Resonance: distibuted but no skin\")\n    resn_lgd = \"\\n\".join(resn_lgd_lst)\n\n    clr_lst = ['red', 'blue', 'black', 'green', 'magenta']\n    sty_lst = ['-', ':', '--', '-.', '-']\n    wdt_lst = [2, 2, 1, 1, 1]\n\n    fig, ax = plt.subplots(1,1)\n    fig.set_size_inches(8.0, 9.0)\n\n    ii=0\n    ax.plot(hlst_dst, zlst_dst, label=ttl_dst+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\n\n    ii=1\n    ax.plot(tf_hlst, tf_zlst_dst, label=ttl_dst+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\n\n    ii=2\n    ax.plot(hlst_pi, zlst_pi, label=ttl_pi+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\n\n    ii=3\n    ax.plot(tf_hlst, tf_zlst_pi, label=ttl_pi+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\n\n    ax.set_xticks(hmajor)\n    ax.set_yticks(ymajor)\n    #ax.set_yscale('log')\n    ax.set_xlabel(\"Harmonic Order\")\n    ax.set_ylabel(\"Harmonic Impedance (pu)\")\n    ax.set_title(\"IEEE 14 Bus Harmonics Test System\")\n    ax.grid(True, which='both')\n    ax.legend()\n    ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')\n\n    if filetyp=='pdf':\n        pdffile = os.path.join(outpath, \"{}.pdf\".format(casnam))\n        pdfobj  = PdfPages(pdffile)\n    else:\n        figfile = os.path.join(outpath, \"{}.png\".format(casnam))\n\n    if filetyp=='pdf':\n        pdfobj.savefig(fig, bbox_inches='tight')\n        pdfobj.close()\n        print(\" Plots saved: {}\".format(pdffile))\n    else:\n        fig.savefig(figfile, bbox_inches='tight')\n        print(\" Plots saved: {}\".format(figfile))\n\n    if filetyp!='pdf':\n        if flag_show:\n            plt.show()\n        else:\n            plt.close('all')\n\n#"
  },
  {
    "id": 243,
    "text": "def plot_main_fscan_ieee_test(outpath, **kwds):\n    \"\"\"Plot IEEE Test Case frequency scan Thevenin impedance.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.backends.backend_pdf import PdfPages\n\n    filetyp = kwds.get('filetyp', 'png')\n    verbose = kwds.get('verbose', False)\n    pctmx1  = kwds.get('pctmx1',  60.0)\n    dpctpn1 = kwds.get('dpctpn1', 75.0)\n    pctmx2  = kwds.get('pctmx2',  20.0)\n    dpctpn2 = kwds.get('dpctpn2', 85.0)\n\n    flag_show = kwds.get('flag_show', True)\n\n    if verbose:\n        report = sys.stdout.write\n    else:\n        report = None\n\n    csv_dict = {\n        1: {'nam': \"ieee_testcase_linmdl=0_fscan.csv\", 'ttl': \"nominal PI\"},\n        2: {'nam': \"ieee_testcase_linmdl=1_fscan.csv\", 'ttl': \"long line distibuted with skin effect\"},\n        3: {'nam': \"ieee_testcase_linmdl=2_fscan.csv\", 'ttl': \"long line distibuted but no skin effect\"},\n        }\n\n    csv_exists_dict = {}\n    for k, vdict in csv_dict.items():\n        nam = vdict['nam']\n        csvfile = os.path.join(outpath, nam)\n        if os.path.exists(csvfile):\n            csv_exists_dict[k] = vdict\n\n    if not csv_exists_dict:\n        msg = \"\\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n    hmajor = []\n    for ii in range(0, 41, 5):\n        hmajor.append(ii)\n\n    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\n\n    busnum = 3\n\n    clr_lst = ['black', 'green', 'red']\n    sty_lst = ['--', ':', '-']\n    wdt_lst = [2, 3, 1]\n\n    resn_lgd = ''\n    fig, ax = plt.subplots(1,1)\n    fig.set_size_inches(8.0, 9.0)\n    ii = 0\n    for k, vdict in csv_exists_dict.items():\n        nam = vdict['nam']\n        ttl = vdict['ttl']\n        csvfile = os.path.join(outpath, nam)\n        thevz_dict = get_fscan_csvdata(csvfile)\n        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\n        if not ierr:\n            ax.plot(hlst, zlst, label=ttl, color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\n            if k==3:\n                peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=report)\n                resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\n                resn_lgd_lst.insert(0, \"Resonance: linmdl-distibuted but no skin\")\n                resn_lgd = \"\\n\".join(resn_lgd_lst)\n\n        ii += 1\n\n    ax.set_xticks(hmajor)\n    ax.set_yticks(ymajor)\n    #ax.set_yscale('log')\n    ax.set_xlabel(\"Harmonic Order\")\n    ax.set_ylabel(\"Harmonic Impedance (pu)\")\n    ax.set_title(\"IEEE 14 Bus Harmonics Test System\")\n    ax.grid(True, which='both')\n    ax.legend()\n    if resn_lgd: ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')\n\n    casnam = 'ieee_test'\n    if filetyp=='pdf':\n        pdffile = os.path.join(outpath, \"{}_fscan.pdf\".format(casnam))\n        pdfobj  = PdfPages(pdffile)\n    else:\n        figfile = os.path.join(outpath, \"{}_fscan.png\".format(casnam))\n\n    if filetyp=='pdf':\n        pdfobj.savefig(fig, bbox_inches='tight')\n        pdfobj.close()\n        print(\" Plots saved: {}\".format(pdffile))\n    else:\n        fig.savefig(figfile, bbox_inches='tight')\n        print(\" Plots saved: {}\".format(figfile))\n\n    if filetyp!='pdf':\n        if flag_show:\n            plt.show()\n        else:\n            plt.close('all')\n\n#"
  },
  {
    "id": 244,
    "text": "def _har_ana_ieee_test(**kwds):\n    \"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n    Allowed kwds:\n\n    outpath  = os.getcwd(), Folder name to save outfile files\n    rpt2file = False, Save Report to file\n\n    Thresholds to filter Thevenin Impedance\n        dft_thresholds = True, Use defualt thresholds\n\n        pctmx1  = kwds.get('pctmx1' , 60.0)\n        dpctpn1 = kwds.get('dpctpn1', 75.0)\n        pctmx2  = kwds.get('pctmx2' , 20.0)\n        dpctpn2 = kwds.get('dpctpn2', 85.0)\n    \"\"\"\n    import psspy\n\n    name,major,minor,modlvl,date,stat = psspy.psseversion()\n\n    kwds_api = {}\n    kwds_api['anaoptn'   ] = 0\n    kwds_api['dstnbuop'  ] = 0\n    kwds_api['dstnrptop' ] = 1\n    kwds_api['imachimpop'] = 0\n    kwds_api['dcimpop'   ] = 0\n    kwds_api['triplenop' ] = 0\n    kwds_api['genimpop'  ] = 0\n\n    kwds_api['hord_min' ] = 0.0\n    kwds_api['hord_max' ] = 40.0\n    kwds_api['hord_stp' ] = 0.33\n\n    kwds_api['hrsfile'  ] = ''\n\n    fscan_buslist = [3]\n    sid = 3\n    busall = 0\n    psspy.bsys(sid, numbus=len(fscan_buslist), buses=fscan_buslist)\n\n    outpath = kwds.get('outpath', os.getcwd())\n    rpt2file = kwds.get('rpt2file', False)\n    dft_thresholds = kwds.get('dft_thresholds', True)\n\n    inherit = kwds.get('inherit', False)\n    if inherit:\n        kwds_api['load_mdltyp'] = 7\n\n    if not dft_thresholds:\n        pctmx1  = kwds.get('pctmx1' , 60.0)\n        dpctpn1 = kwds.get('dpctpn1', 75.0)\n        pctmx2  = kwds.get('pctmx2' , 20.0)\n        dpctpn2 = kwds.get('dpctpn2', 85.0)\n\n        s_pctmx1  = \"{:g}\".format(pctmx1)\n        s_dpctpn1 = \"{:g}\".format(dpctpn1)\n        s_pctmx2  = \"{:g}\".format(pctmx2)\n        s_dpctpn2 = \"{:g}\".format(dpctpn2)\n        usr_thresholds = \"thresholds_usr_{}_{}_{}_{}\".format(s_pctmx1, dpctpn1, s_pctmx2, dpctpn2)\n\n    for linmdl in [0, 1, 2]:\n        outnam = \"ieee_testcase_linmdl={}\".format(linmdl)\n        if dft_thresholds:\n            if not inherit:\n                outpath1 = os.path.join(outpath,\"dft_thresholds\")\n            else:\n                outpath1 = os.path.join(outpath,\"dft_thresholds_inherit\")\n        else:\n            outpath1 = os.path.join(outpath,usr_thresholds)\n\n        if not os.path.exists(outpath1): os.makedirs(outpath1)\n\n        if rpt2file:\n            dstnfile = os.path.join(outpath1, \"{}_dstn.txt\".format(outnam))\n            resnfile = os.path.join(outpath1, \"{}_resn.txt\".format(outnam))\n        else:\n            dstnfile = ''\n            resnfile = ''\n\n        kwds_api['linmdl']   = linmdl\n        kwds_api['dstnfile'] = dstnfile\n        kwds_api['resnfile'] = resnfile\n\n        if dft_thresholds:\n            psspy.har_set_resn_thresholds_default()\n        else:\n            psspy.har_set_resn_thresholds(pctmx1=pctmx1, dpctpn1=dpctpn1, pctmx2=pctmx2, dpctpn2=dpctpn2)\n\n        ierr = psspy.har_analysis_2(sid, busall, **kwds_api)\n\n        if not ierr:\n            if kwds_api['anaoptn'] in [0, 1]:\n                fscan_csvfile = os.path.join(outpath1, \"{}_fscan.csv\".format(outnam))\n                psspy.har_export_fscan(fscan_csvfile)\n\n                msg = \"\\n Frequency Scan Thevenin impedance exported to file:\\n    {}\".format(fscan_csvfile)\n                print(msg)\n\n            ok350402 = major==35 and minor>=4 and modlvl>=2\n            ok3505   = major>=35 and minor>=5\n            ok3600   = major>=36\n\n            if ok350402 or ok3505 or ok3600:\n                if kwds_api['anaoptn'] in [0, 2]:\n                    dstn_csvfile = os.path.join(outpath1, \"{}_dstn.csv\".format(outnam))\n                    voltoptn, flowoptn, cursrcoptn = 2, 2, 2\n                    psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )\n\n                    pn, xtn = os.path.splitext(dstn_csvfile)\n                    msg  = \"\\n Distortion calculation results exported to files:\\n\"\n                    msg += \"    {}_volt{}\\n\".format(pn, xtn)\n                    msg += \"    {}_flow{}\\n\".format(pn, xtn)\n                    msg += \"    {}_cursrc{}\\n\".format(pn, xtn)\n                    print(msg)\n\n#"
  },
  {
    "id": 245,
    "text": "def _ieee_test_get_names(datapath, outpath):\n\n    if datapath is None:        # use Example folder\n        exampath = os.path.dirname(__file__)\n        datapath = exampath\n\n    savfile = os.path.join(datapath, 'ieee_harmonics_test_case.sav')\n    harfile = os.path.join(datapath, 'ieee_harmonics_test_case_har.rawx')\n\n    if not os.path.exists(savfile):\n        msg = \"\\n Error- File not found, terminated:\\n    {}\".format(savfile)\n        print(msg)\n\n    if not os.path.exists(harfile):\n        msg = \"\\n Error- File not found, terminated:\\n    {}\".format(harfile)\n        print(msg)\n\n    if outpath is None:\n        exampath = os.path.dirname(__file__)\n        outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee')\n        if not os.path.exists(outpath): os.makedirs(outpath)\n\n    return savfile, harfile, outpath\n\n#"
  },
  {
    "id": 246,
    "text": "def run_ieee_test(datapath=None, outpath=None):\n    \"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n    \"\"\"\n    import psspy\n\n    psspy.psseinit()\n\n    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\n    psspy.case(savfile)\n    psspy.readrawx(harfile, 'harmonics', 'new')\n\n    _har_ana_ieee_test(outpath=outpath, rpt2file=True)\n\n#"
  },
  {
    "id": 247,
    "text": "def run_ieee_test_inherit(datapath=None, outpath=None):\n    \"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n    \"\"\"\n    import psspy\n\n    psspy.psseinit()\n\n    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\n    hnam, hext = os.path.splitext(harfile)\n    harfile = \"{}_inherit{}\".format(hnam, hext)\n    if not os.path.exists(harfile):\n        msg = \" Error - harmonics data file not found, calculations terminated\\n    {}\".format(harfile)\n        print(msg)\n    psspy.case(savfile)\n    psspy.readrawx(harfile, 'harmonics', 'new')\n\n    _har_ana_ieee_test(outpath=outpath, rpt2file=True, inherit=True)\n\n#"
  },
  {
    "id": 248,
    "text": "def run_ieee_test_thevz_thresholds(datapath=None, outpath=None):\n    \"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n    \"\"\"\n    import psspy\n\n    psspy.psseinit()\n\n    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\n    psspy.case(savfile)\n    psspy.readrawx(harfile, 'harmonics', 'new')\n\n    kwds = {}\n    kwds['outpath' ] = outpath\n    kwds['rpt2file' ] = True\n    kwds['dft_thresholds' ] = False\n\n    kwds['pctmx1' ] = 60.0\n    kwds['dpctpn1'] = 75.0\n    kwds['pctmx2' ] = 20.0\n    kwds['dpctpn2'] = 65.0\n\n    _har_ana_ieee_test(**kwds)\n\n#"
  },
  {
    "id": 249,
    "text": "def plot_fscan_ieee_test(outpath=None, **kwds):\n    \"\"\"Plot PSSE Harmonic Analysis Frequency Scan results of IEEE Test Case.\n    \"\"\"\n    if outpath is None:\n        exampath = os.path.dirname(__file__)\n        outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\n    if not os.path.exists(outpath):\n        msg = \"\\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n##    kwds = {}\n##    kwds['filetyp'] = 'png'\n##    kwds['verbose'] = verbose\n##    kwds['pctmx1' ] = pctmx1\n##    kwds['dpctpn1'] = dpctpn1\n##    kwds['pctmx2' ] = pctmx2\n##    kwds['dpctpn2'] = dpctpn2\n\n    plot_main_fscan_ieee_test(outpath, **kwds)\n\n#"
  },
  {
    "id": 250,
    "text": "def plot_fscan_ieee_test_tf_psse(outpath=None, **kwds):\n    \"\"\"Plot Frequency Scan results of PSSE Harmonic Analysis and IEEE Task Force for IEEE Test Case.\n    \"\"\"\n    if outpath is None:\n        exampath = os.path.dirname(__file__)\n        outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\n    if not os.path.exists(outpath):\n        msg = \"\\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n##    kwds = {}\n##    kwds['filetyp'] = 'png'\n##    kwds['verbose'] = verbose\n##    kwds['pctmx1' ] = pctmx1\n##    kwds['dpctpn1'] = dpctpn1\n##    kwds['pctmx2' ] = pctmx2\n##    kwds['dpctpn2'] = dpctpn2\n\n    plot_main_fscan_ieee_test_and_tf(outpath, **kwds)\n\n#"
  },
  {
    "id": 251,
    "text": "def compare_dstn_ieee_test(outpath=None, inherit=False):\n\n    if outpath is None:\n        exampath = os.path.dirname(__file__)\n        if not inherit:\n            outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\n        else:\n            outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds_inherit')\n\n    if not os.path.exists(outpath):\n        msg = \"\\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n    csvnam_volt   = \"ieee_testcase_linmdl=2_dstn_volt.csv\"\n    csvnam_flow   = \"ieee_testcase_linmdl=2_dstn_flow.csv\"\n    csvnam_cursrc = \"ieee_testcase_linmdl=2_dstn_cursrc.csv\"\n\n    csvfile_volt   = os.path.join(outpath, csvnam_volt)\n    csvfile_cursrc = os.path.join(outpath, csvnam_cursrc)\n    compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc)\n\n#"
  },
  {
    "id": 252,
    "text": "def plot_dstn_ieee_test_volt_ieee519(outpath=None, *buses, **kwds):\n    \"\"\"Plot PSSE Harmonic Distortion Calculations results of IEEE Test Case.\n    \"\"\"\n    if outpath is None:\n        exampath = os.path.dirname(__file__)\n        outpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\n    if not os.path.exists(outpath):\n        msg = \"\\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\\n    {}\".format(outpath)\n        print(msg)\n        return\n\n    csvfnam = r\"ieee_testcase_linmdl=2_dstn_volt.csv\"\n    csvfile = os.path.join(outpath, csvfnam)\n\n    figfnam = 'ieee_testcase_linmdl=2_dstn_volt'\n    figfile = os.path.join(outpath, figfnam)\n\n    kwds2 = {}\n    kwds2['figfiletyp'  ] = kwds.get('figfiletyp'  , 'pdf'   )\n    kwds2['figfile'     ] = kwds.get('figfile'     , figfile )\n    kwds2['flag_thd'    ] = kwds.get('flag_thd'    , True    )\n    kwds2['flag_indv'   ] = kwds.get('flag_indv'   , True    )\n    kwds2['flag_busgrps'] = kwds.get('flag_busgrps', False   )\n    kwds2['plt_buses'   ] = kwds.get('plt_buses'   , [-1]    )\n    kwds2['flag_show'   ] = kwds.get('flag_show'   , True    )\n\n    plot_distortion_volt_ieee519(csvfile, *buses, **kwds2)\n\n#"
  },
  {
    "id": 253,
    "text": "def _run_har_ana_main(*fscanbuses, **kwds):\n    # Run Harmonic Analysis using working case\n    import psspy\n\n    name,major,minor,modlvl,date,stat = psspy.psseversion()\n\n    # subsystem\n    onezerobus = False\n    if fscanbuses:\n        if len(fscanbuses)==1:\n            if fscanbuses[0]==0:\n                onezerobus = True\n\n    if fscanbuses:\n        if not onezerobus:\n            sid = 3\n            busall = 0\n            psspy.bsys(sid, numbus=len(fscanbuses), buses=fscanbuses)\n        else:\n            # no scan, just run distortion calculations\n            sid = 0\n            busall = 0\n    else:\n        totbus = psspy.totbus()\n        # if case has <100 buses, run scan on all buses\n        if totbus<100:\n            sid = 0\n            busall = 1\n        else:\n            # no scan, just run distortion calculations\n            sid = 0\n            busall = 0\n\n    ierr = True\n    outfdict = {}\n    outfdict['dstn'] = ''\n    outfdict['resn'] = ''\n    outfdict['scan'] = ''\n\n    anaoptn = kwds.get('anaoptn', 0)\n    if sid==0 and busall==0:\n        if anaoptn==0:\n            kwds['anaoptn'] = 2  # only distortion anlysis\n        elif anaoptn==2:\n            pass\n        else:\n            msg = \"\\n Error- Specify frequency scan buses, terminated\"\n            print(msg)\n            return ierr, outfdict\n\n    outfnam  = kwds.get('outfnam' , '')\n    outpath  = kwds.get('outpath' , '')\n\n    if not outfnam:\n        savfile, snpfile = psspy.sfiles()\n        if not savfile:\n            outfnam = \"tmpout\"\n        else:\n            p, nx = os.path.split(savfile)\n            outfnam, xtn = os.path.splitext(nx)\n\n    if outpath:\n        if not os.path.exists(outpath): os.makedirs(outpath)\n        dstnfile = os.path.join(outpath, \"{}_dstn.txt\".format(outfnam))\n        resnfile = os.path.join(outpath, \"{}_resn.txt\".format(outfnam))\n    else:\n        dstnfile = ''\n        resnfile = ''\n\n    kwds['hrsfile']  = ''\n    kwds['dstnfile'] = dstnfile\n    kwds['resnfile'] = resnfile\n\n    if 'outpath' in kwds: del kwds['outpath']\n    if 'outfnam' in kwds: del kwds['outfnam']\n\n    ierr = psspy.har_analysis(sid, busall, **kwds)\n\n    fscan_csvfile = ''\n    dstn_volt_csvfile = ''\n    dstn_flow_csvfile = ''\n    dstn_cursrc_csvfile = ''\n\n    if not ierr and outpath:\n        if anaoptn in [0,1]:\n            if not ierr and outpath:\n                fscan_csvfile = os.path.join(outpath, \"{}_fscan.csv\".format(outfnam))\n                psspy.har_export_fscan(fscan_csvfile)\n                msg = \"\\n Frequency Scan Thevenin impedance saved to file:\\n    {}\".format(fscan_csvfile)\n                print(msg)\n\n        ok350402 = major==35 and minor>=4 and modlvl>=2\n        ok3505   = major>=35 and minor>=5\n        ok3600   = major>=36\n\n        if ok350402 or ok3505 or ok3600:\n            if anaoptn in [0, 2]:\n                dstn_csvfile = os.path.join(outpath, \"{}_dstn.csv\".format(outfnam))\n                voltoptn, flowoptn, cursrcoptn = 2, 2, 2\n\n                psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )\n\n                pn, xtn = os.path.splitext(dstn_csvfile)\n                dstn_volt_csvfile = r\"{}_volt{}\".format(pn, xtn)\n                dstn_flow_csvfile = r\"{}_flow{}\".format(pn, xtn)\n                dstn_cursrc_csvfile = r\"{}_cursrc{}\".format(pn, xtn)\n\n                msg += r\"    {}\\n\".format(dstn_volt_csvfile)\n                msg += r\"    {}\\n\".format(dstn_flow_csvfile)\n                msg += r\"    {}\\n\".format(dstn_cursrc_csvfile)\n                print(msg)\n\n    outfdict['dstn'] = dstnfile\n    outfdict['resn'] = resnfile\n    outfdict['scan'] = fscan_csvfile\n    outfdict['dstn_volt'] = dstnfile\n    outfdict['dstn_flow'] = resnfile\n    outfdict['dstn_cursrc'] = fscan_csvfile\n\n    return ierr, outfdict\n\n#"
  },
  {
    "id": 254,
    "text": "def run_har_analysis(savfile, *fscanbuses, **kwds):\n    \"\"\"Run PSSE Harmonic Analysis using savfile and harfile provided.\n\n    Arguments:\n        savfile (str): PSSE Saved Case file name\n\n        fscanbuses (int): One or bus numbers at which frequency scan done\n\n        kwds (dict):  All PSSE har_analysis() API keywords plus followng\n            are allowed key words.\n\n            harfile (str) : PSSE harmonics data (.har) file\n            outpath (str) : Output Results File Folder name\n            outfnam (str) : Output Results File Name prefix\n    \"\"\"\n\n    import psspy\n\n    if not os.path.exists(savfile):\n        msg = \"\\n Error- File not found, terminated:\\n    {}\".format(savfile)\n        print(msg)\n        return True, {}\n\n    harfile = kwds.get('harfile', '')\n    if harfile:\n        if not os.path.exists(harfile):\n            msg = \"\\n Error- File not found, ignored:\\n    {}\".format(harfile)\n            print(msg)\n            harfile = ''\n\n    psspy.psseinit()\n\n    ierr = psspy.case(savfile)\n    if ierr:\n        msg = \"\\n Error- reading SAV file, terminated:\\n    {}\".format(savfile)\n        print(msg)\n        return True, {}\n\n    if harfile:\n        ierr = psspy.readrawx(harfile, 'harmonics', 'new')\n        if ierr:\n            msg = \"\\n Error- reading Harmonics data file, terminated:\\n    {}\".format(harfile)\n            print(msg)\n            return True, {}\n\n    if 'harfile' in kwds: del kwds['harfile']\n    ierr, outfdict = _run_har_ana_main(*fscanbuses, **kwds)\n\n    return ierr, outfdict\n\n#"
  },
  {
    "id": 255,
    "text": "def _plot_fscan_one(ax, hlst, zlst, **kwds):\n    #  main plot function\n    basemva  = kwds.get('basemva' , 100.0)\n    basekv   = kwds.get('basekv'  , None)\n    hmajor   = kwds.get('hmajor'  , [])\n    ymajor   = kwds.get('ymajor'  , [])\n    plotzpu  = kwds.get('plotzpu' , False)\n    title    = kwds.get('title'   , '')\n    add_xlbl = kwds.get('add_xlbl', None)\n    add_lgnd = kwds.get('add_lgnd', False)\n    annot_xy = kwds.get('annot_xy', (0.5, 0.5))\n\n    pctmx1  = kwds.get('pctmx1' , 60.0)\n    dpctpn1 = kwds.get('dpctpn1', 75.0)\n    pctmx2  = kwds.get('pctmx1' , 20.0)\n    dpctpn2 = kwds.get('dpctpn1', 85.0)\n    report  = kwds.get('report' , None)\n\n    if add_lgnd:\n        peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report)\n\n    ylbl = \"Thevenin Impedance (pu)\"\n    if not plotzpu:\n        if basemva and basekv:\n            zbase = basekv*basekv/basemva\n            zlst_ohm = [zbase*each for each in zlst]\n            zlst = zlst_ohm[:]\n            del zlst_ohm\n            ylbl = \"Thevenin Impedance (ohm)\"\n\n            if add_lgnd:\n                peak_lst_rx_ohm = [zbase*each for each in peak_lst_rx]\n                peak_lst_rx = peak_lst_rx_ohm[:]\n                del peak_lst_rx_ohm\n\n    if add_lgnd:\n        resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\n        resn_lgd = \"\\n\".join(resn_lgd_lst)\n\n    if add_lgnd:\n        ax.plot(hlst, zlst, label=resn_lgd)\n    else:\n        ax.plot(hlst, zlst)\n    #ax.set_yscale('log')\n    if hmajor: ax.set_xticks(hmajor)\n    if ymajor: ax.set_yticks(ymajor)\n    if (add_xlbl): ax.set_xlabel(\"Harmonic Order\")\n    ax.set_ylabel(ylbl)\n\n    ax.grid(True, which='both')\n\n    if add_lgnd:\n        ax.legend(loc='best')\n\n    if title: ax.set_title(title)\n\n#"
  },
  {
    "id": 256,
    "text": "def _set_output_figfile_name(outfigfile, figfiletyp):\n\n    figfiletyp_in = figfiletyp\n    if figfiletyp_in:\n        if figfiletyp_in not in _ALLOWED_FIG_FILE_TYPES:\n            figfiletyp_in = ''\n\n    opth, nx = os.path.split(outfigfile)\n    n, x = os.path.splitext(nx)\n\n    if x:\n        figfiletyp_fl = ''\n        xlw = x.lower().strip()\n        if xlw:\n            if xlw[1:] in _ALLOWED_FIG_FILE_TYPES:\n                figfiletyp_fl = xlw[1:]\n\n    if figfiletyp_in:\n        figfiletyp = figfiletyp_in\n    elif figfiletyp_fl:\n        figfiletyp = figfiletyp_fl\n    else:\n        figfiletyp = 'pdf'\n\n    xlw = \".{}\".format(figfiletyp)\n\n    if not opth: opth = os.getcwd()\n    outfigfile = os.path.join(opth, \"{}{}\".format(n, xlw))\n\n    return outfigfile, figfiletyp\n\n#"
  },
  {
    "id": 257,
    "text": "def plot_frequency_scan(busnum, *csvfiles, **kwds):\n    \"\"\"Plot Harmonics Frequency Scan Thevenin Impedance.\n    for one bus from multiple Frequency Scan Result Files\n\n    Arguments:\n        busnum (int): Bus Number. The 'csvfiles' provided must have Thevenin Impedance\n            for this bus.\n\n        csvfiles (str): One or more CSV files that contain Frequency Scan results.\n            These files are created by api psspy.har_export_fscan(..).\n\n        kwds (dict):  Followng are allowed key words.\n\n            (A) These keywords are for plot figure options.\n\n            figfiletyp (str): File type to which plots are saved.\n                              ='pdfobj' -- files are saved to already created pdfobj\n                              [Create pdfobj = PdfPages(pdffile). This is done so\n                              as to save many plots to one pdffile.]\n                              ='pdf', 'png', 'jpg' etc. [all allowed file types].\n                              (default: '')\n            figfile (str)   : Name of the file or pdfobj to save plots\n                              When file name is not provided plot is not saved.\n                              (default: '')\n            flag_show (bool): Flag (True or False), Option to show plots on screen or not.\n                              (default: True)\n            basemva (float) : Base MVA (used to calculate Thev Z in ohms)\n                              (default: 100.0)\n            basekv  (float) : Base kV of the bus (used to calculate Thev Z in ohms)\n                              (default: No default allowed)\n            hmajor  (float) : List of Harmonics Orders (used to draw X axis grid)\n                              (default: [])\n            ymajor  (float) : List of Thev Z (used to draw X axis grid)\n                              (default: [])\n            ttl_lst (str)   : Title list (one for each csvfile provided)\n                              When one title is provided, same title is used for all.\n                              (default: [])\n            plotzpu (bool)  : True for Plot PU Thev Z\n                              (default: False)\n            add_lgnd (bool) : True to add resonance rrequeny legend\n                              (default: False)\n            annot_xy (tuple): Resonance Frequency legend location\n                              Specify normalized (0 through 1) XY co-ordinates of a point\n                              (default: (0.5, 0.5))\n            subplts (bool)  : True, plot as subplots for more than one csvfiles.\n                              (default: True) Subplots are drawn with 3 rows and 1 column.\n            fwidth  (float) : Figure Width in inches\n                              (default: matplotlib rcParms default figure width)\n            fheight (float) : Figure Height in inches\n                              (default: matplotlib rcParms default figure height)\n\n            (B) These keywords are for filtering and reporting Thevenin Impedance Peaks.\n\n            - Criterion 1 to select Thevenin Impedance Peak - slow rising peak point\n            pctmx1 (float)     : current point in percent of maximum peak value\n                                 (default:60.0)\n            dpctpn1 (float)    : delta previous and delta next points in percent of current point\n                                 (default:75.0)\n\n            - Criterion 2 to select Thevenin Impedance Peak - fast rising peak point\n            pctmx2 (float)     : current point in percent of maximum peak value\n                                 (default:20.0)\n            dpctpn2 (float)    : delta previous and delta next points in percent of current point\n                                 (default:85.0)\n\n            verbose (bool)     : Show verbose (detailed) output of Thevenin Impedance filtering\n                                 (default: False)\n            verbose_file (str) : File name to write verbose output.\n                                 (default: '')\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.backends.backend_pdf import PdfPages\n\n    # Use outfigfile to save output figure file and\n    # also use its path to find csvfile when csvfile path is not provided.\n    csvpath = ''\n\n    figfiletyp = kwds.get('figfiletyp', '')\n    figfiletyp = figfiletyp.lower()\n\n    outfigfile = kwds.get('figfile', '')\n    flag_show  = kwds.get('flag_show', True)\n\n    if outfigfile:\n        if figfiletyp=='pdfobj':\n            pass\n        else:\n            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)\n    else:\n        figfiletyp = ''\n\n    title = ''\n    has_ttl4each = False\n    ttl_lst = kwds.get('ttl_lst', [])\n    nttl = len(ttl_lst)\n    ncsv = len(csvfiles)\n    if nttl==ncsv:\n        has_ttl4each = True\n    elif nttl==1 and ncsv>1:\n        title = ttl_lst[0]\n\n    exists_csvfiles = []\n    exists_titles   = []\n    for ii, csvnam in enumerate(csvfiles):\n        if has_ttl4each:\n            ttl = ttl_lst[ii]\n        else:\n            ttl = title\n        if os.path.exists(csvnam):\n            exists_csvfiles.append(csvnam)\n            exists_titles.append(ttl)\n        else:\n            p, nx = os.path.split(csvnam)\n            if not p and csvpath:\n                csvnam2 = os.path.join(csvpath, nx)\n                if os.path.exists(csvnam2):\n                    exists_csvfiles.append(csvnam2)\n                    exists_titles.append(ttl)\n            else:\n                msg = \" File not found: {}\".format(csvnam)\n                print(msg)\n\n    if not exists_csvfiles:\n        return\n\n    fwidth  = kwds.get('fwidth',  None)\n    fheight = kwds.get('fheight', None)\n    subplts = kwds.get('subplts', True)\n\n    verbose  = kwds.get('verbose', False)\n    verbose_file = kwds.get('verbose_file', '')\n    report = None\n    if verbose:\n        if verbose_file:\n            verbose_fobj = open(verbose_file, 'w')\n            report = verbose_fobj.write\n        else:\n            report = sys.stdout.write\n\n    if subplts:\n        if fwidth is None or fheight is None:\n            fwidth, fheight = 8.0, 9.0\n\n    nfigs = len(exists_csvfiles)\n    if not subplts:\n        npages = nfigs\n        nrows = 1\n    else:\n        if nfigs>3:\n            npages = int(math.ceil(nfigs/3.0))   # three subplots per page\n            nrows = 3\n        else:\n            npages = 1\n            nrows = nfigs\n\n    if outfigfile and figfiletyp=='pdf':\n        pdffile = outfigfile\n        pdfobj = PdfPages(pdffile)\n    elif outfigfile and figfiletyp=='pdfobj':\n        pdfobj = outfigfile\n\n    nn = 0\n    for pp in range(npages):\n        fig, axlst = plt.subplots(nrows,1)\n        if nrows==1: axlst = [axlst]\n        fig.subplots_adjust(hspace=0.25)\n        if fwidth is not None or fheight is not None:\n            fig.set_size_inches(fwidth, fheight)\n\n        for nr in range(nrows):\n            ii = pp*nrows + nr\n            if ii<nfigs:\n                csvfile = exists_csvfiles[ii]\n                ttl = exists_titles[ii]\n                ax = axlst[nr]\n                if (nr+1==nrows):\n                    add_xlbl = True\n                else:\n                    add_xlbl = False\n\n                kwds['title'] = ttl\n                kwds['add_xlbl'] = add_xlbl\n                kwds['report'] = report\n\n                thevz_dict = get_fscan_csvdata(csvfile)\n                ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\n                if not ierr:\n                    _plot_fscan_one(ax, hlst, zlst, **kwds)\n            else:\n                axlst[nr].set_visible(False)\n\n        if outfigfile:\n            if figfiletyp=='pdf':\n                pdfobj.savefig(fig, bbox_inches='tight')\n            elif figfiletyp=='pdfobj':\n                try:\n                    pdfobj.savefig(fig, bbox_inches='tight')\n                except:\n                    traceback.print_last()\n            else:\n                if npages>1:\n                    pn, x = os.path.splitext(outfigfile)\n                    zn = \"{}\".format(pp).zfill(2)\n                    tmpfnam = \"{}_{}{}\".format(pn,zn,x)\n                else:\n                    tmpfnam = outfigfile\n                fig.savefig(tmpfnam, bbox_inches='tight')\n\n    if outfigfile:\n        if figfiletyp=='pdf':\n            pdfobj.close()\n\n        if figfiletyp=='pdfobj':\n            plt.close(fig=fig)\n        else:\n            print(\" Plots saved: {}\".format(outfigfile))\n\n    if verbose:\n        if verbose_file:\n            verbose_fobj.close()\n\n    if figfiletyp!='pdfobj':\n        if flag_show:\n            plt.show()\n        else:\n            plt.close('all')\n\n#"
  },
  {
    "id": 258,
    "text": "def plot_distortion_volt_ieee519(csvfile, *buses, **kwds):\n    \"\"\"Plot Distortion Calculations Bus Voltages THD and Individual Harmonic levels with\n    IEEE 519 Voltage Distortion Limits.\n    Arguments:\n        csvfile (str): CSV file that contain Distortion Calculations Bus Voltages results.\n            This file is created by api psspy.har_export_dstn(..).\n            No default allowed.\n\n        buses (int): One or more Study Bus Numbers. THD and Individual harmonic levels are plotted\n            for these many buses when provided.\n            (default - consider all buses)\n\n        kwds (dict):  Followng are allowed key words.\n\n            (A) These keywords are for plot figure options.\n\n            figfiletyp (str)   : File type to which plots are saved.\n                                 ='pdfobj' -- files are saved to already created pdfobj\n                                 [Create pdfobj = PdfPages(pdffile). This is done so\n                                 as to save many plots to one pdffile.]\n                                 ='pdf', 'png', 'jpg' etc. [all allowed file types].\n                                 (default: '')\n            figfile (str)      : Name of the file or pdfobj to save plots\n                                 When file name is not provided plot is not saved.\n                                 (default: '')\n            flag_thd (bool)    : Flag (True or False), Option to plot THD of all study buses.\n                                 (default: True)\n            flag_indv (bool)   : Flag (True or False), Option to plot maximum individual harmonic levels\n                                 of all study buses. For each bus, maximum individual harmonic level among all\n                                 harmonic orders is found and plotted.\n                                 (default: True)\n            flag_busgrps (bool): Flag (True or False) Option to plot bus THD and INDV of bus groups.\n                                 True -- Group buses as per their nominal voltage and IEEE 519 - Table 1\n                                 voltage at PCC. Plot those bus groups in separate figures.\n                                 False -- Plot all buses in one figure.\n                                 (default: True)\n            plt_buses (list)   : List of bus numbers (subset of Study Bus Numbers) to plot harmonic distortions.\n                                 Bus THD and INDV harmonic distortions are plotted on the same figure.\n                                 A separate figure created for each bus.\n                                 Specify =[-1] or =-1 to plot all study buses.\n                                 (default: [])\n            flag_show (bool)   : Flag (True or False), Option to show plots on screen or not.\n                                 (default: True)\n            flag_xtick (bool)  : Flag (True or False), Option to Lable and Tick all X axis bus numbers.\n                                 (default: True). Set this false if plotting for many numbers. Plot\n                                 automatically assigns few labels and ticks in that case.\n    \"\"\"\n\n    import matplotlib.pyplot as plt\n    from matplotlib.backends.backend_pdf import PdfPages\n\n    if not os.path.exists(csvfile):\n        msg = \" Distortion Bus Volts file not found: {}\".format(csvfile)\n        print(msg)\n        return\n\n    volt_dict = get_dstn_csvdata_volt(csvfile)\n\n    # get organized Distortion results data\n    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)\n    if ierr==1:\n        msg = \" IEEE 519 Bus Groups not found in Distortion Bus Volts file: {}\".format(csvfile)\n        print(msg)\n        return\n\n    all_xnam = all_bus_xy['xnam']\n    all_xnum = range(len(all_xnam))\n\n    # separate groups and plot their bars so as to have ONE legend lable for a group\n    bar_grps = {}\n    for idx, xnum, thd, indv, indv_hord in zip(all_bus_xy['lmtidx'], all_xnum, all_bus_xy['thd'],\n                                               all_bus_xy['indv'], all_bus_xy['indv_hord']):\n        if idx not in bar_grps:\n            bar_grps[idx] = {'xnum':[], 'thd':[], 'indv':[], 'indv_hord':[]}\n        bar_grps[idx]['xnum'].append(xnum)\n        bar_grps[idx]['thd'].append(thd)\n        bar_grps[idx]['indv'].append(indv)\n        bar_grps[idx]['indv_hord'].append(indv_hord)\n\n    # preserve legend order\n    grpidx_ordr = list(bar_grps.keys())\n    grpidx_ordr.sort()\n\n    # Use outfigfile to save output figure file and\n    # also use its path to find csvfile when csvfile path is not provided.\n\n    figfiletyp = kwds.get('figfiletyp', '')\n    figfiletyp = figfiletyp.lower()\n\n    outfigfile = kwds.get('figfile', '')\n\n    flag_thd     = kwds.get('flag_thd', True)\n    flag_indv    = kwds.get('flag_indv', True)\n    flag_busgrps = kwds.get('flag_busgrps', False)\n    plt_buses    = kwds.get('plt_buses', [])\n    flag_show    = kwds.get('flag_show', True)\n    flag_xtick   = kwds.get('flag_xtick', True)\n\n    # validate plt_buses\n    ok_pltbus_list = []\n    if plt_buses:\n        bus_ok_dict = {}\n        for bus_sec, vdict in each_bus_xy.items():\n            bus, sec = bus_sec\n            if bus not in bus_ok_dict:\n                bus_ok_dict[bus] = []\n            bus_ok_dict[bus].append(bus_sec)\n\n        if type(plt_buses)==int:\n            buslst = [plt_buses]\n        elif type(plt_buses) in [list, tuple]:\n            buslst = plt_buses[:]\n        else:\n            buslst = []\n            msg = \" Invalid plt_buses={} specified, ignored. Individual Bus plots not done.\".format(plt_buses)\n            print(msg)\n\n        if len(buslst)==1 and buslst[0]==-1:\n            for bus in bus_ok_dict:\n                ok_pltbus_list.extend(bus_ok_dict[bus])\n        else:\n            buslst.sort()\n            for bus in buslst:\n                if bus not in bus_ok_dict:\n                    msg = \" Invalid plt_bus={}, ignored. Bus does not exist in results.\".format(bus)\n                    print(msg)\n                else:\n                    ok_pltbus_list.extend(bus_ok_dict[bus])\n\n    if outfigfile:\n        if figfiletyp=='pdfobj':\n            pass\n        else:\n            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)\n    else:\n        figfiletyp = ''\n\n    if outfigfile and figfiletyp=='pdf':\n        pdffile = outfigfile\n        pdfobj = PdfPages(pdffile)\n    elif outfigfile and figfiletyp=='pdfobj':\n        pdfobj = outfigfile\n\n    fignum = 0\n    if flag_thd:\n        bgn_allbus_thd = False\n        for idx in grpidx_ordr:\n            if flag_busgrps:\n                fignum += 1\n                fig = plt.figure(num=fignum)\n                ax = fig.add_subplot(111)\n                do_lbls = True\n            else:\n                if not bgn_allbus_thd:\n                    bgn_allbus_thd = True\n                    fignum += 1\n                    fig = plt.figure(num=fignum)\n                    ax = fig.add_subplot(111)\n                if idx==grpidx_ordr[-1]:\n                    do_lbls = True\n                else:\n                    do_lbls = False\n\n            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']\n            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\n            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']\n            lmt_hvdc = _ieee519_table1_thd_limits[lmtkv].get('thd_hvdc', 0.0)\n            if lmt_hvdc>0.0:\n                lbl = \"{} [{}] [with HVDC={}%]\".format(lmt_thd, lbl, lmt_hvdc)\n            else:\n                lbl = \"{} [{}]\".format(lmt_thd, lbl)\n            clr = _COLOR_PREFERENCE[idx]\n            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['thd'], width=0.1, label=lbl, color=clr)\n\n            # draw limit lines\n            ax.axhline(y=lmt_thd, color=clr, linestyle='--', linewidth=1.5)\n            if lmt_hvdc>0.0:\n                ax.axhline(y=lmt_hvdc, color=clr, linestyle='--', linewidth=1.5)\n\n            # labels and title\n            if do_lbls:\n                ttl = \" Voltage THD\"\n                ax.set_title(ttl)\n                ax.set_xlabel(\"Bus Numbers\")\n                ax.set_ylabel(\"% THD\")\n                if flag_xtick:\n                    ax.set_xticks(all_xnum, all_xnam)\n                h_lgd = ax.legend(title=\"IEEE 519 %THD Limits\")\n                h_lgd.get_frame().set_linewidth(0)\n                h_lgd.set_draggable(True)\n\n                if outfigfile:\n                    if figfiletyp=='pdf':\n                        pdfobj.savefig(fig, bbox_inches='tight')\n                    elif figfiletyp=='pdfobj':\n                        try:\n                            pdfobj.savefig(fig, bbox_inches='tight')\n                        except:\n                            traceback.print_last()\n                    else:\n                        pn, x = os.path.splitext(outfigfile)\n                        if flag_busgrps:\n                            tmpfnam = \"{}_thd_{}{}\".format(pn,idx,x)\n                        else:\n                            tmpfnam = \"{}_thd{}\".format(pn,x)\n                        fig.savefig(tmpfnam, bbox_inches='tight')\n\n    if flag_indv:\n        bgn_allbus_indv = False\n        for idx in grpidx_ordr:\n            if flag_busgrps:\n                fignum += 1\n                fig = plt.figure(num=fignum)\n                ax = fig.add_subplot(111)\n                do_lbls = True\n            else:\n                if not bgn_allbus_indv:\n                    bgn_allbus_indv = True\n                    fignum += 1\n                    fig = plt.figure(num=fignum)\n                    ax = fig.add_subplot(111)\n                if idx==grpidx_ordr[-1]:\n                    do_lbls = True\n                else:\n                    do_lbls = False\n\n            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']\n            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\n            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']\n            lbl     = \"{} [{}]\".format(lmt_indv, lbl)\n            clr = _COLOR_PREFERENCE[idx]\n            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['indv'], width=0.1, label=lbl, color=clr)\n\n            do_bar_lbl_nam = False\n            if flag_busgrps:\n                do_bar_lbl_nam = True\n            else:\n                if all_xnum[0]==bar_grps[idx]['xnum'][0]:\n                    do_bar_lbl_nam = True\n\n            lbls = []\n            for hord in bar_grps[idx]['indv_hord']:\n                if do_bar_lbl_nam:\n                    lbls.append(\"HORD={}\".format(int(hord)))\n                    do_bar_lbl_nam = False\n                else:\n                    lbls.append(\"{}\".format(int(hord)))\n            if flag_xtick:\n                ax.bar_label(h, labels=lbls, padding=2)\n\n            # draw limit lines\n            ax.axhline(y=lmt_indv, color=clr, linestyle='--', linewidth=1.5)\n\n            # labels and title\n            if do_lbls:\n                ttl = \" Voltage Individual Harmonic Levels (maximum)\"\n                ax.set_title(ttl)\n                ax.set_xlabel(\"Bus Numbers\")\n                ax.set_ylabel(\"% INDV\")\n                if flag_xtick:\n                    ax.set_xticks(all_xnum, all_xnam)\n                h_lgd = ax.legend(title=\"IEEE 519 %INDV Limits\")\n                h_lgd.get_frame().set_linewidth(0)\n                h_lgd.set_draggable(True)\n\n                if outfigfile:\n                    if figfiletyp=='pdf':\n                        pdfobj.savefig(fig, bbox_inches='tight')\n                    elif figfiletyp=='pdfobj':\n                        try:\n                            pdfobj.savefig(fig, bbox_inches='tight')\n                        except:\n                            traceback.print_last()\n                    else:\n                        pn, x = os.path.splitext(outfigfile)\n                        if flag_busgrps:\n                            tmpfnam = \"{}_indv_{}{}\".format(pn,idx,x)\n                        else:\n                            tmpfnam = \"{}_indv{}\".format(pn,x)\n                        fig.savefig(tmpfnam, bbox_inches='tight')\n\n    if ok_pltbus_list:\n        for bus_sec in ok_pltbus_list:\n            vdict = each_bus_xy[bus_sec]\n            xnam  = vdict['xnam']\n\n            idx     = vdict['lmtidx']\n            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\n            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']\n            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']\n\n            lbl_thd = \"%THD={}\".format(lmt_thd)\n            lbl_indv = \"%INDV={}\".format(lmt_indv)\n\n            fignum += 1\n            fig = plt.figure(num=fignum)\n            ax = fig.add_subplot(111)\n\n            clr_thd = _COLOR_PREFERENCE_BUS[0]\n            h = ax.bar(vdict['hord'][0], vdict['pct'][0], width=0.3, label=lbl_thd, color=clr_thd)\n\n            clr_indv = _COLOR_PREFERENCE_BUS[1]\n            h = ax.bar(vdict['hord'][1:], vdict['pct'][1:], width=0.3, label=lbl_indv, color=clr_indv)\n\n            # draw limit lines if any limit is violated\n            maxpct = max(vdict['pct'])\n            if maxpct>lmt_thd or maxpct>lmt_indv:\n                ax.axhline(y=lmt_thd,  color=clr_thd, linestyle='--', linewidth=1.5)\n                ax.axhline(y=lmt_indv, color=clr_indv, linestyle='--', linewidth=1.5)\n\n            ttl = \" Bus={}, Voltage THD and Individual Harmonic Levels\".format(xnam)\n            ax.set_title(ttl)\n            ax.set_xlabel(\"Harmonic Order\")\n            ax.set_ylabel(\"%THD and % INDV\")\n            if flag_xtick:\n                ax.set_xticks(vdict['hord'])\n            h_lgd = ax.legend(title=\"IEEE 519 Limits\")\n            h_lgd.get_frame().set_linewidth(0)\n            h_lgd.set_draggable(True)\n\n            if outfigfile:\n                if figfiletyp=='pdf':\n                    pdfobj.savefig(fig, bbox_inches='tight')\n                elif figfiletyp=='pdfobj':\n                    try:\n                        pdfobj.savefig(fig, bbox_inches='tight')\n                    except:\n                        traceback.print_last()\n                else:\n                    pn, x = os.path.splitext(outfigfile)\n                    tmpfnam = \"{}_thd_bus_{}{}\".format(pn,xnam,x)\n                    fig.savefig(tmpfnam, bbox_inches='tight')\n\n    if outfigfile:\n        if figfiletyp=='pdf':\n            pdfobj.close()\n\n        if figfiletyp=='pdfobj':\n            plt.close(fig=fig)\n        else:\n            if figfiletyp=='pdf':\n                print(\" Plots saved: {}\".format(outfigfile))\n            else:\n                pn, x = os.path.splitext(outfigfile)\n                print(\" Plots saved: {}..., File Type={}\".format(pn, x[1:]))\n\n    if figfiletyp!='pdfobj':\n        if flag_show:\n            plt.show()\n        else:\n            plt.close('all')\n\n#"
  },
  {
    "id": 259,
    "text": "def test1():\n    \"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\n    Uses Example folder files.\n    Compare PSSE and TF distortion calculation results.\n    \"\"\"\n    run_ieee_test()\n    compare_dstn_ieee_test()\n\ndef test1A():\n    \"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\n    Specify Load Models from API argument and specify them as inherit in harmonics data file.\n    Uses Example folder files.\n    \"\"\"\n    run_ieee_test_inherit()\n    compare_dstn_ieee_test(inherit=True)\n\ndef test1B():\n    \"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\n    Also specify thresholds to filter thevenin resonance frequencies.\n    Uses Example folder files.\n    \"\"\"\n    run_ieee_test_thevz_thresholds()\n\ndef test2():\n    \"\"\"Plot Harmonics Test PSSE Results.\n    Uses Example folder files.\n    \"\"\"\n    plot_fscan_ieee_test()\n\ndef test2A():\n    \"\"\"Plot Harmonics Test PSSE Results.\n    Also specify thresholds to filter thevenin resonance frequencies.\n    Uses Example folder files.\n    \"\"\"\n    plot_fscan_ieee_test(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0)\n\ndef test3(figfiletyp='pdf', flag_show=True):\n    \"\"\"Plot Harmonics Test PSSE and harmonics Task Force Results.\n    Also specify thresholds to filter thevenin resonance frequencies.\n    Plot Distortion Calculation Results.\n    Uses Example folder files.\n    \"\"\"\n    plot_fscan_ieee_test_tf_psse(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0, figfiletyp=figfiletyp, flag_show=flag_show)\n    plot_dstn_ieee_test_volt_ieee519(figfiletyp=figfiletyp, flag_show=flag_show)\n\ndef test3A():\n    \"\"\"Plot Harmonics Test PSSE and harmonics Task Force Results.\n    Uses Example folder files.\n    \"\"\"\n    plot_fscan_ieee_test_tf_psse()\n\ndef test4():\n    \"\"\"Run Harmonics Analysis on Example folder 'sample' case.\n    Output Reports created in Report Window\n    \"\"\"\n    workdir  = os.path.dirname(__file__)\n    datapath = workdir\n    savfile  = os.path.join(datapath, \"sample.sav\")\n    harfile  = os.path.join(datapath, \"sample_har.rawx\")\n    run_har_analysis(savfile, harfile=harfile)\n\ndef test5():\n    \"\"\"Run Harmonics Analysis on Example folder 'sample_zils' case.\n    Output Reports created in 'outpath' folder with savfile name used for file name prefix.\n    \"\"\"\n    workdir  = os.path.dirname(__file__)\n    datapath = workdir\n    savfile  = os.path.join(datapath, \"sample_zils.sav\")\n    harfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\n    outpath  = os.path.join(workdir,  \"output_harmonics_demo\", \"sample_zils\")\n    run_har_analysis(savfile, harfile=harfile, outpath=outpath)\n\ndef test6():\n    \"\"\"Run Harmonics Analysis on Example folder 'sample_nb' case.\n    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\n    \"\"\"\n    workdir  = os.path.dirname(__file__)\n    datapath = workdir\n    savfile  = os.path.join(datapath, \"sample_nb.sav\")\n    harfile  = os.path.join(datapath, \"sample_har.rawx\")\n    outfnam  = \"sample_nbXX\"\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", outfnam)\n    run_har_analysis(savfile, harfile=harfile, outpath=outpath, outfnam=outfnam)\n\ndef test7():\n    \"\"\"Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.\n    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\n    Also specified values to some API arguments.\n    \"\"\"\n    workdir  = os.path.dirname(__file__)\n    datapath = workdir\n    savfile  = os.path.join(datapath, \"sample_zils_nb_sec.sav\")\n    harfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec\")\n    run_har_analysis(savfile, harfile=harfile, outpath=outpath, linmdl=1,\n                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)\n\ndef test8():\n    \"\"\"Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.\n    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\n    Also specified values to some API arguments.\n    Do frequency scan on few buses.\n    \"\"\"\n    workdir  = os.path.dirname(__file__)\n    datapath = workdir\n    savfile  = os.path.join(datapath, \"sample_zils_nb_sec.sav\")\n    harfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\n    run_har_analysis(savfile, 101, 212, 154, harfile=harfile, outpath=outpath, linmdl=1,\n                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)\n\ndef test9():\n    \"\"\"Plot Frequency Scan, one file\n    \"\"\"\n    kwds = {}\n    kwds['basemva'] = 100.0\n    kwds['basekv']  = 21.6\n    kwds['basehz']  = 60.0\n    kwds['hmajor']  = []\n    kwds['ymajor']  = []\n    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)']\n    kwds['add_lgnd']= True\n    kwds['plotzpu'] = False\n    workdir  = os.path.dirname(__file__)\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\n    csvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")\n    kwds['figfile'] = os.path.join(outpath, \"fscan_bus101_ohms.png\")\n    kwds['flag_show'] = True\n    plot_frequency_scan(101, csvfile1, **kwds)\n\ndef test10():\n    \"\"\"Plot Frequency Scan, two files\n    \"\"\"\n    kwds = {}\n    kwds['basemva'] = 100.0\n    kwds['basekv']  = 21.6\n    kwds['basehz']  = 60.0\n    kwds['hmajor']  = []\n    kwds['ymajor']  = []\n    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']\n    kwds['add_lgnd']= True\n    kwds['plotzpu'] = False\n    workdir  = os.path.dirname(__file__)\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\n    csvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils\")\n    csvfile2 = os.path.join(outpath, \"sample_zils_fscan.csv\")\n    kwds['figfile'] = os.path.join(outpath, \"fscan_bus101_ohms.pdf\")\n    kwds['flag_show'] = True\n    plot_frequency_scan(101, csvfile1, csvfile2, **kwds)\n\ndef test11():\n    \"\"\"Plot Frequency Scan, two files, figfiletype=pdfobj\n    \"\"\"\n    from matplotlib.backends.backend_pdf import PdfPages\n\n    kwds = {}\n    kwds['basemva'] = 100.0\n    kwds['basekv']  = 21.6\n    kwds['basehz']  = 60.0\n    kwds['hmajor']  = []\n    kwds['ymajor']  = []\n    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']\n    kwds['add_lgnd']= True\n    kwds['plotzpu'] = False\n    workdir  = os.path.dirname(__file__)\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\n    csvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")\n    outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils\")\n    csvfile2 = os.path.join(outpath, \"sample_zils_fscan.csv\")\n\n    pdffile = os.path.join(outpath, \"fscan_bus101_ohms_2.pdf\")\n    pdfobj = PdfPages(pdffile)\n\n    kwds['figfiletyp'] = 'pdfobj'\n    kwds['figfile'] = pdfobj\n    kwds['flag_show'] = True\n\n    plot_frequency_scan(101, csvfile1, **kwds)\n    plot_frequency_scan(101, csvfile2, **kwds)\n\n    pdfobj.close()\n    print(\" Plots saved: {}\".format(pdffile))\n\n#"
  },
  {
    "id": 260,
    "text": "def _temp():\n    pass\n    # Available tests\n    # Note 1: Run tests 2, 2A, 3, 3A, 9, 10, 11 from outside of PSSE GUI.\n    # Note 2: Other tests can be run from inside as well as outside of PSSE GUI.\n    # Note 3: Copy and Modify test4() and later tests to use on any SAV and HAR files.\n    #\n    test1()    # (a) Run Harmonics Analysis using IEEE Test case\n               # (b) Compare PSSE and TF distortion calculation results\n    test1A()   # (a) Run Harmonics Analysis using IEEE Test case, but use inherit load model in data file\n               # (b) Compare PSSE and TF distortion calculation results\n    test1B()   # Run Harmonics Analysis using IEEE Test case and specify thresholds to filter thevenin resonance frequencies\n    test2()    # Plot IEEE Test case Frequency scan.\n    test2A()   # Plot IEEE Test case PSSE Results and specify thresholds to filter thevenin resonance frequencies\n    test3()    # (a) Plot Harmonics Test case PSSE and harmonics Task Force Frequency scan Results\n               #     with thresholds specified to filter thevenin resonance frequencies.\n               # (b) Plot distortion calculation results.\n    test3A()   # Plot IEEE Test case PSSE and harmonics Task Force Results (default thresholds)\n    test4()    # Run Harmonics Analysis on Example folder 'sample' case, Output Reports created in Report Window\n    test5()    # Run Harmonics Analysis on Example folder 'sample_zils' case, Output Reports created in files\n    test6()    # Run Harmonics Analysis on Example folder 'sample_nb' case\n    test7()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case\n    test8()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case and frequency scan on few buses\n    test9()    # Plot Frequency Scan, one file [sample_zils_nb_sec_few]\n    test10()   # Plot Frequency Scan, two files [sample_zils_nb_sec_fscan, sample_zils_fscan]\n    test11()   # Plot Frequency Scan, two files, figfiletype=pdfobj\n\n    # To compare PSSE and IEEE Test Case Results, run following tests.\n    test1()    # Run Analysis\n    test3()    # Write DSTN results comparison report, plot FSCAN TF and PSSE results, plot DSTN results\n    # or run test3() with\n    # figfiletyp as below, so as to create png file that can be inserted into DOC report\n    # flag_show as below to create and save plots to files, do not show plots to the screen\n    test3(figfiletyp='png')\n    test3(figfiletyp='png', flag_show=False)\n\n#"
  },
  {
    "id": 262,
    "text": "'''This is an example file showing how to use arrbox.harmonics module to post process\n   harmonic analysis results.\n\nHow to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\n    import psseXX\n\n- Refer ieee_test_pp function that shows\n    - how to get frequency scan results in python object\n    - how to get distortion calculation results in python object\n    - set desired voltage distortion limits\n    - create voltage distortion limits violations report\n    - plot and decorate frequency scan and voltage distortion results\n\n- Refer API manual arrbox > HAR_PP object for all available methods.\n'''\n\nimport os\nimport sys\n\n#"
  },
  {
    "id": 263,
    "text": "def ieee_test_pp(do_fscan_plts=False, do_dstn_plts=False, show_plts=False):\n    \"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\n    Uses Example folder files.\n    \"\"\"\n\n    # Use from Example folder to run har_analysis.\n    import harmonics_demo\n\n    import arrbox.harmonics\n\n    outpath = os.path.dirname(__file__)\n    outpath = os.path.join(outpath, \"output_har_demo_arrbox\")\n    if not os.path.exists(outpath): os.makedirs(outpath)\n\n    harmonics_demo.run_ieee_test(outpath=outpath)\n\n    outpath2 = os.path.join(outpath, \"har_pp\")\n    if not os.path.exists(outpath2): os.makedirs(outpath2)\n\n    prgfile = os.path.join(outpath2, \"ieee_test_har_demo_arrbox_progress.txt\")\n    prgfile_fobj = open(prgfile, 'w')\n    progress = prgfile_fobj.write\n\n    harobj = arrbox.harmonics.HAR_PP(progress=progress)\n\n    # Frequency Scan Results\n    ierr = harobj.fscan_obj()\n    fscanobj = harobj.fscan\n\n    buses = list(fscanobj.bus.keys())\n    progress(\"fscanobj.ierr={}\\n\".format(fscanobj.ierr))\n    progress(\"fscanobj.hord=\\n{}\\n\".format(fscanobj.hord))\n\n    for b in buses:\n        progress(\"Scanned Bus={}\\n\".format(b))\n        progress(\"{}\\n\".format(fscanobj['bus'][b].keys()))\n        progress(\"name={}, basekv={}\\n\".format(fscanobj.bus[b].name, fscanobj.bus[b].basekv))\n        progress(\"{}\\n\".format(fscanobj.bus[b].mag))\n        progress(\"{}\\n\".format(fscanobj.bus[b].phase))\n\n    # Distortion Calculation Results\n    ierr = harobj.dstn_obj()\n    dstn_vltobj = harobj.dstn.volt\n\n    progress(\"dstn_vltobj.keys()={}\\n\".format(dstn_vltobj.keys()))\n\n    progress(\"dstn_vltobj.thd.bus={}\\n{}\\n\".format(len(dstn_vltobj.thd.bus), dstn_vltobj.thd.bus))\n    progress(\"dstn_vltobj.thd.pct={}\\n{}\\n\".format(len(dstn_vltobj.thd.pct), dstn_vltobj.thd.pct))\n\n    progress(\"dstn_vltobj.indv.bus={}\\n{}\\n\".format(len(dstn_vltobj.indv.bus), dstn_vltobj.indv.bus))\n    progress(\"dstn_vltobj.indv.hord_max={}\\n{}\\n\".format(len(dstn_vltobj.indv.hord_max), dstn_vltobj.indv.hord_max))\n    progress(\"dstn_vltobj.indv.pct_max={}\\n{}\\n\".format(len(dstn_vltobj.indv.pct_max), dstn_vltobj.indv.pct_max))\n\n    progress(\"dstn_vltobj.bus.keys()={}\\n\".format(dstn_vltobj.bus.keys()))\n    buslist = harobj.dstn.volt.bus\n    for bus in buslist:\n        basekv = harobj.dstn.volt.bus[bus].basekv\n        lmt_thd = harobj.dstn.volt.bus[bus].lmt_thd\n        lmt_indv = harobj.dstn.volt.bus[bus].lmt_indv\n\n        vdict = harobj.dstn.volt.bus[bus].hord\n        for hord, vdc2 in  vdict.items():\n            vr, vx, vmag, vang, pct  = vdc2.vr,  vdc2.vx, vdc2.vmag,  vdc2.vang, vdc2.pct\n            txt = \"{}, {}, {}, {}, {}, {}, {}, basekv={}, lmt_indv={}, lmt_thd={}\\n\".\\\n                  format(bus, hord, vr, vx, vmag, vang, pct, basekv, lmt_indv, lmt_thd)\n            progress(txt)\n\n    harobj.show_vlt_dstn_limits()\n\n    vlmt_dict = harobj.get_vlt_dstn_limits()\n    progress(\"vlmt_dict\\n\")\n    for lmtkv, vdct in vlmt_dict.items():\n        progress(\"   key={}, value={}\\n\".format(lmtkv, vdct))\n    progress('\\n')\n\n    progress(\"\\nVoltage violations report - rptoptn=0\\n\")\n    harobj.report_vlt_dstn_limits_violations(rptfile=None)\n\n    progress(\"\\nVoltage violations report - rptoptn=1\\n\")\n    harobj.report_vlt_dstn_limits_violations(rptoptn=1, rptfile=None)\n\n    progress(\"\\nVoltage violations report - rptoptn=2\\n\")\n    harobj.report_vlt_dstn_limits_violations(rptoptn=2, rptfile=None)\n\n    prgfile_fobj.close()\n    print(\" Progress Saved to file: {}\".format(prgfile))\n\n    # Frequency Scan Plots\n    if do_fscan_plts:\n        if not harobj.fscan.ierr:\n            fig1, ax1 = harobj.plot_fscan_mag(3, color='r')\n            fig1.savefig(\"zz_001.png\")\n\n            fig1, ax1 = harobj.plot_fscan_mag(3, color='r', marker='D', markevery=(0, 0.2))\n            harobj.plot_decorate(ax1, xmin=10)\n            fig1.savefig(\"zz_001-1.png\")\n\n            harobj.plot_decorate(ax1, add_legend=True)\n\n            if show_plts:\n                harobj.plot_show()\n            else:\n                harobj.plot_close()\n\n    # Distortion Calculation Plots\n    if do_dstn_plts:\n        if not harobj.dstn.ierr:\n            pdffile = os.path.join(outpath2, 'zplt_dstn_1.pdf')\n            harobj.plot_pdf_open(pdffile)\n            fig1, ax1 = harobj.plot_vlt_dstn_thd(0, 1, optn_lmtgrp=True, optn_lmtlin=True)\n            #harobj.plot_decorate(ax1, add_legend=True)\n            #harobj.plot_decorate(ax1, add_legend=True, xticks='all')\n            harobj.plot_decorate(ax1, add_legend=True, xticks=[302, 301, 11, 3, 4])\n\n            fig2, ax2 = harobj.plot_vlt_dstn_indv(0, 1, optn_lmtgrp=True, optn_lmtlin=True)\n            harobj.plot_decorate(ax2, add_legend=True, xticks='all')\n\n            fig3, ax3 = harobj.plot_vlt_dstn_bus(1)\n            harobj.plot_decorate(ax3, xscale='log', yscale='log')\n\n            harobj.plot_pdf_add_figure(fig1, fig2, fig3)\n            harobj.plot_pdf_close()\n\n            figfile = os.path.join(outpath2, 'zplt_dstn_2.pdf')\n            harobj.plot_save(figfile, fig1, fig2)\n\n            figfile = os.path.join(outpath2, 'zplt21_dstn')\n            harobj.plot_save(figfile, fig1)\n\n            figfile = os.path.join(outpath2, 'zplt22_dstn')\n            harobj.plot_save(figfile, fig1, fig2)\n\n            figfile = os.path.join(outpath2, 'zplt23_dstn')\n            harobj.plot_save(figfile, fig1, fig2, fig3)\n\n            if show_plts:\n                harobj.plot_show()\n            else:\n                harobj.plot_close()\n\n#"
  },
  {
    "id": 266,
    "text": "'''\nThis file calculates 3 Phase Fault Currents for IEC Test Network (IEC 60909-4, Figure 16) by network reduction.\nRefer to Program Application Guide, Volume I, Chapter 10 for schematics and equations.\nIt uses network data from IEC 60909-4 Table 11.\nThis impedance data (corrected if necessary) of the electrical equipment\n(see figure 16) is referred to the 110 kV side. Z(2) = Z(1) = Z\nResults from these calculations are compared against results from PSS(R)E and those provided in\nIEC 60909-4 Table 12.\n'''\n\nimport os, math, time\nsqrt3 = math.sqrt(3.0)\nsbase = 100.0     # MVA\n\nstr_time = time.strftime(\"%Y%m%d_%H%M%S_\", time.localtime())\nfnamout  = str_time + 'iec60909_testnetwork_calculations.txt'\nfnamout  = os.path.join(os.getcwd(),fnamout)\nfoutobj  = open(fnamout,'w')\n\n#"
  },
  {
    "id": 267,
    "text": "def format_complex(v):\n    vre = v.real\n    vim = abs(v.imag)\n    if v.imag<0:\n        sgn = '-'\n    else:\n        sgn = '+'\n    retv = '%-10.6g %s j %-10.6g' % (vre, sgn, vim)\n    return retv\n\ndef format_z_ratio(vlst,method=None):\n    retvlst = []\n    for v in vlst:\n        vstr = format_complex(v)\n        xbyr = v.imag/v.real\n        if method=='C':\n            xbyr = xbyr/0.4\n        elif method=='DC':\n            xbyr = xbyr/0.055\n        retv = '%s, %-10.6g' % (vstr, xbyr)\n        retvlst.append(retv)\n    return retvlst\n\ndef print_complex(nam, v):\n    vstr = format_complex(v)\n    retv = '%-7s = %s\\n' % (nam, vstr)\n    #print retv.strip()\n    return retv\n\ndef print_impedance_xr_ratio(nam, v, adj=1.0):\n    vstr = format_complex(v)\n    xbyr = adj*v.imag/v.real\n    if adj!=1.0:\n        retv = '%-6s = %s  X/R adj = %-10.6g\\n' % (nam, vstr, xbyr)\n    else:\n        retv = '%-6s = %s  X/R     = %-10.6g\\n' % (nam, vstr, xbyr)\n    print(retv.strip())\n    return retv\n\ndef print_fault_current(nam,v):\n    vrect = format_complex(v)\n    vmag = abs(v)\n    vang = math.degrees(math.atan(v.imag/v.real))\n    #retv = '%-6s = %s    OR %-10.6g / %-5.2g deg\\n' % (nam, vrect, vmag, vang)\n    retv = '%-6s = %-10.6g\\n' % (nam, vmag)\n    print(retv.strip())\n    return retv\n\n#"
  },
  {
    "id": 268,
    "text": "def print_z():\n    dat_from_table11 = True\n    txt = ''\n    txt  += print_complex('zq1',    zq1)\n    txt  += print_complex('zq1t',   zq1t)\n    txt  += print_complex('zq2',    zq2)\n    txt  += print_complex('zt3amv', zt3amv)\n    txt  += print_complex('zt3bmv', zt3bmv)\n    txt  += print_complex('zt3cmv', zt3cmv)\n    txt  += print_complex('zt5mv',  zt5mv)\n    if not dat_from_table11:\n        txt  += print_complex('zt1mv',  zt1mv)\n        txt  += print_complex('zg1',    zg1)\n        txt  += print_complex('zg1t',   zg1t)\n    txt  += print_complex('zs1',     zs1)\n    if not dat_from_table11:\n        txt  += print_complex('zt2mv',  zt2mv)\n        txt  += print_complex('zg2',    zg2)\n        txt  += print_complex('zg2t',   zg2t)\n    txt  += print_complex('zs2',    zs2)\n    txt  += print_complex('zg3',    zg3)\n    txt  += print_complex('zg3t',   zg3t)\n    txt  += print_complex('zm1',    zm1)\n    txt  += print_complex('zm1t',   zm1t)\n    txt  += print_complex('zm2',    zm2)\n    txt  += print_complex('zm2t',   zm2t)\n    txt  += print_complex('zl1',    zl1)\n    txt  += print_complex('zl2',    zl2)\n    txt  += print_complex('zl3',    zl3)\n    txt  += print_complex('zl4',    zl4)\n    txt  += print_complex('zl5',    zl5)\n    txt  += print_complex('zl6',    zl6)\n    txt  += print_complex('zl6t',   zl6t)\n    return txt\n\ndef print_network_reduction_z(txstr,zdct):\n    for k,v in list(zdct.items()):\n        txstr += print_complex(k,v)\n    return txstr\n\n#"
  },
  {
    "id": 269,
    "text": "def table11_data(xftr,peak=False):\n    # peak = True, calculations are for Peak current, use Rgf for generators.\n    \n    global zq1, zq1t, zq2, zt3amv, zt3bmv, zt3cmv, zt5mv, zs1\n    global zs2, zg3, zg3t, zm1, zm1t, zm2, zm2t\n    global zl1, zl2, zl3, zl4, zl5, zl6, zl6t\n\n    # TABLE 11 Data\n    zq1    =  0.631933 +   6.319335j\n    zq1t   =  0.056874 +   0.568740j\n    zq2    =  0.434454 +   4.344543j\n\n    zt3amv =  0.045714 +   8.096989j\n    zt3bmv =  0.053563 -   0.079062j\n    zt3cmv =  0.408568 +  20.292035j\n\n    zt5mv  =  2.046454 +  49.072241j\n\n    # power station unit 1 data\n    #Ks       = 0.995975\n    #zg1t     = (0.059977324263+12.3433333333j)\n    #zg1t*Ks  = (0.0597359155329+12.2936514167j)\n    #zt1mv*Ks = (0.439058979167+14.0430253611j)\n    #zs1 = Ks*(zg1t + zt1mv) = (0.4987948947+26.3366767778j)\n\n    Ks1    =  0.995975\n    zg1    =  0.059977 +  12.343333j\n    zg1c   =  0.059736 +  12.293651j\n    zt1c   =  0.439059 +  14.043025j\n    #zs1    =  0.498795 +  26.336676j\n    zs1    =  zg1c + zt1c\n\n    # power station unit 2 data\n    #Ks       = 0.876832\n    #zg2t     = (0.65306122449+23.04j)\n    #zg2t*Ks  = (0.572624979592+20.20220928j)\n    #zt2mv*Ks = (0.63131904+15.1384987665j)\n    #zs2 = Ks*(zg2t + zt2mv) = (1.20394401959+35.3407080465j)\n\n    Ks2    =  0.876832\n    zg2    =  0.653061 +  23.04j\n    zg2c   =  0.572625 +  20.202214j\n    zt2c   =  0.631319 +  15.138499j\n    #zs2    =  1.203944 +  35.340713j\n    zs2    =  zg2c + zt2c\n\n    zg3    =  0.017790 +   1.089623j\n    zg3t   =  2.133964 + 130.705301j\n\n    zm1    =  0.341497 +   3.414968j\n    zm1t   = 40.964124 + 409.641243j\n    zm2    =  0.412137 +   4.121368j\n    zm2t   = 49.437719 + 494.377190j\n\n    zl1    = 2.4   + 7.8j\n    zl2    = 1.2   + 3.9j\n    zl3    = 0.3   + 0.975j\n    zl4    = 0.96  + 3.88j\n    zl5    = 1.8   + 5.79j\n    zl6    = 0.082 + 0.086j\n    zl6t   = 9.836281 + 10.316100j\n\n    # Fictitious resistances RGf may be used for the calculation of the peak short circuit current\n    # RGf = 0.05 X''d for generators with UrG > 1 kV and SrG >= 100 MVA\n    # RGf = 0.07 X''d for generators with UrG > 1 kV and SrG < 100 MVA\n    # RGf = 0.15 X''d for generators with UrG <= 1 000 V\n    if peak:\n        # G1 -> 150 MVA, 21 kV\n        # G2 -> 100 MVA, 10.5 kV\n        # RGf = 0.05 X''d\n        zg1  = complex(0.05*zg1.imag, zg1.imag)\n        zg1c = zg1*Ks1\n        zs1  = zg1c + zt1c\n\n        zg2  = complex(0.05*zg2.imag, zg2.imag)\n        zg2c = zg2*Ks2\n        zs2  = zg2c + zt2c\n\n        zg3  = complex(0.07*zg3.imag, zg3.imag)\n        zg3t = complex(0.07*zg3t.imag, zg3t.imag)\n\n    if xftr != 1.0:\n        zq1    = complex(zq1.real,    zq1.imag*xftr)\n        zq1t   = complex(zq1t.real,   zq1t.imag*xftr)\n        zq2    = complex(zq2.real,    zq2.imag*xftr)\n        zt3amv = complex(zt3amv.real, zt3amv.imag*xftr)\n        zt3bmv = complex(zt3bmv.real, zt3bmv.imag*xftr)\n        zt3cmv = complex(zt3cmv.real, zt3cmv.imag*xftr)\n        zt5mv  = complex(zt5mv.real,  zt5mv.imag*xftr)\n        zs1    = complex(zs1.real,    zs1.imag*xftr)\n        zs2    = complex(zs2.real,    zs2.imag*xftr)\n        zg3    = complex(zg3.real,    zg3.imag*xftr)\n        zg3t   = complex(zg3t.real,   zg3t.imag*xftr)\n        zm1    = complex(zm1.real,    zm1.imag*xftr)\n        zm1t   = complex(zm1t.real,   zm1t.imag*xftr)\n        zm2    = complex(zm2.real,    zm2.imag*xftr)\n        zm2t   = complex(zm2t.real,   zm2t.imag*xftr)\n        zl1    = complex(zl1.real,    zl1.imag*xftr)\n        zl2    = complex(zl2.real,    zl2.imag*xftr)\n        zl3    = complex(zl3.real,    zl3.imag*xftr)\n        zl4    = complex(zl4.real,    zl4.imag*xftr)\n        zl5    = complex(zl5.real,    zl5.imag*xftr)\n        zl6    = complex(zl6.real,    zl6.imag*xftr)\n        zl6t   = complex(zl6t.real,   zl6t.imag*xftr)\n\n#"
  },
  {
    "id": 270,
    "text": "def parallel(zp,zq):\n    return (zp*zq)/(zp+zq)\n\ndef calculate_3ph_fault_zthev():\n    # Reduction at Bus 5\n    z7g  = parallel(zm1t, zm2t)\n    z6g1 = zl6t + z7g\n    z6g2 = parallel(zg3t, z6g1)\n    z56  = zt5mv/2.0\n    z5g1 = z56 + z6g2\n    z5g2 = parallel(zq2, z5g1)\n\n    rdzstr = ''\n    rdzstr = print_network_reduction_z(rdzstr,{'z7g':z7g, 'z6g1':z6g1, 'z6g2':z6g2, 'z56':z56, 'z5g1':z5g1, 'z5g2':z5g2})\n\n    # Reduction at Bus 2\n    z12t3   = zt3amv + zt3bmv\n    z12t3t4 = z12t3/2.0\n    z2g1    = zq1t + z12t3t4\n    \n    rdzstr = print_network_reduction_z(rdzstr,{'z12t3':z12t3, 'z12t3t4':z12t3t4, 'z2g1':z2g1})\n\n    # delta to star of buses 2, 3, 5, star point=N1\n    zden1 = zl1 + zl3 + zl4\n    za    = (zl1*zl3) / zden1\n    zb    = (zl1*zl4) / zden1\n    zc    = (zl3*zl4) / zden1\n\n    rdzstr = print_network_reduction_z(rdzstr,{'za':za, 'zb':zb, 'zc':zc})\n\n    # star to delta of buses N1, 3, 4, and ground\n    znum1 = zb*zs2 + zb*zl2 + zs2*zl2\n    zd = znum1/zs2\n    ze = znum1/zl2\n    zf = znum1/zb\n\n    rdzstr = print_network_reduction_z(rdzstr,{'zd':zd, 'ze':ze, 'zf':zf})\n\n    # delta to star of buses N1, 4, 5, star point=N2\n    zden2 = zc + zd + zl5\n    zg    = (zc*zd)  / zden2\n    zh    = (zd*zl5) / zden2\n    zi    = (zc*zl5) / zden2\n\n    rdzstr = print_network_reduction_z(rdzstr,{'zg':zg, 'zh':zh, 'zi':zi})\n\n    # Zthev at Bus 4\n    z1    = z2g1 + za\n    z2    = parallel(z1, ze)\n    z3    = z2 + zg\n    z4    = zi + z5g2\n    z5    = parallel(z3, z4)\n    z6    = z5 + zh\n    z7    = parallel(z6,zf)\n    zthv4 = parallel(z7, zs1)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'z1':z1, 'z2':z2, 'z3':z3, 'z4':z4, 'z5':z5, 'z6':z6, 'z7':z7})\n\n    # Zthev at Bus 5\n    z8    = parallel(zs1,zf)\n    z9    = z8 + zh\n    z10   = parallel(z3,z9)\n    z11   = zi + z10\n    zthv5 = parallel(z11, z5g2)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'z8':z8, 'z9':z9, 'z10':z10, 'z11':z11})\n\n    # Zthev at Bus 2\n    z12   = parallel(z4,z9)\n    z13   = z12 + zg\n    z14   = parallel(z13,ze)\n    z15   = za + z14\n    zthv2 = parallel(z15, z2g1)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'z12':z12, 'z13':z13, 'z14':z14, 'z15':z15})\n\n    # Zthev at Bus 1\n    z16   = z15 + z12t3t4\n    z17   = z16*(400.*400.)/(120.*120.)\n    zthv1 = parallel(z17, zq1)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'z16':z16, 'z17':z17})\n\n    # Zthev at Bus 6\n    zt5lv = zt5mv*(10.5*10.5)/(115.0*115.0)\n    z21   = parallel(z11, zq2)\n    z21lv = z21*(10.5*10.5)/(115.0*115.0)\n    z22   = z21lv + zt5lv*0.5\n    z24   = parallel(zm1, zm2)\n    z25   = zl6 + z24\n    z26   = parallel(zg3, z25)\n    zthv6 = parallel(z22, z26)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'zt5lv':zt5lv, 'z21':z21, 'z21lv':z21lv, 'z22':z22, 'z24':z24, 'z25':z25, 'z26':z26})\n\n    # Zthev at Bus 7\n    z27   = parallel(z22, zg3)\n    z28   = z27 + zl6\n    zthv7 = parallel(z28, z24)\n\n    rdzstr = print_network_reduction_z(rdzstr,{'z27':z27, 'z28':z28})\n\n    zthev = [zthv1, zthv2, zthv4, zthv5, zthv6, zthv7]\n    \n    return zthev, rdzstr\n\n#"
  },
  {
    "id": 271,
    "text": "def calculate_3ph_fault_ik(zthev):\n\n    zthv1 = zthev[0]\n    zthv2 = zthev[1]\n    zthv4 = zthev[2]\n    zthv5 = zthev[3]\n    zthv6 = zthev[4]\n    zthv7 = zthev[5]\n\n    vflt = 1.1*110.0/sqrt3\n    if2   = vflt/zthv2\n    if4   = vflt/zthv4\n    if5   = vflt/zthv5\n\n    vflt1 = 1.1*380.0/sqrt3\n    if1   = vflt1/zthv1\n\n    vfl67 = 1.1*10.0/sqrt3\n    if6   = vfl67/zthv6\n    if7   = vfl67/zthv7\n\n    ik = [if1, if2, if4, if5, if6, if7]\n    return ik\n\n#"
  },
  {
    "id": 272,
    "text": "def calculate_k_factor_method_B(bus,zc):\n    r = zc.real\n    x = zc.imag\n    rx = r/x\n    rbyx = -3.0*rx\n    k = 1.02 + 0.98*math.exp(rbyx)\n    if bus==7: k = k*1.15   # add safety factor for bus 7 faults\n    if k>2.0: k=2.0\n    return k    \n    \ndef calculate_k_factor_method_C(zc):\n    r = zc.real\n    x = zc.imag\n    rx = r/x\n    rbyx = 0.4*rx\n    rbyx = -3.0*rbyx\n    k = 1.02 + 0.98*math.exp(rbyx)\n    #print 'K factor for r/x=%f, is k=%f' % (rbyx,k)\n    return k\n\ndef calculate_ip(buslst,iklst,zclst,method):\n    klst  = []\n    iplst = []\n    for bus,ik,zc in zip(buslst,iklst,zclst):\n        ik = abs(ik)\n        if method=='B':\n            k  = calculate_k_factor_method_B(bus,zc)\n        if method=='C':\n            k  = calculate_k_factor_method_C(zc)\n        ip = k*math.sqrt(2.0)*ik\n        klst.append(k)\n        iplst.append(ip)\n\n    return klst, iplst\n\ndef back_calculate_k(iklst,iplst):\n    klst = []\n    for ik,ip in zip(iklst,iplst):\n        # ip=k*sprt(2)*ik\n        k = ip/(math.sqrt(2)*ik)\n        klst.append(k)\n    return klst\n\ndef calculate_idc(iklst,zlst):\n    # idc = sprt(2)*ik*e^(-2piftR/X)\n    idclst = []\n    for ik,z in zip(iklst,zlst):\n        r = z.real\n        x = z.imag\n        rx = r/x\n        rx = 0.055*rx\n        rbyx = -2.0*math.pi*50.0*0.1*rx\n        k = math.exp(rbyx)\n        idc = math.sqrt(2)*abs(ik)*k\n        #print 'dc component: z, k, abs(ik), idc = ',z,k,abs(ik),idc\n        idclst.append(idc)\n    return idclst\n    \n#"
  },
  {
    "id": 273,
    "text": "foutobj.write('IEC 60909-4:2000 Figure 16 (Page 121) 3-phase Fault Calculations with Network reduction')\nfoutobj.write(' '+time.asctime())\nfoutobj.write('\\n')\n\nbuses = [1,2,4,5,6,7]\n\n# Base frequency calculations\nxftr = 1.0\ntable11_data(xftr)\nbase_z = print_z()\n\nzthev_bas, rdzstr_bas = calculate_3ph_fault_zthev()\n\nik_bas = calculate_3ph_fault_ik(zthev_bas)\n\n# Method B\n# Method B peak currents are worse (compared to results in standard) when Rgf is used.\n#xftr = 1.0\n#table11_data(xftr,peak=True)\n#mthdB_z = print_z()\n#zthev_b, rdzstr_b = calculate_3ph_fault_zthev()\n#k_b, ip_b = calculate_ip(buses,ik_bas,zthev_b,method='B')\nk_b, ip_b = calculate_ip(buses,ik_bas,zthev_bas,method='B')\n\n# Method C\nxftr = 20.0/50.0\ntable11_data(xftr,peak=True)\nmthdC_z = print_z()\n\nzthev_c, rdzstr_c = calculate_3ph_fault_zthev()\nk_c, ip_c = calculate_ip(buses,ik_bas,zthev_c,method='C')\n\n# DC Component\n# tmin=0.1 s, f*t = 50*0.1 = 5, fc/f=0.055\nxftr = 0.055\ntable11_data(xftr,peak=False)\ndc_z = print_z()\n\nzthev_dc, rdzstr_dc = calculate_3ph_fault_zthev()\nidc_cal = calculate_idc(ik_bas,zthev_dc)\n\n# Table 12 from Standard\nik1_tbl12   = 40.6447\nip1_b_tbl12 = 100.5766\nip1_c_tbl12 = 100.5677\nib1_tbl12   = 40.645\n\nik2_tbl12   = 31.7831\nip2_b_tbl12 = 80.8249\nip2_c_tbl12 = 80.6079\nib2_tbl12   = 31.570\n\nik4_tbl12   = 16.2277\nip4_b_tbl12 = 36.8041\nip4_c_tbl12 = 36.8427\nib4_tbl12   = 16.017\n\nik5_tbl12   = 33.1894\nip5_b_tbl12 = 83.6266\nip5_c_tbl12 = 83.4033\nib5_tbl12   = 32.795\n\nik6_tbl12   = 37.5629\nip6_b_tbl12 = 99.1910\nip6_c_tbl12 = 98.1434\nib6_tbl12   = 34.028\n\nik7_tbl12   = 25.5895\nip7_b_tbl12 = 51.3864*1.15\nip7_c_tbl12 = 51.6899\nib7_tbl12   = 23.212\n\nik_tbl12   = [ik1_tbl12,   ik2_tbl12,   ik4_tbl12,   ik5_tbl12,   ik6_tbl12,   ik7_tbl12  ] \nip_b_tbl12 = [ip1_b_tbl12, ip2_b_tbl12, ip4_b_tbl12, ip5_b_tbl12, ip6_b_tbl12, ip7_b_tbl12] \nip_c_tbl12 = [ip1_c_tbl12, ip2_c_tbl12, ip4_c_tbl12, ip5_c_tbl12, ip6_c_tbl12, ip7_c_tbl12] \nib_tbl12   = [ib1_tbl12,   ib2_tbl12,   ib4_tbl12,   ib5_tbl12,   ib6_tbl12,   ib7_tbl12  ] \n\nk_b_tbl12  = back_calculate_k(ik_tbl12,ip_b_tbl12)\nk_c_tbl12  = back_calculate_k(ik_tbl12,ip_c_tbl12)\n\n# PSS(R)E Results\n# Bus Nums      1        2        4        5        6       7\nik_psse  = [ 40.6447, 31.7830, 16.2277, 33.1894, 37.5628, 25.5894]\nipb_psse = [100.5766, 80.5119, 36.8041, 83.6265, 99.1908, 59.0943]\nipc_psse = [100.5676, 80.6079, 36.8427, 83.4033, 98.1432, 51.6898]\nidc_psse = [  2.7396, 12.7917,  2.6296,  3.9796, 15.1072,  0.0671]\nibs_psse = [ 40.6426, 31.5777, 16.0211, 32.8065, 34.0131, 23.1936]\niba_psse = [ 40.7348, 34.0702, 16.2354, 33.0470, 37.2171, 23.1937]\n\n# Print Base frequency and Method C impedances\nbase_z_lst  = base_z.split('\\n')\nmthdC_z_lst = mthdC_z.split('\\n')\ndc_z_lst = dc_z.split('\\n')\n\nrdzstr_bas_lst = rdzstr_bas.split('\\n')\nrdzstr_c_lst   = rdzstr_c.split('\\n')\nrdzstr_dc_lst  = rdzstr_dc.split('\\n')\n\nhdr = r\"\"\"NETWORK ELEMENT IMPEDANCES in OHMS (COMPARE this to TABLE 11, PP 127)\n|"
  },
  {
    "id": 274,
    "text": "BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\n\nfor v1,v2,v3 in zip(base_z_lst, mthdC_z_lst,dc_z_lst):\n    if not v1: continue\n    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\\n'\n    foutobj.write(txt)\n    \n\nhdr = r\"\"\"\nNETWORK REDUCTION  CALCULATION IMPEDANCES in OHMS \n|"
  },
  {
    "id": 275,
    "text": "BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\n\nfor v1,v2,v3 in zip(rdzstr_bas_lst, rdzstr_c_lst, rdzstr_dc_lst):\n    if not v1: continue\n    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\\n'\n    foutobj.write(txt)\n\nhdr = r\"\"\"\nThevenin Impedance in OHMS calculated with NETWORK REDUCTION (R+jX, X/R ratio)\n|BUS| |"
  },
  {
    "id": 276,
    "text": "BASE FREQUENCY --------|    |   |----- METHOD C FREQ (fc/f=0.4)----|    |   |---- DC COMPONENT (fc/f=0.055)----|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\n\nzstrlst_bas = format_z_ratio(zthev_bas)\nzstrlst_c   = format_z_ratio(zthev_c,method='C')\nzstrlst_dc  = format_z_ratio(zthev_dc,method='DC')\nfor b,zstr, zstr_c, zstr_dc in zip(buses,zstrlst_bas,zstrlst_c,zstrlst_dc):\n    foutobj.write('  %d    %s       %s       %s' % (b, zstr, zstr_c, zstr_dc))\n    foutobj.write('\\n')\n\nhdr =\"\"\"\n METHOD        BUS    I\"k       K ip(50)     ip(50)     K ip(20)     ip(20)      Ib dc\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\n\nfor b1,ik,kb,ipb,kc,ipc,idc,ik_t,kb_t,ipb_t,kc_t,ipc_t,ik_e,ipb_e,ipc_e,idc_e in zip(buses, ik_bas, k_b, ip_b, k_c, ip_c, idc_cal,\n                                                            ik_tbl12, k_b_tbl12, ip_b_tbl12, k_c_tbl12, ip_c_tbl12,\n                                                            ik_psse, ipb_psse, ipc_psse, idc_psse):\n    ikabs = abs(ik)\n    s1    = ' '\n    lin1 = \" CALCULATED   %(b1)3d   %(ikabs)-10.4f   %(kb)-10.4f %(ipb)-10.4f   %(kc)-10.4f %(ipc)-10.4f   %(idc)-10.4f\" % vars()\n    lin2 = \" PSS(R)E      %(s1)3s   %(ik_e)-10.4f   %(s1)10s %(ipb_e)-10.4f   %(s1)10s %(ipc_e)-10.4f   %(idc_e)-10.4f\" % vars()\n    lin3 = \" STANDARD     %(s1)3s   %(ik_t)-10.4f   %(kb_t)-10.4f %(ipb_t)-10.4f   %(kc_t)-10.4f %(ipc_t)-10.4f\" % vars()\n    foutobj.write(lin1)\n    foutobj.write('\\n')\n\n    foutobj.write(lin2)\n    foutobj.write('\\n')\n\n    foutobj.write(lin3)\n    foutobj.write('\\n\\n')\n\nfoutobj.close()    \n\nmsg = \" Results saved in file: %s\" % fnamout\nprint(msg)\n#"
  },
  {
    "id": 278,
    "text": "'''There are three different ways to calculate faults using IECS.\n1) Using activity IECS (psspy.iecs_4)\n   Runs all types of faults, creates text reports, but no access to results from Python script.\n\n2) Using Python module arrbox.iecs.iecs_currents\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain both phase and sequence fault currents.\n       b) contain faults currents for bus faults only.\n       c) does not contain faults currents for linout and linend faults.\n\n3) Using Python module arrbox.fault.FAULT_SUMMARY\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain only total fault currents for faults calculated.\n       b) contain faults currents for bus, linout and linend faults.\n\nThis is an example file showing how to run IECS fault calculations using either of these methods."
  },
  {
    "id": 279,
    "text": "How to use this file?\n\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\n    import psseXX\n    [Here XX is PSSE major version number.]\n\nB) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.\n    run_iecs_4(..)\n    run_iecs_currents_txtrpt(..)\n    run_iecs_currents_xls(..)\n    run_fault_summary_iecs(..)\n\n    Run either of these functions under  __main__ to see how they work.\n\nC) Create similar functions for the network case and faults you want to run.\n\n'''\n#"
  },
  {
    "id": 280,
    "text": "#\n\"\"\"\nUse any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default   Description\n                    # STATUS array\nflt3ph   = 0        # 1 0=>omit, 1=>include\nfltlg    = 0        # 2 0=>omit, 1=>include\nfltllg   = 0        # 3 0=>omit, 1=>include\nfltll    = 0        # 4 0=>omit, 1=>include\nrptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl   = 0        # 6  number of contribution levels\nfltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,\n                    #    2=>AUX.XMER (connected to power station unit) LV bus\nlinout   = 0        # 8  0=>omit, 1=>include\nlinend   = 0        # 9  0=>omit, 1=>include\ntpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,\n                    #    3=>N unchanged and phi=0\nlnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,\n                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\ndcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\ncfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,\n                    #    2=>User specified, maximum current, 3=>User specified, minimum current\nloadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\ngenxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs\n                    # VALUES array\nbrktime  = 0.1      # 0.1 seconds, breaker contact parting time\nucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)\n                    # File args\niecfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n\n#"
  },
  {
    "id": 281,
    "text": "import sys, os, time, math\n\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n             'owners':[], 'zones':[]}\n\ndef fault_bsys(sid, **kwds):\n    import psspy\n\n    if sid==0: return\n\n    actv_kwds = {}  # activity keywords\n    for k, v in bsys_kwds.items():\n        if k in kwds:\n            actv_kwds[k] = kwds[k]\n        else:\n            actv_kwds[k] = v\n\n    actv_kwds['sid']      = sid\n    actv_kwds['numarea']  = len(actv_kwds['areas'])\n    actv_kwds['numbus']   = len(actv_kwds['buses'])\n    actv_kwds['numowner'] = len(actv_kwds['owners'])\n    actv_kwds['numzone']  = len(actv_kwds['zones'])\n\n    ierr = psspy.bsys(**actv_kwds)\n\n    return ierr\n\n#"
  },
  {
    "id": 285,
    "text": "def _frmted_z(self, cnum):\n        r=cnum.real\n        x=cnum.imag\n        csign='+j'\n        if x<0:\n            csign='-j'\n            x=abs(x)\n\n        if r==0:\n            rstr=''\n        else:\n            rstr=\"%9.6f\" % r\n\n        if x==0:\n            xstr=''\n            csign=''\n        else:\n            xstr=\"%9.6f\" % x\n\n        zstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\n\n        return zstr\n\n    #"
  },
  {
    "id": 288,
    "text": "def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\n        if scfmt=='rectangular':\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n            crnt = abs(crnt)\n        else:\n            cval = cval.real\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n\n        mva  = math.sqrt(3.0)*basekv*crnt/1000.0\n\n        return crnt, mva\n\n    #"
  },
  {
    "id": 291,
    "text": "def run_fault_summary(self, sid, allbus, **kwds):\n        import psspy, arrbox.fault\n\n        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)\n\n        if fltobj.ierr!=0:\n            raise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\n\n        return fltobj\n\n    #"
  },
  {
    "id": 292,
    "text": "def report_iecs_currents(self, rlst, rptfile=''):\n        import psspy\n\n        if rlst.ierr: return\n\n        if rptfile:\n            p, nx = os.path.split(rptfile)\n            n, x = os.path.splitext(nx)\n            if not x:\n                x = '.txt'\n                nx = n + x\n            if p:\n                rptfile = os.path.join(p, nx)\n            else:\n                rptfile = os.path.join(os.getcwd(), nx)\n            rptfile_h = open(rptfile,'w')\n            report    = rptfile_h.write\n        else:\n            psspy.beginreport()\n            report = psspy.report\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        nfbus=len(rlst.fltbus)\n\n        txtlst = []\n        if not rptfile: txtlst.append('')\n\n        ttlstr=\"PSS(R)E IECS SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\n        ln1str,ln2str=psspy.titldt()\n        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))\n        txtlst.append(ttlstr.center(maxlen))\n        txtlst.append(ln1str.center(maxlen))\n        txtlst.append(ln2str.center(maxlen))\n        txtlst.append('')\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        scunit = rlst.scunit\n        scfmt  = rlst.scfmt\n\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        if scunit == 'pu':\n            units = 'PU'\n        else:\n            units = 'AMP'\n        unitstr   = units.center(10)\n        clnhdr    = \"   BUS     \" + 6*unitstr\n\n        for i in range(nfbus):\n            txtlst = []\n            txtlst.append('')\n            txtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\n            txtlst.append(clnhdr)\n            fbus   = rlst.fltbus[i]\n            if flt3ph:\n                ttxt   = \"%6d\" % fbus\n                spc    = '3PH'\n                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltlg:\n                if flt3ph:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = ' LG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltllg:\n                if flt3ph or fltlg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = 'LLG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltll:\n                if flt3ph or fltlg or fltllg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc     = ' LL'\n                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            txtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\n\n            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\n            z1str =\"Z1: \" + z1str\n            if fltlg or fltllg or fltll:\n                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\n                z2str =\"Z2: \" + z2str\n                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\n                z0str =\"Z0: \" + z0str\n                tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n            else:\n                tmptxt=\"%(z1str)s\" % vars()\n            txtlst.append(tmptxt)\n\n            if scunit_z!='pu':\n                txtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\n                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\n                z1str =\"Z1: \" + z1str\n                if fltlg or fltllg or fltll:\n                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\n                    z2str =\"Z2: \" + z2str\n                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\n                    z0str =\"Z0: \" + z0str\n                    tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n                else:\n                    tmptxt=\"%(z1str)s\" % vars()\n                txtlst.append(tmptxt)\n\n            tmptxt=110*'-'\n            txtlst.append(tmptxt)\n            txtlst.append('')\n\n            txtall = \"\\n\".join(txtlst)\n            report(txtall)\n\n        # Maximum Fault Currents\n        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\n        unitstr   = units.center(11)\n        unitstr = ''\n        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\n            t = each+'('+units+')'\n            t = ' ' + t.center(9) + ' '\n            unitstr += t\n\n        txtlst = []\n        txtlst.append('')\n\n        clnhdr    = \"   BUS  \" + unitstr + \"  Description\"\n        txtlst.append(\"BREAKER DUTY CURRENTS\")\n        txtlst.append(clnhdr)\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        for i in range(nfbus):\n            fbus   = rlst.fltbus[i]\n            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\n            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\n            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\n            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\n            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\n            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\n            dsc    = rlst.maxfltdsc[i]\n            if rptfile: report('\\n')\n            tmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\n            report(tmptxt)\n\n        #"
  },
  {
    "id": 294,
    "text": "def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):\n        import psspy\n        import excelpy\n\n        if rlst.ierr: return\n\n        # bus data\n        sid  = -1   # consider subsystem of all buses\n        flag = 1    # consider only in-service buses\n        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\n        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\n        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\n        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\n\n        bus_data = {}\n        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\n            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        scunit   = rlst.scunit\n        scfmt    = rlst.scfmt\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        nfbus=len(rlst.fltbus)\n\n        xlswbk = excelpy.workbook(xlsfile)\n        xlswbk.show()\n\n        savfile, snpfile = psspy.sfiles()\n        line1, line2 = psspy.titldt()\n\n        ttl      = r\"PSSE Short Circuit Calculations Using IECS\"\n        ttl      = ttl + 5*' ' + time.ctime()\n        ttl_file = savfile\n        ttl_line1= line1.strip()\n        ttl_line2= line2.strip()\n\n        cln_mrglst = []\n        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\n        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\n        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\n            if fltok:\n                cln_mrglst.append(len(cln_heads_r1)+1)\n                cln_heads_r1.extend([clnnam, ''])\n                cln_heads_r2.extend(['MVA', 'AMP'])\n\n        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\n        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\n\n        colheads = [cln_heads_r1, cln_heads_r2]\n\n        row = 7\n        cln = 1\n\n        sbase = psspy.sysmva()\n\n        for i in range(nfbus):\n            rowdata = []\n            fbus    = rlst.fltbus[i]\n            basekv  = bus_data[fbus]['basekv']\n            prefltv = bus_data[fbus]['prefltv']\n\n            rowdata.append(fbus)\n            rowdata.append(bus_data[fbus]['name'])\n            rowdata.append(basekv)\n            rowdata.append(basekv*abs(prefltv))\n\n            if flt3ph:\n                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            if fltlg:\n                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltllg:\n                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltll:\n                cval = rlst.fltll[i].ib   # Ifault=Ib\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            zpos  = rlst.thevzpu[i].z1\n            zneg  = rlst.thevzpu[i].z2\n            zzero = rlst.thevzpu[i].z0\n\n            s_zpos  = self._frmted_z(zpos)\n            s_zneg  = self._frmted_z(zneg)\n            s_zzero = self._frmted_z(zzero)\n\n            rowdata.extend([s_zpos, s_zneg, s_zzero])\n\n            brow,rcln = xlswbk.set_range(row,cln,rowdata)\n            row = brow + 1\n\n        xlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\n        xlswbk.autofit_columns((6,9,brow,rcln))\n        xlswbk.align((6,9,brow,rcln),'right')\n\n        # headings and column titles\n        xlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n        xlswbk.merge((1,1,1,rcln))\n\n        xlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((2,1,2,rcln))\n\n        xlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((3,1,3,rcln))\n\n        xlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((4,1,4,rcln))\n\n        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\n\n        xlswbk.merge((5,1,5,2))\n        for cln in cln_mrglst:\n            xlswbk.merge((5,cln,5,cln+1))\n        xlswbk.merge((5,rcln-2,5,rcln))\n\n        xlswbk.align((1,1),'h_center')\n        xlswbk.align_rows((1,1,6,1),'h_center')\n\n        if xlsfile: xlswbk.save(xlsfile)\n\n#"
  },
  {
    "id": 296,
    "text": "def _get_outpath():\n    import psspy\n    \n    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()\n    s_mjr = \"{}\".format(mjr)\n    s_mnr = \"{}\".format(mnr)\n    s_pch = \"{}\".format(pch)\n    vnam = \"v{}{}{}\".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))\n    outnam = \"output_iecs_demo_{}\".format(vnam)\n    \n    outpath = os.path.join(os.getcwd(), outnam)\n    if not os.path.exists(outpath): os.makedirs(outpath)\n    \n    return outpath\n    \n#"
  },
  {
    "id": 297,
    "text": "def _get_iec60909_network_files():\n    savfile = 'iec60909_testnetwork_50Hz.sav'\n    iecfile = 'iec60909_testnetwork.iec'\n    \n    if not os.path.exists(savfile):\n        examdir = _get_exam_path()\n        savfile = os.path.join(examdir, savfile)\n        iecfile = os.path.join(examdir, iecfile)\n        if not os.path.exists(savfile):\n            msg = \" IEC 60909 Network case not found.\\n    {}\".format(savfile)\n            print(msg)\n            raise Exception(\" Case File not found\")\n\n    return savfile, iecfile\n\n#"
  },
  {
    "id": 298,
    "text": "def run_iecs_4(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    set_prg_rpt(rptfile=rptfile)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    iecsobj.run_iecs_api(sid, allbus, **kwds)\n\n    reset_prg_rpt()\n\n#"
  },
  {
    "id": 299,
    "text": "def run_iecs_currents_txtrpt(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iecs_currents_{}.txt\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\n    iecsobj.report_iecs_currents(rlst, rptfile)\n\n#"
  },
  {
    "id": 300,
    "text": "def run_iecs_currents_xls(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    xlsfile = \"z_iecs_currents_{}\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    xlsfile = os.path.join(outpath, xlsfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\n    iecsobj.excel_iecs_currents(rlst, xlsfile)\n\n#"
  },
  {
    "id": 301,
    "text": "def run_fault_summary_iecs(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iecs_fault_summary_{}.txt\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n##    kwds = {\n##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,\n##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,\n##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,\n##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,\n##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)\n    fltobj.text_report(rptfile)\n\n#"
  },
  {
    "id": 302,
    "text": "# IEC 60909 Test Network - Compare PSSE Results  \ndef run_iec60909_test_network():\n    # Results output of following run_iecs_4(..)\n    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.\n    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)\n    \n#"
  },
  {
    "id": 303,
    "text": "def _temp():\n    # Run either of these functions under  __main__ to see how they work.\n    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n\n    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\n\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\n\n    run_iec60909_test_network()\n\n#"
  },
  {
    "id": 305,
    "text": "'''There are three different ways to calculate faults using IECS.\n1) Using activity IECS (psspy.iecs_4)\n   Runs all types of faults, creates text reports, but no access to results from Python script.\n\n2) Using Python module arrbox.iecs.iecs_currents\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain both phase and sequence fault currents.\n       b) contain faults currents for bus faults only.\n       c) does not contain faults currents for linout and linend faults.\n\n3) Using Python module arrbox.fault.FAULT_SUMMARY\n   Runs all types of faults, creates text reports and returns results in python object that can be\n   accessed from Python script.\n   The returned python object\n       a) contain only total fault currents for faults calculated.\n       b) contain faults currents for bus, linout and linend faults.\n\nThis is an example file showing how to run IECS fault calculations using either of these methods."
  },
  {
    "id": 306,
    "text": "How to use this file?\n\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\n    import psseXX\n    [Here XX is PSSE major version number.]\n\nB) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.\n    run_iecs_4(..)\n    run_iecs_currents_txtrpt(..)\n    run_iecs_currents_xls(..)\n    run_fault_summary_iecs(..)\n\n    Run either of these functions under  __main__ to see how they work.\n\nC) Create similar functions for the network case and faults you want to run.\n\n'''\n#"
  },
  {
    "id": 307,
    "text": "#\n\"\"\"\nUse any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default   Description\n                    # STATUS array\nflt3ph   = 0        # 1 0=>omit, 1=>include\nfltlg    = 0        # 2 0=>omit, 1=>include\nfltllg   = 0        # 3 0=>omit, 1=>include\nfltll    = 0        # 4 0=>omit, 1=>include\nrptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl   = 0        # 6  number of contribution levels\nfltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,\n                    #    2=>AUX.XMER (connected to power station unit) LV bus\nlinout   = 0        # 8  0=>omit, 1=>include\nlinend   = 0        # 9  0=>omit, 1=>include\ntpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,\n                    #    3=>N unchanged and phi=0\nlnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,\n                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\ndcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\ncfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,\n                    #    2=>User specified, maximum current, 3=>User specified, minimum current\nloadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\ngenxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs\n                    # VALUES array\nbrktime  = 0.1      # 0.1 seconds, breaker contact parting time\nucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)\n                    # File args\niecfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n\n#"
  },
  {
    "id": 308,
    "text": "import sys, os, time, math\n\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n             'owners':[], 'zones':[]}\n\ndef fault_bsys(sid, **kwds):\n    import psspy\n\n    if sid==0: return\n\n    actv_kwds = {}  # activity keywords\n    for k, v in bsys_kwds.items():\n        if k in kwds:\n            actv_kwds[k] = kwds[k]\n        else:\n            actv_kwds[k] = v\n\n    actv_kwds['sid']      = sid\n    actv_kwds['numarea']  = len(actv_kwds['areas'])\n    actv_kwds['numbus']   = len(actv_kwds['buses'])\n    actv_kwds['numowner'] = len(actv_kwds['owners'])\n    actv_kwds['numzone']  = len(actv_kwds['zones'])\n\n    ierr = psspy.bsys(**actv_kwds)\n\n    return ierr\n\n#"
  },
  {
    "id": 312,
    "text": "def _frmted_z(self, cnum):\n        r=cnum.real\n        x=cnum.imag\n        csign='+j'\n        if x<0:\n            csign='-j'\n            x=abs(x)\n\n        if r==0:\n            rstr=''\n        else:\n            rstr=\"%9.6f\" % r\n\n        if x==0:\n            xstr=''\n            csign=''\n        else:\n            xstr=\"%9.6f\" % x\n\n        zstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\n\n        return zstr\n\n    #"
  },
  {
    "id": 315,
    "text": "def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\n        if scfmt=='rectangular':\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n            crnt = abs(crnt)\n        else:\n            cval = cval.real\n            if scunit=='pu':\n                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\n                crnt = cval*baseamp\n            else:\n                crnt = cval\n\n        mva  = math.sqrt(3.0)*basekv*crnt/1000.0\n\n        return crnt, mva\n\n    #"
  },
  {
    "id": 318,
    "text": "def run_fault_summary(self, sid, allbus, **kwds):\n        import psspy, arrbox.fault\n\n        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)\n\n        if fltobj.ierr!=0:\n            raise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\n\n        return fltobj\n\n    #"
  },
  {
    "id": 319,
    "text": "def report_iecs_currents(self, rlst, rptfile=''):\n        import psspy\n\n        if rlst.ierr: return\n\n        if rptfile:\n            p, nx = os.path.split(rptfile)\n            n, x = os.path.splitext(nx)\n            if not x:\n                x = '.txt'\n                nx = n + x\n            if p:\n                rptfile = os.path.join(p, nx)\n            else:\n                rptfile = os.path.join(os.getcwd(), nx)\n            rptfile_h = open(rptfile,'w')\n            report    = rptfile_h.write\n        else:\n            psspy.beginreport()\n            report = psspy.report\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        nfbus=len(rlst.fltbus)\n\n        txtlst = []\n        if not rptfile: txtlst.append('')\n\n        ttlstr=\"PSS(R)E IECS SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\n        ln1str,ln2str=psspy.titldt()\n        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))\n        txtlst.append(ttlstr.center(maxlen))\n        txtlst.append(ln1str.center(maxlen))\n        txtlst.append(ln2str.center(maxlen))\n        txtlst.append('')\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        scunit = rlst.scunit\n        scfmt  = rlst.scfmt\n\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        if scunit == 'pu':\n            units = 'PU'\n        else:\n            units = 'AMP'\n        unitstr   = units.center(10)\n        clnhdr    = \"   BUS     \" + 6*unitstr\n\n        for i in range(nfbus):\n            txtlst = []\n            txtlst.append('')\n            txtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\n            txtlst.append(clnhdr)\n            fbus   = rlst.fltbus[i]\n            if flt3ph:\n                ttxt   = \"%6d\" % fbus\n                spc    = '3PH'\n                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltlg:\n                if flt3ph:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = ' LG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltllg:\n                if flt3ph or fltlg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc    = 'LLG'\n                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            if fltll:\n                if flt3ph or fltlg or fltllg:\n                    ttxt = 6*' '\n                else:\n                    ttxt = \"%6d\" % fbus\n                spc     = ' LL'\n                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\n                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\n                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\n                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\n                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\n                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\n                tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\n                txtlst.append(tmptxt)\n\n            txtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\n\n            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\n            z1str =\"Z1: \" + z1str\n            if fltlg or fltllg or fltll:\n                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\n                z2str =\"Z2: \" + z2str\n                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\n                z0str =\"Z0: \" + z0str\n                tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n            else:\n                tmptxt=\"%(z1str)s\" % vars()\n            txtlst.append(tmptxt)\n\n            if scunit_z!='pu':\n                txtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\n                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\n                z1str =\"Z1: \" + z1str\n                if fltlg or fltllg or fltll:\n                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\n                    z2str =\"Z2: \" + z2str\n                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\n                    z0str =\"Z0: \" + z0str\n                    tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\n                else:\n                    tmptxt=\"%(z1str)s\" % vars()\n                txtlst.append(tmptxt)\n\n            tmptxt=110*'-'\n            txtlst.append(tmptxt)\n            txtlst.append('')\n\n            txtall = \"\\n\".join(txtlst)\n            report(txtall)\n\n        # Maximum Fault Currents\n        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\n        unitstr   = units.center(11)\n        unitstr = ''\n        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\n            t = each+'('+units+')'\n            t = ' ' + t.center(9) + ' '\n            unitstr += t\n\n        txtlst = []\n        txtlst.append('')\n\n        clnhdr    = \"   BUS  \" + unitstr + \"  Description\"\n        txtlst.append(\"BREAKER DUTY CURRENTS\")\n        txtlst.append(clnhdr)\n        txtall = \"\\n\".join(txtlst)\n        report(txtall)\n\n        for i in range(nfbus):\n            fbus   = rlst.fltbus[i]\n            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\n            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\n            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\n            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\n            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\n            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\n            dsc    = rlst.maxfltdsc[i]\n            if rptfile: report('\\n')\n            tmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\n            report(tmptxt)\n\n        #"
  },
  {
    "id": 321,
    "text": "def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):\n        import psspy\n        import excelpy\n\n        if rlst.ierr: return\n\n        # bus data\n        sid  = -1   # consider subsystem of all buses\n        flag = 1    # consider only in-service buses\n        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\n        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\n        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\n        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\n\n        bus_data = {}\n        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\n            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\n\n        flt3ph = rlst.flt3ph\n        fltlg  = rlst.fltlg\n        fltllg = rlst.fltllg\n        fltll  = rlst.fltll\n\n        scunit   = rlst.scunit\n        scfmt    = rlst.scfmt\n        scunit_z = rlst.scunit_z\n        scfmt_z  = rlst.scfmt_z\n\n        nfbus=len(rlst.fltbus)\n\n        xlswbk = excelpy.workbook(xlsfile)\n        xlswbk.show()\n\n        savfile, snpfile = psspy.sfiles()\n        line1, line2 = psspy.titldt()\n\n        ttl      = r\"PSSE Short Circuit Calculations Using IECS\"\n        ttl      = ttl + 5*' ' + time.ctime()\n        ttl_file = savfile\n        ttl_line1= line1.strip()\n        ttl_line2= line2.strip()\n\n        cln_mrglst = []\n        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\n        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\n        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\n            if fltok:\n                cln_mrglst.append(len(cln_heads_r1)+1)\n                cln_heads_r1.extend([clnnam, ''])\n                cln_heads_r2.extend(['MVA', 'AMP'])\n\n        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\n        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\n\n        colheads = [cln_heads_r1, cln_heads_r2]\n\n        row = 7\n        cln = 1\n\n        sbase = psspy.sysmva()\n\n        for i in range(nfbus):\n            rowdata = []\n            fbus    = rlst.fltbus[i]\n            basekv  = bus_data[fbus]['basekv']\n            prefltv = bus_data[fbus]['prefltv']\n\n            rowdata.append(fbus)\n            rowdata.append(bus_data[fbus]['name'])\n            rowdata.append(basekv)\n            rowdata.append(basekv*abs(prefltv))\n\n            if flt3ph:\n                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            if fltlg:\n                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltllg:\n                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([3*mva, 3*crnt])\n\n            if fltll:\n                cval = rlst.fltll[i].ib   # Ifault=Ib\n                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\n                rowdata.extend([mva, crnt])\n\n            zpos  = rlst.thevzpu[i].z1\n            zneg  = rlst.thevzpu[i].z2\n            zzero = rlst.thevzpu[i].z0\n\n            s_zpos  = self._frmted_z(zpos)\n            s_zneg  = self._frmted_z(zneg)\n            s_zzero = self._frmted_z(zzero)\n\n            rowdata.extend([s_zpos, s_zneg, s_zzero])\n\n            brow,rcln = xlswbk.set_range(row,cln,rowdata)\n            row = brow + 1\n\n        xlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\n        xlswbk.autofit_columns((6,9,brow,rcln))\n        xlswbk.align((6,9,brow,rcln),'right')\n\n        # headings and column titles\n        xlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n        xlswbk.merge((1,1,1,rcln))\n\n        xlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((2,1,2,rcln))\n\n        xlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((3,1,3,rcln))\n\n        xlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\n        xlswbk.merge((4,1,4,rcln))\n\n        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\n\n        xlswbk.merge((5,1,5,2))\n        for cln in cln_mrglst:\n            xlswbk.merge((5,cln,5,cln+1))\n        xlswbk.merge((5,rcln-2,5,rcln))\n\n        xlswbk.align((1,1),'h_center')\n        xlswbk.align_rows((1,1,6,1),'h_center')\n\n        if xlsfile: xlswbk.save(xlsfile)\n\n#"
  },
  {
    "id": 323,
    "text": "def _get_outpath():\n    import psspy\n    \n    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()\n    s_mjr = \"{}\".format(mjr)\n    s_mnr = \"{}\".format(mnr)\n    s_pch = \"{}\".format(pch)\n    vnam = \"v{}{}{}\".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))\n    outnam = \"output_iecs_demo_{}\".format(vnam)\n    \n    outpath = os.path.join(os.getcwd(), outnam)\n    if not os.path.exists(outpath): os.makedirs(outpath)\n    \n    return outpath\n    \n#"
  },
  {
    "id": 324,
    "text": "def _get_iec60909_network_files():\n    savfile = 'iec60909_testnetwork_50Hz.sav'\n    iecfile = 'iec60909_testnetwork.iec'\n    \n    if not os.path.exists(savfile):\n        examdir = _get_exam_path()\n        savfile = os.path.join(examdir, savfile)\n        iecfile = os.path.join(examdir, iecfile)\n        if not os.path.exists(savfile):\n            msg = \" IEC 60909 Network case not found.\\n    {}\".format(savfile)\n            print(msg)\n            raise Exception(\" Case File not found\")\n\n    return savfile, iecfile\n\n#"
  },
  {
    "id": 325,
    "text": "def run_iecs_4(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    set_prg_rpt(rptfile=rptfile)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    iecsobj.run_iecs_api(sid, allbus, **kwds)\n\n    reset_prg_rpt()\n\n#"
  },
  {
    "id": 326,
    "text": "def run_iecs_currents_txtrpt(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iecs_currents_{}.txt\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\n    iecsobj.report_iecs_currents(rlst, rptfile)\n\n#"
  },
  {
    "id": 327,
    "text": "def run_iecs_currents_xls(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    xlsfile = \"z_iecs_currents_{}\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    xlsfile = os.path.join(outpath, xlsfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\n    iecsobj.excel_iecs_currents(rlst, xlsfile)\n\n#"
  },
  {
    "id": 328,
    "text": "def run_fault_summary_iecs(**kwds):\n    import psspy\n    psspy.psseinit(buses=150000)\n\n    savfile, iecfile = _get_iec60909_network_files()\n\n    buses = [1,2,3,4,5,6,7,8]\n    sid, allbus = 3, 0\n\n    nam_unt = {0:'pu', 1:'amp'}\n    unt=1\n\n    rptfile = \"z_iecs_fault_summary_{}.txt\".format(nam_unt[unt])\n    outpath = _get_outpath()\n    rptfile = os.path.join(outpath, rptfile)\n\n    ierr = psspy.case(savfile)\n    ierr = fault_bsys(sid, buses=buses)\n\n    # set short circuit options\n    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical\n    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\n    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\n    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\n    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n\n##    kwds = {\n##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,\n##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,\n##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,\n##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,\n##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }\n\n    kwds['iecfile'] = iecfile\n    iecsobj = IECS_DEMO()\n    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)\n    fltobj.text_report(rptfile)\n\n#"
  },
  {
    "id": 329,
    "text": "# IEC 60909 Test Network - Compare PSSE Results  \ndef run_iec60909_test_network():\n    # Results output of following run_iecs_4(..)\n    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.\n    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)\n    \n#"
  },
  {
    "id": 330,
    "text": "def _temp():\n    # Run either of these functions under  __main__ to see how they work.\n    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n\n    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\n\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\n    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\n\n    run_iec60909_test_network()\n\n#"
  },
  {
    "id": 332,
    "text": "'''\nThis is an example file showing how to use \"iecs_currents\" function from pssarrays module.\n\nIECS_CURRENTS function returns IEC 60909 standard fault currents for each faulted bus and\neach type of fault applied. They are:\n    ia1   = Positive Sequence Current\n    ia2   = Negative Sequence Current\n    ia0   = Zero Sequence Current\n    ia    = Phase A current\n    ib    = Phase B current\n    ic    = Phase C current\n    ipb   = peak Current - Method B, ip(B)\n    ipc   = peak Current - Method C, ip(C)\n    idc   = DC component of asymmetrical breaking current, idc\n    ibsym = symmetrical breaking current (r.m.s.), ib(sym)\n    ibuns = asymmetrical breaking current (r.m.s.), ib(uns)\n\nThe APIs used in this program are part of python \"pssarrays\" module."
  },
  {
    "id": 333,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psse35\n\n- call funtion\n    run_iecs_report()\n\n    You may want to change inputs specified in this function.\n    run_iecs_report(savfile, iecfile, fltbuses, rptfile)\n    Defaults:\n        savfile  = 'iec60909_testnetwork_50Hz.sav'\n        iecfile  = 'iec60909_testnetwork.iec'\n        fltbuses = [1,2,3,4,5,6,7,8]\n        rptfile  = 'iecs_report_iec60909_testnetwork_50Hz.txt'\n                   When this script is called from PSSE's Example Folder,\n                   report is created in subfolder 'Output_Pyscript'\n'''\n\n#"
  },
  {
    "id": 335,
    "text": "def encode_complex_number_xbyr(cnum):\n    r=cnum.real\n    x=cnum.imag\n    csign='+j'\n    if x<0:\n        csign='-j'\n        x=abs(x)\n\n    if r==0:\n        rstr=''\n        xbyr=''\n    else:\n        rstr=\"%9.6f\" % r\n        xbyr=\"%9.6f\" % (x/r)\n\n    if x==0:\n        xstr=''\n        csign=''\n    else:\n        xstr=\"%9.6f\" % x\n\n    cstr=\"%(rstr)s%(csign)s%(xstr)s, %(xbyr)s\" % vars()\n\n    return cstr\n\n#"
  },
  {
    "id": 337,
    "text": "def create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,\n                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,\n                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):\n\n    import psspy, arrbox.iecs\n\n    # open case\n    if savfile: psspy.case(savfile)\n\n    # set sc units and format\n    psspy.short_circuit_units(units)\n    psspy.short_circuit_coordinates(fmt)\n\n    sid = 3\n    if fltbuses:\n        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])\n        busall = 0\n    else:\n        busall = 1\n\n    # call pssarrays routine\n    rlst=arrbox.iecs.iecs_currents(sid=sid, all=busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,\n            fltll=fltll, linout=linout, linend=linend, tpunty=tpunty, lnchrg=lnchrg,\n            shntop=shntop, dcload=dcload, zcorec= zcorec, optnftrc=optnftrc, loadop=loadop,\n            genxop=genxop, brktime=brktime, vfactorc=vfactorc,\n            iecfile=iecfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)\n    if rlst.ierr!=0:\n        raise Exception(\"arrbox.iecs.iecs_currents error= %d\\n\" % rlst.ierr)\n\n    if rptfile:\n        p, nx = os.path.split(rptfile)\n        n, x = os.path.splitext(nx)\n        if not x:\n            x = '.txt'\n            nx = n + x\n        if p:\n            rptfile = os.path.join(p, nx)\n        else:\n            rptfile = os.path.join(os.getcwd(), nx)\n        rptfile_h = open(rptfile,'w')\n        report    = rptfile_h.write\n    else:\n        psspy.beginreport()\n        report = psspy.report\n\n    nfbus=len(rlst.fltbus)\n\n    ttlstr=\"PSS(R)E IEC 60909 SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\n    ln1str,ln2str=psspy.titldt()\n    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))\n    report(ttlstr.center(maxlen))\n    report(\"\\n\")\n    report(ln1str.center(maxlen))\n    report(\"\\n\")\n    report(ln2str.center(maxlen))\n    report(\"\\n\\n\")\n\n    scunit = rlst.scunit\n    scfmt  = rlst.scfmt\n    if scunit == 'pu':\n        units = 'PU'\n    else:\n        units = 'AMP'\n    unitstr   = units.center(10)\n    clnhdr    = \"   BUS     \" + 6*unitstr + \"\\n\"\n\n    for i in range(nfbus):\n        report(\"           <-i''k--> <-ip(B)-> <-ip(C)-> <--idc--> <ib(sym)> <ib(uns)>\\n\")\n        report(clnhdr)\n        fbus   = rlst.fltbus[i]\n        if flt3ph:\n            ttxt   = \"%6d\" % fbus\n            spc    = '3PH'\n            ia1    = current_magnitude(scfmt,rlst.flt3ph[i].ia1)\n            ia2    = current_magnitude(scfmt,rlst.flt3ph[i].ia2)\n            ia0    = current_magnitude(scfmt,rlst.flt3ph[i].ia0)\n            ia     = current_magnitude(scfmt,rlst.flt3ph[i].ia)\n            ib     = current_magnitude(scfmt,rlst.flt3ph[i].ib)\n            ic     = current_magnitude(scfmt,rlst.flt3ph[i].ic)\n            ipb    = current_magnitude(scfmt,rlst.flt3ph[i].ipb)\n            ipc    = current_magnitude(scfmt,rlst.flt3ph[i].ipc)\n            idc    = current_magnitude(scfmt,rlst.flt3ph[i].idc)\n            ibsym  = current_magnitude(scfmt,rlst.flt3ph[i].ibsym)\n            ibuns  = current_magnitude(scfmt,rlst.flt3ph[i].ibuns)\n            tmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltlg:\n            if flt3ph:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc    = ' LG'\n            ia1    = current_magnitude(scfmt,rlst.fltlg[i].ia1)\n            ia2    = current_magnitude(scfmt,rlst.fltlg[i].ia2)\n            ia0    = current_magnitude(scfmt,3*rlst.fltlg[i].ia0)\n            ia     = current_magnitude(scfmt,rlst.fltlg[i].ia)\n            ib     = current_magnitude(scfmt,rlst.fltlg[i].ib)\n            ic     = current_magnitude(scfmt,rlst.fltlg[i].ic)\n            ipb    = current_magnitude(scfmt,rlst.fltlg[i].ipb)\n            ipc    = current_magnitude(scfmt,rlst.fltlg[i].ipc)\n            idc    = current_magnitude(scfmt,rlst.fltlg[i].idc)\n            ibsym  = current_magnitude(scfmt,rlst.fltlg[i].ibsym)\n            ibuns  = current_magnitude(scfmt,rlst.fltlg[i].ibuns)\n            tmptxt = \"%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltllg:\n            if flt3ph or fltlg:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc    = 'LLG'\n            ia1    = current_magnitude(scfmt,rlst.fltllg[i].ia1)\n            ia2    = current_magnitude(scfmt,rlst.fltllg[i].ia2)\n            ia0    = current_magnitude(scfmt,3*rlst.fltllg[i].ia0)\n            ia     = current_magnitude(scfmt,rlst.fltllg[i].ia)\n            ib     = current_magnitude(scfmt,rlst.fltllg[i].ib)\n            ic     = current_magnitude(scfmt,rlst.fltllg[i].ic)\n            ipb    = current_magnitude(scfmt,rlst.fltllg[i].ipb)\n            ipc    = current_magnitude(scfmt,rlst.fltllg[i].ipc)\n            idc    = current_magnitude(scfmt,rlst.fltllg[i].idc)\n            ibsym  = current_magnitude(scfmt,rlst.fltllg[i].ibsym)\n            ibuns  = current_magnitude(scfmt,rlst.fltllg[i].ibuns)\n            tmptxt = \"%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        if fltll:\n            if flt3ph or fltlg or fltllg:\n                ttxt = 6*' '\n            else:\n                ttxt = \"%6d\" % fbus\n            spc     = ' LL'\n            ia1    = current_magnitude(scfmt,rlst.fltll[i].ia1)\n            ia2    = current_magnitude(scfmt,rlst.fltll[i].ia2)\n            ia0    = current_magnitude(scfmt,rlst.fltll[i].ia0)\n            ia     = current_magnitude(scfmt,rlst.fltll[i].ia)\n            ib     = current_magnitude(scfmt,rlst.fltll[i].ib)\n            ic     = current_magnitude(scfmt,rlst.fltll[i].ic)\n            ipb    = current_magnitude(scfmt,rlst.fltll[i].ipb)\n            ipc    = current_magnitude(scfmt,rlst.fltll[i].ipc)\n            idc    = current_magnitude(scfmt,rlst.fltll[i].idc)\n            ibsym  = current_magnitude(scfmt,rlst.fltll[i].ibsym)\n            ibuns  = current_magnitude(scfmt,rlst.fltll[i].ibuns)\n            tmptxt = \"%(ttxt)s %(spc)s %(ib)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\n            report(tmptxt)\n\n        report(\"\\nTHEVENIN IMPEDANCE (pu), X/R\\n\")\n        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)\n        z1str =\"Z1: \" + z1str\n        if fltlg or fltllg or fltll:\n            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)\n            z2str =\"Z2: \" + z2str\n            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)\n            z0str =\"Z0: \" + z0str\n            tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\n        else:\n            tmptxt=\"%(z1str)s\\n\" % vars()\n        report(tmptxt)\n\n        if scunit != 'pu':\n            report(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\\n\")\n            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)\n            z1str =\"Z1: \" + z1str\n            if fltlg or fltllg or fltll:\n                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)\n                z2str =\"Z2: \" + z2str\n                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)\n                z0str =\"Z0: \" + z0str\n                tmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\n            else:\n                tmptxt=\"%(z1str)s\\n\" % vars()\n            report(tmptxt)\n\n        tmptxt=110*'-'\n        report(tmptxt)\n        report(\"\\n\")\n\n    # Maximum Fault Currents\n    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\n    unitstr   = units.center(11)\n    unitstr = ''\n    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\n        t = each+'('+units+')'\n        t = ' ' + t.center(9) + ' '\n        unitstr += t\n\n    clnhdr    = \"   BUS  \" + unitstr + \"  Description\\n\"\n    report(\"\\nBREAKER DUTY CURRENTS\\n\")\n    report(clnhdr)\n    for i in range(nfbus):\n        fbus   = rlst.fltbus[i]\n        ia1    = current_magnitude(scfmt,rlst.maxflt[i].ia1)\n        ia2    = current_magnitude(scfmt,rlst.maxflt[i].ia2)\n        ia0    = current_magnitude(scfmt,rlst.maxflt[i].ia0)\n        ia     = current_magnitude(scfmt,rlst.maxflt[i].ia)\n        ib     = current_magnitude(scfmt,rlst.maxflt[i].ib)\n        ic     = current_magnitude(scfmt,rlst.maxflt[i].ic)\n        dsc    = rlst.maxfltdsc[i]\n        tmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\\n\" % vars()\n        report(tmptxt)\n\n    #"
  },
  {
    "id": 339,
    "text": "def check_psse_example_folder(rptfile):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n    rptpath, rptfnam = os.path.split(rptfile)\n    if not rptpath:\n        rptpath = os.getcwd()\n        cwd = rptpath.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n        else:\n            outdir = os.getcwd()\n        rptfile  = os.path.join(outdir, rptfnam)\n\n    return rptfile\n\n#"
  },
  {
    "id": 340,
    "text": "def run_iecs_report(savfile='iec60909_testnetwork_50Hz.sav', iecfile='iec60909_testnetwork.iec',\n                    fltbuses=[1,2,3,4,5,6,7,8], rptfile='iecs_report_iec60909_testnetwork_50Hz.txt'):\n\n    import psspy\n\n    psspy.psseinit()\n\n    # Inputs, change as required\n\n    units    = 1       # 0=per unit,    1=physical\n    fmt      = 0       # 0=rectangular, 1=polar coordinates\n\n    flt3ph   = 1       #\n    fltlg    = 1       #\n    fltllg   = 1       #\n    fltll    = 1       #\n    linout   = 0       #\n    linend   = 0       #\n    tpunty   = 0       #\n    lnchrg   = 1       #\n    shntop   = 1       #\n    dcload   = 0       #\n    zcorec   = 0       #\n    optnftrc = 0       #\n    loadop   = 1       #\n    genxop   = 0       # 0=X\", 1=X', 2=Xs (generator reactance)\n\n    brktime  = 0.1     # 0.1 seconds\n    vfactorc = 1.0     #\n\n    rptfile  = check_psse_example_folder(rptfile)\n\n    fcdfile  = \"\"\n    scfile   = \"\"\n\n    rprtyp   = -1      # no report\n    rprlvl   = 0       # number of contribution levels\n\n    create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,\n                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,\n                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)\n\n#"
  },
  {
    "id": 345,
    "text": "def get_nlevel_buses(homebus, nlevels):\n    \"\"\"\n    Python Syntax:\n        lvl_busdict = get_nlevel_buses(savfile, homebus, nlevels)\n\n    Arguments:\n        homebus(integer) : Home (starting) bus number to start finding next buses\n        nlevels(integer) : Number of levels of buses from Home Bus\n    \"\"\"\n    import psspy\n    psspy.psseinit()\n\n    lvl_list = [n+1 for n in range(nlevels)]\n\n    lvl_busdict = {}\n    lvl_busdict[0] = [homebus]\n\n    do_buslist = [homebus]\n    done_busdict = {}\n\n    for lvl in lvl_list:\n        if not do_buslist: break\n        tmp_busdict = {}\n\n        # Search for branches and two winding transformers\n        for ibus in do_buslist:\n            ierr = psspy.inibrn(ibus, single=2)\n            #print(\"0 inibrn: ierr={}, ibus={}\".format(ierr, ibus))\n            if ierr == 0:\n                while True:\n                    ierr,jbus,ickt = psspy.nxtbrn(ibus)\n                    #print(\"1 nxtbrn: ierr={}, jbus={}\".format(ierr, jbus))\n                    if ierr: break\n                    tmp_busdict[jbus] = 1\n\n        # Search for three winding transformers\n        for ibus in do_buslist:\n            ierr = psspy.inibrn(ibus, single=2)\n            if ierr == 0:\n                while True:\n                    ierr,jbus,kbus,ickt = psspy.nxtbrn3(ibus)\n                    #print(\"2 nxtbrn3: ierr={}, jbus={}, kbus={}\".format(ierr, jbus, kbus))\n                    if ierr: break\n                    tmp_busdict[jbus] = 1\n                    if (kbus>0): tmp_busdict[kbus] = 1\n\n        tmp_buslist = list(tmp_busdict.keys())\n        tmp_buslist.sort()\n\n        for ibus in do_buslist:\n            done_busdict[ibus] = 1\n\n        do_buslist = []\n        for ibus in tmp_buslist:\n            if ibus not in done_busdict:\n                do_buslist.append(ibus)\n\n        lvl_busdict[lvl] = do_buslist[:]\n\n    # all done\n    return lvl_busdict\n\n#"
  },
  {
    "id": 346,
    "text": "def test_me():\n    import psse3502\n    import psspy\n    psspy.psseinit()\n    savfile = \"sample.sav\"\n    psspy.case(savfile)\n    lvl_busdict = get_nlevel_buses(151, 3)\n    #lvl_busdict = get_nlevel_buses(206, 10)\n    #lvl_busdict = get_nlevel_buses(101, 10)\n    print(\"N Level Buses\")\n    for lvl, buslist in lvl_busdict.items():\n        print(\"Level={}, Buses={}\".format(lvl, buslist))\n\n#"
  },
  {
    "id": 351,
    "text": "def get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 353,
    "text": "def otdf_excel(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None, show=True):\n\n    import psspy, arrbox.dfax_pp\n\n    import excelpy\n\n    if not os.path.exists(savfile):\n        print(\"\\n SAV file '%s' not found.\" % savfile)\n        return\n\n    if not os.path.exists(dfxfile):\n        print(\"\\n DFAX file '%s' not found.\" % dfxfile)\n        return\n\n    p, nx = os.path.split(dfxfile)\n    n, x  = os.path.splitext(nx)\n    xlfile = get_output_filename(outpath, 'otdffactors_'+n)\n\n    psspy.psseinit()\n\n    psspy.case(savfile)\n\n    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)\n\n    otdfobj = dfxobj.otdf_factors()\n    if otdfobj.ierr != 0: return\n\n    otdfxls = excelpy.workbook(xlfile, 'OTDF FACTORS', overwritesheet=True)\n    if show: otdfxls.show()\n    otdfxls.show_alerts(0) # do not show pop-up alerts\n\n    otdfxls.page_format(orientation=\"landscape\",left=1.0,right=1.0,\n                       top=0.5,bottom=0.5,header=0.25,footer=0.25)\n    otdfxls.page_footer(left='page number of page total', right='date, time')\n    otdfxls.page_header(center='file name:sheet name')\n    otdfxls.font_sheet()\n\n    # Report Title\n    col = 1\n    row = 1\n    tmplst = ([\"OTDF Factors Report\"],[dfxfile])\n    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\n    otdfxls.font((1,1),fontColor='red',fontSize=14)\n    otdfxls.font_color((2,1),'blue')\n\n    row = bottomRow + 1\n\n    tmplst = [\n        otdfobj.casetitle.line1,                                       #\n        otdfobj.casetitle.line2,                                       #\n        ''\n        'Saved Case file              = %s' % otdfobj.file.sav,         #\n        'DFAX file                    = %s' % otdfobj.file.dfx,         #\n        'Subsystem file               = %s' % otdfobj.file.sub,         #\n        'Monitored Element file       = %s' % otdfobj.file.mon,         #\n        'Contingency Description file = %s' % otdfobj.file.con,         #\n        ]\n\n    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst,transpose=True)\n    row = bottomRow + 2 # one blank row\n\n    txt = \"'*** OTDF Contingency Description ***\"\n    otdfxls.set_cell((row,col),txt,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n    row = row + 1\n\n    tmplst=[]\n    for i in range(otdfobj.size.ncase):\n        lbl  = otdfobj.colabel[i]\n        desc = otdfobj.codesc[i]\n        tmplst.append([lbl,desc])\n    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\n    otdfxls.align((row,col,bottomRow,col),'right')\n    otdfxls.font_color((row,col,bottomRow,col),'dgreen')\n\n    row = bottomRow + 2 # one blank row\n\n    txt = \"'*** OTDF Factors ***\"\n    otdfxls.set_cell((row,col),txt,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n    row = row + 1\n\n    tmplst=['<"
  },
  {
    "id": 355,
    "text": ">']\n    for each in otdfobj.colabel:\n        tmplst.append(each.strip())\n    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\n    otdfxls.align((row,col,bottomRow,rightCol),'right')\n    otdfxls.font_color((row,col,bottomRow,rightCol),'blue')\n\n    row = bottomRow + 1\n\n    tmplst=[]\n    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):\n        tmplst.append([otdfobj.melement[i].strip()])\n    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\n    otdfxls.align((row,col,bottomRow,col),'right')\n    otdfxls.font_color((row,col,bottomRow,col),'dgreen')\n\n    col = rightCol + 1\n    bottomRow,rightCol = otdfxls.set_range(row,col,otdfobj.factor,transpose=True,numberFormat='0.0000')\n\n    otdfxls.width((1,1),53)\n    otdfxls.width((1,2,1,rightCol),12)\n\n    #"
  },
  {
    "id": 363,
    "text": "def get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 365,
    "text": "def otdf_report(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):\n\n    import psspy, arrbox.dfax_pp\n\n    if not os.path.exists(savfile):\n        print(\"\\n SAV file '%s' not found.\" % savfile)\n        return\n\n    if not os.path.exists(dfxfile):\n        print(\"\\n DFAX file '%s' not found.\" % dfxfile)\n        return\n\n    p, nx = os.path.split(dfxfile)\n    n, x  = os.path.splitext(nx)\n    rptfile = get_output_filename(outpath, 'otdffactors_'+n+'.txt')\n\n    psspy.psseinit()\n\n    psspy.case(savfile)\n\n    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)\n    otdfobj = dfxobj.otdf_factors()\n    if otdfobj.ierr != 0: return\n\n    rptfile_h = open(rptfile,'w')\n    report    = rptfile_h.write\n\n    # (0) Report title\n    ttl_hline = '*' + 46* ' *' + '\\n\\n'\n    ttl       = 30*' ' + \"OTDF Factors Report\" + \"\\n\"\n    ttl_file  = 30*' ' + otdfobj.file.dfx + \"\\n\"\n    ttl_time  = 30*' ' + time.ctime() + \"\\n\\n\"\n    report(ttl_hline)\n    report(ttl)\n    report(ttl_file)\n    report(ttl_time)\n    report(ttl_hline)\n\n    report('%s\\n' % otdfobj.casetitle.line1)\n    report('%s\\n' % otdfobj.casetitle.line2)\n    report('\\n')\n\n    report('Saved Case file              = %s\\n' % otdfobj.file.sav)\n    report('DFAX file                    = %s\\n' % otdfobj.file.dfx)\n    report('Subsystem file               = %s\\n' % otdfobj.file.sub)\n    report('Monitored Element file       = %s\\n' % otdfobj.file.mon)\n    report('Contingency Description file = %s\\n' % otdfobj.file.con)\n    report('\\n')\n\n    report('*** OTDF Contingency Description ***\\n')\n    for i in range(otdfobj.size.ncase):\n        lbl  = otdfobj.colabel[i]\n        desc = otdfobj.codesc[i]\n        report(\"  %(lbl)12s  %(desc)s\\n\" %vars())\n\n    report(\"\\n\")\n    report('*** OTDF Factors ***\\n')\n    report('  <"
  },
  {
    "id": 367,
    "text": ">  ')\n    for each in otdfobj.colabel:\n        report(\"%12s  \" %each.strip())\n    report(\"\\n\")\n    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):\n        report(\"  %52s  \" % otdfobj.melement[i].strip())\n        for j in range(otdfobj.size.ncase):\n            report(\"%12.6f  \" % otdfobj.factor[j][i])\n        report(\"\\n\")\n\n    #"
  },
  {
    "id": 372,
    "text": "'''\nIn some PSSE Saved Cases, especially some old sav files, all transformer data is provided on\nSystem MVA base (SBASE). When this network data is to be used to calculate fault currents\naccording to \"IEC 60909\" standard, in order to calculate correct IEC impedance correction factors,\nnameplate transformer winding MVA data is required.\n\nThis file is used to:\n(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and\n    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.\n    Refer function: change_winding_mva(rating='')\n    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),\n    then this files can be used to change transformer winding MVA with selected Rating. \n\n(2) Create transformers IEC data file.\n    Refer function: create_iecdata(wdgmva='',rptfile='')\n    Create a text file with all transformer branches and then use this file to provide\n    nameplate transformer winding MVA as part of transformer nameplate IEC data records."
  },
  {
    "id": 373,
    "text": "Functions:\n\n(1) change_winding_mva(rating='')\n    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.\n\n(2) create_iecdata(wdgmva='',rptfile='')\n    Create IEC data file for all Transformers Winding MVA.\n    Each IEC data record for a transformer has following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n\n    Transformers IEC data records created here need to put in complete IEC data file.\n        Refer POM Volume 1, API IECS for format of IEC data file.\n        \n    This function creates output file depending on the wndmva input provided.\n    (1) If wndmva is not provided, it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT\n    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.\n\n    (2) If wndmva=\"SBASE\", it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n\n    (3) If wndmva=\"RATEA\" or \"RATEB\" or \"RATEC\", it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)\n          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)\n          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)\n          If any of the winding MVA is zero, it is ignored.\n    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values."
  },
  {
    "id": 374,
    "text": "How to use this file?\n\n(1) Open the Saved Case using PSS(R)E GUI\n\n(2) Without PROMPT for inputing arguments:\n    Call follwoing functions from CLI or another Python automation file:\n    change_winding_mva(rating)\n    or\n    create_iecdata(wndmva, rptfile)\n\n(3) With PROMPTS for inputing arguments:\n    Call follwoing functions from CLI or another Python automation file:\n    dochng()\n    or\n    docreate()\n'''\n\nimport psspy, os\n\n#"
  },
  {
    "id": 375,
    "text": "def _splitstring_commaspace(tmpstr):\n    '''Split string first at comma and then by space. Example:\n    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\n    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n    '''\n    strlst = []\n    commalst = tmpstr.split(',')\n    for each in commalst:\n        eachlst = each.split()\n        if eachlst:\n            strlst.extend(eachlst)\n        else:\n            strlst.extend(' ')\n\n    return strlst\n\n#"
  },
  {
    "id": 376,
    "text": "def _check_wdgmva(instr):\n    '''check for valid wdgmva string.'''\n\n    if type(instr) != str: instr = str(instr)\n    instr0 = instr\n    \n    instr = instr.strip().lower()\n    if not instr:\n        retv = ''\n    elif instr =='ratea':\n        retv = \"RATEA\"\n    elif instr =='rateb':\n        retv = \"RATEB\"\n    elif instr =='ratec':\n        retv = \"RATEC\"\n    elif instr =='sbase':\n        retv = \"SBASE\"\n    else:\n        print(' Input value \"%s\" not recognized.\\n' % str(instr0))\n        retv = ''\n\n    return retv\n\n#"
  },
  {
    "id": 378,
    "text": "def _get_xmer_data(wdgmva=''):\n\n    '''\n    wdgmva = 0 or ''    # return just transfomrer buses and ckt id\n           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE\n           \n           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from\n           = 'rateb'    # winding rating A or B or C\n           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)\n    '''\n    \n    sid   = -1       # all buses\n    owner = 1        # ignored\n    ties  = 1        # ignored\n\n    # Get Two Winding Transformer Specified Rating\n    flag  = 2        # =1 in-service transformers, =2 all\n    entry = 1        # each branch once only\n\n    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])\n    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])\n    if wdgmva:\n        if wdgmva == \"SBASE\":\n            strval = \"SBASE1\"\n        else:\n            strval = wdgmva\n        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])\n\n    two_wdg_xmers = {}\n    for i in range(len(tmplist1[0])):\n        busi  = tmplist1[0][i]\n        busj  = tmplist1[1][i]\n        cktid = tmplist2[0][i]\n        if wdgmva:\n            val = tmplist3[0][i]\n        else:\n            val = ''\n        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}\n\n    # Three Winding Transformer Specified Rating\n    flag  = 3        # =2 all windings of in-service transformers\n                     # =3 all transformers\n    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)\n                     # need to be done differently when entry = 1\n\n    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])\n    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])\n    if wdgmva:\n        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])\n\n    three_wdg_xmers = {}\n    nwdgs = len(tmplist1[0])\n    for i in range(0,nwdgs,3):\n        busi     = tmplist1[0][i]\n        busj     = tmplist1[1][i]\n        busk     = tmplist1[2][i]\n        cktid    = tmplist2[0][i]\n        if wdgmva == 'SBASE':\n            val1 = tmplist3[0][i]\n            val2 = tmplist3[0][i+1]\n            val3 = tmplist3[0][i+2]\n        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:\n            ratea_w1 = tmplist3[0][i]\n            ratea_w2 = tmplist3[0][i+1]\n            ratea_w3 = tmplist3[0][i+2]\n            val1 = _min_rate(ratea_w1,ratea_w2)\n            val2 = _min_rate(ratea_w2,ratea_w3)\n            val3 = _min_rate(ratea_w3,ratea_w1)\n        else:\n            val1 = ''\n            val2 = ''\n            val3 = ''\n            \n        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}\n   \n    return two_wdg_xmers, three_wdg_xmers\n\n#"
  },
  {
    "id": 379,
    "text": "def change_winding_mva(rating=''):\n    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''\n\n    wdgmva = _check_wdgmva(rating)\n    \n    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:\n        print(\" No need to update working case.\")\n        return\n    \n    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\n\n    lst2wdg = list(two_wdg_xmers.keys())\n    lst2wdg.sort()\n\n    lst3wdg = list(three_wdg_xmers.keys())\n    lst3wdg.sort()\n\n    for brn in lst2wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        ckt  = brn[2]\n        sbase12 = two_wdg_xmers[brn]['sbase12']\n        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)\n\n    for brn in lst3wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = brn[2]    \n        ckt  = brn[3]\n        sbase12 = three_wdg_xmers[brn]['sbase12']\n        sbase23 = three_wdg_xmers[brn]['sbase23']\n        sbase31 = three_wdg_xmers[brn]['sbase31']    \n        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,\n                                                      realari8=sbase23, realari9=sbase31)\n    \n#"
  },
  {
    "id": 380,
    "text": "def create_iecdata(wdgmva='',rptfile=''):\n    '''Create IEC data file for all Transformers Winding MVA.'''\n\n    wdgmva = _check_wdgmva(wdgmva)\n\n    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\n\n    if rptfile:     # open report file to write\n        p,nx = os.path.split(rptfile)\n        if not p: p = os.getcwd()\n        n,x = os.path.splitext(nx)\n        if not x or x.lower() != '.txt': x = '.txt'\n        nx = n + x\n        rptfile = os.path.join(p,nx)\n        rptfile_h = open(rptfile,'w')\n        report       = rptfile_h.write\n    else:           # send results to PSS(R)E report window\n        psspy.beginreport()\n        report = psspy.report\n\n    # printing\n    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\\n')\n\n    # Two Winding Transformers\n    lst2wdg = list(two_wdg_xmers.keys())\n    lst2wdg.sort()\n    for brn in lst2wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = 0\n        ckt  = brn[2].strip()\n        sbase12 = two_wdg_xmers[brn]['sbase12']\n        if sbase12:\n            sbase12 = \"%8.2f\" % sbase12\n        else:\n            sbase12 = ''\n        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\\n' % vars())\n\n    # Three Winding Transformers\n    lst3wdg = list(three_wdg_xmers.keys())\n    lst3wdg.sort()\n\n    for brn in lst3wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = brn[2]    \n        ckt  = brn[3].strip()\n        sbase12  = three_wdg_xmers[brn]['sbase12']\n        sbase23  = three_wdg_xmers[brn]['sbase23']\n        sbase31  = three_wdg_xmers[brn]['sbase31']    \n        if sbase12:\n            sbase12 = \"%8.2f\" % sbase12\n            sbase23 = \"%8.2f\" % sbase23\n            sbase31 = \"%8.2f\" % sbase31\n        else:\n            sbase12 = ''\n            sbase23 = ''\n            sbase31 = ''\n\n        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\\n' % vars())\n\n    if rptfile:\n        print(\" Transformers IEC Data records saved in file %s.\" % rptfile)\n\n#"
  },
  {
    "id": 382,
    "text": "def docreate():\n    psspy.prompt(\"PROVIDE WINDING MVA selection string and IEC DATA output text file name:\\n\\n\\\n        - ALLOWED WINDING MVA selection string\\n\\\n             sbase, ratea, rateb, ratec or ''(empty string) \\n\")\n    psspy.prompt(\"        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\\n\")\n    psspy.prompt(\"TYPE inputs separated either by comma or space.\")\n    \n    ierr, instr = psspy.userin()\n    wndmva  = ''\n    rptfile = ''\n\n    if instr:\n        instrlst = _splitstring_commaspace(instr)\n        wndmva = instrlst[0]\n        try:\n            rptfile = instrlst[1]\n        except:\n            pass\n\n    create_iecdata(wndmva, rptfile)\n    \n#"
  },
  {
    "id": 385,
    "text": "'''\nIn some PSSE Saved Cases, especially some old sav files, all transformer data is provided on\nSystem MVA base (SBASE). When this network data is to be used to calculate fault currents\naccording to \"IEC 60909\" standard, in order to calculate correct IEC impedance correction factors,\nnameplate transformer winding MVA data is required.\n\nThis file is used to:\n(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and\n    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.\n    Refer function: change_winding_mva(rating='')\n    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),\n    then this files can be used to change transformer winding MVA with selected Rating. \n\n(2) Create transformers IEC data file.\n    Refer function: create_iecdata(wdgmva='',rptfile='')\n    Create a text file with all transformer branches and then use this file to provide\n    nameplate transformer winding MVA as part of transformer nameplate IEC data records."
  },
  {
    "id": 386,
    "text": "Functions:\n\n(1) change_winding_mva(rating='')\n    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.\n\n(2) create_iecdata(wdgmva='',rptfile='')\n    Create IEC data file for all Transformers Winding MVA.\n    Each IEC data record for a transformer has following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n\n    Transformers IEC data records created here need to put in complete IEC data file.\n        Refer POM Volume 1, API IECS for format of IEC data file.\n        \n    This function creates output file depending on the wndmva input provided.\n    (1) If wndmva is not provided, it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT\n    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.\n\n    (2) If wndmva=\"SBASE\", it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n\n    (3) If wndmva=\"RATEA\" or \"RATEB\" or \"RATEC\", it creates records in the following format.\n    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\n    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)\n          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)\n          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)\n          If any of the winding MVA is zero, it is ignored.\n    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values."
  },
  {
    "id": 387,
    "text": "How to use this file?\n\n(1) Open the Saved Case using PSS(R)E GUI\n\n(2) Without PROMPT for inputing arguments:\n    Call follwoing functions from CLI or another Python automation file:\n    change_winding_mva(rating)\n    or\n    create_iecdata(wndmva, rptfile)\n\n(3) With PROMPTS for inputing arguments:\n    Call follwoing functions from CLI or another Python automation file:\n    dochng()\n    or\n    docreate()\n'''\n\nimport psspy, os\n\n#"
  },
  {
    "id": 388,
    "text": "def _splitstring_commaspace(tmpstr):\n    '''Split string first at comma and then by space. Example:\n    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\n    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n    '''\n    strlst = []\n    commalst = tmpstr.split(',')\n    for each in commalst:\n        eachlst = each.split()\n        if eachlst:\n            strlst.extend(eachlst)\n        else:\n            strlst.extend(' ')\n\n    return strlst\n\n#"
  },
  {
    "id": 389,
    "text": "def _check_wdgmva(instr):\n    '''check for valid wdgmva string.'''\n\n    if type(instr) != str: instr = str(instr)\n    instr0 = instr\n    \n    instr = instr.strip().lower()\n    if not instr:\n        retv = ''\n    elif instr =='ratea':\n        retv = \"RATEA\"\n    elif instr =='rateb':\n        retv = \"RATEB\"\n    elif instr =='ratec':\n        retv = \"RATEC\"\n    elif instr =='sbase':\n        retv = \"SBASE\"\n    else:\n        print(' Input value \"%s\" not recognized.\\n' % str(instr0))\n        retv = ''\n\n    return retv\n\n#"
  },
  {
    "id": 391,
    "text": "def _get_xmer_data(wdgmva=''):\n\n    '''\n    wdgmva = 0 or ''    # return just transfomrer buses and ckt id\n           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE\n           \n           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from\n           = 'rateb'    # winding rating A or B or C\n           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)\n    '''\n    \n    sid   = -1       # all buses\n    owner = 1        # ignored\n    ties  = 1        # ignored\n\n    # Get Two Winding Transformer Specified Rating\n    flag  = 2        # =1 in-service transformers, =2 all\n    entry = 1        # each branch once only\n\n    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])\n    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])\n    if wdgmva:\n        if wdgmva == \"SBASE\":\n            strval = \"SBASE1\"\n        else:\n            strval = wdgmva\n        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])\n\n    two_wdg_xmers = {}\n    for i in range(len(tmplist1[0])):\n        busi  = tmplist1[0][i]\n        busj  = tmplist1[1][i]\n        cktid = tmplist2[0][i]\n        if wdgmva:\n            val = tmplist3[0][i]\n        else:\n            val = ''\n        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}\n\n    # Three Winding Transformer Specified Rating\n    flag  = 3        # =2 all windings of in-service transformers\n                     # =3 all transformers\n    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)\n                     # need to be done differently when entry = 1\n\n    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])\n    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])\n    if wdgmva:\n        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])\n\n    three_wdg_xmers = {}\n    nwdgs = len(tmplist1[0])\n    for i in range(0,nwdgs,3):\n        busi     = tmplist1[0][i]\n        busj     = tmplist1[1][i]\n        busk     = tmplist1[2][i]\n        cktid    = tmplist2[0][i]\n        if wdgmva == 'SBASE':\n            val1 = tmplist3[0][i]\n            val2 = tmplist3[0][i+1]\n            val3 = tmplist3[0][i+2]\n        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:\n            ratea_w1 = tmplist3[0][i]\n            ratea_w2 = tmplist3[0][i+1]\n            ratea_w3 = tmplist3[0][i+2]\n            val1 = _min_rate(ratea_w1,ratea_w2)\n            val2 = _min_rate(ratea_w2,ratea_w3)\n            val3 = _min_rate(ratea_w3,ratea_w1)\n        else:\n            val1 = ''\n            val2 = ''\n            val3 = ''\n            \n        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}\n   \n    return two_wdg_xmers, three_wdg_xmers\n\n#"
  },
  {
    "id": 392,
    "text": "def change_winding_mva(rating=''):\n    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''\n\n    wdgmva = _check_wdgmva(rating)\n    \n    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:\n        print(\" No need to update working case.\")\n        return\n    \n    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\n\n    lst2wdg = list(two_wdg_xmers.keys())\n    lst2wdg.sort()\n\n    lst3wdg = list(three_wdg_xmers.keys())\n    lst3wdg.sort()\n\n    for brn in lst2wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        ckt  = brn[2]\n        sbase12 = two_wdg_xmers[brn]['sbase12']\n        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)\n\n    for brn in lst3wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = brn[2]    \n        ckt  = brn[3]\n        sbase12 = three_wdg_xmers[brn]['sbase12']\n        sbase23 = three_wdg_xmers[brn]['sbase23']\n        sbase31 = three_wdg_xmers[brn]['sbase31']    \n        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,\n                                                      realari8=sbase23, realari9=sbase31)\n    \n#"
  },
  {
    "id": 393,
    "text": "def create_iecdata(wdgmva='',rptfile=''):\n    '''Create IEC data file for all Transformers Winding MVA.'''\n\n    wdgmva = _check_wdgmva(wdgmva)\n\n    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\n\n    if rptfile:     # open report file to write\n        p,nx = os.path.split(rptfile)\n        if not p: p = os.getcwd()\n        n,x = os.path.splitext(nx)\n        if not x or x.lower() != '.txt': x = '.txt'\n        nx = n + x\n        rptfile = os.path.join(p,nx)\n        rptfile_h = open(rptfile,'w')\n        report       = rptfile_h.write\n    else:           # send results to PSS(R)E report window\n        psspy.beginreport()\n        report = psspy.report\n\n    # printing\n    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\\n')\n\n    # Two Winding Transformers\n    lst2wdg = list(two_wdg_xmers.keys())\n    lst2wdg.sort()\n    for brn in lst2wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = 0\n        ckt  = brn[2].strip()\n        sbase12 = two_wdg_xmers[brn]['sbase12']\n        if sbase12:\n            sbase12 = \"%8.2f\" % sbase12\n        else:\n            sbase12 = ''\n        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\\n' % vars())\n\n    # Three Winding Transformers\n    lst3wdg = list(three_wdg_xmers.keys())\n    lst3wdg.sort()\n\n    for brn in lst3wdg:\n        ibus = brn[0]\n        jbus = brn[1]\n        kbus = brn[2]    \n        ckt  = brn[3].strip()\n        sbase12  = three_wdg_xmers[brn]['sbase12']\n        sbase23  = three_wdg_xmers[brn]['sbase23']\n        sbase31  = three_wdg_xmers[brn]['sbase31']    \n        if sbase12:\n            sbase12 = \"%8.2f\" % sbase12\n            sbase23 = \"%8.2f\" % sbase23\n            sbase31 = \"%8.2f\" % sbase31\n        else:\n            sbase12 = ''\n            sbase23 = ''\n            sbase31 = ''\n\n        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\\n' % vars())\n\n    if rptfile:\n        print(\" Transformers IEC Data records saved in file %s.\" % rptfile)\n\n#"
  },
  {
    "id": 395,
    "text": "def docreate():\n    psspy.prompt(\"PROVIDE WINDING MVA selection string and IEC DATA output text file name:\\n\\n\\\n        - ALLOWED WINDING MVA selection string\\n\\\n             sbase, ratea, rateb, ratec or ''(empty string) \\n\")\n    psspy.prompt(\"        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\\n\")\n    psspy.prompt(\"TYPE inputs separated either by comma or space.\")\n    \n    ierr, instr = psspy.userin()\n    wndmva  = ''\n    rptfile = ''\n\n    if instr:\n        instrlst = _splitstring_commaspace(instr)\n        wndmva = instrlst[0]\n        try:\n            rptfile = instrlst[1]\n        except:\n            pass\n\n    create_iecdata(wndmva, rptfile)\n    \n#"
  },
  {
    "id": 399,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example, where XX could be 33 or 34:\n    import psseXX\n\n- call any of the function as below\n    accc()\n    accc(accfile='savnw.acc', show=True, cosep=True)\n\n    pv()\n    pv(pvfile='savnw.pv', show=True)\n\n    qv()\n    qv(qvfile='savnw.qv', show=True)"
  },
  {
    "id": 401,
    "text": "import sys, os\n\ndef get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 403,
    "text": "def accc(accfile='savnw.acc', outpath=None, show=True, cosep=True):\n    import pssexcel\n\n    if not os.path.exists(accfile):\n        prgmsg = \" Error: Input accfile '{0}' does not exist\".format(accfile)\n        print(prgmsg)\n        return\n\n    # Change these values as required.\n    string  = ['s','e','b','i','v','l','g','p','a']\n    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\n\n    p, nx = os.path.split(accfile)\n    n, x  = os.path.splitext(nx)\n\n    xlsfile = get_output_filename(outpath, 'pssexcel_demo_accc_' + n)\n\n    sheet = n + '_accc'\n    overwritesheet = True\n\n    baseflowvio = False\n    basevoltvio = False\n    flowlimit   = 0.0\n    flowchange  = 0.0\n    voltchange  = 0.0\n    branchanglediff = True\n    angdifmin=0.05\n\n    pssexcel.accc(accfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show,\n                  baseflowvio=baseflowvio, basevoltvio=basevoltvio, flowlimit=flowlimit,\n                  flowchange=flowchange, voltchange=voltchange, angdifmin=angdifmin, cosep=cosep, branchanglediff=branchanglediff)\n\n#"
  },
  {
    "id": 404,
    "text": "def pv(pvfile='savnw.pv', outpath=None, show=True):\n    import pssexcel\n\n    if not os.path.exists(pvfile):\n        prgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\n        print(prgmsg)\n        return\n\n    # Change these values as required.\n    string  = ['s','v','m','g','l','b','i']\n    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\n\n    p, nx = os.path.split(pvfile)\n    n, x  = os.path.splitext(nx)\n\n    xlsfile = get_output_filename(outpath, 'pssexcel_demo_pv_' + n)\n\n    sheet = n + '_pv'\n    overwritesheet = True\n\n    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n\n#"
  },
  {
    "id": 405,
    "text": "def qv(qvfile='savnw.qv', outpath=None, show=True):\n    import pssexcel\n\n    if not os.path.exists(qvfile):\n        prgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\n        print(prgmsg)\n        return\n\n    # Change these values as required.\n    string  = ['s','v','m','g']\n    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\n\n    p, nx = os.path.split(qvfile)\n    n, x  = os.path.splitext(nx)\n\n    xlsfile = get_output_filename(outpath, 'pssexcel_demo_qv_' + n)\n\n    sheet = n + '_qv'\n    overwritesheet = True\n\n    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n\n#"
  },
  {
    "id": 412,
    "text": "import sys, os\n\ndef get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 414,
    "text": "def excel_report(pvfile='savnw.pv', outpath=None, show=True):\n    import pssexcel\n\n    if not os.path.exists(pvfile):\n        prgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\n        print(prgmsg)\n        return\n\n    # Change these values as required.\n    string  = ['s','v','m','g','l','b','i']\n    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']\n\n    p, nx = os.path.split(pvfile)\n    n, x  = os.path.splitext(nx)\n\n    xlsfile = get_output_filename(outpath, 'pv_export_' + n)\n\n    sheet = n + '_pv'\n    overwritesheet = True\n\n    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n\n#"
  },
  {
    "id": 415,
    "text": "def text_report(pvfile='savnw.pv', outpath=None):\n\n    import arrbox.pv_pp\n\n    if not os.path.exists(pvfile):\n        prgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\n        print(prgmsg)\n        return\n\n    pvobj = arrbox.pv_pp.PV_PP(pvfile)\n\n    p, nx = os.path.split(pvfile)\n    n, x  = os.path.splitext(nx)\n\n    smryfile = get_output_filename(outpath, 'pv_export_' + n +'_summary.txt')\n    solnfile = get_output_filename(outpath, 'pv_export_' + n +'_solution.txt')\n\n    ierr = pvobj.summary_report(smryfile)\n\n    ierr = pvobj.solution_report(colabels=None,rptfile=solnfile)\n\n#"
  },
  {
    "id": 422,
    "text": "import sys, os\n\ndef get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 424,
    "text": "def excel_report(qvfile='savnw.qv', outpath=None, show=True):\n    import pssexcel\n\n    if not os.path.exists(qvfile):\n        prgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\n        print(prgmsg)\n        return\n\n    # Change these values as required.\n    string  = ['s','v','m','g']\n    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']\n\n    p, nx = os.path.split(qvfile)\n    n, x  = os.path.splitext(nx)\n\n    xlsfile = get_output_filename(outpath, 'qv_export_' + n)\n\n    sheet = n + '_qv'\n    overwritesheet = True\n\n    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n\n#"
  },
  {
    "id": 425,
    "text": "def text_report(qvfile='savnw.qv', outpath=None):\n\n    import arrbox.qv_pp\n\n    if not os.path.exists(qvfile):\n        prgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\n        print(prgmsg)\n        return\n\n    qvobj = arrbox.qv_pp.QV_PP(qvfile)\n\n    p, nx = os.path.split(qvfile)\n    n, x  = os.path.splitext(nx)\n\n    smryfile = get_output_filename(outpath, 'qv_export_' + n +'_summary.txt')\n    solnfile = get_output_filename(outpath, 'qv_export_' + n +'_solution.txt')\n\n    ierr = qvobj.summary_report(smryfile)\n\n    ierr = qvobj.solution_report(colabels=None,rptfile=solnfile)\n\n#"
  },
  {
    "id": 428,
    "text": "'run_idle.py - This script starts up the IDLE interpreter (for Python 2.3).'\n\nimport sys\n\n# Import IDLE's PyShell and run its main()\nsys.argv=['','-n','-t','PSS/E-Python Shell'] #Arguments for IDLE\nimport idlelib.PyShell                       #Import the PyShell module\nidlelib.PyShell.main()                       #Start IDLE\n\n#[sample_add_substations.py]    Create sample_zils case with various Node Breaker Substation Configurations\n#"
  },
  {
    "id": 429,
    "text": "'''This file shows example of adding one or more substation configurations.\nUses sample.raw and sample.seq files.\n\nThis example uses substations data [latitude, longitude, RG] from sample_fv4.gic, but applies\ndifferent Substation Configurations.\n'''\nss_config = {\n    1: 'SB',        #'Single Bus',\n    2: 'RB',        #'Ring Bus',\n    3: 'DBDB',      #'Double Bus double breaker',\n    4: 'BH',        #'Breaker and a half',\n    5: 'DBSB',      #'Double Bus Single breaker',\n    6: 'MBTB',      #'Main Bus Transfer Bus',\n    }\n\nsub_dict = {\n     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211      ]},\n     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022   ]},\n     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154                    ]},\n     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202              ]},\n     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204]},\n     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                ]},\n     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002      ]},\n     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005           ]},\n     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018       ]},\n    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                          ]},\n    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                          ]},\n    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212                          ]},\n    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                          ]},\n    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                          ]},\n    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                          ]},\n    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                 ]},\n    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                         ]},\n    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                         ]},\n    }\n\nrawfnam           = r\"sample.raw\"\nseqfnam           = r\"sample.seq\"\nrawoutfnam        = r\"sample\"\nrawoutfnam_nb     = r\"sample_nb\"\nrawoutfnam_nb_sec = r\"sample_nb_sec\"\nprgfnam           = r\"sample_nb_progress.txt\"\n\nimport os\n\n#"
  },
  {
    "id": 430,
    "text": "def solve_pf():\n    import psspy\n    pf_options = [1,0,0,1,1,0,99,0]\n    psspy.fdns(pf_options)\n    psspy.fdns(pf_options)\n    ival = psspy.solved()\n    return ival\n\ndef save_case(rawfile, seqfile, savfnam, outpath):\n    import psspy\n    psspy.read(0, rawfile)\n    psspy.resq(seqfile)\n    ival = solve_pf()\n    if ival==0:\n        savfile = \"{}.sav\".format(savfnam)\n        savfile = os.path.join(outpath, savfile)\n        psspy.save(savfile)\n\n#"
  },
  {
    "id": 431,
    "text": "def run(datapath=None, outpath=None):\n    import psspy\n\n    if datapath is None:        # use Example folder\n        psspy_dir = os.path.dirname(psspy.__file__)\n        psse_dir, jnk = os.path.split(psspy_dir)\n        datapath = os.path.join(psse_dir, 'Example')\n\n    rawfile = os.path.join(datapath, rawfnam)\n    seqfile = os.path.join(datapath, seqfnam)\n\n    if not os.path.exists(rawfile):\n        msg = \"\\n Error- RAW file not found, terminated:\\n    {}\".format(rawfile)\n        print(msg)\n        return\n\n    if not os.path.exists(seqfile):\n        msg = \"\\n Error- SEQ file not found, terminated:\\n    {}\".format(seqfile)\n        print(msg)\n        return\n\n    if outpath is None:\n        outpath = os.path.dirname(__file__)\n        outpath = os.path.join(outpath, 'output_sample_nb')\n    if not os.path.exists(outpath): os.makedirs(outpath)\n\n    psspy.psseinit()\n\n    prgfile = os.path.join(outpath, prgfnam)\n\n    psspy.progress_output(2,prgfile,[0,0])\n\n    _i = psspy.getdefaultint()\n    _f = psspy.getdefaultreal()\n    _s = psspy.getdefaultchar()\n\n    psspy.read(0, rawfile)\n    psspy.resq(seqfile)\n\n    ival_raw = solve_pf()\n    if ival_raw>0:\n        msg = \"\\n Error - Power flow non converged. RAW file:\\n    {}\".format(rawfile)\n        print(msg)\n        return\n\n    sslst = list(sub_dict.keys())\n    sslst.sort()\n\n    for ss in sslst:\n        vdict = sub_dict[ss]\n        name  = sub_dict[ss]['name']\n        lat   = sub_dict[ss]['lat']\n        lon   = sub_dict[ss]['long']\n        rg    = sub_dict[ss]['rg']\n        config= sub_dict[ss]['config']\n        buses = sub_dict[ss]['buses']\n\n        s_ss = \"{:{fill}2d}\".format(ss, fill='0')\n        s_config = ss_config[config]\n\n        ss_name  = \"SS{}_{}_TYP_{}_{}\".format(s_ss, name, config, s_config)\n\n        for b in buses:\n            psspy.station_build_config(b,ss,_s,config)\n\n        psspy.station_data(ss, [lat, lon, rg], ss_name)\n\n    # Update/Change Node and Switching Device Names\n    sid = -1\n    flag = 1\n    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])\n    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])\n\n    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):\n        nlst = nam.strip().split('_')\n        newlst = ['SS', nlst[1], 'NODE', str(node)]\n        newnam = '_'.join(newlst)\n        psspy.station_node_chng(ss,node,[_i,_i],newnam)\n\n    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])\n    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])\n\n    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):\n        nlst = nam.strip().split('_')\n        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]\n        newnam = '_'.join(newlst)\n        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)\n\n    #"
  },
  {
    "id": 433,
    "text": "# Solve power flow and save raw file\n    ival_raw_nb = solve_pf()\n    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\n                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, NO ZILS')\n    rawfileout_nb = \"{}.raw\".format(rawoutfnam_nb)\n    rawfileout_nb = os.path.join(outpath, rawfileout_nb)\n    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)\n\n    seqfileout_nb = \"{}.seq\".format(rawoutfnam_nb)\n    seqfileout_nb = os.path.join(outpath, seqfileout_nb)\n    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)\n\n    if ival_raw_nb>0:\n        msg = \"\\n Error - Power flow non converged after adding substations, SAV file not created.\"\n        print(msg)\n\n    #"
  },
  {
    "id": 434,
    "text": "# Create substation sections\n    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n\n    #"
  },
  {
    "id": 435,
    "text": "# Solve power flow and save raw file\n    ival_raw_nb_sec = solve_pf()\n    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\n                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, NO ZILS')\n    rawfileout_nb_sec = \"{}.raw\".format(rawoutfnam_nb_sec)\n    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)\n    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)\n\n    seqfileout_nb_sec = \"{}.seq\".format(rawoutfnam_nb_sec)\n    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)\n    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)\n\n    if ival_raw_nb_sec>0:\n        msg = \"\\n Error - Power flow non converged after adding substation sections, SAV file not created.\"\n        print(msg)\n        return\n\n    #"
  },
  {
    "id": 436,
    "text": "# Create .sav files\n    if not os.path.exists(seqfile):\n        msg = \"\\n Error- SEQ sile not found:\\n    {}\".format(seqfile)\n        print(msg)\n        return\n\n    # base case\n    save_case(rawfile, seqfile, rawoutfnam, outpath)\n\n    # base+NB case\n    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)\n\n    # base+NB+sections case\n    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)\n\n    #"
  },
  {
    "id": 438,
    "text": "def test1():\n    # Run from outside of PSSE GUI.\n    # Use input sample RAW/SEQ files from specified folder [datapath].\n    # Create output RAW/SEQ files in specified folder [outpath].\n    import psse35\n    datapath = os.getcwd()\n    outpath  = os.getcwd()\n    run(datapath=datapath, outpath=outpath)\n\n#"
  },
  {
    "id": 439,
    "text": "def test2():\n    # Run from inside of PSSE GUI.\n    # Use input sample RAW/SEQ files from specified folder [datapath].\n    # Create output RAW/SEQ files in specified folder [outpath].\n    import psse35\n    datapath = os.getcwd()\n    outpath  = os.getcwd()\n    run(datapath=datapath, outpath=outpath)\n\n#"
  },
  {
    "id": 442,
    "text": "'''This file shows example of adding one or more substation configurations.\nUses sample_zils.raw and sample_zils.seq files.\n\nThis example uses substations data [latitude, longitude, RG] from sample_zils_fv4.gic, but applies\ndifferent Substation Configurations.\n'''\nss_config = {\n    1: 'SB',        #'Single Bus',\n    2: 'RB',        #'Ring Bus',\n    3: 'DBDB',      #'Double Bus double breaker',\n    4: 'BH',        #'Breaker and a half',\n    5: 'DBSB',      #'Double Bus Single breaker',\n    6: 'MBTB',      #'Main Bus Transfer Bus',\n    }\n\nsub_dict = {\n     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211, 80102, 80151 ]},\n     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022, 803022    ]},\n     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154, 809154                     ]},\n     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202, 80203                ]},\n     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204         ]},\n     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                         ]},\n     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002, 803002       ]},\n     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005                    ]},\n     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018, 803008, 803010, 803018]},\n    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                                   ]},\n    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                                   ]},\n    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212, 80212                            ]},\n    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                                   ]},\n    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                                   ]},\n    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                                   ]},\n    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                          ]},\n    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                                  ]},\n    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                                  ]},\n    19: {'name': 'DC2TERM',     'lat': 31.7104,  'long': -84.5694 ,  'rg':0.30, 'config':1, 'buses': [301, 80301                            ]},\n    20: {'name': 'DCMTERM',     'lat': 33.9163,  'long': -81.9163 ,  'rg':0.31, 'config':1, 'buses': [401, 402, 80402                       ]},\n    }\n\nrawfnam           = r\"sample_zils.raw\"\nseqfnam           = r\"sample_zils.seq\"\nrawoutfnam        = r\"sample_zils\"\nrawoutfnam_nb     = r\"sample_zils_nb\"\nrawoutfnam_nb_sec = r\"sample_zils_nb_sec\"\nprgfnam           = r\"sample_zils_nb_progress.txt\"\n\nimport os\n\n#"
  },
  {
    "id": 443,
    "text": "def solve_pf():\n    import psspy\n    pf_options = [1,0,0,1,1,0,99,0]\n    psspy.fdns(pf_options)\n    psspy.fdns(pf_options)\n    ival = psspy.solved()\n    return ival\n\ndef save_case(rawfile, seqfile, savfnam, outpath):\n    import psspy\n    psspy.read(0, rawfile)\n    psspy.resq(seqfile)\n    ival = solve_pf()\n    if ival==0:\n        savfile = \"{}.sav\".format(savfnam)\n        savfile = os.path.join(outpath, savfile)\n        psspy.save(savfile)\n\n#"
  },
  {
    "id": 444,
    "text": "def run(datapath=None, outpath=None):\n    import psspy\n\n    if datapath is None:        # use Example folder\n        psspy_dir = os.path.dirname(psspy.__file__)\n        psse_dir, jnk = os.path.split(psspy_dir)\n        datapath = os.path.join(psse_dir, 'Example')\n\n    rawfile = os.path.join(datapath, rawfnam)\n    seqfile = os.path.join(datapath, seqfnam)\n\n    if not os.path.exists(rawfile):\n        msg = \"\\n Error- RAW file not found, terminated:\\n    {}\".format(rawfile)\n        print(msg)\n        return\n\n    if not os.path.exists(seqfile):\n        msg = \"\\n Error- SEQ file not found, terminated:\\n    {}\".format(seqfile)\n        print(msg)\n        return\n\n    if outpath is None:\n        outpath = os.path.dirname(__file__)\n        outpath = os.path.join(outpath, 'output_sample_nb')\n    if not os.path.exists(outpath): os.makedirs(outpath)\n\n    psspy.psseinit()\n\n    prgfile = os.path.join(outpath, prgfnam)\n\n    psspy.progress_output(2,prgfile,[0,0])\n\n    _i = psspy.getdefaultint()\n    _f = psspy.getdefaultreal()\n    _s = psspy.getdefaultchar()\n\n    psspy.read(0, rawfile)\n    psspy.resq(seqfile)\n\n    ival_raw = solve_pf()\n    if ival_raw>0:\n        msg = \"\\n Error - Power flow non converged. RAW file:\\n    {}\".format(rawfile)\n        print(msg)\n        return\n\n    sslst = list(sub_dict.keys())\n    sslst.sort()\n\n    for ss in sslst:\n        vdict = sub_dict[ss]\n        name  = sub_dict[ss]['name']\n        lat   = sub_dict[ss]['lat']\n        lon   = sub_dict[ss]['long']\n        rg    = sub_dict[ss]['rg']\n        config= sub_dict[ss]['config']\n        buses = sub_dict[ss]['buses']\n\n        s_ss = \"{:{fill}2d}\".format(ss, fill='0')\n        s_config = ss_config[config]\n\n        ss_name  = \"SS{}_{}_TYP_{}_{}\".format(s_ss, name, config, s_config)\n\n        for b in buses:\n            psspy.station_build_config(b,ss,_s,config)\n\n        psspy.station_data(ss, [lat, lon, rg], ss_name)\n\n    # Update/Change Node and Switching Device Names\n    sid = -1\n    flag = 1\n    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])\n    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])\n\n    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):\n        nlst = nam.strip().split('_')\n        newlst = ['SS', nlst[1], 'NODE', str(node)]\n        newnam = '_'.join(newlst)\n        psspy.station_node_chng(ss,node,[_i,_i],newnam)\n\n    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])\n    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])\n\n    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):\n        nlst = nam.strip().split('_')\n        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]\n        newnam = '_'.join(newlst)\n        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)\n\n    #"
  },
  {
    "id": 446,
    "text": "# Solve power flow and save raw file\n    ival_raw_nb = solve_pf()\n    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\n                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, CONTAINS ZILS')\n    rawfileout_nb = \"{}.raw\".format(rawoutfnam_nb)\n    rawfileout_nb = os.path.join(outpath, rawfileout_nb)\n    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)\n\n    seqfileout_nb = \"{}.seq\".format(rawoutfnam_nb)\n    seqfileout_nb = os.path.join(outpath, seqfileout_nb)\n    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)\n\n    if ival_raw_nb>0:\n        msg = \"\\n Error - Power flow non converged after adding substations, SAV file not created.\"\n        print(msg)\n\n    #"
  },
  {
    "id": 447,
    "text": "# Create substation sections\n    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n\n    #"
  },
  {
    "id": 448,
    "text": "# Solve power flow and save raw file\n    ival_raw_nb_sec = solve_pf()\n    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\n                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, CONTAINS ZILS')\n    rawfileout_nb_sec = \"{}.raw\".format(rawoutfnam_nb_sec)\n    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)\n    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)\n\n    seqfileout_nb_sec = \"{}.seq\".format(rawoutfnam_nb_sec)\n    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)\n    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)\n\n    if ival_raw_nb_sec>0:\n        msg = \"\\n Error - Power flow non converged after adding substation sections, SAV file not created.\"\n        print(msg)\n        return\n\n    #"
  },
  {
    "id": 449,
    "text": "# Create .sav files\n    if not os.path.exists(seqfile):\n        msg = \"\\n Error- SEQ sile not found:\\n    {}\".format(seqfile)\n        print(msg)\n        return\n\n    # base case\n    save_case(rawfile, seqfile, rawoutfnam, outpath)\n\n    # base+NB case\n    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)\n\n    # base+NB+sections case\n    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)\n\n    #"
  },
  {
    "id": 451,
    "text": "def test1():\n    # Run from outside of PSSE GUI.\n    # Use input sample RAW/SEQ files from specified folder [datapath].\n    # Create output RAW/SEQ files in specified folder [outpath].\n    import psse35\n    datapath = os.getcwd()\n    outpath  = os.getcwd()\n    run(datapath=datapath, outpath=outpath)\n\n#"
  },
  {
    "id": 452,
    "text": "def test2():\n    # Run from inside of PSSE GUI.\n    # Use input sample RAW/SEQ files from specified folder [datapath].\n    # Create output RAW/SEQ files in specified folder [outpath].\n    import psse35\n    datapath = os.getcwd()\n    outpath  = os.getcwd()\n    run(datapath=datapath, outpath=outpath)\n\n#"
  },
  {
    "id": 456,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psse35\n\n- call any of the function as below\n    run_demo()  OR\n    run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None)\n    You could modify various inputs in run)demo() as desired.\n'''\n\n#"
  },
  {
    "id": 457,
    "text": "import sys, os\n\ndef get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 459,
    "text": "def create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile):\n    # Create Report\n    import arrbox.sensitivity_flow_to_mw\n\n    flow2mw = arrbox.sensitivity_flow_to_mw()\n\n    ierr = flow2mw.sensitivity_flow_to_mw_report(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',\n        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='',rptfile=rptfile)\n\n#"
  },
  {
    "id": 460,
    "text": "def demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys):\n    # Access factor results in Python script\n    import arrbox.sensitivity_flow_to_mw\n\n    flow2mw = arrbox.sensitivity_flow_to_mw()\n\n    robj = flow2mw.sensitivity_flow_to_mw(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',\n        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='')\n\n    print(\"\\n Returned dictionary object as is:\")\n    print(robj)\n    print('\\n')\n\n    print(\"  Getting 'ngenbuses' value by different ways:\")\n    print(\"     robj.ngenbuses    = {0:d}\".format(robj.ngenbuses))\n    print(\"     robj.ngenBuses    = {0:d}\".format(robj.ngenBuses))\n    print(\"     robj['ngenbuses'] = {0:d}\".format(robj['ngenbuses']))\n    print(\"     robj['NGENbuses'] = {0:d}\".format(robj['NGENbuses']))\n    print('\\n')\n\n    print(\"  Bus names for which generator factors are calculated:\")\n    print(list(robj.genvalues.keys()))\n    print('\\n')\n\n    print(\"  Generator factors:\")\n    for bus, vdict in list(robj.genvalues.items()):\n        tdct = {'bus':bus, 'pmax':vdict.pmax, 'pmin':vdict.pmin, 'pgen':vdict.pgen, 'sftr':vdict.factor}\n        print(\"{bus:s}  {pmax:8.2f}  {pmin:8.2f} {pgen:8.2f}  {sftr:8.5f}\".format(**tdct))\n\n#"
  },
  {
    "id": 461,
    "text": "def run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):\n    import psspy\n\n    ibus        = 151\n    jbus        = 152\n    kbus        = 0\n    ckt         = '1'\n    mainsys     = 'STUDY'\n    netmod      = 'dc'\n    brnflowtyp  = 'mw'\n    transfertyp = 'import'\n    oppsystyp   = 'slack bus'\n    dispmod     = 1\n    toln        = None\n    oppsys      = ''\n\n    if not os.path.exists(savfile):\n        prgmsg = \" Error: Input savfile '{0}' does not exist\".format(savfile)\n        print(prgmsg)\n        return\n\n    if not os.path.exists(dfxfile):\n        prgmsg = \" Error: Input dfxfile '{0}' does not exist\".format(dfxfile)\n        print(prgmsg)\n        return\n\n    p, nx = os.path.split(dfxfile)\n    n, x = os.path.splitext(nx)\n\n    rptfile = get_output_filename(outpath, 'sensitivity_factors_' + n +'_report.txt')\n\n    psspy.psseinit()\n\n    psspy.case(savfile)\n\n    create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile)\n\n    demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys)\n\n#"
  },
  {
    "id": 464,
    "text": "# [\t]     04/23/20     Python Functions to emulate GRPG\n#\n#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n#  *                                                                     *\n#  *  THIS PROGRAM AND ITS DOCUMENTATION ARE TRADE SECRETS OF POWER      *\n#  *  TECHNOLOGIES, INC. (PTI).  THEY HAVE BEEN LEASED TO                *\n#  *                   client full name (clabr)                          *\n#  *  SUBJECT TO TERMS WHICH PROHIBIT clabr FROM DISCLOSING OR TRANS-    *\n#  *  FERRING THE PROGRAM OR ITS DOCUMENTATION, WHETHER IN ITS ORIGINAL  *\n#  *  OR MODIFIED FORM, TO A THIRD PARTY, OR FROM USING THE PROGRAM FOR  *\n#  *  ANY PURPOSE OTHER THAN COMPUTATION RELATING TO clabr'S OWN SYSTEM. *\n#  *  ANY SUCH TRANSFER OR USE BY clabr OR ITS EMPLOYEES WILL CONSTI-    *\n#  *  TUTE A BREACH OF CONFIDENCE AND OF THE CONTRACT UNDER WHICH        *\n#  *  RIGHTS OF USE HAVE BEEN GRANTED.                                   *\n#  *                                                                     *\n#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n'''The functions in this Python module return:\n    - formatted text which can be used to put annotation on slider diagrams.\n    - values which are used to generate formatted text above.\nExample: function 'area_summary' returns formatted text and\n         function 'area_summary_v' returns values used by 'area_summary'\n         i.e, functions with name ending with \"_v\" return values\n'''\n\nimport psspy"
  },
  {
    "id": 465,
    "text": "def area_summary_v(arnum):\n    '''Returns desired and net interchange, loads, generation and losses for\n    area 'arnum'.\npdes,pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.area_summary_v(arnum)\n'''\n    sid  = 3\n    flag = 2\n    ierr = psspy.asys(sid, flag, [arnum])\n    ierr, rdata = psspy.aareareal(sid,flag,\n        ['PDES','PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])\n    psspy.asysdef(sid, 0)\n    if ierr==0:\n        (pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata\n        if len(pdes)>0:\n           return pdes[0],pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]\n    return None,None,None,None,None,None,None,None,None\n\ndef area_summary(arnum):\n    '''Returns formatted text showing desired and net interchange, loads, generation\n     and losses for area 'arnum'.\ntxt = pssgrpg.area_summary(arnum)\n'''\n    pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = area_summary_v(arnum)\n    if pdes:\n        txt = '''Area %(arnum)d Summary:\n  Desired Interchange: %(pdes)9.2f MW\n  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR\n  Area loads         : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR\n  Area generation    : %(pgen)9.2f MW, %(qgen)9.2f MVAR\n  Area losses        : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\n    else:\n        txt = '''Area %(arnum)d Summary:\n  Desired Interchange: None\n  Net Interchange    : None\n  Area loads         : None\n  Area generation    : None\n  Area losses        : None''' % vars()\n    return txt\n\ndef area_interchange_net_v(arnum):\n    '''Returns desired and net interchange for area 'arnum'.\npdes,pint,qint = pssgrpg.area_interchange_net_v(arnum)\n'''\n    sid  = 3\n    flag = 2\n    ierr = psspy.asys(sid, flag, [arnum])\n    ierr, rdata = psspy.aareareal(sid,flag,['PDES','PINT','QINT'])\n    psspy.asysdef(sid, 0)\n    if ierr==0:\n        (pdes,pint,qint) = rdata\n        if len(pdes)>0:\n           return pdes[0],pint[0],qint[0]\n    return None,None,None\n\ndef area_interchange_net(arnum):\n    '''Returns formatted text showing desired and net interchange for area 'arnum'.\ntxt = pssgrpg.area_interchange_net(arnum)\n'''\n    pdes,pint,qint = area_interchange_net_v(arnum)\n    if pdes:\n        txt = '''Area %(arnum)d Interchange:\n  Desired Interchange: %(pdes)9.2f MW\n  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\n    else:\n        txt = '''Area %(arnum)d Interchange:\n  Desired Interchange: None\n  Net Interchange    : None''' % vars()\n    return txt\n\ndef area_interchange_ij_v(iar,jar):\n    '''Returns interchange from area 'iar' to area 'jar'.\np,q = pssgrpg.area_interchange_ij_v(iar,jar)\n'''\n    ierr, cmpval = psspy.aritoj(iar,jar)\n    if ierr==0:\n        return cmpval.real, cmpval.imag\n    return None,None\n\ndef area_interchange_ij(iar,jar):\n    '''Returns formatted text showing interchange from area 'iar' to area 'jar'.\ntxt = pssgrpg.area_interchange_ij(iar,jar)\n'''\n    pint,qint = area_interchange_ij_v(iar,jar)\n    if pint:\n        txt = '''Interchange from Area %(iar)d to Area %(jar)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\n    else:\n        txt = '''Interchange from Area %(iar)d to Area %(jar)d: None''' % vars()\n    return txt"
  },
  {
    "id": 466,
    "text": "def zone_summary_v(znnum):\n    '''Returns net interchange, loads, generation and losses for zone 'znnum'.\npint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.zone_summary_v(znnum)\n'''\n    sid  = 3\n    flag = 2\n    ierr = psspy.zsys(sid, flag, [znnum])\n    ierr, rdata = psspy.azonereal(sid,flag,\n        ['PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])\n    psspy.zsysdef(sid, 0)\n    if ierr==0:\n        (pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata\n        if len(pint)>0:\n           return pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]\n    return None,None,None,None,None,None,None,None,None\n\ndef zone_summary(znnum):\n    '''Returns formatted text showing net interchange, loads, generation and losses\n    for zone 'znnum'.\ntxt = pssgrpg.zone_summary(znnum)\n'''\n    pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = zone_summary_v(znnum)\n    if pint:\n        txt = '''Zone %(znnum)d Summary:\n  Net Interchange : %(pint)9.2f MW, %(qint)9.2f MVAR\n  Zone loads      : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR\n  Zone generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR\n  Zone losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\n    else:\n        txt = '''Zone %(znnum)d Summary:\n  Net Interchange : None\n  Zone loads      : None\n  Zone generation : None\n  Zone losses     : None''' % vars()\n    return txt\n\ndef zone_interchange_ij_v(izn,jzn):\n    '''Returns interchange from zone 'izn' to zone 'jzn'.\np,q = pssgrpg.zone_interchange_ij_v(izn,jzn)\n'''\n    ierr, cmpval = psspy.znitoj(izn,jzn)\n    if ierr==0:\n        return cmpval.real, cmpval.imag\n    return None,None\n\ndef zone_interchange_ij(izn,jzn):\n    '''Returns formatted text showing interchange from zone 'izn' to zone 'jzn'.\ntxt = pssgrpg.zone_interchange_ij(izn,jzn)\n'''\n    pint,qint = zone_interchange_ij_v(izn,jzn)\n    if pint:\n        txt = '''Interchange from Zone %(izn)d to Area %(jzn)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\n    else:\n        txt = '''Interchange from Zone %(izn)d to Zone %(jzn)d: None''' % vars()\n    return txt"
  },
  {
    "id": 467,
    "text": "def system_summary_v():\n    '''Returns working case loads, generation and losses.\npload,qload,pgen,qgen,ploss,qloss = pssgrpg.system_summary_v()\n'''\n    ierr, syslod = psspy.systot('LOAD')\n    ierr, sysgen = psspy.systot('GEN')\n    ierr, syslos = psspy.systot('LOSS')\n    return syslod.real, syslod.imag, sysgen.real, sysgen.imag, syslos.real, syslos.imag\n\ndef system_summary():\n    '''Returns formatted text showing working case loads, generation and losses.\ntxt = pssgrpg.system_summary()\n'''\n    pload,qload,pgen,qgen,ploss,qloss = system_summary_v()\n    txt = '''Case Summary:\n  Total loads      : %(pload)9.2f MW, %(qload)9.2f MVAR\n  Total generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR\n  Total losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\n    return txt"
  },
  {
    "id": 469,
    "text": "'''\nWECCLF converter is used to convert PSLF Power Flow (.epc) and Sequence (.seq) Data\nto PSSE Power Flow (.raw) and Sequence (.seq) Data.\n\nAdditionally it also compares PSSE and PSLF Power Flow Solutions.\n\nWECCLF converter can be run from its own GUI:\n>>> import wecclf_gui\n>>> wecclf_gui.main()\n\nThis scripts shows different ways to run WECCLF Converter from Python Scripts.\n'''\n\nimport os, sys\n\n#"
  },
  {
    "id": 470,
    "text": "def run_wecclf(pslf_version, pslf_epcfile, psse_version, workdir=os.getcwd(), testnum=2):\n\n    import ndppslf\n\n    if not os.path.exists(pslf_epcfile):\n        msgtxt = \" EPC file does not exist, WECCLF converter not run.\\n    {}\".format(pslf_epcfile)\n        print(msgtxt)\n        return\n\n    p, nx = os.path.split(pslf_epcfile)\n    nam, ext  = os.path.splitext(nx)\n\n    outdir = 'wecclf_demo_output_v{}'.format(psse_version)\n    workdir = os.path.join(workdir, outdir)\n    if not os.path.exists(workdir): os.makedirs(workdir)\n\n    rawfnam  = \"{}_v{}.raw\".format(nam, psse_version)\n    rawfile  = os.path.join(workdir, rawfnam)\n\n    prgsplit = False\n    prgfull  = True\n\n    if testnum==1:\n        #(1) Convert and compare power flow solutions using all default options\n        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\n            psse_rawfile=rawfile, ratea=1, rateb=2, ratec=3,\n            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull)\n\n    elif testnum==2:\n        #(2) Convert only\n        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\n            psse_rawfile=rawfile, do_psse_pfsoln=False,\n            workdir=workdir, compare_pfsoln=False, prgfull=prgfull, prgsplit=prgsplit)\n\n    elif testnum==3:\n        #(3) Convert and compare power flow solutions using options from epcfile and options as specified\n        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\n            psse_rawfile=rawfile,\n            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,\n            pfmethod='RSOL', use_epcoptns=False, itmxn=100, flat=0, varlmt=99, nondiv=0,\n            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,\n            compare_pfsoln=True, show_ntop=-1, toler_vpu=-0.001,\n            toler_pgen=-1.0, toler_qgen=-1.0, toler_bact=-0.01, toler_pitf=-1.0, toler_qitf=-1.0)\n\n    elif testnum==4:\n        #(4) Convert and compare power flow solutions using options as specified\n        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\n            psse_rawfile=rawfile, psse_autofile='',\n            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,\n            pfmethod='RSOL', use_epcoptns=False, itmxn=100, toln=0.1, thrshz=0.0001, tap=0,\n            area=0, phshft=0, dctap=1, swsh=1,flat=0, varlmt=99, nondiv=0,\n            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,\n            compare_pfsoln=True, show_ntop=100, toler_vpu=0.02, toler_pgen=1.0,\n            toler_qgen=-1.0, toler_bact=0.01, toler_pitf=1.0, toler_qitf=-1.0)\n\n#"
  },
  {
    "id": 471,
    "text": "def _run_how():\n    pass\n##    # EPC file version=18\n##    epcfile18 = r\"sample18.epc\"\n##    run_wecclf(18, epcfile18, psse_version=34, workdir=os.getcwd(), testnum=3)\n##\n##    # EPC file version=19\n##    epcfile19 = r\"sample19.epc\"\n##    run_wecclf(19, epcfile19, psse_version=34, workdir=os.getcwd(), testnum=3)\n##\n##    # EPC file version=21\n##    epcfile21 = r\"sample21.epc\"\n##    run_wecclf(21, epcfile21, psse_version=34, workdir=os.getcwd(), testnum=3)\n\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nif __name__ == '__main__':\n    pass\n    # Here \"import psse34\" or \"import psse35\" as appropriate.\n    # Then run required test. See _run_how() above for reference.\n#[wordpy_demo.py]  Demo for using functions from wordpy module\n#"
  },
  {
    "id": 472,
    "text": "'''\n'wordpy' module provides Pythonic Interface to Miscrosoft Word.\nThis module has functions to create new or update existing Microsoft Word document by:\n- adding text into Word document\n- inserting pictures/plots into Word document\n\nThis is an example file showing how to use various functions available in wordpy module."
  },
  {
    "id": 473,
    "text": "How to use this file?\n\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\n    import psse35\n\n- call any of the function as below\n    run()  OR\n    run(pssplt_eps_files, pict_files, docfile, outpath, show)\n    You could modify various inputs in run)demo() as desired.\n\n'''\n\n#"
  },
  {
    "id": 474,
    "text": "import sys, os\n\ndef get_output_dir(outpath):\n    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\n\n    if outpath:\n        outdir = outpath\n        if not os.path.exists(outdir): os.mkdir(outdir)\n    else:\n        outdir = os.getcwd()\n        cwd = outdir.lower()\n        i = cwd.find('pti')\n        j = cwd.find('psse')\n        k = cwd.find('example')\n        if i>0 and j>i and k>j:     # called from Example folder\n            outdir = os.path.join(outdir, 'Output_Pyscript')\n            if not os.path.exists(outdir): os.mkdir(outdir)\n\n    return outdir\n\n#"
  },
  {
    "id": 476,
    "text": "def run(pssplt_eps_files=[], pict_files=[], docfile='', outpath=None, show=True):\n    \"\"\"\nInputs:\npssplt_eps_files --> List of Multi-page 'eps' plot files created by PSSPLT\npict_files       --> List of any word compatible picture files (.eps, .wmf, .png, .bmp etc.)\ndocfile          --> Word file name\noutpath          --> Outpath where Word file created/saved\nShow             --> = True, Show Word\n                     = False, Create and Save Word file but do not show\n\"\"\"\n    import wordpy\n\n    pssplt_eps_files_lst = []\n    for fnam in pssplt_eps_files:\n        if not os.path.exists(fnam): continue\n        pssplt_eps_files_lst.append(fnam)\n\n    pict_files_lst   = []\n    pict_caption_lst = []\n    for fnam in pict_files:\n        if not os.path.exists(fnam): continue\n        p, nx = os.path.split(fnam)\n        caption, x = os.path.splitext(nx)\n        pict_files_lst.append(fnam)\n        pict_caption_lst.append(caption)\n\n    if  docfile:\n        p, nx = os.path.split(docfile)\n        docfnam, x = os.path.splitext(nx)\n    else:\n        docfnam = r'wordpy_demo_created'\n        p = outpath\n\n    # doc file\n    docfile = get_output_filename(p, docfnam)\n\n    docoverwrite = True\n\n    # Picture Insert Options (see help(wordpy) for explaination)\n    align      = 'center'\n    captionpos = 'below'\n    height     = None\n    width      = None\n    rotate     = None\n\n    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n    # Put-it-together\n    wdobj = wordpy.workdoc(docfile=docfile, overwrite=docoverwrite)\n    if show:\n        wdobj.show()\n\n    wdobj.page_format(orientation=\"portrait\",left=0.75,right=0.75,top=0.5,bottom=0.5,\n                      header=0.25,footer=0.25)\n\n    wdobj.add_styled_para('Use of Python and Word','Title')\n\n    txt = \"This file is produced by Python script, by inserting picture files into word document. \\\n    It uses python module 'wordpy'.\\n\\n\\\n    This module is mainly created to add plot files (.eps, .png, .wmf etc.) \\\n    created by PSSPLT/PSSPLOT to existing or new Word files.\\n\\n\\\n    Use PSSPLT to create .eps files, and PSSPLOT to create .wmf files. Then use \\\n    'wordpy' module to create Word document from those files.\\n\\n\\\n    How to use it?\\n\\n\\\n    Use 'workdoc' function to create Miscrosoft Word object and use 'add_picture(...)' or \\\n    'add_pictures(...)' methods to insert pictures into the doc file.\\n\\n\"\n    wdobj.add_text(txt)\n\n    txt = \"\"\"Use either of the following to create Word object:\n    (1) When file does not exist, create new file.\n        wdobj = wordpy.workdoc()\n    (2) When file exists, do not remove the content and add data at the end.\n        wdobj = wordpy.workdoc(r\"c:\\working dir\\ex1.doc\", overwrite=False)\n    (3) When file exists, remove the content and create new file.\n        wdobj = wordpy.workdoc(r\"c:\\working dir\\ex1.doc\", overwrite=True)\n    \"\"\"\n    wdobj.add_text(txt)\n\n    if pssplt_eps_files_lst:\n        wdobj.insert_page_break()\n        wdobj.add_styled_para('Inserting multi-page PSSPLT EPS Files - add_pssplt_eps(...)','Heading 1')\n        for fnam in pssplt_eps_files_lst:\n            wdobj.add_pssplt_eps(fnam, captionlst=True, align=align, captionpos=captionpos,\n                                 height=height, width=width, rotate=rotate)\n            wdobj.insert_page_break()\n\n    if pict_files_lst:\n        wdobj.add_styled_para('Inserting One Picture File - add_picture(...)','Heading 1')\n        wdobj.add_picture(pictfile=pict_files_lst[0], caption=pict_caption_lst[0], align=align,\n                          captionpos=captionpos, height=None, width=None, rotate=0.0)\n        wdobj.insert_page_break()\n\n    if pict_files_lst:\n        wdobj.add_styled_para('Inserting Many Picture Files - add_pictures(...)','Heading 1')\n        wdobj.add_pictures(pictfilelst=pict_files_lst, captionlst=pict_caption_lst, align=align,\n                           captionpos=captionpos, height=height, width=width, rotate=0.0)\n\n    wdobj.save()\n\n    if not show:\n        txt = \"\\n Word file created:\\n     {0}\".format(wdobj.DOCFNAM)\n        wdobj.close()\n        print(txt)\n\n#"
  }
]