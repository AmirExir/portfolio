[
  {
    "id": "chunk_001",
    "text": "--- Area Data \u2014 .txt ---\nArea Data \u2014\nArea Data\u00b6\naareachar\nreturn an array of character values for subsystem areas.\naareacount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the area data family.\naareacplx\nreturn an array of complex values for subsystem areas.\naareaint\nreturn an array of integer values for subsystem areas.\naareareal\nreturn an array of real values for subsystem areas.\naareatypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the area data family (aAreaInt, aAreaReal, aAreaCplx and aAreaChar).\n--- Area Subsystems \u2014 .txt ---\nArea Subsystems \u2014\nArea Subsystems\u00b6\nasys\ndefine an area subsystem.\nasysdef\nset the definition of an area subsystem.\nasysinit\ninitialize or re-initialize an area subsystem.\n--- Assign Branch Quantities To Output Channels \u2014 .txt ---\nAssign Branch Quantities To Output Channels \u2014\nAssign Branch Quantities To Output Channels\u00b6\nbranch_app_r_x_channel\nadd a pair of output channels containing the apparent impedance, as seen at the from bus of a specified branch, along with a corresponding call to the RELAY2 monitoring model.\nbranch_mva_channel\nadd an output channel containing the MVA flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\nbranch_p_and_q_channel\nadd a pair of output channels containing the active and reactive power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\nbranch_p_channel\nadd an output channel containing the active power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.\nthree_wnd_app_r_x_channel\nadd a pair of output channels containing the apparent impedance as seen at the from bus of a specified three-winding transformer, along with a corresponding call to the RELAY3 monitoring model.\nthree_wnd_mva_channel\nadd an output channel containing the MVA flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\nthree_wnd_p_and_q_channel\nadd a pair of output channels containing the active and reactive power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\nthree_wnd_p_channel\nadd an output channel containing the active power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.\n--- Assign Machine Quantities To Output Channels \u2014 .txt ---\nAssign Machine Quantities To Output Channels \u2014\nAssign Machine Quantities To Output Channels\u00b6\nmachine_app_r_x_channel\nadd a pair of output channels containing the apparent impedance of the system, as seen from the terminals of a specified machine, along with a corresponding call to the GENTMZ monitoring model.\nmachine_array_channel\nadd an output channel containing a plant related model variable of a designated type for a specified machine.\nmachine_iterm_channel\nadd an output channel containing the terminal current of a specified machine, along with a corresponding call to the GENTMC monitoring model.\n--- Assign Other Quantities To Output Channels \u2014 .txt ---\nAssign Other Quantities To Output Channels \u2014\nAssign Other Quantities To Output Channels\u00b6\nbus_frequency_channel\nadd an output channel containing the per unit frequency deviation at a specified bus.\nstate_channel\nadd an output channel containing the value of a specified STATE.\nvar_channel\nadd an output channel containing the value of a specified VAR.\nvoltage_and_angle_channel\nadd a pair of output channels containing the voltage magnitude in per unit and phase angle in degrees of a specified bus, along with a corresponding call to the VOLMAG monitoring model.\nvoltage_channel\nadd an output channel containing the voltage magnitude in per unit of a specified bus, along with a corresponding call to the VOLMAG monitoring model.\n--- Auxiliary Signal Models \u2014 .txt ---\nAuxiliary Signal Models \u2014\nAuxiliary Signal Models\u00b6\nadd_fctsauxsignal_model\nadd a FACTS device auxiliary signal model at the specified injection point of the designated FACTS device.\nadd_mtdcauxsignal_model\nadd a multi-terminal dc line auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.\nadd_ttdcauxsignal_model\nadd a two-terminal dc line auxiliary signal model at the specified injection point of the designated two-terminal dc line.\nadd_vsdcauxsignal_model\nadd a VSC dc line auxiliary signal model at the specified injection point of the designated VSC dc line.\nauxmod_pack\nremove entries that are marked as unused from the auxiliary signal model connection tables and the auxiliary signal array allocation tables.\nauxmod_unconnected\nlist or remove from dynamics working memory those auxiliary signal models that are assigned to dc lines or FACTS devices that are not present in the current power flow working case (unconnected).\nauxmod_user\nlist user-written auxiliary signal model definitions or to remove user-written auxiliary signal model definitions that are not assigned to any dc lines or FACTS devices (unused) from the user model definition tables.\nchange_fctsauxmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified FACTS device.\nchange_fctsauxmod_con\nchange the value of a CON of an auxiliary signal model of a specified FACTS device.\nchange_fctsauxmod_data\nchange_fctsauxmod_icon\nchange the value of an integer ICON of an auxiliary signal model of a specified FACTS device.\nchange_fctsauxmod_var\nchange the value of a VAR of an auxiliary signal model of a specified FACTS device.\nchange_mtdcauxmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified multi-terminal dc line.\nchange_mtdcauxmod_con\nchange the value of a CON of an auxiliary signal model of a specified multi- terminal dc line.\nchange_mtdcauxmod_data\nchange_mtdcauxmod_icon\nchange the value of an integer ICON of an auxiliary signal model of a specified multi-terminal dc line.\nchange_mtdcauxmod_var\nchange the value of a VAR of an auxiliary signal model of a specified multi- terminal dc line.\nchange_ttdcauxmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified two-terminal dc line.\nchange_ttdcauxmod_con\nchange the value of a CON of an auxiliary signal model of a specified two- terminal dc line."
  },
  {
    "id": "chunk_002",
    "text": "change_ttdcauxmod_data\nchange_ttdcauxmod_icon\nchange the value of an integer ICON of an auxiliary signal model of a specified two-terminal dc line.\nchange_ttdcauxmod_var\nchange the value of a VAR of an auxiliary signal model of a specified two- terminal dc line.\nchange_vsdcauxmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified VSC dc line.\nchange_vsdcauxmod_con\nchange the value of a CON of an auxiliary signal model of a specified VSC dc line.\nchange_vsdcauxmod_data\nchange_vsdcauxmod_icon\nchange the value of an integer ICON of an auxiliary signal model of a specified VSC dc line.\nchange_vsdcauxmod_var\nchange the value of a VAR of an auxiliary signal model of a specified VSC dc line.\nfctsauxmod_remove\nremove an auxiliary signal model from the specified injection point of a designated FACTS device.\nfctsauxmod_status\nchange the status of the auxiliary signal model at the specified injection point of a designated FACTS device.\nmtdcauxmod_remove\nremove an auxiliary signal model from the specified auxiliary signal index of the designated multi-terminal dc line.\nmtdcauxmod_status\nchange the status of the auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.\nttdcauxmod_remove\nremove an auxiliary signal model from the specified injection point of the designated two-terminal dc line.\nttdcauxmod_status\nchange the status of the auxiliary signal model at the specified injection point of the designated two-terminal dc line.\nvsdcauxmod_remove\nremove an auxiliary signal model from the specified injection point of the designated VSC dc line.\nvsdcauxmod_status\nchange the status of the auxiliary signal model at the specified injection point of the designated VSC dc line.\n--- Branch Data \u2014 .txt ---\nBranch Data \u2014\nBranch Data\u00b6\nabrnchar\nreturn an array of character values for subsystem branches.\nabrncount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the branch data family.\nabrncplx\nreturn an array of complex values for subsystem branches.\nabrnint\nreturn an array of integer values for subsystem branches.\nabrnreal\nreturn an array of real values for subsystem branches.\nabrntypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch data family (aBrnInt, aBrnReal, aBrnCplx and aBrnChar).\n--- Branch Flow Data \u2014 .txt ---\nBranch Flow Data \u2014\nBranch Flow Data\u00b6\naflowchar\nreturn an array of character values for subsystem branches.\naflowcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the branch flow data family.\naflowcplx\nreturn an array of complex values for subsystem branches.\naflowint\nreturn an array of integer values for subsystem branches.\naflowreal\nreturn an array of real values for subsystem branches.\naflowtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch flow data family (aFlowInt, aFlowReal, aFlowCplx and aFlowChar).\n--- Bus Data \u2014 .txt ---\nBus Data \u2014\nBus Data\u00b6\nabuschar\nreturn an array of character values for subsystem buses.\nabuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the bus data family.\nabuscplx\nreturn an array of complex values for subsystem buses.\nabusint\nreturn an array of integer values for subsystem buses.\nabusreal\nreturn an array of real values for subsystem buses.\nabustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the bus data family (aBusInt, aBusReal, aBusCplx and aBusChar).\n--- Bus Subsystems \u2014 .txt ---\nBus Subsystems \u2014\nBus Subsystems\u00b6\nbsys\ndefine a bus subsystem.\nbsysadd\nadd elements to an existing bus subsystem.\nbsysdef\nset the definition of a bus subsystem.\nbsysdelo\ndelete a single bus from a bus subsystem.\nbsysinit\ninitialize or re-initialize a bus subsystem.\nbsysmem\nreplicate the specified bus subsystem in a bus subsystem file.\nbsyso\nbuild a bus subsystem one bus at a time.\nbsysrcl\nrecall a specified bus subsystem saved in a bus subsystem file.\n--- Cct Models \u2014 .txt ---\nCct Models \u2014\nCct Models\u00b6\nadd_cct2dco_model\nadd an \u201cother\u201d type model attached to a 2-terminal dc line.\nadd_cct2wtd_model\nadd a 2-winding transformer device model to the specified 2-winding transformer.\nadd_cct3wtd_model\nadd a 3-winding transformer device model to the specified 3-winding transformer.\nadd_cctbrnd_model\nadd a branch device model to the specified branch.\nadd_cctbrno_model\nadd a branch \u201cother\u201d model to the specified branch.\nadd_cctbuso_model\nadd an \u201cother\u201d type model attached to a bus.\nadd_cctmcno_model\nadd a machine other model to the specified machine.\nadd_cctmcnp_model\nadd a machine protection model to the specified machine.\nadd_cctmsco_model\nadd a miscellaneous \u201cother\u201d type model with the specified model instance.\nadd_cctswso_model\nadd_cctswso_model_2\nadd a switched shunt \u201cother\u201d model to the specified bus.\ncct2dco_list\nlist \u201cother\u201d type models attached to 2-terminal dc lines.\ncct2dcomod_remove\nremove an \u201cother\u201d type model attached to a 2-terminal dc line.\ncct2dcomod_status\nchange status of an \u201cother\u201d type model attached to a 2-terminal dc line.\ncct2wtd_list\nlist \u201cother\u201d type models attached to 2-winding transformers.\ncct2wtdmod_remove\nremove a 2-winding transformer device model attached to the specified 2-winding transformer.\ncct2wtdmod_status\nchange the status of a 2-winding transformer device model attached to the specified 2-winding transformer.\ncct3wtd_list\nlist \u201cother\u201d type models attached to 3-winding transformers.\ncct3wtdmod_remove\nremove a 3-winding transformer device model attached to the specified 3-winding transformer.\ncct3wtdmod_status\nchange the status of a 3-winding transformer device model attached to the specified 3-winding transformer.\ncctbrnd_list\nlist device type models attached to branches.\ncctbrndmod_remove\nremove a branch device model attached to the specified branch.\ncctbrndmod_status\nchange the status of a branch device model attached to the specified branch.\ncctbrno_list\nlist \u201cother\u201d type models attached to branches.\ncctbrnomod_remove\nremove a branch \u201cother\u201d model attached to the specified branch.\ncctbrnomod_status\nchange the status of a branch \u201cother\u201d model attached to the specified branch."
  },
  {
    "id": "chunk_003",
    "text": "cctbuso_list\nlist \u201cother\u201d type models attached to buses.\ncctbusomod_remove\nremove an \u201cother\u201d type model attached to a bus.\ncctbusomod_status\nchange status of an \u201cother\u201d type model attached to a bus.\ncctmcno_list\nlist \u201cother\u201d type models attached to machines.\ncctmcnomod_remove\nremove a machine \u201cother\u201d model attached to the specified machine.\ncctmcnomod_status\nchange status of a machine \u201cother\u201d model attached to the specified machine.\ncctmcnp_list\nlist protection models attached to machines.\ncctmcnpmod_remove\nremove a machine protection model attached to the specified machine.\ncctmcnpmod_status\nchange status of a machine protection model attached to the specified machine.\ncctmod_pack\npack CCT model definition tables.\ncctmod_user\nlist or remove user-written CCT model definitions.\ncctmsco_list\nlist miscellaneous \u201cother\u201d type models.\ncctmscomod_remove\nremove a miscellaneous \u201cother\u201d type model with the specified model instance.\ncctmscomod_status\nchange status of a miscellaneous \u201cother\u201d type model with the specified model instance.\ncctswso_list\nlist \u201cother\u201d type models attached to switched shunts.\ncctswsomod_remove\ncctswsomod_remove_2\nremove an \u201cother\u201d type model attached to a switched shunt.\ncctswsomod_status\ncctswsomod_status_2\nchange status of an \u201cother\u201d type model attached to a switched shunt.\nchange_cct2dcomod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\nchange_cct2dcomod_con\nchange the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\nchange_cct2dcomod_icon\nchange the value of an integer ICON of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\nchange_cct2dcomod_var\nchange the value of VAR of the \u201cother\u201d type model attached to a specified 2-terminal dc line.\nchange_cct2wtdmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the 2-winding transformer device model of a specified branch.\nchange_cct2wtdmod_con\nchange the value of a real constant (CON) of the 2-winding transformer device model of a specified branch.\nchange_cct2wtdmod_icon\nchange the value of an integer ICON of the 2-winding transformer device model of a specified branch.\nchange_cct2wtdmod_var\nchange the value of VAR of the 2-winding transformer device model of a specified branch.\nchange_cct3wtdmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the 3-winding transformer device model of a specified branch.\nchange_cct3wtdmod_con\nchange the value of a real constant (CON) of the 3-winding transformer device model of a specified branch.\nchange_cct3wtdmod_icon\nchange the value of an integer ICON of the 3-winding transformer device model of a specified branch.\nchange_cct3wtdmod_var\nchange the value of VAR of the 3-winding transformer device model of a specified branch.\nchange_cctbrndmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the branch device model of a specified branch.\nchange_cctbrndmod_con\nchange the value of a real constant (CON) of the branch device model of a specified branch.\nchange_cctbrndmod_icon\nchange the value of an integer ICON of the branch device model of a specified branch.\nchange_cctbrndmod_var\nchange the value of VAR of the branch device model of a specified branch.\nchange_cctbrnomod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the branch \u201cother\u201d model of a specified branch.\nchange_cctbrnomod_con\nchange the value of a real constant (CON) of the branch \u201cother\u201d model of a specified branch.\nchange_cctbrnomod_icon\nchange the value of an integer ICON of the branch \u201cother\u201d model of a specified branch.\nchange_cctbrnomod_var\nchange the value of VAR of the branch \u201cother\u201d model of a specified branch.\nchange_cctbusomod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified bus.\nchange_cctbusomod_con\nchange the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified bus.\nchange_cctbusomod_icon\nchange the value of an integer ICON of the \u201cother\u201d type model attached to a specified bus.\nchange_cctbusomod_var\nchange the value of VAR of the \u201cother\u201d type model attached to a specified bus.\nchange_cctmcnomod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the machine \u201cother\u201d model for a specified machine.\nchange_cctmcnomod_con\nchange the value of a real constant (CON) of the machine \u201cother\u201d model for a specified machine.\nchange_cctmcnomod_icon\nchange the value of an integer ICON of the machine \u201cother\u201d model for a specified machine.\nchange_cctmcnomod_var\nchange the value of VAR of the machine \u201cother\u201d model for a specified machine.\nchange_cctmcnpmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the machine protection model of a specified machine.\nchange_cctmcnpmod_con\nchange the value of a real constant (CON) of the machine protection model of a specified machine.\nchange_cctmcnpmod_icon\nchange the value of an integer ICON of the machine protection model of a specified machine.\nchange_cctmcnpmod_var\nchange the value of VAR of the machine protection model of a specified machine.\nchange_cctmscomod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the miscellaneous \u201cother\u201d type model with the specified model instance.\nchange_cctmscomod_con\nchange the value of a real constant (CON) of the miscellaneous \u201cother\u201d type model with the specified model instance.\nchange_cctmscomod_icon\nchange the value of an integer ICON of the miscellaneous \u201cother\u201d type model with the specified model instance.\nchange_cctmscomod_var\nchange the value of VAR of the miscellaneous \u201cother\u201d type model with the specified model instance.\nchange_cctswsomod_chricn\nchange_cctswsomod_chricn_2\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the \u201cother\u201d type model attached to a specified switched shunt.\nchange_cctswsomod_con\nchange_cctswsomod_con_2\nchange the value of a real constant (CON) of the \u201cother\u201d type model attached to a specified switched shunt.\nchange_cctswsomod_icon\nchange_cctswsomod_icon_2\nchange the value of an integer ICON of the \u201cother\u201d type model attached to a specified switched shunt.\nchange_cctswsomod_var\nchange_cctswsomod_var_2\nchange the value of VAR of the \u201cother\u201d type model attached to a specified switched shunt.\n--- Character Data \u2014 .txt ---\nCharacter Data \u2014\nCharacter Data\u00b6\nget_char_length\nreturn the number of characters required to accommodate the data corresponding to the specified STRING entries, which can be for any of the a*Char data retrieval functions.\n--- Dc Line Related Models \u2014 .txt ---"
  },
  {
    "id": "chunk_004",
    "text": "Dc Line Related Models \u2014\nDc Line Related Models\u00b6\nadd_mtdcline_model\nadd a multi-terminal dc line model to the specified multi-terminal dc line.\nadd_ttdcline_model\nadd a two-terminal dc line model to the specified two-terminal dc line.\nadd_vsdcline_model\nadd a VSC dc line model to the specified VSC dc line.\nchange_mtdclmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the multi-terminal dc line model of a specified multi-terminal dc line.\nchange_mtdclmod_con\nchange the value of a CON of the multi-terminal dc line model of a specified multi-terminal dc line.\nchange_mtdclmod_data\nchange_mtdclmod_icon\nchange the value of an integer ICON of the multi-terminal dc line model of a specified multi-terminal dc line.\nchange_mtdclmod_var\nchange the value of a VAR of the multi-terminal dc line model of a specified multi-terminal dc line.\nchange_ttdclmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the two-terminal dc line model of a specified two-terminal dc line.\nchange_ttdclmod_con\nchange the value of a CON of the two-terminal dc line model of a specified two- terminal dc line.\nchange_ttdclmod_data\nchange_ttdclmod_icon\nchange the value of an integer ICON of the two-terminal dc line model of a specified two-terminal dc line.\nchange_ttdclmod_var\nchange the value of a VAR of the two-terminal dc line model of a specified two- terminal dc line.\nchange_vsdclmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the VSC dc line model of a specified VSC dc line.\nchange_vsdclmod_con\nchange the value of a CON of the VSC dc line model of a specified VSC dc line.\nchange_vsdclmod_data\nchange_vsdclmod_icon\nchange the value of an integer ICON of the VSC dc line model of a specified VSC dc line.\nchange_vsdclmod_var\nchange the value of a VAR of the VSC dc line model of a specified VSC dc line.\ndclmod_pack\nremove entries that are marked as unused from the dc line model connection tables and the dc line array allocation tables.\ndclmod_unconnected\nlist or remove from dynamics working memory those dc line models that are assigned to dc lines that are not present in the current power flow working case (unconnected).\ndclmod_user\nlist user-written dc line model definitions or to remove user-written dc line model definitions that are not assigned to any dc lines (unused) from the user model definition tables.\nmtdclmod_remove\nremove the multi-terminal dc line model from a specified multi-terminal dc line.\nmtdclmod_status\nchange the status of the multi-terminal dc line model at a specified multi- terminal dc line.\nttdclmod_remove\nremove the two-terminal dc line model from a specified two-terminal dc line.\nttdclmod_status\nchange the status of the two-terminal dc line model at a specified two-terminal end line.\nvsdclmod_remove\nremove the VSC dc line model from a specified VSC dc line.\nvsdclmod_status\nchange the status of the VSC dc line model at a specified VSC dc line.\n--- Diagram View \u2014 .txt ---\nDiagram View \u2014\nDiagram View\u00b6\nchangediagcontour\nchange the contour parameters for the contour in the active Slider diagram in the GUI.\ncheckdiagfile\ncheck the active Slider Diagram in the GUI against the current network case.\nclosediagfile\nclose the active Slider Diagram in the GUI without prompting to save the Diagram.\ndeletediagcontour\ndelete the contour from the active Slider Diagram in the GUI.\nenablediagcontour\nspecify the contour parameters and display a contour in the active Slider Diagram in the GUI.\nexportbuslocfile\nexportbuslocfile_2\nexport the bus location from the active Slider Diagram in the GUI to a file.\nexportimagefile\nexportimagefile_2\nexport an image of the active Slider Diagram in the GUI to a file.\ngexmbus\ncreate a GEXM/GOUT display of a bus in an active Slider diagram in the GUI.\ngrowbus\nGROW a bus in an active Slider diagram in the GUI.\ngrowbuslevels\nGROW a bus and all the connected buses up to the specified number of levels away in an active Slider diagram in the GUI.\ngrowdiagram\ngrowdiagram_2\nGROW a bus and all the connected buses in an active Slider diagram in the GUI.\ngrowstation\nThis API routine was first introduced in release 34.\ngrpg\nproduce a GRPG report in the active Slider diagram in the GUI.\nimportdrawfile\nimport a Draw Data File into an active Slider diagram in the GUI.\nimportimagefile\nimport an image into the background layer of the active Slider diagram in the GUI.\nnewdiagfile\nopen a new Slider diagram in the GUI.\nnextdiagfiledataset\nThis API is used to display the next element in the active data set on the active Slider diagram.\nopenaccfile\nopenaccfile_2\nThis API is used to open an existing ACC results file for displaying results on diagram.\nopenbuslocfile\nopen an existing bus location file in the GUI.\nopendiagfile\nopen an existing Slider diagram in the GUI.\nprevdiagfiledataset\nThis API is used to display the previous element in the active data set on the active Slider diagram.\nprintdiagfile\nprintdiagfile_2\nprint the active Slider diagram in the GUI.\nrefreshdiagcontour\nrefresh the contour in the active Slider diagram in the GUI.\nrefreshdiagfile\nrefresh the results and styles in the active Slider diagram in the GUI.\nrenumdiagfile\nrenumber buses in the active Slider diagram in the GUI.\nsavediagfile\nsave the active Slider diagram in the GUI.\nsetdiagautofile\nspecify an automation file that is run each time results are updated on the active Slider diagram.\nsetdiagfont\nspecify the default text font in the active Slider diagram.\nsetdiagprec\nsetdiagprec_2\nspecify the precision of results displayed in Slider Diagrams.\nsetdiagprop\nsetdiagprop_2\nsetdiagprop_3\nsetdiagprop_4\nsetdiagprop_5\nspecify basic properties in the active Slider diagram.\nsetdiagresaccc\nsetdiagresaccc_2\nsetdiagresaccc_3\nset the ACCC analysis annotation options in the active Slider diagram.\nsetdiagresascc\nsetdiagresascc_2\nsetdiagresascc_3\nThis API is used to set the ASCC short circuit analysis annotation options in the active Slider diagram.\nsetdiagresdata\nsetdiagresdata_2\nsetdiagresdata_3\nspecify the basic Power Flow annotation options in the active Slider Diagram.\nsetdiagresdyn\nsetdiagresdyn_2\nThis API is used to set the dynamic simulation annotation options in the active Slider diagram.\nsetdiagresgdif\nspecify the case comparison voltage and range checking annotation options in the active Slider diagram.\nsetdiagresiec"
  },
  {
    "id": "chunk_005",
    "text": "setdiagresiec_2\nsetdiagresiec_3\nspecify the IEC annotation options in the active Slider diagram.\nsetdiagresmust\nThis API is used to set the MUST simulation annotation options in the active Slider diagram.\nsetdiagresopf\nsetdiagresopf_2\nsetdiagresopf_3\nspecify the OPF annotation options in the active Slider diagram.\nsetdiagrespflowcheck\nsetdiagrespflowcheck_2\nsetdiagrespflowcheck_3\nspecify the Power Flow voltage and range checking annotation options in the active Slider Diagram.\nsetdiagrespflowoptions\nsetdiagrespflowoptions_2\nsetdiagrespflowoptions_3\nspecify the basic Power Flow annotation options in the active Slider diagram.\nsetdiagresrel\nsetdiagresrel_2\nsetdiagresrel_3\nspecify the reliability annotation options in the active Slider diagram.\nsetdiagresscgr\nspecify the short circuit analysis voltage and range checking annotation options in the active Slider diagram.\nsetdiagrestypeacc\nset the type of results displayed in the active Slider diagram to ACCC results.\nsetdiagrestypeascc\nset the type of results displayed in the active Slider diagram to ASCC fault calculation results.\nsetdiagrestypedata\nset the type of results displayed in the active Slider diagram to impedance data values.\nsetdiagrestypedyn\nset the type of results displayed in the active Slider diagram to Dynamics data results.\nsetdiagrestypegdif\nset the type of results displayed in the active Slider diagram to the differences in values between the current network case and a supplied comparison case.\nsetdiagrestypegic\nset the type of results displayed in the active Slider diagram to GIC solution results.\nsetdiagrestypeharm\nset the type of results displayed in the active Slider diagram to Harmonics solution results.\nsetdiagrestypeiec\nset the type of results displayed in the active Slider diagram to IEC Fault calculation results.\nsetdiagrestypemust\nset the type of results displayed in the active Slider diagram to MUST solution results.\nsetdiagrestypeopf\nset the type of results displayed in the active Slider diagram to OPF solution results.\nsetdiagrestypepflow\nset the type of results displayed in the active Slider diagram to Power Flow results.\nsetdiagrestyperel\nset the type of results displayed in the active Slider diagram to reliability analysis results.\nsetdiagrestypescgr\nset the type of results displayed in the active Slider diagram to the results of a short circuit analysis.\nsetdiagrestypetspf\nset the type of results displayed in the active Slider diagram to TSPF solution results.\nsetdiagresvrcs\nsetdiagresvrcs_2\nspecify the system diagram defaults for Voltage coloring and style, Out of Service coloring and style etc.\nsetdiagtitle\nset the title of the active Slider diagram.\nswitchdiagfiledataset\nThis API is used to rotate through values for the current element in the active data set on the active Slider diagram.\nupdatebuslocdiagfile\nupdate bus locations in the active Slider diagram in the GUI using the positions found in the current bus location file.\n--- Dynamic Simulation Operation \u2014 .txt ---\nDynamic Simulation Operation \u2014\nDynamic Simulation Operation\u00b6\naddmodellibrary\nadd a library to the list to be searched for library models.\nastr\ncalculate and replicates the state variable system matrices in the form required by the Linear Dynamic Analysis Program, LSYSAN (activity ASTR).\naulist\nlist auxiliary signal models that inject signals into dc lines or FACTS devices connected to subsystem buses, along with their storage locations in the dynamics data arrays.\nchange_channel_out_file\nmodify the dynamic simulation channel output filename in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).\nchange_chricn\nchange the value of an element of the CHRICN array (a character ICON).\nchange_con\nchange the value of an element of the CON array.\nchange_gref\nchange the value of the element of the GREF (governor reference) array associated with a specified machine.\nchange_icon\nchange the value of an element of the ICON array (an integer ICON).\nchange_state\nchange the value of an element of the STATE array, as well as the values of the corresponding time derivative (DSTATE) and the associated memory cell used in the integration algorithm (STORE).\nchange_swsref\nchange_swsref_2\nchange the value of the element of the SWREF array associated with a specified switched shunt.\nchange_var\nchange the value of an element of the VAR array.\nchange_vref\nchange the value of the element of the VREF array associated with a specified machine.\ncrctrun\nrun critical clearing time calculation in dynamic simulations.\ndclist\nlist dc line models connected to subsystem buses along with their storage locations in the dynamics data arrays.\ndlst\ntabulate specified portions of one or more of the PSSE dynamics data storage arrays.\ndocu\ntabulate the data associated with equipment models referenced in the user\u2019s simulation setup.\ndropmodellibrary\nremove a library from the list being searched for library models.\ndropmodelprogram\nremove a model from the list of known library models; library models are added to this list the first time that they are called.\ndyda\nreplicate dynamics model data in the form of a Dynamics Data Input file.\ndynamics_solution_param_2\nmodify the dynamic simulation solution parameters (except the channel output filename) in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).\ndynamics_solution_params\ndynamicsmode\nreturn PSSE to dynamics mode following the use of the POWERFLOWMODE API while in dynamics mode.\ndynexportcsv\nexport dynamics engine and dynamics model messages that are displayed after running a dynamics simulation to CSV file format.\ndyre_add\nread a Dynamics Model Raw Data File and append the model references specified in its data records to the simulation data already contained in dynamics working memory (activity DYRE,ADD).\ndyre_new\nclear dynamics working memory, read a Dynamics Data File, and place the model references specified on its data records into dynamics working memory.\nerun\ncalculate PSSE state-space dynamic simulations of excitation system response tests.\nestr_open_circuit_test\ninitialize a PSSE dynamic simulation for excitation system open circuit response simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.\nestr_response_ratio_test\ninitialize a PSSE dynamic simulation for excitation system response ratio test simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.\nfclist\nlist FACTS device models connected to subsystem buses along with their storage locations in the dynamics data arrays.\ngrun\ncalculate PSSE state-space dynamic simulations of turbine-governor response tests.\ngstr\ninitialize a PSSE dynamic simulation for governor response simulations and to specify the Channel Output File into which the output channel values are to be recorded during the simulation."
  },
  {
    "id": "chunk_006",
    "text": "increment_gref\nadd a specified value to the value of the element of the GREF (governor reference) array associated with a specified machine.\nincrement_swsref\nincrement_swsref_2\nadd a specified value to the value of the element of the SWREF (switched shunt reference) array associated with a specified switched shunt.\nincrement_vref\nadd a specified value to the value of the element of the VREF (voltage reference) array associated with a specified machine.\nldclist\nlist load models connected to subsystem loads along with their storage locations in the dynamics data arrays.\nldlist\nlist load models connected to subsystem loads along with their storage locations in the dynamics data arrays.\nload_array_channel\nadd an output channel containing the active or reactive component of a designated load.\nmlst\nlist plant models connected to subsystem machines along with their storage locations in the dynamics data arrays.\nmrun\ncalculate PSSE extended term dynamic simulations.\nmstr\ninitialize a PSSE dynamic simulation for extended term simulations and to specify the Channel Output File into which the output channel values are to be recorded during the dynamic simulation.\npowerflowmode\nswitch PSSE from dynamics mode to power flow mode.\npsas\nconvert a PSAS Command File into a PSSE Response File.\nrllist\nlist line relay models connected to subsystem buses along with their storage locations in the dynamics data arrays.\nrstr\nread a dynamics Snapshot File into PSSE working memory.\nrun\ncalculate PSSE state-space dynamic simulations.\nrwdy\nreplicate portions of dynamics model data in the form of either a breaker duty data file, unit inertia and governor data file, or PSSPLT relay characteristic data file.\nset_chnfil_type\nset/Get the channel output file type (extended type or not).\nset_disable_run\nenable or disable the simulation option setting that precludes dynamic simulation runs in the event there are fatal errors in the model data.\nset_freq_relay_v_thresh\nThis API is used to set voltage threshold for use in frequency relay models.\nset_genang\nset_genang_2\nset_genang_3\nenable or disable the simulation option setting that scans for generators for which the angle differs from the angular average by more than a specified threshold.\nset_genang_subsys_flag\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scan for generators exceeding angle threshold.\nset_genpwr\nenable or disable the simulation option setting that scans for generators for which the mechanical power differs from its electrical power by more than a specified threshold.\nset_genspdev\nenable or disable the simulation option setting that scans for generators for which the speed deviation is more than a specified threshold.\nset_genspdev_subsys_flag\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans for generators for which the speed deviation is more than a specified threshold.\nset_load_model_thresh\nThis API is used to set the MW, P over Q, and load bus voltage thresholds for load models.\nset_model_debug_output_flag\nenable or disable the simulation option setting for dynamic model debug output.\nset_netfrq\nenable or disable the simulation option setting that models the frequency dependence of network parameters.\nset_next_channel\nassign the next available channel index value.\nset_next_icon\nassign the next available ICON index value.\nset_next_var\nassign the next available VAR index value.\nset_osscan\nenable or disable the simulation option setting that scans for out-of-step conditions using a generic relay.\nset_osscan_2\nset_osscan_subsys_flag\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans for out-of-step conditions using a generic relay.\nset_relang\nenable or disable the simulation option setting that expresses the ANGLE array relative to a designated reference angle.\nset_relscn\nenable or disable the simulation option setting that scans branches using a generic branch relay.\nset_relscn_subsys_flag\nUse this API api for get/set the flag that is used for the subsystem defintion for performing scans of branches using a generic branch relay.\nset_vltscn\nenable or disable the simulation option setting that scans buses for high or low values of voltage magnitude.\nset_vltscn_subsys_flag\nUse this API api for get/set the flag that is used for the subsystem definition for performing scans of buses for high or low voltage magnitudes.\nset_volt_viol_subsys_flag\nThis API is used to set the flag to denote the bus subsystem to be used for voltage violation (voltage recovery and voltage dip) checks.\nset_voltage_dip_check\nThis API is used to enable or disable the simulation option setting which scans buses for voltage dip (back-swing).\nset_voltage_rec_check\nThis API is used to enable or disable the simulation option setting which scans buses for voltage recovery (primary and secondary recovery).\nset_zsorce_reconcile_flag\nenable or disable the simulation option setting for automatic ZSORCE reconciliation.\nsize_ds\nobtain a summary of utilization in the general purpose dynamics data storage arrays as well as in the various model connection and allocation tables contained in dynamics working memory.\nsnap\nsave PSSE dynamics working memory into a Snapshot file.\nstrt\nstrt_2\nThis API routine is the second release of the dynamic simulation initialization function.\nswslist\nlist switched shunt models connected to subsystem buses along with their storage locations in the dynamics data arrays.\ntrig_volt_violation_check\nThis API is used to trigger voltage violation (voltage recovery, voltage dip) checks.\nwnlist\nlist wind models connected to subsystem buses along with their storage locations in the dynamics data arrays.\n--- Dynamic Simulation Output Channel Operation \u2014 .txt ---\nDynamic Simulation Output Channel Operation \u2014\nDynamic Simulation Output Channel Operation\u00b6\nchange_channel\nchange the channel address and the channel identifier of a specified output channel.\nchsb\nspecify, on a subsystem basis, the simulation variables to monitor during dynamic simulation runs (activity CHSB).\ncrt_plot_channel\nassign one of the main simulation output channels to a designated CRT plot channel.\ndelete_all_plot_channels\ndelete all the plot channels in the working case.\ndmpc\nreplicate the output channel specifications from dynamics working memory in the form of a response file suitable for transferring them to another snapshot that models essentially the same system.\nlist_channel_models\ntabulate the output channel monitoring models referenced in the dynamic model.\nremove_unused_chan_models\ndelete from the output channel monitoring model table those model references indicating equipment that is not present in the power flow working case."
  },
  {
    "id": "chunk_007",
    "text": "--- Event Studies \u2014 .txt ---\nEvent Studies \u2014\nEvent Studies\u00b6\ncloseeventstudyfile\nclose an open Event Study file.\nopeneventstudyfile\nopen a new or existing event study file in the GUI.\nrundynamiceventstudy\nrun a dynamic study using the active event study in the open event study file.\nrunpowerfloweventstudy\nrun a power flow study using the active event study in the open event study file.\nsaveeventstudyfile\nsave existing event studies in an event study file.\nsetactiveeventstudy\nselect an Event Study in an Event file as the active Event Study for running dynamic or power flow event studies.\n--- Extension Data Access \u2014 .txt ---\nExtension Data Access \u2014\nExtension Data Access\u00b6\nget_ext_acline_char\nget ac line character extension data.\nget_ext_acline_int\nget ac line integer extension data.\nget_ext_acline_logical\nget ac line logical extension data.\nget_ext_acline_real\nget ac line real extension data.\nget_ext_area_char\nget area character extension data.\nget_ext_area_int\nget area integer extension data.\nget_ext_area_logical\nget area logical extension data.\nget_ext_area_real\nget area real extension data.\nget_ext_bus_char\nget bus character extension data.\nget_ext_bus_int\nget bus integer extension data.\nget_ext_bus_logical\nget bus logical extension data.\nget_ext_bus_real\nget bus real extension data.\nget_ext_char\nget character extension data.\nget_ext_facts_char\nget facts device character extension data.\nget_ext_facts_int\nget facts device integer extension data.\nget_ext_facts_logical\nget facts device logical extension data.\nget_ext_facts_real\nget facts device real extension data.\nget_ext_fixshunt_char\nget fixed shunt character extension data.\nget_ext_fixshunt_int\nget fixed shunt integer extension data.\nget_ext_fixshunt_logical\nget fixed shunt logical extension data.\nget_ext_fixshunt_real\nget fixed shunt real extension data.\nget_ext_generator_char\nget generator character extension data.\nget_ext_generator_int\nget generator integer extension data.\nget_ext_generator_logical\nget generator logical extension data.\nget_ext_generator_real\nget generator real extension data.\nget_ext_gne_char\nget general network element device character extension data.\nget_ext_gne_int\nget general network element device integer extension data.\nget_ext_gne_logical\nget general network element device logical extension data.\nget_ext_gne_real\nget general network element device real extension data.\nget_ext_iatrans_char\nget inter-area transfer character extension data.\nget_ext_iatrans_int\nget inter-area transfer integer extension data.\nget_ext_iatrans_logical\nget inter-area transfer logical extension data.\nget_ext_iatrans_real\nget inter-area transfer real extension data.\nget_ext_indmach_char\nget induction machine character extension data.\nget_ext_indmach_int\nget induction machine integer extension data.\nget_ext_indmach_logical\nget induction machine logical extension data.\nget_ext_indmach_real\nget induction machine real extension data.\nget_ext_int\nget integer extension data.\nget_ext_load_char\nget load character extension data.\nget_ext_load_int\nget load integer extension data.\nget_ext_load_logical\nget load logical extension data.\nget_ext_load_real\nget load real extension data.\nget_ext_logical\nget logical extension data.\nget_ext_msline_char\nget multi-section line character extension data.\nget_ext_msline_int\nget multi-section line integer extension data.\nget_ext_msline_logical\nget multi-section line logical extension data.\nget_ext_msline_real\nget multi-section line real extension data.\nget_ext_ntermdc_char\nget multi-terminal dc line character extension data.\nget_ext_ntermdc_int\nget multi-terminal dc line integer extension data.\nget_ext_ntermdc_logical\nget multi-terminal dc line logical extension data.\nget_ext_ntermdc_real\nget multi-terminal dc line real extension data.\nget_ext_owner_char\nget owner character extension data.\nget_ext_owner_int\nget owner integer extension data.\nget_ext_owner_logical\nget owner logical extension data.\nget_ext_owner_real\nget owner real extension data.\nget_ext_rating_char\nget rating character extension data.\nget_ext_rating_int\nget rating integer extension data.\nget_ext_rating_logical\nget rating logical extension data.\nget_ext_rating_real\nget rating real extension data.\nget_ext_real\nget real extension data.\nget_ext_rowcount\nget extension data table row count.\nget_ext_sub_char\nget substation character extension data.\nget_ext_sub_int\nget substation integer extension data.\nget_ext_sub_logical\nget substation logical extension data.\nget_ext_sub_real\nget substation real extension data.\nget_ext_subnode_char\nget substation node character extension data.\nget_ext_subnode_int\nget substation node integer extension data.\nget_ext_subnode_logical\nget substation node logical extension data.\nget_ext_subnode_real\nget substation node real extension data.\nget_ext_subswd_char\nget substation switching device character extension data.\nget_ext_subswd_int\nget substation switching device integer extension data.\nget_ext_subswd_logical\nget substation switching device logical extension data.\nget_ext_subswd_real\nget substation switching device real extension data.\nget_ext_swshunt_char\nget switched shunt character extension data.\nget_ext_swshunt_int\nget switched shunt integer extension data.\nget_ext_swshunt_logical\nget switched shunt logical extension data.\nget_ext_swshunt_real\nget switched shunt real extension data.\nget_ext_sysswd_char\nget system switching device character extension data.\nget_ext_sysswd_int\nget system switching device integer extension data.\nget_ext_sysswd_logical\nget system switching device logical extension data.\nget_ext_sysswd_real\nget system switching device real extension data.\nget_ext_transformer_char\nget transformer character extension data.\nget_ext_transformer_int\nget transformer integer extension data.\nget_ext_transformer_logical\nget transformer logical extension data.\nget_ext_transformer_real\nget transformer real extension data.\nget_ext_twotermdc_char\nget two-terminal dc line character extension data.\nget_ext_twotermdc_int\nget two-terminal dc line integer extension data.\nget_ext_twotermdc_logical\nget two-terminal dc line logical extension data.\nget_ext_twotermdc_real\nget two-terminal dc line real extension data.\nget_ext_vscdc_char\nget voltage source converter dc line character extension data.\nget_ext_vscdc_int\nget voltage source converter dc line integer extension data.\nget_ext_vscdc_logical\nget voltage source converter dc line logical extension data.\nget_ext_vscdc_real\nget voltage source converter dc line real extension data.\nget_ext_zone_char\nget zone character extension data.\nget_ext_zone_int\nget zone integer extension data.\nget_ext_zone_logical\nget zone logical extension data.\nget_ext_zone_real\nget zone real extension data.\nset_ext_acline_char\nset ac line character extension data.\nset_ext_acline_int\nset ac line integer extension data.\nset_ext_acline_logical\nset ac line logical extension data.\nset_ext_acline_real\nset ac line real extension data.\nset_ext_area_char\nset area character extension data.\nset_ext_area_int\nset area integer extension data.\nset_ext_area_logical\nset area logical extension data.\nset_ext_area_real\nset area real extension data.\nset_ext_bus_char\nset bus character extension data.\nset_ext_bus_int\nset bus integer extension data.\nset_ext_bus_logical\nset bus logical extension data.\nset_ext_bus_real\nset bus real extension data.\nset_ext_char\nset character extension data.\nset_ext_facts_char\nset facts device character extension data.\nset_ext_facts_int\nset facts device integer extension data.\nset_ext_facts_logical\nset facts device logical extension data.\nset_ext_facts_real\nset facts device real extension data.\nset_ext_fixshunt_char\nset fixed shunt character extension data.\nset_ext_fixshunt_int\nset fixed shunt integer extension data.\nset_ext_fixshunt_logical\nset fixed shunt logical extension data.\nset_ext_fixshunt_real\nset fixed shunt real extension data.\nset_ext_generator_char\nset generator character extension data.\nset_ext_generator_int\nset generator integer extension data.\nset_ext_generator_logical\nset generator logical extension data.\nset_ext_generator_real\nset generator real extension data.\nset_ext_gne_char\nset general network element device character extension data.\nset_ext_gne_int\nset general network element device integer extension data.\nset_ext_gne_logical\nset general network element device logical extension data.\nset_ext_gne_real\nset general network element device real extension data.\nset_ext_iatrans_char\nset inter-area transfer character extension data.\nset_ext_iatrans_int\nset inter-area transfer integer extension data.\nset_ext_iatrans_logical\nset inter-area transfer logical extension data.\nset_ext_iatrans_real\nset inter-area transfer real extension data."
  },
  {
    "id": "chunk_008",
    "text": "set_ext_indmach_char\nset induction machine character extension data.\nset_ext_indmach_int\nset induction machine integer extension data.\nset_ext_indmach_logical\nset induction machine logical extension data.\nset_ext_indmach_real\nset induction machine real extension data.\nset_ext_int\nset integer extension data.\nset_ext_load_char\nset load character extension data.\nset_ext_load_int\nset load integer extension data.\nset_ext_load_logical\nset load logical extension data.\nset_ext_load_real\nset load real extension data.\nset_ext_logical\nset logical extension data.\nset_ext_msline_char\nset multi-section line character extension data.\nset_ext_msline_int\nset multi-section line integer extension data.\nset_ext_msline_logical\nset multi-section line logical extension data.\nset_ext_msline_real\nset multi-section line real extension data.\nset_ext_ntermdc_char\nset multi-terminal dc line character extension data.\nset_ext_ntermdc_int\nset multi-terminal dc line integer extension data.\nset_ext_ntermdc_logical\nset multi-terminal dc line logical extension data.\nset_ext_ntermdc_real\nset multi-terminal dc line real extension data.\nset_ext_owner_char\nset owner character extension data.\nset_ext_owner_int\nset owner integer extension data.\nset_ext_owner_logical\nset owner logical extension data.\nset_ext_owner_real\nset owner real extension data.\nset_ext_rating_char\nset rating character extension data.\nset_ext_rating_int\nset rating integer extension data.\nset_ext_rating_logical\nset rating logical extension data.\nset_ext_rating_real\nset rating real extension data.\nset_ext_real\nset real extension data.\nset_ext_sub_char\nset substation character extension data.\nset_ext_sub_int\nset substation integer extension data.\nset_ext_sub_logical\nset substation logical extension data.\nset_ext_sub_real\nset substation real extension data.\nset_ext_subnode_char\nset substation node character extension data.\nset_ext_subnode_int\nset substation node integer extension data.\nset_ext_subnode_logical\nset substation node logical extension data.\nset_ext_subnode_real\nset substation node real extension data.\nset_ext_subswd_char\nset substation switching device character extension data.\nset_ext_subswd_int\nset substation switching device integer extension data.\nset_ext_subswd_logical\nset substation switching device logical extension data.\nset_ext_subswd_real\nset substation switching device real extension data.\nset_ext_swshunt_char\nset switched shunt character extension data.\nset_ext_swshunt_int\nset switched shunt integer extension data.\nset_ext_swshunt_logical\nset switched shunt logical extension data.\nset_ext_swshunt_real\nset switched shunt real extension data.\nset_ext_sysswd_char\nset system switching device character extension data.\nset_ext_sysswd_int\nset system switching device integer extension data.\nset_ext_sysswd_logical\nset system switching device logical extension data.\nset_ext_sysswd_real\nset system switching device real extension data.\nset_ext_transformer_char\nset transformer character extension data.\nset_ext_transformer_int\nset transformer integer extension data.\nset_ext_transformer_logical\nset transformer logical extension data.\nset_ext_transformer_real\nset transformer real extension data.\nset_ext_twotermdc_char\nset two-terminal dc line character extension data.\nset_ext_twotermdc_int\nset two-terminal dc line integer extension data.\nset_ext_twotermdc_logical\nset two-terminal dc line logical extension data.\nset_ext_twotermdc_real\nset two-terminal dc line real extension data.\nset_ext_vscdc_char\nset voltage source converter dc line character extension data.\nset_ext_vscdc_int\nset voltage source converter dc line integer extension data.\nset_ext_vscdc_logical\nset voltage source converter dc line logical extension data.\nset_ext_vscdc_real\nset voltage source converter dc line real extension data.\nset_ext_zone_char\nset zone character extension data.\nset_ext_zone_int\nset zone integer extension data.\nset_ext_zone_logical\nset zone logical extension data.\nset_ext_zone_real\nset zone real extension data.\n--- Facts Device Bus Data \u2014 .txt ---\nFacts Device Bus Data \u2014\nFacts Device Bus Data\u00b6\nafactsbuschar\nreturn an array of character values for subsystem FACTS device buses.\nafactsbuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device bus data family.\nafactsbuscplx\nreturn an array of complex values for subsystem FACTS device buses.\nafactsbusint\nreturn an array of integer values for subsystem FACTS device buses.\nafactsbusreal\nreturn an array of real values for subsystem FACTS device buses.\nafactsbustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device bus data family (aFactsBusInt, aFactsBusReal, aFactsBusCplx and aFactsBusChar).\n--- Facts Device Data \u2014 .txt ---\nFacts Device Data \u2014\nFacts Device Data\u00b6\nafactschar\nreturn an array of character values for subsystem FACTS devices.\nafactscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device data family.\nafactscplx\nreturn an array of complex values for subsystem FACTS devices.\nafactsint\nreturn an array of integer values for subsystem FACTS devices.\nafactsreal\nreturn an array of real values for subsystem FACTS devices.\nafactstypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device data family (aFactsInt, aFactsReal, aFactsCplx and aFactsChar).\n--- Facts Device Models \u2014 .txt ---\nFacts Device Models \u2014\nFacts Device Models\u00b6\nadd_facts_device_model\nadd a FACTS device model to the specified FACTS device.\nchange_fctmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the FACTS device model of a specified FACTS device.\nchange_fctmod_con\nchange the value of a CON of the FACTS device model of a specified FACTS device.\nchange_fctmod_data\nchange_fctmod_icon\nchange the value of an integer ICON of the FACTS device model of a specified FACTS device.\nchange_fctmod_var\nchange the value of a VAR of the FACTS device model of a specified FACTS device.\nfctmod_pack\nremove entries that are marked as unused from the FACTS device model connection tables and the FACTS device model array allocation tables.\nfctmod_remove\nremove the FACTS device model from a specified FACTS device.\nfctmod_status\nchange the status of the FACTS device model at a specified FACTS device.\nfctmod_unconnected\nlist or remove from dynamics working memory those FACTS device models that are assigned to FACTS device that are not present in the current power flow working case (unconnected).\nfctmod_user\nlist user-written FACTS device model definitions or to remove user-written FACTS device model definitions that are not assigned to any FACTS devices (unused) from the user model definition tables.\ngmb_add_facts_dev_model\nadd a GMB FACTS device model to the specified FACTS device.\n--- Fault Analysis Data \u2014 .txt ---\nFault Analysis Data \u2014\nFault Analysis Data\u00b6\nmbidncs\nchange the table name of the specified non-conventional source fault contribution table in the working case.\nseq_3_wind_grounding_data\nmodify the zero sequence grounding data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).\nseq_3_wind_winding_data\nmodify the zero sequence impedance data of one winding of an existing three- winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data)."
  },
  {
    "id": "chunk_009",
    "text": "seq_branch_data\nseq_branch_data_3\nmodify the zero sequence data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Zero Sequence Non-Transformer Branch Data).\nseq_bus_data\nBus load sequence data is now accessible as load sequence data.\nseq_fixed_shunt_data\nmodify the zero sequence data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Fixed Shunt Data).\nseq_induction_mach_data\nseq_induction_mach_data_2\nUse this API routine to modify the sequence data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Impedance Data).\nseq_load_data\nUse this API routine to modify the sequence data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).\nseq_machine_data\nseq_machine_data_3\nseq_machine_data_4\nUse this API routine to modify the sequence data of an existing machine in the working case (see PSSE Program Operation Manual, Positive Sequence Generator Impedance Data, Negative Sequence Generator Impedance Data and Zero Sequence Generator Impedance Data).\nseq_machine_ncs_data\nUse this API routine to modify a machine\u2019s existing non-conventional source fault current contribution (NCSFCC) data or to add NCSFCC data to an existing machine in the working case.\nseq_machine_ncs_data_purg\nUse this API routine to delete a machine\u2019s existing non-conventional source fault current contribution (NCSFCC) data.\nseq_mutual_data\nmodify existing zero sequence mutual impedance data in the working case or to add a new zero sequence mutual coupling to the working case (see PSSE Program Operation Manual, Zero Sequence Mutual Impedance Data).\nseq_ncs_flt_cntrb_chng\nThis API routine was first introduced in release 34.\nseq_ncs_flt_cntrb_data\nseq_ncs_flt_cntrb_purg\nseq_ncs_table_data\nmodify the data of an existing non-conventional source fault contribution table in the working case or to add a new non-conventional source fault contribution table to the working case.\nseq_ncs_table_onept\nmodify the one data point of an existing non-conventional source fault contribution table in the working case or to add a new one data point to non-conventional source fault contribution table to the working case.\nseq_ncs_table_purg\ndelete an existing non-conventional source fault contribution table from the working case.\nseq_ncs_table_purg_onept\ndelete specified data point in an existing non-conventional source fault contribution table.\nseq_ncs_table_type\nget NCS table type.\nseq_switched_shunt_data\nseq_switched_shunt_data_3\nmodify the zero sequence data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Switched Shunt Data).\nseq_three_winding_data\nseq_three_winding_data_3\nmodify the zero sequence data of an existing three-winding transformer in the working case.\nseq_two_winding_data\nseq_two_winding_data_3\nmodify the zero sequence data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).\n--- Fault Analysis Operation \u2014 .txt ---\nFault Analysis Operation \u2014\nFault Analysis Operation\u00b6\nansi\nansi_2\nansi_3\nThis API routine executes the third release of the ANSI fault calculation function.\nascc\nascc_1a\nascc_2\nascc_3\nThis API is used to apply a series of faults at various locations in the working case.\nascc_scfile\nThis API reads ASCC short circuit results from SCFILE and produces same ASCC output report that was generated when SCFILE was created.\nbkdy\ncalculate and report circuit breaker interrupting duty for 3-phase faults at all buses in a specified subsystem of the working case (activity BKDY).\ncheck_sequence_data\nUse this API routine to perform data checks on the selected categories of sequence data for all buses in the working case or for all buses in a specified subsystem.\nflat\nflat_2\nThis API routine is the second release of the flat conditions function.\niecs\niecs_2\niecs_3\niecs_4\nThis API executes the fourth release of the IEC short circuit calculations function.\niecs_scfile\nThis API reads IECS short circuit results from SCFILE and produces same IECS output report that was generated when SCFILE was created.\nnewseq\ninitialize the fault analysis data arrays, set them to default values, and set the flag indicating that sequence data is present in the working case.\nsceq\nconstruct network equivalents of the positive and zero sequence networks and calculates source impedances at equivalent source nodes for all three sequences in preparation for the unbalanced fault analysis activities of PSSE.\nscgr\nscmu\nscmu_2\ncalculate simultaneous unbalances.\nscop\ntabulate unbalanced fault solution output.\nseqd\nseqd_2\nUse this API routine to factorize the sequence matrices in preparation for unbalanced fault calculations SCMU and SPCB.\nsequence_network_setup\nspecify or return the option to enable or disable automatic fault analysis sequence network setup.\nsqex\ntabulate all fault analysis data pertaining to a specified bus.\n--- Fixed Shunt Bus Data \u2014 .txt ---\nFixed Shunt Bus Data \u2014\nFixed Shunt Bus Data\u00b6\nafxshntbuschar\nreturn an array of character values for subsystem buses.\nafxshntbuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt bus data family.\nafxshntbuscplx\nreturn an array of complex values for subsystem buses.\nafxshntbusint\nreturn an array of integer values for subsystem buses.\nafxshntbusreal\nreturn an array of real values for subsystem buses.\nafxshntbustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt bus data family (aFxShntBusInt, aFxShntBusReal, aFxShntBusCplx and aFxShntBusChar).\n--- Fixed Shunt Data \u2014 .txt ---\nFixed Shunt Data \u2014\nFixed Shunt Data\u00b6\nafxshuntchar\nreturn an array of character values for subsystem fixed shunts.\nafxshuntcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt data family.\nafxshuntcplx\nreturn an array of complex values for subsystem fixed shunts.\nafxshuntint\nreturn an array of integer values for subsystem fixed shunts.\nafxshuntreal\nreturn an array of real values for subsystem fixed shunts.\nafxshunttypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt data family (aFxShuntInt, aFxShuntReal, aFxShuntCplx and aFxShuntChar).\n--- Gic Data \u2014 .txt ---\nGic Data \u2014\nGic Data\u00b6\ngic_2tdc\nmodify or add new two terminal dc GIC shunt data to the working case.\ngic_2tdc_chng\nmodify new two terminal dc GIC shunt data from the working case."
  },
  {
    "id": "chunk_010",
    "text": "gic_2tdc_purg\npurge new two terminal dc GIC shunt data from the working case.\ngic_brn\nmodify or add new GIC branch data to the working case.\ngic_brn_chng\nmodify new GIC branch data from the working case.\ngic_brn_purg\npurge GIC branch data from the working case.\ngic_earth1d_usr\nmodify or add new GIC User 1D Earth Model data to the working case.\ngic_earth1d_usr_chng\nmodify GIC User 1D Earth Model data from the working case.\ngic_facts\nmodify or add new FACTS device GIC shunt data to the working case.\ngic_facts_chng\nmodify new FACTS device GIC shunt data from the working case.\ngic_facts_purg\npurge new FACTS device GIC shunt data from the working case.\ngic_fxsh\nmodify or add new fixed shunt GIC shunt data to the working case.\ngic_fxsh_chng\nmodify fixed shunt GIC shunt data from the working case.\ngic_fxsh_purg\npurge fixed shunt GIC shunt data from the working case.\ngic_load\nmodify or add new load GIC shunt data to the working case.\ngic_load_chng\nmodify load GIC shunt data from the working case.\ngic_load_purg\npurge load GIC shunt data from the working case.\ngic_mtdc\nmodify or add new multi terminal dc GIC shunt data to the working case.\ngic_mtdc_chng\nmodify new multi terminal dc GIC shunt data from the working case.\ngic_mtdc_purg\npurge new multi terminal dc GIC shunt data from the working case.\ngic_substn\nmodify or add new GIC sub station data to the working case.\ngic_substn_chng\nmodify GIC sub station data to the working case.\ngic_substn_purg\npurge GIC sub station data to the working case.\ngic_swsh\nmodify or add new GIC switched shunt data to the working case.\ngic_swsh_chng\nmodify GIC switched shunt data from the working case.\ngic_swsh_purg\npurge GIC switched shunt data from the working case.\ngic_trn\nmodify or add new GIC transformer data to the working case.\ngic_trn_chng\nmodify GIC transformer data to the working case.\ngic_trn_purg\npurge GIC transformer data from the working case.\ngic_vscdc\nmodify or add new vscdc GIC shunt data to the working case.\ngic_vscdc_chng\nmodify new vscdc GIC shunt data from the working case.\ngic_vscdc_purg\npurge new vscdc GIC shunt data from the working case.\n--- Gic Operation \u2014 .txt ---\nGic Operation \u2014\nGic Operation\u00b6\ngic\ngic_2\ngic_3\ngic_4\ngic_5\ngic_6\ngic_7\ngic_8\ncalculate Geomagnetically Induced Currents (GIC) in electric power system network as a result of Geomagnetic Disturbance (GMD).\ngic_branch_efield_nn\ncalculate geoelectric efield induced in the network branches from specified geoelectric efield grid data using nearest neigbor (NN) alogorithm.\ngic_earth1d_usr_purg\npurge GIC User 1D Earth Model data from the working case.\ngic_efield_waveshape\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as provided in EFLDFILE.\ngic_efield_waveshape_ref\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 benhcmark event.\ngic_efield_waveshape_supp\nFor Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 supplemental event.\ngic_mvarloss_scaling_factors\nSpecify KFACTORS to determine transformer reactive power losses due to geomagnetic currents (GICs) flow.\ngic_new\ninitialize all data records required for GIC analysis.\ngic_pf_options\nspecify the Newton-Raphson power flow solution options used in GIC.\ngic_purg\npurge all GIC data from the working case.\ngic_read\nread GIC Data Text (.gic) File into the working case memory.\ngic_read_efield_grid\nread Geoelectric Efield Grid Data File into the working case memory.\ngic_thermal_impact\ngic_thermal_impact_1\ncalculate Transformer Thermal Impact assessement GIC(t) curve using specified effective Eastward GIC(E) and Nortward GIC(N) for one specific transformer.\ngic_write\nwrite working case GIC Data to text (.gic) file.\ngic_write_stn\nwrite working case GIC Data to text (.gic) file version 4 that has substation data.\n--- Graphical Analysis Output \u2014 .txt ---\nGraphical Analysis Output \u2014\nGraphical Analysis Output\u00b6\npoly_print\nprint the results of activity POLY from a .pol results file.\npv_print\nprint the results of PV analysis from the .pv results file\nqv_print\nprint the results of QV analysis from a .qv resultsfile.\nsetfullviewgrapharea\nspecify the parameters of the scales used for plotting the results of PV and QV analysis.\nsetfullviewscale\nspecify the parameters of the scales used for plotting the results of PV and QV analysis.\n--- Harmonics Data \u2014 .txt ---\nHarmonics Data \u2014\nHarmonics Data\u00b6\nhar_2tdc\nmodify or add new harmonics Two Terminal DC data to the working case.\nhar_2tdc_chng\nmodify harmonics Two Terminal DC data in the working case.\nhar_2tdc_purg\npurge specified harmonics Two Terminal DC data from the working case.\nhar_brn\nmodify or add new harmonics branch data to the working case.\nhar_brn_chng\nmodify harmonics branch data to the working case.\nhar_brn_purg\npurge specified harmonics branch data from the working case.\nhar_cursrc\nmodify or add new harmonics current source table data to the working case.\nhar_cursrc_chng\nchange harmonics current source table data in the working case.\nhar_cursrc_chng_name\nchange harmonics current source table name in the working case.\nhar_cursrc_chng_onept\nmodify one data point to harmonics current source table in the working case.\nhar_cursrc_name\nadd or change harmonics current source table name in the working case.\nhar_cursrc_onept\nmodify or add new one data point to harmonics current source table in the working case.\nhar_cursrc_purg\npurge specified harmonics current source table data from the working case.\nhar_cursrc_purg_onept\npurge specified data point in harmonics current source table.\nhar_facts\nmodify or add new harmonics FACTS device data to the working case.\nhar_facts_chng\nmodify harmonics FACTS device data in the working case.\nhar_facts_purg\npurge specified harmonics FACTS device data from the working case.\nhar_impchar\nmodify or add new harmonics impedance characteristics table data to the working case.\nhar_impchar_chng\nchange harmonics impedance characteristics table data in the working case.\nhar_impchar_chng_name\nchange harmonics impedance characteristics table name in the working case.\nhar_impchar_chng_onept\nmodify one data point to harmonics impedance characteristics table in the working case.\nhar_impchar_name\nadd or change harmonics impedance characteristics table name in the working case.\nhar_impchar_onept\nmodify or add new one data point to harmonics impedance characteristics table in the working case.\nhar_impchar_purg\npurge specified harmonics impedance characteristics table data from the working case.\nhar_impchar_purg_onept\npurge specified data point in harmonics impedance characteristics table.\nhar_indmc\nmodify or add new harmonics induction machine data to the working case."
  },
  {
    "id": "chunk_011",
    "text": "har_indmc_chng\nmodify harmonics induction machine data to the working case.\nhar_indmc_purg\npurge specified harmonics induction machine data from the working case.\nhar_load\nmodify or add new harmonics load data to the working case.\nhar_load_chng\nmodify harmonics load data to the working case.\nhar_load_purg\npurge specified harmonics load data from the working case.\nhar_mach\nmodify or add new harmonics machine data to the working case.\nhar_mach_chng\nmodify harmonics machine data to the working case.\nhar_mach_purg\npurge specified harmonics machine data from the working case.\nhar_mtdc\nmodify or add new harmonics Multi Terminal DC data to the working case.\nhar_mtdc_chng\nmodify harmonics Multi Terminal DC data in the working case.\nhar_mtdc_purg\npurge specified harmonics Multi Terminal DC data from the working case.\nhar_passive_filter\nmodify or add new harmonics passive filter data to the working case.\nhar_passive_filter_chng\nmodify harmonics passive filter data in the working case.\nhar_passive_filter_purg\npurge specified harmonics passive filter data from the working case.\nhar_set_par_lodmdl_cigre_measurement\nset parameters for harmonics load data user model CIGRE_MEASUREMENT.\nhar_set_par_lodmdl_cigre_motive\nset parameters for harmonics load data user model CIGRE_MOTIVE.\nhar_set_par_lodmdl_cigre_passive\nset parameters for harmonics load data user model CIGRE_PASSIVE.\nhar_set_par_lodmdl_ieee_2rl_parallel\nset parameters for harmonics load data user model IEEE_2RL_PARALLEL.\nhar_set_par_lodmdl_ieee_im\nset parameters for harmonics load data user model IEEE_IM.\nhar_set_par_lodmdl_ieee_measurement\nset parameters for harmonics load data user model IEEE_MEASUREMENT.\nhar_set_par_lodmdl_ieee_skin\nset parameters for harmonics load data user model IEEE_SKIN.\nhar_set_par_lodmdl_large_async_motor\nset parameters for harmonics load data user model LARGE_ASYNC_MOTOR.\nhar_trn\nmodify or add new harmonics transformer data to the working case.\nhar_trn_chng\nmodify harmonics transformer data to the working case.\nhar_trn_purg\npurge specified harmonics transformer data from the working case.\nhar_vltsrc\nmodify or add new harmonics voltage source table data to the working case.\nhar_vltsrc_chng\nchange harmonics voltage source table data in the working case.\nhar_vltsrc_chng_name\nchange harmonics voltage source table name in the working case.\nhar_vltsrc_chng_onept\nmodify one data point to harmonics voltage source table in the working case.\nhar_vltsrc_name\nadd or change harmonics voltage source table name in the working case.\nhar_vltsrc_onept\nmodify or add new one data point to harmonics voltage source table in the working case.\nhar_vltsrc_purg\npurge specified harmonics voltage source table data from the working case.\nhar_vltsrc_purg_onept\npurge specified data point in harmonics voltage source table.\nhar_vscdc\nmodify or add new harmonics VSCDC data to the working case.\nhar_vscdc_chng\nmodify harmonics VSCDC data in the working case.\nhar_vscdc_purg\npurge specified harmonics VSCDC data from the working case.\n--- Harmonics Operation \u2014 .txt ---\nHarmonics Operation \u2014\nHarmonics Operation\u00b6\nhar_analysis\nhar_analysis_2\nrun harmonics analysis.\nhar_create_pfcase\nsave working case updated for harmonic frequency and passive filters added as fixed shunts.\nhar_exists_dstn_results\nCheck if Harmonics Distortion Calculation results available in PSSE working memory from previously run harmonic analysis activity.\nhar_exists_fscan_results\nCheck if Harmonics Frequency Scan results available in PSSE working memory from previously run harmonic analysis activity.\nhar_export_dstn\nexport harmonics distortion calculation results to comma separated (.csv) file.\nhar_export_fscan\nexport harmonics frequency scan results to comma separated (.csv) file.\nhar_new\ninitialize all data records required for Harmonics analysis.\nhar_purg\npurge all harmonics data from the working case.\nhar_set_resn_thresholds\nset parameters to filter resonances from harmonic analysis frequency scan response.\nhar_set_resn_thresholds_default\nset default parameters to filter resonances from harmonic analysis frequency scan response.\n--- Induction Machine Bus Data \u2014 .txt ---\nInduction Machine Bus Data \u2014\nInduction Machine Bus Data\u00b6\naindmacbuschar\nUse this API routine to return an array of character values for subsystem buses.\naindmacbuscount\nUse this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine bus data family.\naindmacbuscplx\nUse this API routine to return an array of complex values for subsystem buses.\naindmacbusint\nUse this API routine to return an array of integer values for subsystem buses.\naindmacbusreal\nUse this API routine to return an array of real values for subsystem buses.\naindmacbustypes\nUse this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine bus data family (aIndMacBusInt, aIndMacBusReal, aIndMacBusCplx and aIndMacBusChar).\n--- Induction Machine Data \u2014 .txt ---\nInduction Machine Data \u2014\nInduction Machine Data\u00b6\naindmacchar\nUse this API routine to return an array of character values for subsystem induction machines.\naindmaccount\nUse this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine data family.\naindmaccplx\nUse this API routine to return an array of complex values for subsystem induction machines.\naindmacint\nUse this API routine to return an array of integer values for subsystem induction machines.\naindmacreal\nUse this API routine to return an array of real values for subsystem induction machines.\naindmactypes\nUse this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine data family (aIndMacInt, aIndMacReal, aIndMacCplx and aIndMacChar).\n--- Induction Machine Models \u2014 .txt ---\nInduction Machine Models \u2014\nInduction Machine Models\u00b6\nadd_indmac_model\nadd an induction machine model to a specified machine.\nchange_immod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of an induction machine model at a specified machine.\nchange_immod_con\nchange the value of a CON of a designated induction machine model at a specified machine.\nchange_immod_icon\nchange the value of an integer ICON of a designated induction machine model at a specified machine.\nchange_immod_var\nchange the value of a VAR of a designated induction machine model at a specified machine.\nimmod_pack\nremove entries that are marked as unused from the induction machine model contables.\nimmod_remove\nremove an induction machine model of a designated type from a specified machine.\nimmod_status\nchange the status of an induction machine model at a specified machine.\nimmod_unconnected\nlist or remove from dynamics working memory those induction machine models that are assigned to machines that are not present in the current power flow working case (unconnected)."
  },
  {
    "id": "chunk_012",
    "text": "immod_user\nlist user-written induction machine model definitions or to remove user-written induction machine model definitions that are not assigned to any machines (unused) from the user model definition tables.\n--- Line Relay Models \u2014 .txt ---\nLine Relay Models \u2014\nLine Relay Models\u00b6\nadd_relay_model\nadd a line relay model in the designated relay slot of the from bus end of a specified branch.\nchange_rlmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the line relay model in the designated relay slot of the from bus end of a specified branch.\nchange_rlmod_con\nchange the value of a CON of the line relay model in the designated relay slot of the from bus end of a specified branch.\nchange_rlmod_data\nchange_rlmod_icon\nchange the value of an integer ICON of the line relay model in the designated relay slot of the from bus end of a specified branch.\nchange_rlmod_var\nchange the value of a VAR of the line relay model in the designated relay slot of the from bus end of a specified branch.\nrlmod_pack\nremove entries that are marked as unused from the line relay model connection tables and the line relay model array allocation tables.\nrlmod_remove\nremove the line relay model in the designated relay slot of the from bus end of a specified branch.\nrlmod_status\nchange the status of the line relay model in the designated relay slot of the from bus end of a specified branch.\nrlmod_unconnected\nlist or remove from dynamics working memory those line relay models that are assigned to branches that are not present in the current power flow working case (unconnected).\nrlmod_user\nlist user-written line relay model definitions or to remove user-written line relay model definitions that are not assigned to any branches (unused) from the user model definition tables.\n--- Load Bus Data \u2014 .txt ---\nLoad Bus Data \u2014\nLoad Bus Data\u00b6\nalodbuschar\nreturn an array of character values for subsystem buses.\nalodbuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the load bus data family.\nalodbuscplx\nreturn an array of complex values for subsystem buses.\nalodbusint\nreturn an array of integer values for subsystem buses.\nalodbusreal\nreturn an array of real values for subsystem buses.\nalodbustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load bus data family (aLodBusInt, aLodBusReal, aLodBusCplx and aLodBusChar).\n--- Load Component Models \u2014 .txt ---\nLoad Component Models \u2014\nLoad Component Models\u00b6\nadd_loadc_model\nadd a load component model of a designated type to a specified load or subsystem.\nchange_ldmodc_cdesc\nchange the value of a Model Description of a load component model at a specified load or subsystem).\nchange_ldmodc_chricn\nchange the value of a CHRICN of a load component model at a specified load or subsystem).\nchange_ldmodc_con\nchange the value of a CON of a load component model at a specified load or subsystem.\nchange_ldmodc_icon\nchange the value of a ICON of a load component model at a specified load or subsystem.\nchange_ldmodc_var\nchange the value of a VAR of a load component model at a specified load or subsystem.\n--- Load Data \u2014 .txt ---\nLoad Data \u2014\nLoad Data\u00b6\naloadchar\nreturn an array of character values for subsystem loads.\naloadcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the load data family.\naloadcplx\nreturn an array of complex values for subsystem loads.\naloadint\nreturn an array of integer values for subsystem loads.\naloadreal\nreturn an array of real values for subsystem loads.\naloadtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load data family (aLoadInt, aLoadReal, aLoadCplx and aLoadChar).\n--- Load Related Models \u2014 .txt ---\nLoad Related Models \u2014\nLoad Related Models\u00b6\nadd_load_model\nadd a load related model of a designated type to a specified load or subsystem.\nchange_ldmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of a load related model at a specified load or subsystem.\nchange_ldmod_con\nchange the value of a CON of a load related model at a specified load or subsystem.\nchange_ldmod_data\nchange_ldmod_icon\nchange the value of an integer ICON of a load related model at a specified load or subsystem.\nchange_ldmod_var\nchange the value of a VAR of a load related model at a specified load or subsystem.\nldmod_pack\nremove entries that are marked as unused from the load model connection tables and the load model array allocation tables.\nldmod_remove\nremove a load related model of a designated type from a specified load or subsystem.\nldmod_status\nchange the status of a load related model of a designated type for all subsystem loads at which it is applied.\nldmod_status2\nchange the status of a load related model of a designated type at a specified load.\nldmod_unconnected\nlist or remove from dynamics working memory those load related models that are assigned to loads that are not present in the current power flow working case (unconnected).\nldmod_user\nlist user-written load model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables.\nldmodc_pack\nremove entries that are marked as unused from the load component model connection tables.\nldmodc_remove\nremove a load component related model of a designated type from a specified load or subsystem.\nldmodc_status\nchange the status of a load related model of a designated type for all subsystem loads at which it is applied.\nldmodc_unconnected\nlist or remove from dynamics working memory those load Component models that are assigned to loads that are not present in the current power flow working case (unconnected).\nldmodc_user\nlist user-written load component model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables."
  },
  {
    "id": "chunk_013",
    "text": "--- Machine Data \u2014 .txt ---\nMachine Data \u2014\nMachine Data\u00b6\namachchar\nreturn an array of character values for subsystem machines.\namachcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the machine data family.\namachcplx\nreturn an array of complex values for subsystem machines.\namachint\nreturn an array of integer values for subsystem machines.\namachreal\nreturn an array of real values for subsystem machines.\namachtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the machine data family (aMachInt, aMachReal, aMachCplx and aMachChar).\n--- Multi-Terminal Dc Line Converter Data \u2014 .txt ---\nMulti-Terminal Dc Line Converter Data \u2014\nMulti-Terminal Dc Line Converter Data\u00b6\namultitrmdcconvchar\nreturn an array of character values for subsystem multi-terminal dc line converters.\namultitrmdcconvcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line converter data family.\namultitrmdcconvcplx\nreturn an array of complex values for subsystem multi-terminal dc line converters.\namultitrmdcconvint\nreturn an array of integer values for subsystem multi-terminal dc line converters.\namultitrmdcconvreal\nreturn an array of real values for subsystem multi-terminal dc line converters.\namultitrmdcconvtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (aMultiTrmDcConvInt, aMultiTrmDcConvReal, aMultiTrmDcConvCplx and aMultiTrmDcConvChar).\n--- Multi-Terminal Dc Line Data \u2014 .txt ---\nMulti-Terminal Dc Line Data \u2014\nMulti-Terminal Dc Line Data\u00b6\namultitrmdcchar\nreturn an array of character values for subsystem multi-terminal dc lines.\namultitrmdccount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line data family.\namultitrmdccplx\nreturn an array of complex values for subsystem multi-terminal dc lines.\namultitrmdcint\nreturn an array of integer values for subsystem multi-terminal dc lines.\namultitrmdcreal\nreturn an array of real values for subsystem multi-terminal dc lines.\namultitrmdctypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the multi-terminal dc line data family (aMultiTrmDcInt, aMultiTrmDcReal, aMultiTrmDcCplx and aMultiTrmDcChar).\n--- Multiple Element Data \u2014 .txt ---\nMultiple Element Data \u2014\nMultiple Element Data\u00b6\navoltagedroopchar\nreturn an array of character values for the voltage droop controls.\navoltagedroopcount\nreturn the number of voltage droop controls.\navoltagedroopint\nreturn an array of real values for the voltage droop controls.\navoltagedroopreal\nreturn an array of real values for the voltage droop controls.\ngetmodellibraries\nReturn the list of libraries that are searched for dynamically (i.e.\ngetmodelprograms\nReturn the list dynamically (i.e.\ngettspfprofilebyelement\nreturn an array of character values for the Time Series Power Flow profiles by element name.\ngettspfprofilecountbyelement\nreturn the number of Time Series Power Flow profile by element name.\ngettspfprofiledata\nreturn an array of real values for Time Series Power Flow profile data.\ngettspfprofiledatabyset\nreturn an array of real values for Time Series Power Flow profile data for given curve set id.\ngettspfprofiledatacolumncount\nreturn the number of Time Series Power Flow profile data column count for a curve set.\ngettspfprofiledatacount\nreturn the number of Time Series Power Flow profile data count.\nlast_pf\nReturn last attempted network solution data.\nrxpath\nreturn buses from starting bus to ending bus with shortest electricity distance in terms of one of two options, impedance and number of buses.\ntreedat\nreturn Swing Bus and Island Data of Working Case Network.\n--- Node Breaker Data \u2014 .txt ---\nNode Breaker Data \u2014\nNode Breaker Data\u00b6\nfetch_adjvar_term_node\nobtain the terminal node to which an OPF adjustable bus shunt is connected to.\nfetch_indmachine_term_node\nobtain the terminal node to which a machine is connected to.\nfetch_load_term_node\nobtain the terminal node to which a load is connected to.\nfetch_machine_term_node\nobtain the terminal node to which a machine is connected to.\nfetch_shunt_term_node\nobtain the terminal node to which a shunt is connected to.\nfetch_sws_shunt_term_node\nfetch_sws_shunt_term_node_2\nobtain the terminal node to which a switched shunt is connected to.\nplant_bus_section_chng\nstation_2dc_bus_term_chng\nchange the station two-term dc rectifier or inverter node terminal connection in the working case.\nstation_2dc_conv_term_chng\nThis API changes both node terminal connections of an existing two-term dc rectifier and inverter terminal data in the working case.\nstation_adjvar_term_chng\nchange a substation OPF adjustable bus shunt node terminal connection in the working case.\nstation_branch_term_chng\naccess existing station branch terminal data in the working case.\nstation_branch_term_move\nmove one terminal node connection of a branch in the working case.\nstation_bus_purg\nThis API routine was first introduced in release 34.2.\nstation_chng\nmodify the data of an existing substation data in the working case.\nstation_data\nmodify the data of an existing substation data in the working case, or to add a new substation to the working case.\nstation_facts_bus_term_chng\nchange the station FACTS device node terminal data connection in the working case.\nstation_facts_term_chng\nThis API changes the FACTS device sending and terminal end node terminal connections.\nstation_indmachine_term_chng\nchange a substation induction machine node terminal connection in the working case.\nstation_load_term_chng\naccess existing station load terminal data in the working case.\nstation_machine_term_chng\nchange a substation machine terminal connection in the working case.\nstation_mtdc_bus_term_chng\nchange the station multi-terminal converter node terminal connection in the working case.\nstation_mtdc_term_chng\nThis API changes both node terminal connections of an existing multi-terminal converter in the working case.\nstation_node_chng\nmodify the data of an existing substation node in the working case.\nstation_node_data\nmodify the data of an existing substation node in the working case, or to add a new substation node to the working case.\nstation_node_number\nchange a node number in an existing substation.\nstation_node_purg\ndelete a node in an existing substation.\nstation_number\nchange a substation number for an existing substation.\nstation_purg\ndelete a substation and all node-breaker components within that substation from the working case.\nstation_shunt_term_chng\nchange a substation fixed shunt terminal connection in the working case."
  },
  {
    "id": "chunk_014",
    "text": "station_swd_chng\nmodify the data of an existing station switching device in the working case.\nstation_swd_data\nmodify the data of an existing substation switching device in the working case, or to add a new substation switching device to the working case.\nstation_swd_mbid\nmodify the circuit identifier of an existing station switching device in the working case.\nstation_swd_move\nmove the \u201cto\u201d node of an existing substation switching device in the working case.\nstation_swd_purg\ndelete an existing substation switching device in the working case.\nstation_sws_shunt_term_chng\nstation_sws_shunt_term_chng_2\nchange a substation switched shunt node terminal connection in the working case.\nstation_three_wnd_term_chng\naccess existing substation three-winding transformer terminal data in the working case.\nstation_three_wnd_term_move\nmove one terminal node connection of a three-winding transformer in the working case.\nstation_vscdc_bus_term_chng\nchange the vsc dc converter node terminal connection in the working case.\nstation_vscdc_conv_term_chng\nThis API changes both node terminal connections of an existing vsc dc converter in the working case.\nsystem_swd_chng\nmodify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.\nsystem_swd_data\nadd or modify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.\n--- Node Breaker Operation \u2014 .txt ---\nNode Breaker Operation \u2014\nNode Breaker Operation\u00b6\nconvert_section_to_bus\nUse this API routine to convert a bus section, one that had been automatically created within a substation due to open substation switching devices, into a main network bus.\nisolate2dclinebybreaker\nisolate a two-terminal DC line using system or substation breakers.\nisolate3wtbybreaker\nisolate a three-winding transformer using system or substation breakers.\nisolatebusbybreaker\nisolate a bus using system or substation breakers.\nisolatefactsbybreaker\nisolate a FACTS device using system or substation breakers.\nisolateindmachinebybreaker\nisolate an induction machine using system or substation breakers.\nisolatelinebybreaker\nisolate a two-winding transformer or non-transformer line using system or substation breakers.\nisolateloadbybreaker\nisolate a load using system or substation breakers.\nisolatemachinebybreaker\nisolate a machine using system or substation breakers.\nisolatemslinebybreaker\nisolate a multi-section line using system or substation breakers.\nisolatemtdclinebybreaker\nisolate a multi-terminal dc line using system or substation breakers.\nisolatenodebybreaker\nisolate a substation node using system or substation breakers.\nisolateshuntbybreaker\nisolate a fixed shunt using system or substation breakers.\nisolateswdbybreaker\nisolate a substation switching device using system or substation breakers.\nisolateswshuntbybreaker\nisolateswshuntbybreaker_2\nisolate a switched shunt using system or substation breakers.\nisolatevscdclinebybreaker\nisolate a VSC DC line using system or substation breakers.\nrestorestatesfromisolate\nrestore the network working case back to its original state; the state prior to all \u201cIsolate By Breaker\u201d actions that have been taken.\nstation_ampout\nprint current within a substation.\nstation_build_config\nautomatically build a general layout configuration for a bus being built within a substation.\nstation_list\nlist components in a substation.\nstation_pout\nstation_pout_2\nprint power flows within a substation.\nstation_tree\nUse this API routine to check the node breaker model and the consistency between node breaker and bus branch models.\n--- Non-Engineering \u2014 .txt ---\nNon-Engineering \u2014\nNon-Engineering\u00b6\nalert\nsend output to the alert device.\nappendrecording\nStart recording program operation at end of specified file.\nbeginreport\ncreate a new report tab in the GUI.\nclearalertoutput\nClear the Alerts/Warnings tab of the output bar in the GUI\nclearprogressoutput\nClear the Progress tab of the output bar in the GUI\nfilein\nGet input from file (Fortran unit number).\ngetbatdefaults\nRetrieve \u201cno input\u201d value for integers and reals.\ngetdefaultchar\nRetrieve \u201cno input\u201d value for characters (i.e., strings) other than filenames.\ngetdefaultint\nRetrieve \u201cno input\u201d value for integers.\ngetdefaultreal\nRetrieve \u201cno input\u201d value for reals (floats).\ngetloadedmodules\nget list of all modules currently loaded\ngetmodfunclist\nGet list if external callable methods given a module name.\nioflush\nForce all files in PSSE to flush buffers to disk, if possible.\nlaunch_program\nThis API routine was first introduced in release 34.1.\npagereport\nplace a report separator on the active report tab of the GUI.\npauserecording\nPause or resume recording program operation.\nprogress\nSend output to progress device.\nprompt\nSend output to prompt device.\npsseinit\nInitialize PSSE.\npsseversion\nGet PSSE version information.\nrefreshgui\nRefresh the graphical user interface.\nreport\nSend output to report device.\nruniplanfile\nExecute an IPLAN program.\nrunrspnsfile\nRun a response file.\nshowloadedlibraries\nshowloadedmodules\nstartrecording\nStart recording program operation.\nstoprecording\nStop recording program operation.\nt_alert_output\nspecify a \u201cT\u201c\u2018d alert device, i.e. a destination for a copy of everything sent to the alert device.\nt_progress_output\nspecify a \u201cT\u201c\u2018d progress device, i.e. a destination for a copy of everything sent to the progress device.\nt_prompt_output\nspecify a \u201cT\u201c\u2018d prompt device, i.e. a destination for a copy of everything sent to the prompt device.\nt_report_output\nspecify a \u201cT\u201c\u2018d report device, i.e. a destination for a copy of everything sent to the report device.\nuserin\nGet input from interactive device.\n--- Optimal Power Flow Data \u2014 .txt ---\nOptimal Power Flow Data \u2014\nOptimal Power Flow Data\u00b6\nnewopf\ninitialize the working case with default OPF data for all bus oriented data records.\nopf_adjbrx_indv\nadd an individual adjustable branch reactance data record to the working case.\nopf_adjbrx_subsys\nadd or modify all OPF branch reactance data records in a specified subsystem of the working case.\nopf_adjload_tbl\nadd an individual adjustable bus load table record to the working case.\nopf_adjvar_indv\nopf_adjvar_indv_2\nadd an individual OPF adjustable bus shunt data record to the working case.\nopf_adjvar_subsys\nadd or modify all OPF adjustable bus shunt records in a specified subsystem of the working case.\nopf_apdsp_tbl\nadd an individual active power dispatch table record to the working case.\nopf_brflw_3wt_indv\nadd a flow constraint record for an individual winding of a three-winding transformer in the working case.\nopf_brflw_brn_indv\nadd an individual branch or two-winding transformer flow constraint record to the working case.\nopf_brflw_subsys\nadd or modify all branch flow data records in a specified subsystem of the working case.\nopf_bus_indv\nopf_bus_indv_2\nadd OPF bus voltage magnitude data to the working case.\nopf_bus_subsys\nadd OPF bus attribute data for all records in a specified subsystem of the working case.\nopf_change_3wt_flow_id\nchange the identifier of a flow constraint record for an individual winding of a three-winding transformer in the working case."
  },
  {
    "id": "chunk_015",
    "text": "opf_change_adjvar_id\nopf_change_brn_flow_id\nchange the identifier of a branch or two-winding transformer OPF flow constraint record in the working case.\nopf_csttbl_lin\nadd a linear cost curve table record to the working case.\nopf_csttbl_poly\nadd a polynomial and exponential cost curve table record to the working case.\nopf_csttbl_quad\nadd a quadratic cost curve table record to the working case.\nopf_gen_rcap_indv\nadd an individual generation reactive capability data record to the working case.\nopf_gen_rcap_subsys\nadd or modify all OPF generator reactive capability records in a specified subsystem of the working case.\nopf_gendsp_indv\nadd generator dispatch data to an individual record in the working case.\nopf_gendsp_subsys\nadd OPF generator dispatch data to all records in a specified subsystem of the working case.\nopf_genrsv_indv\nadd an individual generator reserve data record to the working case.\nopf_genrsv_subsys\nadd or modify all OPF generator reserve records in a specified subsystem of the working case.\nopf_intflw_3wt\nadd a participating three-winding transformer winding to a specified interface flow constraint in the working case.\nopf_intflw_brn\nadd a participating branch to a specified interface flow constraint in the working case.\nopf_intflw_main\nadd an interface flow constraint record to the working case.\nopf_intflw_reset\nremove all interface branches associated with a particular interface flow constraint in the working case.\nopf_lnceqn_adjload\nadd a participating adjustable bus load variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_adjvar\nadd a participating adjustable bus shunt variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_brflow\nadd a participating branch flow variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_intflow\nadd a participating interface flow constraint variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_main\nadd a linear constraint dependency record to the working case.\nopf_lnceqn_pgen\nadd a participating active power dispatch variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_qgen\nadd a participating reactive power dispatch variable of a specified linear constraint dependency equation in the working case.\nopf_lnceqn_reset\nremove all participating variables from a particular OPF linear constraint dependency equation in the working case.\nopf_lnceqn_swshunt\nopf_lnceqn_swshunt_2\nadd a participating switched shunt variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_tran\nadd a participating transformer control variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_vang\nopf_lnceqn_vang_2\nadd a participating bus voltage angle variable to a specified linear constraint dependency equation in the working case.\nopf_lnceqn_vmag\nopf_lnceqn_vmag_2\nadd a participating bus voltage magnitude variable to a specified linear constraint dependency equation in the working case.\nopf_load_indv\nadd an individual OPF bus load data record to the working case.\nopf_load_subsys\nadd or modify all OPF bus load data records in a specified subsystem of the working case.\nopf_perrsv_gen\nadd a participating generation reserve unit to a previously defined period reserve constraint in the working case.\nopf_perrsv_main\nadd a period reserve constraint record to the working case.\nopf_perrsv_reset\nremove all generation reserve units associated with a particular period reserve constraint in the working case.\npurge_all_opf_data\npurge and re-initialize all OPF data records in the working case.\npurge_opf_adjbrx_indv\npurge an individual adjustable branch reactance data record from the working case.\npurge_opf_adjbrx_subsys\npurge all OPF branch reactance data records from a specified subsystem of the working case.\npurge_opf_adjload_tbl\npurge an individual adjustable bus load table from the working case.\npurge_opf_adjvar_indv\npurge_opf_adjvar_indv_3\npurge an individual OPF adjustable bus shunt data record from the working case.\npurge_opf_adjvar_subsys\npurge all OPF adjustable bus shunt records from a specified subsystem of the working case.\npurge_opf_apdsp_tbl\npurge an individual active power dispatch table record from the working case.\npurge_opf_brflw_3wt\npurge an individual flow constraint record of a three-winding transformer from the working case.\npurge_opf_brflw_brn\npurge an individual branch or two-winding transformer flow constraint record from the working case.\npurge_opf_brflw_subsys\npurge all branch flow data records in a specified subsystem in the working case.\npurge_opf_bus_indv\npurge_opf_bus_indv_3\npurge (re-initialize) OPF bus voltage magnitude data for an individual bus or bus section record in the working case.\npurge_opf_bus_subsys\npurge (re-initialize) OPF bus attribute data for all records in a specified subsystem of the working case.\npurge_opf_csttbl_lin\npurge an optimal power flow linear cost curve record from the working case.\npurge_opf_csttbl_poly\npurge an optimal power flow polynomial and exponential cost curve record from the working case.\npurge_opf_csttbl_quad\npurge an optimal power flow quadratic cost curve record from the working case.\npurge_opf_gen_rcap_indv\npurge an individual OPF generation reactive capability data record from the working case.\npurge_opf_gen_rcap_subsys\npurge all OPF generator reactive capability records in a specified subsystem from the working case.\npurge_opf_gendsp_indv\npurge generator dispatch data for an individual record from the working case.\npurge_opf_gendsp_subsys\npurge generator dispatch data for all records from a specified subsystem of the working case.\npurge_opf_genrsv_indv\npurge an individual optimal power flow generator reserve data record from the working case.\npurge_opf_genrsv_subsys\npurge all OPF generator reserve records in a specified subsystem from the working case.\npurge_opf_intflw\npurge an OPF interface flow constraint record, including all of its participating branches, from the working case.\npurge_opf_intflw_3wt\nremove a participating three-winding transformer winding from a specified OPF interface flow constraint in the working case.\npurge_opf_intflw_brn\nremove a participating branch from a specified OPF interface flow constraint in the working case.\npurge_opf_lnceqn\npurge an OPF linear constraint dependency record, including all of its participating variables, from the working case.\npurge_opf_lnceqn_adjload\nremove a participating adjustable bus load variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_adjvar\nremove a participating adjustable bus shunt variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_brflow\nremove a participating branch flow variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_intflow\nremove a participating interface flow constraint variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_pgen\nremove a participating active power dispatch variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_qgen\nremove a participating reactive power dispatch variable from a specified OPF linear constraint dependency equation in the working case."
  },
  {
    "id": "chunk_016",
    "text": "purge_opf_lnceqn_swshunt\npurge_opf_lnceqn_swshunt_2\nremove a participating switched shunt variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_tran\nremove a participating transformer control variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_vang\npurge_opf_lnceqn_vang_2\nremove a participating bus voltage angle variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_lnceqn_vmag\npurge_opf_lnceqn_vmag_2\nremove a participating bus voltage magnitude variable from a specified OPF linear constraint dependency equation in the working case.\npurge_opf_load_indv\npurge (re-initialize) an individual OPF bus load data record from the working case.\npurge_opf_load_subsys\npurge (re-initialize) all OPF bus load data records in a specified subsystem of the working case.\npurge_opf_perrsv\npurge an OPF period reserve constraint record and its association with participating reserve units from the working case.\npurge_opf_perrsv_gen\nremove a participating period reserve unit from a specified OPF period reserve constraint.\n--- Optimal Power Flow Operation \u2014 .txt ---\nOptimal Power Flow Operation \u2014\nOptimal Power Flow Operation\u00b6\nadd_details_to_opf_log\nspecify or return the value of the OPF solution option to add details of the sensitivity values and Lagrange multipliers to the OPF Output Log file.\napply_alternate_step_size\nspecify or return the value of the OPF solution option for applying an alternate lambda mismatch step size.\napply_automatic_scaling\nspecify or return the value of the OPF solution option to apply automatic scaling of the objective coefficients and derivatives to improve convergence of the OPF solution.\nbad_iter_coarse_limit\nspecify or return the number of bad iterations allowed when the barrier coefficient is greater than 011 (mu greater then -2) before the solution progress is terminated as being infeasible.\nbad_iter_fine_limit\nspecify or return the the bad iteration limit when the barrier coefficient is less than, or equal to 011 (mu less than or equal to -2) before the solution progress is terminated as being infeasible.\nclamp_nonoptimized_gens\nspecify or return the value of the OPF solution option to apply the clamp equation to non-optimized generators.\nconstrain_interface_flows\nspecify or return the value of the OPF option to constrain interface flows.\nfinal_opf_barrier_coeff\nspecify or return the value of the final coefficient value that the barrier function is attempting to attain.\nimport_ecdi\nimport data from an Economics Dispatch Data File, as prepared for use in activity ECDI, into the OPF working data.\ninitial_opf_barrier_coeff\nspecify or return the value of the initial OPF barrier coefficient.\ninterface_flow_cost_coeff\nspecify or return the value of the coefficient for the interface flow objective.\nlsto\nlist OPF working case data in a form suitable for data documentation.\nminimize_adj_bus_shunts\nspecify or return the value of the OPF minimize adjustable bus shunts (var compensation) objective function option.\nminimize_fuel_cost\nspecify or return the value of the OPF minimize fuel cost objective option.\nminimize_interface_flows\nspecify or return the value of the OPF minimize interface flows objective option.\nminimize_load_adjustments\nspecify or return the value of the OPF minimize adjustable bus load objective option.\nminimize_p_losses\nspecify or return the value of the OPF minimize active power loss objective option.\nminimize_p_slack\nspecify or return the value of the OPF minimize active power slack objective option.\nminimize_q_losses\nspecify or return the value of the OPF minimize reactive power loss objective option.\nminimize_q_slack\nspecify or return the value of the OPF minimize reactive power slack objective option.\nminimize_reactive_reserve\nspecify or return the value of the OPF minimize reactive reserve objective option.\nminimize_series_comp\nspecify or return the value of the OPF minimize series compensation (adjustable branch reactance) objective option.\nnopf\nrun the Optimal Power Flow solution.\nopen_bus_voltage_limits\nspecify or return the value of the OPF solution option to automatically adjust bus voltage limits, making them more open for initial feasibility.\nopf_barrier_step_length\nspecify or return the value of the barrier function step length setting.\nopf_clamp_decay_factor\nspecify or return the value of the clamp equation decay factor.\nopf_final_clamp_tol\nspecify or return the value of the final clamp tolerance.\nopf_fix_all_generators\nspecify or return the value of the OPF option to treat all generators as nonoptimized (fixed).\nopf_fix_phase_shifters\nspecify or return the value of the OPF option to fix transformer phase shift angle settings.\nopf_fix_switched_shunts\nspecify or return the value of the OPF option to fix switched shunt settings.\nopf_fix_tap_ratios\nspecify or return the value of the OPF option to fix transformer tap ratio settings.\nopf_fixed_voltage_penalty\nspecify or return the value of the penalty for fixed voltage excursions.\nopf_initial_clamp_tol\nspecify or return the value of the initial clamp tolerance.\nopf_interior_shift_factor\nspecify or return the value of the interior shift factor multiplier.\nopf_lambda_tolerance\nspecify or return the value of the Lagrange multiplier blow-up tolerance during an optimal power flow solution.\nopf_lf_control_penalty\nspecify or return the value of the quadratic penalty for loadflow controls.\nopf_max_tap_ratio_step\nspecify or return the value of the maximum transformer tap ratio step.\nopf_min_tap_ratio_step\nset or return the value of the minimum transformer tap ratio step.\nopf_regulate_area_int\nset or return the value of the OPF option to regulate area interchange.\nopf_round_switched_shunts\nset or return the value of the OPF solution option to discretize switched shunts.\nopf_round_tap_ratios\nset or return the value of the OPF solution option to round transformer tap ratio settings.\nopf_scale_qgen_limits\nset or return the value of the OPF option to scale reactive generation limits in the clamped constraint equation.\nopf_step_length_tolerance\nset or return the value of the OPF minimum barrier step length tolerance.\nopf_use_generator_vsched\nset or return the value of the OPF option to employ the generator scheduled voltage.\nopto\nPlease use the individual OPF option setting API\u2019s described in this section.\np_losses_cost_coeff\nset or return the value of the coefficient for the active power loss objective (OPF Solution Options).\nproduce_opf_log_file\nset or return the value of the OPF solution option to produce an OPF solution log file, and if so, the name of the log file.\nq_losses_cost_coeff\nset or return the value of the coefficient for the reactive power loss objective.\nreactive_resv_cost_coeff\nset or return the value of the coefficient for the reactive reserve objective.\nropf\nread an Optimal Power Flow Raw Data File.\nrwop\nreplicate the OPF data contained in the working case in the form of an Optimal Power Flow Data File."
  },
  {
    "id": "chunk_017",
    "text": "set_opf_report_subsystem\ndefine the subsystem to be used when producing the opf output report.\nuse_dual_criteria\nset or return the value of the OPF solution option to apply the power flow mismatch tolerance to the dual variable problem.\nuse_emergency_flow_limits\nset or return the value of the OPF solution option to impose the emergency flow limits instead of the normal flow limits.\nuse_emergency_volt_limits\nset or return the value of the OPF solution option to impose the emergency bus voltage limits instead of the normal bus voltage limits.\nwrite_opf_options_file\nsave the PSSE OPF solution option settings to the PSSOPF.OPT file.\n--- Owner Data \u2014 .txt ---\nOwner Data \u2014\nOwner Data\u00b6\naownerchar\nreturn an array of character values for subsystem owners.\naownercount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the owner data family.\naownercplx\nreturn an array of complex values for subsystem owners.\naownerint\nreturn an array of integer values for subsystem owners.\naownerreal\nreturn an array of real values for subsystem owners.\naownertypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the owner data family (aOwnerInt, aOwnerReal, aOwnerCplx and aOwnerChar).\n--- Owner Subsystems \u2014 .txt ---\nOwner Subsystems \u2014\nOwner Subsystems\u00b6\nosys\ndefine an owner subsystem.\nosysdef\nset the definition of an owner subsystem.\nosysinit\ninitialize or re-initialize an owner subsystem.\n--- Plant Bus Data \u2014 .txt ---\nPlant Bus Data \u2014\nPlant Bus Data\u00b6\nagenbuschar\nreturn an array of character values for subsystem buses.\nagenbuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the plant bus data family.\nagenbuscplx\nreturn an array of complex values for subsystem buses.\nagenbusint\nreturn an array of integer values for subsystem buses.\nagenbusreal\nreturn an array of real values for subsystem buses.\nagenbustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the plant bus data family (aGenBusInt, aGenBusReal, aGenBusCplx and aGenBusChar).\n--- Plant Related Models \u2014 .txt ---\nPlant Related Models \u2014\nPlant Related Models\u00b6\nadd_plant_model\nadd a plant related model of a designated type to a specified machine.\nchange_plmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of a designated plant related model at a specified machine.\nchange_plmod_con\nchange the value of a CON of a designated plant related model at a specified machine.\nchange_plmod_data\nchange_plmod_icon\nchange the value of an integer ICON of a designated plant related model at a specified machine.\nchange_plmod_var\nchange the value of a VAR of a designated plant related model at a specified machine.\ngmb_add_plant_model\nadd a plant related GMB model to a specified machine.\nplmod_consistency\ncheck consistency among the plant related models referenced at each machine.\nplmod_pack\nremove entries that are marked as unused from the plant model connection tables and the plant model array allocation tables.\nplmod_remove\nremove a plant related model of a designated type from a specified machine.\nplmod_status\nchange the status of a plant related model of a designated type at a specified machine.\nplmod_unconnected\nlist or remove from dynamics working memory those plant related models that are assigned to machines that are not present in the current power flow working case (unconnected).\nplmod_user\nlist user-written plant model definitions or to remove user-written plant model definitions that are not assigned to any machines (unused) from the user model definition tables.\n--- Power Flow Data \u2014 .txt ---\nPower Flow Data \u2014\nPower Flow Data\u00b6\narea_data\nmodify area data in the working case (see PSSE Program Operation Manual, Areas, Zones and Owners).\nbranch_chng\nbranch_chng_3\nUse this API routine to modify the data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\nbranch_data\nbranch_data_3\nmodify the data of an existing non-transformer branch in the working case or to add a new non-transformer branch to the working case (see PSSE Program Operation Manual, Non- Transformer Branch Data).\nbus_chng_3\nUse this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).\nbus_chng_4\nUse this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).\nbus_data\nbus_data_2\nbus_data_3\nbus_data_4\nUse this API routine to modify the data of an existing bus in the working case, or to add a new bus to the working case (see PSSE Program Operation Manual, Bus Data).\nbus_number\nchange the bus number of an existing bus in the working case.\ncase_title_data\nchange the two line case title in the working case (see PSSE Program Operation Manual, Case Identification Data).\ncasolution_parameters\nmodify the contingency analysis solution parameters.\ncasolution_parameters_2\nmodify the contingency analysis solution parameters.\ncasolution_parameters_3\nmodify the contingency analysis solution parameters.\nextr\npurge specified buses and all branches connected to them from the working case (activity EXTR).\nfacts_chng_2\nfacts_chng_3\nUse this API routine to modify the data of an existing FACTS device in the working case (see PSSE Program Operation Manual, FACTS Device Data).\nfacts_data\nfacts_data_2\nfacts_data_3\nmodify the data of an existing FACTS device in the working case, or to add a new FACTS device to the working case (see PSSE Program Operation Manual, FACTS Device Data).\ngne_chng\nUse this API routine to modify the data of an existing GNE device in the working case (see PSSE Program Operation Manual, GNE Device Data).\ngne_data\nUse this API routine to run the GNE device data specification function.\nimpedance_correction_data\nimpedance_correction_data_3\nmodify the data of an existing transformer impedance correction table in the working case or to add a new transformer impedance correction table to the working case (see PSSE Program Operation Manual, Transformer Impedance Correction Table Data).\ninduction_machine_chng\nUse this API routine to modify the data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Data)."
  },
  {
    "id": "chunk_018",
    "text": "induction_machine_data\nUse this API routine to modify the data of an existing induction machine in the working case, or to add a new induction machine to the working case (see PSSE Program Operation Manual, Induction Machine Data).\nload_chng_4\nload_chng_5\nload_chng_6\nUse this API routine to modify the data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).\nload_data\nload_data_3\nload_data_4\nload_data_5\nload_data_6\nUse this API routine to modify the data of an existing load in the working case, or to add a new load to the working case (see PSSE Program Operation Manual, Load Data).\nlong_title_data\nchange the sixteen line long title in the working case (see PSSE Program Operation Manual, activity CHTI).\nmachine_cap_curve_chng\nUse this API routine to modify the capability curve data of an existing machine in the working case.\nmachine_cap_curve_data\nUse this API routine to specify or modify the capability curve data of an existing machine in the working case.\nmachine_chng_2\nmachine_chng_3\nUse this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).\nmachine_chng_4\nUse this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).\nmachine_data\nmachine_data_2\nmachine_data_3\nmodify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).\nmachine_data_4\nmodify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).\nmbid2dc\nchange the name of the specified two-terminal dc line.\nmbid3wnd\nchange the identifier of the specified three-winding transformer.\nmbidatrn\nchange the identifier of the specified inter-area transfer.\nmbidbrn\nchange the identifier of the specified non-transformer branch or two-winding transformer.\nmbidfacts\nchange the name of the specified FACTS device.\nmbidgne\nUse this API routine to change the GNE device name of the specified GNE device.\nmbidindmac\nUse this API routine to change the identifier of the specified induction machine.\nmbidload\nchange the identifier of the specified load.\nmbidmac\nchange the identifier of the specified machine.\nmbidmdc\nchange the name of the specified multi-terminal dc line.\nmbidmsl\nchange the identifier of the specified multi-section line.\nmbidshunt\nchange the identifier of the specified fixed bus shunt.\nmbidswshunt\nchange the identifier of the specified switched bus shunt.\nmbidvd\nchange the voltage droop control name of the specified voltage droop control in the working case.\nmbidvsc\nchange the VSC dc line name of the specified VSC dc line.\nmulti_section_line_data\nmodify the definition of an existing multi-section line grouping in the working case or to add a new multi-section line grouping to the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).\nmulti_section_line_edit\nmodify the status and/or metered end designation of an existing multi-section line grouping in the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).\nmulti_term_dc_bus_data\nmodify the data of a dc bus of an existing multi-terminal dc line in the working case or to add a new dc bus to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\nmulti_term_dc_convr_data\nmodify the data of a dc converter of an existing multi-terminal dc line in the working case or to add a new converter to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\nmulti_term_dc_line_chng\nUse this API routine to modify the control mode and mode switch voltage of an existing multi- terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\nmulti_term_dc_line_data\nmodify the control mode and mode switch voltage of an existing multi-terminal dc line in the working case or to add a new multi-terminal dc line to the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\nmulti_term_dc_link_data\nmodify the data of a dc link of an existing multi-terminal dc line in the working case or to add a new dc link to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).\nowner_data\nmodify owner data in the working case (see PSSE Program Operation Manual, Interarea Transfer Data).\npbus_add_mod\nadd or modify transaction event participating bus data.\npbus_delete\nremove a bus from the set of buses that are participating in a transaction event.\nplant_chng\nplant_chng_3\nplant_chng_4\nUse this API routine to modify the data of an existing plant that is part of a substation in the working case.\nplant_data\nplant_data_3\nplant_data_4\nmodify the data of an existing plant in the working case, or to add a new plant to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\npurg\nUse this API routine to delete specified outaged equipment items from the working case.\npurg2dc\ndelete the specified two-terminal dc line from the working case.\npurg3wnd\ndelete the specified three-winding transformer from the working case.\npurg_voltage_droop\ndelete an existing voltage droop control from the working case.\npurgarea\ndelete areas with no equipment assigned to them from the working case.\npurgatrn\ndelete the specified inter-area transfer from the working case.\npurgbrn\ndelete the specified non-transformer branch or two-winding transformer from the working case.\npurgcapcurve\ndelete the specified machine\u2019s capability curve from the working case.\npurge_multi_term_dc_bus\ndelete the specified dc bus from the specified multi-terminal dc line in the working case.\npurge_multi_term_dc_convr\ndelete the specified converter from the specified multi-terminal dc line in the working case.\npurge_multi_term_dc_link\ndelete the specified dc link from the specified multi-terminal dc line in the working case.\npurgfacts\ndelete the specified FACTS device from the working case.\npurggne\nUse this API routine to delete the specified GNE device from the working case.\npurgindmac\nUse this API routine to delete the specified induction machine from the working case.\npurgindmacs\nUse this API routine to delete all induction machines from the specified bus in the working case."
  },
  {
    "id": "chunk_019",
    "text": "purgload\ndelete the specified load from the working case.\npurgloads\ndelete all loads from the specified bus in the working case.\npurgmac\ndelete the specified machine from the working case.\npurgmdc\ndelete the specified multi-terminal dc line from the working case.\npurgmsl\ndelete the specified multi-section line grouping from the working case.\npurgmut\ndelete the specified zero sequence mutual coupling from the working case.\npurgowner\ndelete owners with no equipment assigned to them from the working case.\npurgplnt\ndelete the plant and machine data at the specified bus from the working case.\npurgshunt\ndelete the specified fixed bus shunt from the working case.\npurgshunts\ndelete all fixed shunts from the specified bus in the working case.\npurgsws\ndelete all switched shunts from the specified bus in the working case.\npurgswshunt\ndelete the specified switched bus shunt from the working case.\npurgvsc\ndelete the specified VSC dc line from the working case.\npurgzone\ndelete zones with no equipment assigned to them from the working case.\nratingsettextdata\nchange the column and descriptions for a particular rating set used in reporting.\nshunt_chng\nUse this API routine to modify the data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\nshunt_data\nmodify the data of an existing fixed bus shunt in the working case or to add a new fixed bus shunt to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).\nsolution_parameters\nsolution_parameters_2\nsolution_parameters_3\nsolution_parameters_4\nsolution_parameters_5\nmodify the power flow solution parameters in the working case (see PSSE Program Operation Manual, Sections 6.3.13, 6.3.18, 6.5.1 and 11.7).\nswitched_shunt_chng_3\nswitched_shunt_chng_4\nswitched_shunt_chng_5\nUse this API routine to modify the data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Switched Shunt Data).\nswitched_shunt_data\nswitched_shunt_data_3\nswitched_shunt_data_4\nswitched_shunt_data_5\nmodify the data of an existing switched shunt in the working case or to add a new switched shunt to the working case (see PSSE Program Operation Manual, Switched Shunt Data).\nthree_winding_data\nthree_wnd_imped_chng_3\nthree_wnd_imped_chng_4\nUse this API routine to modify the impedance data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\nthree_wnd_imped_data_3\nthree_wnd_imped_data_4\nUse this API routine to modify the impedance data of an existing three-winding transformer in the working case, or to add a new three-winding transformer to the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\nthree_wnd_impedance_data\nthree_wnd_winding_data\nthree_wnd_winding_data_3\nthree_wnd_winding_data_4\nthree_wnd_winding_data_5\nmodify the data of one winding of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).\ntransaction_add_mod\nadd or modify transaction event data in PSSE working memory.\ntransaction_delete\ndelete a transaction event from PSSE working memory.\ntransfer_chng\nUse this API routine to modify the data of an inter-area transfer in the working case (see PSSE Program Operation Manual, Zone Data).\ntransfer_data\nUse this API routine to modify the data of an inter-area transfer in the working case, or to add a new inter-area transfer to the working case (see PSSE Program Operation Manual, Zone Data).\ntwo_term_dc_converter_data_3\nmodify the data of a dc converter of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).\ntwo_term_dc_convr_data\ntwo_terminal_dc_line_chng\nUse this API routine to modify the link data of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).\ntwo_terminal_dc_line_data\nUse this API routine to modify the link data of an existing two-terminal dc line in the working case, or to add a new two-terminal dc line and its link data to the working case (see PSSE Program Operation Manual, Area Interchange Data).\ntwo_winding_chng_4\ntwo_winding_chng_5\ntwo_winding_chng_6\nUse this API routine to modify the data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Owner Data).\ntwo_winding_data\ntwo_winding_data_3\ntwo_winding_data_4\ntwo_winding_data_5\ntwo_winding_data_6\nmodify the data of an existing two-winding transformer in the working case, or to add a new two-winding transformer to the working case (see PSSE Program Operation Manual, Owner Data).\nvoltage_droop_chng\nUse this API routine to modify the voltage droop control in the working case(see PSSE Program Operation Manual.\nvoltage_droop_data\nUse this API routine to modify the voltage droop control in the working case, or to add a new voltage droop control to the working case (see PSSE Program Operation Manual.\nvsc_dc_converter_data\nvsc_dc_converter_data_3\nmodify the data of a dc converter of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\nvsc_dc_line_chng\nUse this API routine to modify the link data of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\nvsc_dc_line_data\nUse this API routine to modify the link data of an existing VSC dc line in the working case, or to add a new VSC dc line to the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).\nzone_data\nmodify zone data in the working case (see PSSE Program Operation Manual, Zone Data).\n--- Power Flow Operation \u2014 .txt ---\nPower Flow Operation \u2014\nPower Flow Operation\u00b6\naccc\naccc_2\naccc_multiple_merge\nmerge a number of AC contingency solution files (acc files) into one acc file.\naccc_multiple_run_report\naccc_multiple_run_report_2\nreport the results of up to twenty two executions of the AC Contingency Calculation function.\naccc_parallel\naccc_parallel_2\nUse this API routine to run the second release of the parallel implementation of the AC contingency calculation function (use ACCC_WITH_DSP_3 to run AC contingency calculation function serially).\naccc_single_run_report\naccc_single_run_report_2\naccc_single_run_report_3\naccc_single_run_report_4\naccc_single_run_report_5\naccc_single_run_report_6\nThis API is the sixth release of the AC Contingency Report function.\naccc_trip_cor\naccc_trip_cor_2\naccc_trip_cor_3\nThis API is the third release of the function to run AC contingency analysis with tripping simulation and corrective actions.\naccc_with_cor\naccc_with_cor_2\naccc_with_cor_3\nThis API is the third release of function to run AC contingency analysis with corrective actions.\naccc_with_dsp\naccc_with_dsp_2\naccc_with_dsp_3\nrun the second release of AC contingency calculation function (ACCC, ACCC_WITH_DSP).\naccc_with_trip\naccc_with_trip_2\nrun the second version of AC contingency calculation function with a post- contingency tripping function."
  },
  {
    "id": "chunk_020",
    "text": "accc_with_trip_parallel\nrun the parallel version of AC contingency calculation function with a post- contingency tripping function (use ACCC_WITH_TRIP_2 to run the function sequentially).\naccor\naccor_2\naccor_3\nThis API is the third release of corrective action function.\nalert_output\nspecify the alert device.\nallow_pssuserpf\nspecify or return the option to allow or disallow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf).\nalph\nprint an alphabetically sorted table of all buses in a specified subsystem of the working case (activity ALPH).\nappend_accc\nreplicate system conditions of a contingency case solution, as contained in a designated Saved Case File, in the form of a Contingency Solution Output File.\napply_var_limits\nspecify or return the option for the default VAR limits setting; either apply automatically, apply immediately, ignore, or apply on a specific iteration\narea\narea_2\ntabulate area totals by area, as well as the desired area net interchange (activity AREA).\narea_zone\ntabulate area totals by area, along with subtotals by zone.\narnm\narnm_2\nThis API routine is the second release of the area renumbering function.\nbase_frequency\nspecify or return the value of the base frequency option setting.\nbgen\nconvert the mismatch at boundary buses to equivalent load and/or generation (activity BGEN).\nbrch\nbrch_2\ntabulate those branches where impedances or other characteristics are such that they may be detrimental to the rate of convergence of one or more of the power flow solution activities.\nbsnm\nchange the bus numbers of specified network buses in the working case and retain a tabulation, in file form, of bus number changes made (activity BSNM).\nbus_input\nspecify or return the bus input option setting, for either numbers or names.\nbus_output\nspecify or return the bus output option setting, for either numbers or names.\nbus_size_level\nspecify or return the value of the PSSE size level option setting to a multiple of 1,000 between 1,000 and 200,000.\nbusn\ntabulate unused bus numbers within a specified bus number range (activity BUSN).\nca_iterations\nspecify or return the contingency iterations limit setting.\ncase\nopen a PSSE Saved Case file and transfers its data into the PSSE working case.\ncheck_powerflow_data\nUse this API routine to perform data checks on the selected categories of powerflow data for all buses in the working case or for all buses in a specified subsystem.\ncheckvoltagelimits\ntabulate those buses where voltage magnitude is beyond their normal or emergency voltage limits.\nchkcntduplicon\nCheck duplicate labels in Contingengy (CON) file.\nchkcntduplidfx\nCheck duplicate labels in DFAX file.\nclose_powerflow\nRemoves the current powerflow working case from PSSE\u2019s working memory.\nclose_report\nSets the report output device to the standard output and sets the command line to request device selection for individual reporting activities (Activity CLOS).\ncmpr\ntabulate certain case totals, as contained in the working case, with those of a designated Saved Case (activity CMPR).\ncntb\ntabulate the voltage setpoints and desired voltage bands of voltage-controlling equipment in the working case (activity CNTB).\ncong\nconvert generators from their power flow representation in preparation for switching studies and dynamic simulations (activity CONG).\nconl\nconvert the constant MVA load for a specified grouping of network loads to a specified mixture of the constant MVA, constant current, and constant admittance load characteristics (activity CONL).\nconnectivity_check\nspecify or return the option to enable or disable the solution connectivity checking option setting.\ncontrol_area_interchange\nto specify or return the area interchange control option setting to disabled, or enabled with tie lines only, or enabled with tie lines and loads.\ncsv_to_rawx\nimport a rawx (extended raw data) data table from a CSV (comma-separated values) file.\ncsv_to_rawx_with_metamodel\nimport a rawx (extended raw data) data table from a CSV (comma-separated values) file with metamodel.\ndc_tap_adjustment\nspecify or return the option to enable or disable the dc tap adjustment option setting.\ndccc\ndccc_2\nrun contingency case solutions using a linear network (dc) model (activity DCCC).\ndccor\napply corrective actions to the base case using linear programming methods.\ndccor_2\napply corrective actions to the base case using linear programming methods.\ndclf\ndclf_2\nUse this API routine to apply the dc analogy network solution algorithm to the network modeled in the working case (activity DCLF).\ndcpscopf\nThis API is the DC based Preventive Security Constrained Optimal Power Flow solution (DCPSCOPF).\ndeltmpfiles\nDelete closed temporary files.\ndfax\ndfax_2\nconstruct a Distribution Factor Data File (activity DFAX).\ndfax_contingency\ncombine one contingency in the first Distribution Factor file with one contingency in the second Distribution Factor file and so on, till specified contingency level is reached, to create multiple event contingencies and then export resulting contingencies to user defined report device.\ndfti\ncompare tie lines, as contained in the working case, with those of a designated Saved Case (activity DFTI).\ndiff\ncompare specified power flow data and solution results, as contained in the working case, with those of a designated Saved Case (activity DIFF).\ndscn\nelectrically disconnect a bus (activity DSCN).\nduplicate_cntlabel_check\nspecify or return the option to enable or disable the duplicated contingency labels check     when Distribution Factor Data File (.dfx) or Contingency Description Data File (.con) files are used.\necdi\nplace machines in a specified subsystem on- or off-line to satisfy a given subsystem minimum capacity; the in-service machines in the subsystem are then dispatched on the basis of incremental cost to meet a specified total subsystem generation (activity ECDI).\necho\nenable or disable response echoing (activity ECHO).\neeqv\nconstruct an electrical equivalent of a specified subsystem of the working case (activity EEQV).\neqrd\nbuild an electrical equivalent of radial and, optionally, two-point Type 1 buses in a specified subsystem of the working case (activity EQRD).\nexam\ntabulate all power flow data pertaining to a specified bus (activity EXAM).\nfact\nfactorize the network admittance matrix in preparation for switching studies and dynamic simulations (activity FACT).\nfdns\napply the fixed slope decoupled Newton-Raphson power flow calculation (activity FDNS).\nfile_overwrite\nspecify or return the option to set the file overwrite option setting to either ask first or overwrite.\nfind\ntabulate a list of buses matching a partial extended bus name (activity FIND).\nflat_start\nspecify or return the option to enable or disable the voltage flat start option setting."
  },
  {
    "id": "chunk_021",
    "text": "fnsl\napply the Newton-Raphson power flow calculation (activity FNSL).\ngcap\ngcap_2\nprint a report of machine loading and reactive power limit data (activity GCAP).\ngdif\ncalculate differences between the working case and a designated Saved Case (activity GDIF).\ngendsp\nimpose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.\ngendsp_2\nimpose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.\ngens\ntabulate the loading and voltage conditions at plant buses (activity GENS).\ngeol\ntabulate the loading and voltage conditions at the generator terminals for online machines at Type 2 and 3 buses in the working case (activity GEOL).\ngetcontingencysavedcase\nUse this API routine to place the working case in the form of a specified system condition as calculated during a previous run of one of the members of the the AC contingency calculation family.\ngic_pf\nAdd activity GIC calculated Mvar Qloss in scaled manner to the working case to arrive at the converged power flow solution.\ngnestatus\nspecify or return the status of a GNE device.\ngnet\nchange in-service generation to negative MVA load at all Type 2 and 3 buses in the subsystem specified by the user.\nimnet\nUse this API routine to change the status of induction machines that are in-service to out-of- service, and to replace the power flowing from the network into the machine with constant power load.\nimoutage\nUse this API routine to change the status of induction machines that are in-service, but that have been set to the \u201cstalled\u201d (for motors) or \u201ctripped\u201d (for generators) state by the power flow solution, to out-of-service.\nimpc\ncalculate the impact of transaction events on MW flows using a linear network (dc) model.\nimplement_transfer\nimplement_transfer_2\nUse this API routine to apply a specified transfer using the same transfer dispatch methods that are available in the PV analysis calculation engine.\ninlf\ninlf_2\nUse this API routine to run the second release of the inertial and governor response power flow calculation.\ninta\nsummarize tie flows between an interchange area and all other areas in the working case.\nintz\nsummarize tie flows between each zone and all other zones in the working case.\nisolate_levels\nspecify or return the maximum number of levels to go outward when isolating an element by breaker.\njoin\nThe API combines two buses into a single bus.\nlamp\nprint power flow solution output, including loadings in amps, in a traditional power flow report format.\nline_shunt_reporting\nspecify or return the option to enable or disable the line shunt reporting.\nlines_per_page\nspecify or return the page length limits for the four output devices; also retrieve device names.\nlines_per_page_one_device\nspecify or return the page length limit and device name for one of the four output devices.\nlist\nUse this API routine to tabulate the power flow working case in a form suitable for problem data documentation.\nlistcontingencysavedcases\nUse this API routine to obtain a report listing some or all of the system conditions preserved in a ZIP Archive Output File that was created during a previous run of one of the members of the the AC contingency calculation family.\nllrf\napply the line loading relief calculation using a linear network (dc) model.\nload_reduction\ntabulate the amount of load reduction in a specified subsystem due to the voltage at the bus to which the load is connected being below PQBRAK (for constant MVA load) or 0.5 (for constant current load.\nlout\nprint the power flow solution results in a traditional power flow report format.\nltap\ninsert a bus at a designated location along a line.\nmaccc\nmaccc_2\nrun the second release of multiple level contingency analysis.\nmaccc_3\nrun the third release of multiple level contingency analysis.\nmaccc_parallel\nrun the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\nmaccc_parallel_2\nrun the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\nmaccc_trip_cor\nmaccc_trip_cor_2\nmaccc_trip_cor_3\nThis API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.\nmaccc_trip_cor_4\nThis API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.\nmaccc_with_cor\nmaccc_with_cor_2\nmaccc_with_cor_3\nThis API is the third release of function to run multiple AC contingency analysis with corrective actions.\nmaccc_with_cor_4\nThis API is the third release of function to run multiple AC contingency analysis with corrective actions.\nmaccc_with_trip\nmaccc_with_trip_2\nrun the second version of multiple level contingency analysis with tripping simulation.\nmaccc_with_trip_3\nrun the second version of multiple level contingency analysis with tripping simulation.\nmaccc_with_trip_parallel\nrun the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.\nmaccc_with_trip_parallel_2\nrun the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.\nmatrix_growth_factor\nspecify or return the value of the matrix growth factor option setting.\nmcre\nread a Machine Impedance Data File and add the data specified in it to the working case.\nmodr\nuniformly increase or decrease the line resistances of in-service nontransformer branches.\nmov_alpha\nspecify or return the value of the MOV iteration ALPHA option setting.\nmov_iterations\nspecify or return the value of the maximum MOV iterations option setting.\nmov_tolerance\nspecify or return the value of the MOV iteration tolerance option setting.\nmove3wnd\ndisconnect the third bus of a specified three-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.\nmovebrn\ndisconnect the to bus of a specified non-transformer branch or two-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.\nmoveindmac\nUse this API routine to disconnect the specified induction machine from the bus to which it is currently connected, and reconnect it to a designated bus."
  },
  {
    "id": "chunk_022",
    "text": "moveindmacs\nUse this API routine to disconnect all of the induction machines at the specified bus, and reconnect them to a designated bus.\nmoveload\ndisconnect the specified load from the bus to which it is currently connected, and reconnect it to a designated bus.\nmoveloads\ndisconnect all of the load from the specified bus, and reconnect it to a designated bus.\nmovemac\ndisconnect the specified machine from the bus to which it is currently connected, and reconnect it to a designated bus.\nmoveplnt\ndisconnect all of the machines from the specified bus, and reconnect it to a designated bus.\nmoveshunt\ndisconnect the specified fixed shunt from the bus to which it is currently connected, and reconnect it to a designated bus.\nmoveshunts\ndisconnect all of the fixed shunts from the specified bus and reconnect them to a designated bus.\nmovesws\nmoveswshunt\ndisconnect the specified switched shunt from the bus to which it is currently connected, and reconnect it to a designated bus.\nmoveswshunts\ndisconnect all of the switched shunts from the specified bus and reconnect them to a designated bus.\nmslv\napply the modified Gauss-Seidel power flow calculation.\nmsum\nprint a summary of mileage by owner.\nmtdc\nproduce a report of bus voltages and flows for each in-service multi-terminal dc line.\nmultisection_reporting\nspecify or return the option to enable or disable multi-section line reporting.\nmwmi\napply the MAPP MW-mile calculation .\nmwomwmsf\ntabulate generation (MW) on MW-mile shift factors for a specified transaction event.\nmwomwosf\ntabulate generation (MW) on MW-ohm shift factors for a specified transaction event.\nn11_accc\nn11_accc_2\nThis API is the second release of N-1-1 contingency analysis solution.\nn11_accc_3\nThis API is the second release of N-1-1 contingency analysis solution.\nn11_accc_parallel\nrun the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\nn11_accc_parallel_2\nrun the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.\nn11_accc_pscopf\nn11_accc_pscopf_2\nThe API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).\nn11_accc_pscopf_3\nThe API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).\nnetg\nchange the in-service generation to negative MVA load at all Type 2 and 3 buses except those in the subsystem specified by the user.\nnew_dimension\nreset PSSE to an increased bus size level.\nnewcas\nnewcase_2\nThis API is the second release of the function used to initialize a new power flow case.\nnewton_tolerance\nspecify or return the value of the default Newton-Raphson convergence tolerance.\nnon_divergent\nspecify or return the option to specify or return the option to enable or disable the non-divergent Newton power flow solution.\nnon_trans_percent_units\nset the non-transformer branch percent units option setting to either MVA or current expressed as MVA.\nnsol\napply the decoupled Newton-Raphson power flow calculation.\nnumber_threads\nspecify or return the number of processors available for parallel operations.\nordr\ncalculate a sparsity preserving ordering of buses in preparation for the processing of network matrices.\notdf\ntabulate vectors of distribution factors using a linear network (dc) model.\noutput_y_matrix\ndisplay the network admittance matrix for a subsystem of the working case in the form of a list of matrix terms.\nouts\ntabulate those components in the working case that are removed from service.\nownm\nownm_2\nownm_3\nThis API routine is the third release of the owner renumbering function.\nownr\ntabulate owner totals by owner.\npath\nspecify a directory pathname.\nphase_shift_adjustment\nspecify or return the option to enable or disable the phase shift adjustment.\npoly\ncalculate interchange limits of a study system against two opposing systems using a linear network (dc) model.\npout\nprint the power flow solution results with boundary condition and flow information on the left side of the report and other information on the right side.\npower_output\nspecify or return the option to display power output in either MVA or kVA.\npp_accc\nreport the results of the AC contingency calculation function.\npp_accc_multi_case\nprint_outaged_branches\nspecify or return the option to enable or disable whether to print out-of- service branches.\nprint_winding_buses\nspecify or return the option to enable or disable whether to print winding \u201cto\u201d buses of three-winding transformers.\nprogress_output\nspecify the progress output device.\nprompt_output\nspecify the prompt output device.\nprti\nprint the 16 line long title.\npscopf\npscopf_2\nThis API is the second release of Preventive Security Constrained Optimal Power Flow solution (PSCOPF).\npseb\nconvert a PSEB command file into a PSSE response file.\npssehalt\npssehalt_2\nend the operation of PSSE, closes all associated files and returns to the calling application.\npv_engine\npv_engine_1a\npv_engine_2\npv_engine_3\npv_engine_4\npv_engine_5\npv_engine_6\nUse this API routine to run the PV analysis calculation engine.\nqv_engine\nqv_engine_2\nqv_engine_3\nqv_engine_4\nUse this API routine to run the QV analysis calculation engine.\nrank\nestimate the severity of designated single branch outage contingencies and builds a contingency solution output file with contingencies specified in decreasing order of their estimated severities.\nrank_brn_and_mac\nestimate the severity of designated single element outage contingencies and builds a contingency description data file with contingencies specified in decreasing order of their estimated severities.\nrate\nrate_2\ncheck branch loadings.\nrating_set\nspecify or return the current rating set, from 1 to 12.\nrawd\nrawd_2\nreplicate the working case in the form of a power flow raw data file.\nrawdx\nrawx_to_csv\nexport rawx (extended raw data) table to a CSV (comma-separated values) file.\nrdch\nread power flow change data into the working case.\nrdchrawversion\nread a Power Flow Change Raw Data File into the working case.\nrdeq\nbuild an electrical equivalent of radial and, optionally, two-point Type 1 buses outside of a specified subsystem of the working case.\nread\nread a power flow raw data file and add all the data specified in it to the working case.\nreadcapcurves\nread data contained in a Machine Capability Curve Data File into the working case.\nreadrawversion\nread a power flow raw data file and add all the data specified in it to the working case."
  },
  {
    "id": "chunk_023",
    "text": "readrawx\nread an extended raw data file and add all the data specified to the working case.\nreadsub\nread a power flow raw data file and add subsystem data specified in it to the working case.\nreadsubrawversion\nread a power flow raw data file and add subsystem data specified in it to the working case.\nreadx\nrecn\nelectrically reconnect a bus.\nregb\ntabulate those buses where voltages are controlled by generation, switched shunts, and/or other voltage controlling equipment.\nrelind\nrelind_2\nrun probabilistic reliability assessment for transmission systems.\nremm\nread transaction event data from a transactions raw data file and add it to PSSE working memory.\nreport_output\nspecify the report output device.\nresq\nread sequence data from a sequence data file and add it to the working case.\nresqversion\nread a network sequence data file and add all the data specified in it to the working case.\nresult_table_output\nget and set the default tabular output.\nreti\nread the long title from an input file into the working case.\nretry_pssuserpf\nallow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf) after a failure.\nrev29_names\nset the extended bus name input format to either the PSSE-29 or PSSE-30 format.\nrnfi\nreproduce the results of a working case bus renumbering operation in auxiliary data input files.\nrsol\nperform a robust power flow solution (activity RSOL).\nrunlastsolution\nrun the last known power flow solution.\nrwcm\nreplicate the working case in IEEE common tape format.\nrwma\nreplicate machine parametric data from the working case in the form of a machine impedance data file.\nrwmm\nreplicate transaction event data in the form of a transactions data file.\nrwsq\nrwsq_2\nreplicate the sequence data contained in the working case in the form of a sequence data file.\nsave\nsave the PSSE working case in a saved case file.\nscal\nscal_2\nscal_3\nscal_4\nUse this API routine to uniformly increase or decrease any or all specified bus quantities for a specified group of buses.\nsensitivity_flow\nThis API is used to calculate sensitivity factors of a branch flow to MW power at buses, MW power at generator buses, MW at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts:\nsensitivity_flows\nThis API is used to calculate sensitivity factors of flows on the branches in a subsystem to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\nsensitivity_interface\nThis API is used to calculate sensitivity factors of  an interface flow to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap position of tap changing transformers as well as admittance of switched shunts.\nsensitivity_voltage\nThis API is used to calculate sensitivity factors of a bus voltage to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\nsensitivity_voltages\nThis API is used to calculate sensitivity factors of  bus voltages in a subsystem to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.\nset_input_dev\nset the terminal input device to a file.\nset_progress_verbose\nto set the option progress message verbose value.\nshnt\ntabulate fixed and/or switched bus shunts contained in the working case.\nshort_circuit_coordinates\nspecify or return the option to set the fault analysis voltage and current output coordinates to either rectangular or polar coordinates.\nshort_circuit_modeling\nspecify or return the option for the fault analysis modeling setting; either normal three-phase or center tapped two-phase.\nshort_circuit_units\nspecify or return the option to set the fault analysis voltage and current output units to either per unit or physical units.\nshort_circuit_warning\nspecify or return the option to enable or disable the fault analysis warning option setting.\nshort_circuit_z_coordinates\nspecify or return the option to set the fault analysis output impedance coordinates to either rectangular or polar coordinates.\nshort_circuit_z_units\nspecify or return the option to set the fault analysis output impedance units to either per unit or ohms.\nshow\ntabulate summaries of Saved Case and/or Snapshot Files.\nshowtable\nDirects a report table to output console.\nshowtablebyindex\nThis API routine was first introduced in release 35.\nsize\nobtain a summary of the number of components in the working case (activity SIZE).\nsolv\napply the Gauss-Seidel power flow calculation.\nspcb\ncalculate positive sequence equivalents of branch unbalances.\nspil\ncalculate transmission interchange limits using a linear network (dc) model.\nsplt\nadd a bus to the working case and place a zero impedance line between bus BUS and the new bus.\nsqli\ntabulate the sequence data in a form suitable for problem data documentation.\nsraind\nrun the substation reliability analysis.\nstop\nstop_2\nend the operation of PSSE.\nsubs\nsummarize conditions in the working case by tabulating the conditions at each swing system bus, conditions at each area slack area bus, number of components, generation/ load/shunt totals, and loss/line shunt/charging totals by voltage levels.\nswitched_shunt_adjustment\nspecify or return the option to enable or disable switched shunt adjustment.\ntap_adjustment\nspecify or return the option for the default tap adjustment setting; either disabled, stepping or direct.\ntext\nThis API does nothing.\ntflg\nset or reset the adjustment control mode flags for all automatically adjustable transformers contained in the specified subsystem.\nties\ntabulate the flows on all area tie lines, with tie flows grouped by area.\ntiez\ntabulate the flows on all zone tie lines, with tie flows grouped by zone.\ntime\ntabulate timing statistics.\ntlst\ntabulate those transformers in the working case where off-nominal turns ratio or phase shift angle may be adjusted by the power flow solution activities.\ntltg\ncalculate transmission interchange limits using a linear network (dc) model.\ntpch\ncheck the adjustment data associated with voltage or flow controlling transformers."
  },
  {
    "id": "chunk_024",
    "text": "transformer_percent_units\nspecify or return the option to set the transformer percent units to either MVA or current expressed as MVA.\ntransmission_line_units\nto specify or return the option set the transmission line units to either per unit or ohms.\ntree\ncheck for the existence of in-service ac islands that do not contain a Type 3 (swing) bus.\ntspfprofilecurvevalue\nreturn real parameters of Time Series Power Flow profile data.\ntysl\nrun switching study network solutions.\nuser\nrun the user-written activity, subroutine USERAC.\nvamm\ntabulate the vector absolute MW-mile report.\nvamo\ntabulate the vector absolute MW-ohm report.\nvchk\ntabulate those buses where voltage magnitude is outside a specified range.\nvoltage_input\nspecify or return the voltage input option setting; either per unit or kV.\nvoltage_output\nspecify or return the voltage output option setting; either per unit or kV.\nvsmo\ntabulate the vector MW-ohm report.\nwrite_options_file\nsave the present values of the PSSE-25 program option settings to the file psse.opt.\nwritecapcurves\nwrite the capability curve data in the working case in the form of a Capability Curve Raw Data File.\nwriterawversion\nreplicate the working case in the form of power flow raw data file compatible with PSSE 15 or later.\nwriterawx\nwrite an extended raw data file from data in the current working case.\nwriterawxsubsys\nwrite an extended raw data file from data in the current working case, specifying a subsystem.\nwriteseqversion\nwriteseqversion_2\nreplicate the working case in the form of a network sequence data file compatible with PSSE 27 or later.\nxeqv\nbuild an electrical equivalent of the portion of the working case outside of a specified subsystem of the working case.\nzone\nzone_2\ntabulate zone totals by zone.\nzone_area\ntabulate zone totals by zone, along with subtotals by area.\nzonm\nzonm_2\nUse this API routine to reassign the buses, loads and/or induction machines in a specified subsystem of the working case from their original zone to a designated zone.\n--- Scenarios \u2014 .txt ---\nScenarios \u2014\nScenarios\u00b6\nclosescenariofile\nnewscenariofile\nopenscenariofile\nsavescenariofile\nscenarioclose\nclose the currently open Scenario.\nscenariocopyfile\ncopy a file from one group to another group.\nscenariofileadd\nadd a file to the specified group.\nscenariofilecount\nretrieve the number of files in a specified group in the Scenario.\nscenariofilegetattrs\nretrieve the attributes of the specified file.\nscenariofilegetcomments\nretrieve the comments for the specified file.\nscenariofilelengthcomments\ndetermine the buffer size needed to hold the comments for the specified file.\nscenariofilelist\nretrieve the list of files in the specified group.\nscenariofileremove\nremove a file from the specified group.\nscenariofilerename\nrename one of the files in the Scenario.\nscenariofilesetattrs\nmodify the attributes of the specified file.\nscenariofilesetcomments\ndefine or modify the comments for the specified file.\nscenariogetattrs\nretrieve the attributes of the Scenario.\nscenariogetcomments\nretrieve the Scenario comments.\nscenariogetopt\nretrieve the Scenario options.\nscenariogroupadd\nadd a group to the Scenario.\nscenariogroupcount\nretrieve the number of groups in the Scenario.\nscenariogroupgetcomments\nretrieve the comments for the specified group.\nscenariogrouplengthcomments\ndetermine the buffer size needed to hold the comments for the specified group.\nscenariogrouplist\nretrieve the list of groups in the Scenario.\nscenariogroupopen\nadd a group to the Scenario.\nscenariogroupremove\nremove a group from the Scenario.\nscenariogrouprename\nrename one of the groups in the Scenario.\nscenariogroupsetcomments\ndefine or modify the comments for the specified group.\nscenarioisdirty\ndetermine if there are any unsaved changes in the current Scenario.\nscenarioisvalid\ndetermine if there is a valid Scenario in memory.\nscenariolengthcomments\ndetermine the buffer size needed to hold the current Scenario comments.\nscenariomodelgroup\ncreate a new group that is identical to another group.\nscenariomovefile\nmove a file from one group to another group.\nscenarionew\ncreate a new Scenario.\nscenarioopen\nopen a previously created Scenario.\nscenariosave\nsave the currently open Scenario.\nscenariosetattrs\nmodify the root path and startup group attributes of the Scenario.\nscenariosetcomments\ndefine or modify the Scenario comments.\nscenariosetopt\nmodify the Scenario options.\nscenariotrackfileadd\nadd the files currently being tracked.\nscenariotrackfilelist\nretrieve the list of files being tracked.\nscenariotrackfilenum\nretrieve the current number of files being tracked.\nscenariounzip\nunzip a zipped Scenario.\nscenariounzipproblems\nretrieve the problems that occurred during the last unzip attempt.\nscenariounzipsolutions\nsubmit potential solutions to the problems that occurred during the last unzip attempt.\nscenariozip\nzip up the current Scenario.\nscenariozipactive\ndetermine if the Scenario is currently in Zip Mode.\nscenariozipopen\nopen a zipped Scenario.\nscenariozipsave\nThis API routine was first introduced in release 33.2.\n--- Set Disturbance Definition \u2014 .txt ---\nSet Disturbance Definition \u2014\nSet Disturbance Definition\u00b6\ndist_def_3phase_bus_fault\ndefine a three phase fault at a bus in dynamic simulations.\ndist_def_3wind_fault\ndefine a fault at the IBUS end of a three-winding transformer in dynamic simulations.\ndist_def_branch_fault\ndefine a fault at the IBUS end of a non-transformer branch or a two-winding transformer in dynamic simulations.\ndist_def_scmu_fault_3\ndefine an unbalanced fault at a bus in dynamic simulations.\ndist_def_spcb_fault_2\nUse this API routine to define a branch unbalance in dynamic simulations.\n--- Set Disturbance \u2014 .txt ---\nSet Disturbance \u2014\nSet Disturbance\u00b6\ndist_3phase_bus_fault\napply a three phase fault at a bus during dynamic simulations.\ndist_3wind_close\nset a three-winding transformer to in-service during dynamic simulations.\ndist_3wind_fault\napply a fault at the IBUS end of a three-winding transformer during dynamic simulations.\ndist_3wind_trip\nset a three-winding transformer to out-of-service during dynamic simulations.\ndist_branch_close\nset a non-transformer branch or a two-winding transformer to in-service during dynamic simulations.\ndist_branch_fault\napply a fault at the IBUS end of a non-transformer branch or a two-winding transformer during dynamic simulations.\ndist_branch_trip\nset a non-transformer branch or a two-winding transformer to out-of-service during dynamic simulations.\ndist_bus_fault\ndist_bus_fault_2\ndist_bus_fault_3\napply an unbalanced fault at a bus during dynamic simulations.\ndist_bus_trip\ndisconnect a bus during dynamic simulations.\ndist_clear_fault\nclear a fault during dynamic simulations.\ndist_machine_trip\nset a machine to out-of-service during dynamic simulations.\ndist_scmu_fault\ndist_scmu_fault_2\ndist_scmu_fault_3\ncalculate an unbalanced fault and apply the equivalent positive sequence fault admittance at a bus during dynamic simulations.\ndist_spcb_fault\ndist_spcb_fault_2\nUse this API routine to run the second release of the dynamics branch unbalance function.\n--- Single Element Data \u2014 .txt ---\nSingle Element Data \u2014\nSingle Element Data\u00b6\napierrstr\nreturn the message string associated with a specific error code returned from a recordable PSSE API routine."
  },
  {
    "id": "chunk_025",
    "text": "ardat\nreturn area totals.\naredat\nreturn real area data items.\nareint\nreturn integer area data items.\narenam\nreturn the area name.\narenum\nreturn the area number.\nareuse\nindicate if an area is in use.\naritoj\nreturn the interchange between two areas.\nbrncur\nbrndat\nreturn real branch parameters.\nbrndt2\nreturn complex positive and zero sequence parameters for non-transformer branches, and complex positive sequence parameters for transformer branches.\nbrnflo\nreturn the complex branch flow (P+jQ) as calculated at IBUS.\nbrnint\nreturn integer branch parameters.\nbrnmsc\nreturn real branch flow values.\nbrnmva\nbrnnam\nreturn the name of an AC branch.\nbrnstt\nbsysisdef\ncheck whether a bus subsystem has been defined for a given subsystem ID.\nbusdat\nreturn real bus values.\nbusdt1\nreturn complex bus parameters as MVA.\nbusdt2\nreturn complex bus parameters.\nbusexs\ncheck for the existence of a specified bus.\nbusint\nreturn integer bus parameters.\nbusmsm\nreturn complex bus mismatch.\nbusordpos\nreturn the ordinal position of the specified bus or bus section in the numerically ordered list of non-star point buses (i.e., star point buses are excluded).\nbussectdat\nUse this API routine to return real bus section values.\nbussectdt1\nUse this API routine to return complex bus section parameters as MVA.\nbussectdt2\nUse this API routine to return complex bus section parameters.\nbussectexs\nUse this API routine to check for the existence of a specified bus section.\nbussectint\nUse this API routine to return real bus section values.\ncctmdlnam_2dco\nreturn model name of CCT 2-terminal dc line other models.\ncctmdlnam_2wtd\nreturn model name of the CCT 2-winding transformer device model.\ncctmdlnam_3wtd\nreturn model name of the CCT 3-winding transformer device model.\ncctmdlnam_brnd\nreturn model name of the CCT branch device model.\ncctmdlnam_brno\nreturn model name of the CCT branch other model.\ncctmdlnam_buso\nreturn model name of CCT Bus other models.\ncctmdlnam_mcno\nreturn model name of the CCT machine other models.\ncctmdlnam_mcnp\nreturn model name of the CCT machine protection models.\ncctmdlnam_msco\nreturn model name of the CCT Miscellaneous other model.\ncctmdlnam_swso_2\nreturn model name of the CCT switched shunt other type models.\ncctmind_2dco\nreturn starting array indices and status of CCT 2-terminal dc line other models.\ncctmind_2wtd\nreturn starting array indices and status of CCT 2-winding transformer device models.\ncctmind_3wtd\nreturn starting array indices and status of CCT 3-winding transformer device models.\ncctmind_brnd\nreturn starting array indices and status of CCT branch device models.\ncctmind_brno\nreturn starting array indices and status of CCT branch other models.\ncctmind_buso\nreturn starting array indices and status of CCT Bus other models.\ncctmind_mcno\nreturn starting array indices and status of CCT machine other models.\ncctmind_mcnp\nreturn starting array indices and status of CCT machine protection models.\ncctmind_msco\nreturn starting array indices and status of CCT Miscellaneous other models.\ncctmind_swso\ncctmind_swso_2\nreturn starting array indices and status of CCT Switched Shunt other models.\nchktre\ncheck for Type 4 (or greater) buses with in-service branches connected to them.\nchnval\nreturn the present value of the simulation variable assigned to a specified output channel.\ndc2auxmind\nreturn the starting array indices and status of auxiliary signal model associated with 2-terminal dc line for the specified signal index.\ndc2auxmnam\nreturn the auxiliary signal model name associated with a 2-terminal dc line for the specified auxiliary signal index.\ndc2dat\ndc2dat_2\nThis API is the second release of the API that returns real two-terminal dc line quantities.\ndc2int\ndc2int_2\nThis API is the second release of the API that returns integer two-terminal dc line quantities.\ndc2mind\nreturn 2-terminal dc line model starting array indices and status.\ndc2mnam\nreturn 2-terminal dc line model name.\ndcnauxmind\nreturn the starting array indices and status of auxiliary signal model associated with N-terminal dc line for the specified signal index.\ndcnauxmnam\nreturn the auxiliary signal model name associated with a N-terminal dc line for the specified auxiliary signal index.\ndcncin\ndcncin_2\nThis API is the second release of the API that returns integer multi-terminal dc line converter quantities.\ndcndat\ndcndat_2\nThis API is the second release of the API that returns real multi-terminal dc line quantities.\ndcnint\ndcnint_2\nThis API is the second release of the API that returns integer multi-terminal dc line quantities.\ndcnmind\nreturn N-terminal dc line model starting array indices and status.\ndcnmnam\nreturn N-terminal dc line model name.\ndscval\nreturn dynamics character array values.\ndsival\nreturn dynamics integer array values.\ndsrval\nreturn dynamics real values.\nfcdauxmind\nreturn the starting array indices and status of auxiliary signal model associated with FACTS device for the specified signal index.\nfcdauxmnam\nreturn the auxiliary signal model name associated with a FACTS device for the specified auxiliary signal index.\nfcddat\nfcddat_2\nThis API is the second release of the API that returns FACTS device real quantities.\nfcdint\nfcdint_2\nThis API is the second release of the API that returns FACTS device integer quantities.\nfcdmind\nreturn FACTS device model starting array indices and status.\nfcdmnam\nreturn FACTS device model name.\nfxsdt1\nreturn the magnitude of a specified fixed bus shunt.\nfxsdt2\nreturn complex fixed bus shunt.\nfxsint\nreturn integer quantities of the specified fixed bus shunt.\ngencnv\nreturn a flag indicating whether generators are converted.\ngendat\nreturn plant total power output.\ngendt1\nReturns total plant power output in MVA.\ngensectdat\nUse this API routine to return a bus section\u2019s plant total power output.\ngensectdt1\nUse this API routine to return a bus section\u2019s total plant power output in MVA.\nget_mstate\nreturn the MSTATE value.\ngethomepath\nretrieve a user\u2019s HOMEPATH directory.\ngnechr\nUse this API routine to return character quantities of a specified GNE device.\ngnedat\nUse this API routine to return real quantities of a specified GNE device.\ngneint\nUse this API routine to return integer quantities of a specified GNE device.\ninddt1\nUse this API routine to return real induction machine quantities.\ninddt2\nUse this API routine to return complex induction machine quantities.\nindint\nUse this API routine to return integer induction machine quantities.\nini2dc\nInitializes the two-terminal dc line fetching routine \u2018NXT2DC\u2019 for retrieving two-terminal dc lines in dc line name alphabetical order.\ninibrn\nInitializes the branch fetching routine \u2018NXTBRN\u2019 or \u2018NXTBRN3\u2019 for returning branches connected to IBUS."
  },
  {
    "id": "chunk_026",
    "text": "inibrn_2\nInitializes the branch fetching routine \u2018NXTBRN_2\u2019 or \u2018NXTBRN3_2\u2019 for returning branches connected to bus sections described by IBUS and INODE.\ninibrx\nInitializes the branch fetching routine, \u2018NXTBRN\u2019 or \u2018NXTBRN3\u2019 for returning branches connected to IBUS.\ninibrx_2\nInitializes the branch fetching routine, \u2018NXTBRN_2\u2019 or \u2018NXTBRN3_2\u2019 for returning branches connected to IBUS.\ninibus\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending numerical order.\ninibus_2\nInitializes the bus fetching routine \u2018NXTBUS_2\u2019 for retrieving buses in ascending numerical order.\ninibux\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending numerical order.\ninifax\nInitializes the FACTS device fetching routine \u2018NXTFAX\u2019 for retrieving FACTS devices in FACTS device name alphabetical order.\ninifxs\nInitializes the fixed bus shunt fetching routine \u2018NXTFXS\u2019 for returning fixed shunts attached to bus IBUS.\niniind\nInitializes induction machine fetching routine \u2018NXTIND\u2019 for returning induction machines attached to IBUS.\ninilod\nInitializes load fetching routine \u2018NXTLOD\u2019 for returning loads attached to IBUS.\ninimac\nInitializes machine fetching routine \u2018NXTMAC\u2019 for returning machines attached to IBUS.\ninimdc\nInitializes the multi-terminal dc line fetching routine \u2018NXTMDC\u2019 for retrieving multi-terminal dc lines in dc line name alphabetical order.\ninimsl\nInitializes the multi-section line member fetching routine \u2018NXTMSL\u2019 for retrieving lines that are sections of the specified multi-section line from IBUS to JBUS.\nininam\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending alphabetical order.\nininam_2\nInitializes the bus fetching routine \u2018NXTBUS_2\u2019 for retrieving buses in ascending alphabetical order.\nininax\nInitializes the bus fetching routine \u2018NXTBUS\u2019 for retrieving buses in ascending alphabetical order.\ninistabussect\nUse this API routine to initialize the bus section fetching routine \u2018NXTSTABUSSECT\u2019 for retrieving the bus sections in a substation.\ninistanode\nUse this API routine to initialize the node fetching routine \u2018NXTSTANODE\u2019 for retrieving the nodes in a sub-station.\ninistaswdev\nUse this API routine to initialize the switching device fetching routine \u2018NXTSTASWDEV\u2019 for retrieving the switching devices in a substation.\ninisws\nInitializes the switched shunt fetching routine \u2018NXTSWS\u2019 for returning switched shunts attached to bus IBUS.\ninitie\nInitializes the tie branch fetching routine \u2018NXTTIE\u2019 or \u2018NXTTIE3\u2019 for returning tie branches from area IAR.\ninitix\nInitializes the tie branch fetching routine \u2018NXTTIE\u2019 or \u2018NXTTIE3\u2019 for returning tie branches from area IAR.\ninivsc\nInitializes the VSC dc line fetching routine \u2018NXTVSC\u2019 for retrieving VSC dc lines in dc line name alphabetical order.\nisland\nTrips in-service branches connected to Type 4 (or greater) buses, and disconnects islands not containing a swing bus.\niterat\nreturn the number of iterations used in the last solution attempt.\nlmodind\nReturns load-related model starting array indices and status.\nlmodnam\nReturns load-related model name.\nlodcnv\nThis obsolete API always returns a 0.\nloddt1\nReturns load quantities in MVA.\nloddt2\nreturn complex load quantities.\nlodind\nreturn the load array index.\nlodint\nreturn integer load quantities.\nlodtype\nreturn the load type character string.\nmacchr\nreturn character machine quantities.\nmacdat\nreturn real machine quantities.\nmacdt2\nreturn complex machine quantities.\nmacind\nreturn the machine array index.\nmacint\nreturn integer machine quantities.\nmacstt\nreturn the machine status value.\nmaxmsm\nreturn the complex bus mismatch at the bus with the largest MVA mismatch.\nmdlind\nreturn plant-related model starting array indices and status.\nmdllibcnt\nreturn the number of libraries in the list to be searched for dynamics library models.\nmdlnam\nreturn plant-related model name.\nmdlpgmcnt\nreturns the number of model programs loaded from dynamics model libraries.\nnatono\nreturn the bus number for a specified 18-character extended bus name.\nnotona\nreturn the bus 18-character extended bus name for a specified bus number.\nnotonasect\nreturn the bus 18-character extended bus name for a specified bus section.\nnxt2dc\nReturns the next two-terminal dc line in dc line name alphabetical order.\nnxtbrn\nReturns the next branch connected to a bus, excluding three-winding transformers.\nnxtbrn3\nReturns the next branch connected to a bus, including three-winding transformers.\nnxtbrn3_2\nReturns the next branch connected to a bus section, including three-winding transformers.\nnxtbrn_2\nReturns the next branch connected to a bus, excluding three-winding transformers.\nnxtbus\nReturns the next bus in ordered sequence.\nnxtbus_2\nReturns the next bus in ordered sequence.\nnxtfax\nReturns the next FACTS device in FACTS device name alphabetical order.\nnxtfxs\nreturn the identifier of the next fixed shunt connected to a bus.\nnxtind\nUse this API routine to return the identifier of the next induction machine connected to a bus.\nnxtlod\nreturn the identifier of the next load connected to a bus.\nnxtmac\nreturn the identifier of the next machine connected to a bus.\nnxtmdc\nReturns the next multi-terminal dc line in dc line name alphabetical order.\nnxtmsl\nreturn the next multi-section line member branch.\nnxtstabussect\nUse this API routine to retrieve the next bus section in the specified substation.\nnxtstanode\nUse this API routine to retrieve the next node in the specified substation.\nnxtstaswdev\nUse this API routine to retrieve the next switching device in the specified substation.\nnxtsws\nreturn the identifier of the next switched shunt connected to a bus.\nnxttie\nreturn the next tie branch from an area, excluding three-winding transformers.\nnxttie3\nreturn the next tie branch from an area, including three-winding transformers.\nnxtvsc\nReturns the next VSC dc line in dc line name alphabetical order.\nokstrt\nRoutine which may be called after activity STRT or MSTR to indicate the presence of INITIAL CONDITIONS SUSPECT errors (for activity STRT) or at least one MODEL NOT AVAILABLE IN MSTR/MRUN message (for MSTR).\nopenun\nConnects an IPLAN unit number to the Fortran unit used by activity OPEN and returns that IPLAN unit number.\nordbus\nThis API routine returns the bus number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-hidden buses (i.e., star point buses and topological buses are excluded).\nordbussect\nThis API routine returns the bus number and section number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-star point buses (i.e., star point buses are excluded).\nowndat\nReturns the data associated with an owner (\u2018LOAD\u2019 gets loads at buses of owner \u2018IAR\u2019, \u2018LOADLD\u2019 gets loads assigned to owner \u2018IAR\u2019).\nownnam\nReturns the owner name for a specified owner number."
  },
  {
    "id": "chunk_027",
    "text": "ownnum\nReturns the owner number for a specified owner name.\nownuse\nindicate whether an owner is in use.\nprmdat\nUse this API routine to return real-valued solution parameters.\nprmint\nUse this API routine to return integer-valued solution parameters.\nratchr\nget rating set parameters.\nrmodind\nReturns the branch relay model starting array indices and status.\nrmodnam\nReturns the branch relay model name.\nsbsgtbkv\nget previously defined bus subsystem voltage limits.\nsc3wnd\nReturns the three-winding transformer short circuit currents arriving at IBUS following activity SCMU.\nscbrn2\nReturns the branch short circuit currents arriving at IBUS following activity SCMU.\nscbus2\nReturns complex bus voltages and currents following activity SCMU.\nscdone\nrestore the working case after \u2018SCINIT\u2019.\nscinit\ninitialize the short-circuit data retrieval APIs.\nscmac2\nreturn the machine short circuit currents following activity SCMU.\nselctr\nreturn the activity selector indicator.\nsethomepath\nset a user\u2019s HOMEPATH directory.\nsfiles\nreturn the current Saved Case and Snapshot filenames.\nslmodind\nreturn the subsystem load-related model starting array indices and status.\nslmodnam\nreturn the subsystem load-related model name.\nsolstr\nreturn a string indicating the result of the last solution attempt.\nsolved\ncheck whether the last solution attempt reached tolerance.\nsolved_ca\ncheck whether the last corrective action solution attempt reached tolerance.\nstadat\nUse this API routine to return real substation values.\nstaint\nUse this API routine to return integer substation values.\nstaname\nUse this API routine to return a substation\u2019s name.\nstanodeint\nUse this API routine to return integer substation values.\nstanodename\nUse this API routine to return the name of a substation node.\nstarea\nrestrict \u2018NXTBUS\u2019 to a single area.\nstaswdevdat\nUse this API routine to return real substation switching device values.\nstaswdevint\nUse this API routine to return integer substation switching device values.\nstaswdevname\nUse this API routine to return the name of a substation switching device.\nstbskv\nrestrict \u2018NXTBUS\u2019 to a single base voltage level.\nstzone\nrestrict \u2018NXTBUS\u2019 to a single zone.\nswsblk\nswsblk_2\nreturn data for a specified block of a specified switched shunt.\nswsblz\nswsblz2\nswsdat\nswsdat_2\nreturn switched shunt real data.\nswsdt1\nswsint\nswsint_2\nreturn switched shunt integer parameters.\nswsmind\nswsmind_2\nreturn switched shunt model starting array indices and status.\nswsmnam\nswsmnam_2\nreturn switched shunt model name.\nsysmsm\nreturn the total system MVA mismatch.\nsysmva\nreturn the system base MVA.\nsystot\nreturn complex system-wide values.\ntitldt\nreturn the two line case title.\ntotbus\nreturn the total number of buses in the working case.\ntr3dat\nreturn three-winding transformer real values.\ntr3dt2\nreturn three-winding transformer complex values.\ntr3int\nreturn three-winding transformer integer values.\ntr3nam\nreturn three-winding transformer name.\ntrndat\ntrxdat\nreturn the inter-area transfer MW.\ntspfprofilechr\nreturn string parameters of Time Series Power Flow profile.\ntspfprofilecurvechr\nreturn string parameters of Time Series Power Flow profile curve.\ntspfprofilecurveint\nreturn integer parameters of Time Series Power Flow profile curve.\ntspfprofilecurvereal\nreturn real parameters of Time Series Power Flow profile curve.\ntspfprofileint\nreturn integer parameters of Time Series Power Flow profile.\ntspfprofilereal\nreturn real parameters of Time Series Power Flow profile.\nvoltagedroopdata\nreturn voltage droop control real parameters.\nvoltagedroopint\nreturn voltage droop control integer parameters.\nvscauxmind\nreturn the starting array indices and status of auxiliary signal model associated with VSC dc line for the specified signal index.\nvscauxmnam\nreturn the auxiliary signal model name associated with a VSC dc line for the specified auxiliary signal index.\nvsccdt\nreturn VSC dc line real parameters.\nvsccin\nreturn VSC dc line converter integer parameters.\nvscint\nreturn VSC dc line integer parameters.\nvscmind\nreturn VSC dc line model starting array indices and status.\nvscmnam\nreturn VSC dc line model name.\nwindmind\nreturn wind model starting array indices and status.\nwindmnam\nreturn wind model name.\nwnddat\nreturn three-winding transformer real values for winding connected to bus IBUS.\nwnddt2\nreturn three-winding transformer complex values for winding connected to bus IBUS.\nwndint\nreturn three-winding transformer integer values for winding connected to bus IBUS.\nxfrdat\nreturn two-winding transformer real parameters.\nxfrint\nreturn two-winding transformer integer parameters.\nxfrnam\nreturn two-winding transformer name.\nzndat\nreturn zone totals.\nznitoj\nreturn the interchange between two zones.\nzonnam\nreturn the zone name.\nzonnum\nreturn the zone number.\nzonuse\nindicate whether a zone is in use.\n--- Substation Data \u2014 .txt ---\nSubstation Data \u2014\nSubstation Data\u00b6\nastationchar\nreturn an array of character values for subsystem substations.\nastationcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the substation data family.\nastationint\nreturn an array of integer values for subsystem substations.\nastationreal\nreturn an array of real values for subsystem substations.\nastationtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation data family (aStationInt, aStationReal and aStationChar).\n--- Substation Node Data \u2014 .txt ---\nSubstation Node Data \u2014\nSubstation Node Data\u00b6\nanodechar\nreturn an array of character values for subsystem substation nodes.\nanodecount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the substation node data family.\nanodeint\nreturn an array of integer values for subsystem substation nodes.\nanodereal\nreturn an array of real values for subsystem substation nodes.\nanodetypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation node data family (aNodeInt and aNodeChar).\n--- Substation Switching Device Data \u2014 .txt ---\nSubstation Switching Device Data \u2014\nSubstation Switching Device Data\u00b6\nastaswdevchar\nreturn an array of character values for subsystem substation switching devices.\nastaswdevcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the substation switching device data family.\nastaswdevcplx\nreturn an array of complex values for subsystem substation switching devices.\nastaswdevint\nreturn an array of integer values for subsystem substation switching devices.\nastaswdevreal\nreturn an array of real values for subsystem substation switching devices.\nastaswdevtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation switching device data family (aStaSwDevInt, aStaSwDevReal, aStaSwDevCplx and aStaSwDevChar)."
  },
  {
    "id": "chunk_028",
    "text": "--- Substation Terminal Data \u2014 .txt ---\nSubstation Terminal Data \u2014\nSubstation Terminal Data\u00b6\naterminalchar\nreturn an array of integer values for subsystem substation terminals.\naterminalcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the substation terminal data family.\naterminalint\nreturn an array of integer values for subsystem substation terminals.\naterminaltypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation terminal data family (aTerminalInt and aTerminalChar).\n--- Switched Shunt Bus Data \u2014 .txt ---\nSwitched Shunt Bus Data \u2014\nSwitched Shunt Bus Data\u00b6\naswshuntbuschar\nreturn an array of character values for subsystem buses.\naswshuntbuscount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt bus data family.\naswshuntbuscplx\nreturn an array of complex values for subsystem buses.\naswshuntbusint\nreturn an array of integer values for subsystem buses.\naswshuntbusreal\nreturn an array of real values for subsystem buses.\naswshuntbustypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt bus data family (aSwShntBusInt, aSwShntBusReal, aSwShntBusCplx and aSwShntBusChar).\n--- Switched Shunt Data \u2014 .txt ---\nSwitched Shunt Data \u2014\nSwitched Shunt Data\u00b6\naswshchar\nreturn an array of character values for subsystem switched shunts.\naswshcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt data family.\naswshcplx\nreturn an array of complex values for subsystem switched shunts.\naswshint\nreturn an array of integer values for subsystem switched shunts.\naswshreal\nreturn an array of real values for subsystem switched shunts.\naswshtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt data family (aSwshInt, aSwshReal, aSwshCplx and aSwshChar).\n--- Switched Shunt Models \u2014 .txt ---\nSwitched Shunt Models \u2014\nSwitched Shunt Models\u00b6\nadd_swshunt_model\nadd_swshunt_model_2\nadd a switched shunt model to the specified switched shunt device.\nchange_swsmod_chricn\nchange_swsmod_chricn_2\nchange the value of a character ICON (i.e., an element of the CHRICN array) of the switched shunt model of a specified switched shunt device.\nchange_swsmod_con\nchange_swsmod_con_2\nchange the value of a CON of the switched shunt model of a specified switched shunt device.\nchange_swsmod_icon\nchange_swsmod_icon_2\nchange the value of an integer ICON (i.e., an element of the ICON array) of the switched shunt model of a specified switched shunt device.\nchange_swsmod_var\nchange_swsmod_var_2\nchange the value of a VAR of the switched shunt model of a specified switched shunt device.\ngmb_add_swshunt_model\ngmb_add_swshunt_model_2\nadd a GMB switched shunt model to the specified switched shunt device.\nswsmod_pack\nremove entries that are marked as unused from the switched shunt model connection tables and the switched shunt model array allocation tables.\nswsmod_remove\nswsmod_remove_2\nremove the switched shunt model from a specified switched shunt.\nswsmod_status\nswsmod_status_2\nchange the status of the switched shunt model at a specified switched shunt device.\nswsmod_unconnected\nlist or remove from dynamics working memory those switched shunt models that are assigned to switched shunt that are not present in the current power flow working case (unconnected).\nswsmod_user\nlist user-written switched shunt model definitions or to remove user-written switched shunt model definitions that are not assigned to any switched shunt devices (unused) from the user model definition tables.\n--- Three-Winding Transformer Data \u2014 .txt ---\nThree-Winding Transformer Data \u2014\nThree-Winding Transformer Data\u00b6\natr3char\nreturn an array of character values for subsystem three-winding transformers.\natr3count\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer data family.\natr3cplx\nreturn an array of complex values for subsystem three-winding transformers.\natr3int\nreturn an array of integer values for subsystem three-winding transformers.\natr3real\nreturn an array of real values for subsystem three-winding transformers.\natr3types\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer data family (aTr3Int, aTr3Real, aTr3Cplx and aTr3Char).\n--- Three-Winding Transformer Winding Data \u2014 .txt ---\nThree-Winding Transformer Winding Data \u2014\nThree-Winding Transformer Winding Data\u00b6\nawndchar\nreturn an array of character values for subsystem three-winding transformer windings.\nawndcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer winding data family.\nawndcplx\nreturn an array of complex values for subsystem three-winding transformer windings.\nawndint\nreturn an array of integer values for subsystem three-winding transformer windings.\nawndreal\nreturn an array of real values for subsystem three-winding transformer windings.\nawndtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer winding data family (aWndInt, aWndReal, aWndCplx and aWndChar).\n--- Time Series Power Flow Data \u2014 .txt ---\nTime Series Power Flow Data \u2014\nTime Series Power Flow Data\u00b6\npurge_tspf_channel\ndelete all Time Series Power Flow profiles for an element.\npurge_tspf_channel_all\nremover all time series power flow channels for a selected element.\npurge_tspf_profile\ndelete Time Series Power Flow profile by profile name.\npurge_tspf_profilecurve\ndelete Time Series Power Flow profile curve by curvesetid and curvecol and index.\npurge_tspf_profilecurveset\ndelete Time Series Power Flow profile curve set by profile curvesetid.\npurge_tspf_profiledata\ndelete Time Series Power Flow profile data by curvesetid and curvecol and index.\ntspf_channel_chng\nselect time series power flow Cchannels.\ntspf_channel_data\nselect time series power flow Cchannels.\ntspf_profile_chng\nUse this API routine to modify the data of an existing Time Series Power Flow profile.\ntspf_profile_data\nUse this API routine to modify the data of an existing Time Series Power Flow profile, or to add a new Time Series Power Flow profile."
  },
  {
    "id": "chunk_029",
    "text": "tspf_profilecurveset_chng\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve set.\ntspf_profilecurveset_data\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve set, or to add a new Time Series Power Flow profile curve set.\ntspf_profiledata_chng\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve value.\ntspf_profiledata_data\nUse this API routine to modify the data of an existing Time Series Power Flow profile curve value, or to add a new Time Series Power Flow profile curve value.\n--- Time Series Power Flow Operation \u2014 .txt ---\nTime Series Power Flow Operation \u2014\nTime Series Power Flow Operation\u00b6\nimposeprofile\nimpose generation/load at the given time point on profile curves.\ntspf\nrun the time series power flow solution.\ntspf_output_pmatrix\noutput the profile curves within one profile set in the matrix format.\ntspf_output_pmatrix_2\noutput the profile curves within one profile set in the matrix format.\n--- Two-Terminal Dc Line Converter Data \u2014 .txt ---\nTwo-Terminal Dc Line Converter Data \u2014\nTwo-Terminal Dc Line Converter Data\u00b6\na2trmdcconvchar\nreturn an array of character values for subsystem two-terminal dc line converters.\na2trmdcconvcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line converter data family.\na2trmdcconvcplx\nreturn an array of complex values for subsystem two-terminal dc line converters.\na2trmdcconvint\nreturn an array of integer values for subsystem two-terminal dc line converters.\na2trmdcconvreal\nreturn an array of real values for subsystem two-terminal dc line converters.\na2trmdcconvtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (a2TrmDcConvInt, a2TrmDcConvReal, a2TrmDcConvCplx and a2TrmDcConvChar).\n--- Two-Terminal Dc Line Data \u2014 .txt ---\nTwo-Terminal Dc Line Data \u2014\nTwo-Terminal Dc Line Data\u00b6\na2trmdcchar\nreturn an array of character values for subsystem two-terminal dc lines.\na2trmdccount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line data family.\na2trmdccplx\nreturn an array of complex values for subsystem two-terminal dc lines.\na2trmdcint\nreturn an array of integer values for subsystem two-terminal dc lines.\na2trmdcreal\nreturn an array of real values for subsystem two-terminal dc lines.\na2trmdctypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line data family (a2TrmDcInt, a2TrmDcReal, a2TrmDcCplx and a2TrmDcChar).\n--- Two-Winding Transformer Data \u2014 .txt ---\nTwo-Winding Transformer Data \u2014\nTwo-Winding Transformer Data\u00b6\natrnchar\nreturn an array of character values for subsystem two-winding transformers.\natrncount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the two-winding transformer data family.\natrncplx\nreturn an array of complex values for subsystem two-winding transformers.\natrnint\nreturn an array of integer values for subsystem two-winding transformers.\natrnreal\nreturn an array of real values for subsystem two-winding transformers.\natrntypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-winding transformer data family (aTrnInt, aTrnReal, aTrnCplx and aTrnChar).\n--- Using The Vendor Neutral Contingency And Ras Auxiliary File \u2014 .txt ---\nUsing The Vendor Neutral Contingency And Ras Auxiliary File \u2014\nUsing The Vendor Neutral Contingency And Ras Auxiliary File\u00b6\naccc_ras\naccc_ras_2\nrun AC contingency calculation function with RAS model.\nadd2windingconditionelement\nAdd 2WindingConditionElement to RAS memory model\nadd2windingcontingencyelement\nAdd 2WindingContingencyElement to RAS memory model\nadd2windingremedialactionelement\nAdd 2WindingRemedialActionElement to RAS memory model\nadd3windingconditionelement\nAdd 3WindingConditionElement to RAS memory model\nadd3windingcontingencyelement\nAdd 3WindingContingencyElement to RAS memory model\nadd3windingremedialactionelement\nAdd 3WindingRemedialActionElement to RAS memory model\naddaclineconditionelement\nAdd AclineConditionElement to RAS memory model\naddaclinecontingencyelement\nAdd AclineContingencyElement to RAS memory model\naddaclineremedialactionelement\nAdd AclineRemedialActionElement to RAS memory model\naddbusconditionelement\nAdd BusConditionElement to RAS memory model\naddbuscontingencyelement\nAdd BusContingencyElement to RAS memory model\naddbusremedialactionelement\nAdd BusRemedialActionElement to RAS memory model\naddcondition\nAdd Condition to RAS memory model\naddconditionelement\nAdd ConditionElement to RAS memory model\naddcontingency\nAdd Contingency to RAS memory model\naddcontingencyelement\nAdd ContingencyElement to RAS memory model\nadddcconvconditionelement\nAdd DcconvConditionElement to RAS memory model\nadddcconvcontingencyelement\nAdd DcconvContingencyElement to RAS memory model\nadddcconvremedialactionelement\nAdd DcconvRemedialActionElement to RAS memory model\nadddclineconditionelement\nAdd DclineConditionElement to RAS memory model\nadddclinecontingencyelement\nAdd DclineContingencyElement to RAS memory model\nadddclineremedialactionelement\nAdd DclineRemedialActionElement to RAS memory model\naddfixshuntconditionelement\nAdd FixshuntConditionElement to RAS memory model\naddfixshuntcontingencyelement\nAdd FixshuntContingencyElement to RAS memory model\naddfixshuntremedialactionelement\nAdd FixshuntRemedialActionElement to RAS memory model\naddgenconditionelement\nAdd GenConditionElement to RAS memory model\naddgencontingencyelement\nAdd GenContingencyElement to RAS memory model\naddgenremedialactionelement\nAdd GenRemedialActionElement to RAS memory model\naddloadconditionelement\nAdd LoadConditionElement to RAS memory model\naddloadcontingencyelement\nAdd LoadContingencyElement to RAS memory model\naddloadremedialactionelement\nAdd LoadRemedialActionElement to RAS memory model\naddnestedcondition\nAdd NestedCondition to RAS memory model\naddpythonconditionelement\nAdd PythonConditionElement to RAS memory model\naddpythoncontingencyelement\nAdd PythonContingencyElement to RAS memory model\naddpythonremedialactionelement\nAdd PythonRemedialActionElement to RAS memory model\naddremedialaction\nAdd RemedialAction to RAS memory model\naddremedialactionelement\nAdd RemedialActionElement to RAS memory model\naddsubconditionelement\nAdd SubConditionElement to RAS memory model\naddsubcontingencyelement\nAdd SubContingencyElement to RAS memory model\naddsubremedialactionelement\nAdd SubRemedialActionElement to RAS memory model\naddvscdcconditionelement\nAdd VscdcConditionElement to RAS memory model\naddvscdccontingencyelement\nAdd VscdcContingencyElement to RAS memory model\naddvscdcremedialactionelement\nAdd VscdcRemedialActionElement to RAS memory model\nappend_ras\nread a Contingency Definition and Remedial Actions auxiliary file, adding to definitions in memory, if present.\nread_ras\nread a Contingency Definition and Remedial Actions auxiliary file into memory.\nvalidate_ras\nvalidate Contingency and Remedial Actions definitions in memory.\nwrite_ras\nwrite a Contingency Definition and Remedial Actions auxiliary file from memory.\n--- Vsc Dc Line Converter Data \u2014 .txt ---\nVsc Dc Line Converter Data \u2014\nVsc Dc Line Converter Data\u00b6\navscdcconvchar\nreturn an array of character values for subsystem VSC dc line converters.\navscdcconvcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line converter data family."
  },
  {
    "id": "chunk_030",
    "text": "avscdcconvcplx\nreturn an array of complex values for subsystem VSC dc line converters.\navscdcconvint\nreturn an array of integer values for subsystem VSC dc line converters.\navscdcconvreal\nreturn an array of real values for subsystem VSC dc line converters.\navscdcconvtypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line converter data family (aVscDcConvInt, aVscDcConvReal, aVscDcConvCplx and aVscDcConvChar).\n--- Vsc Dc Line Data \u2014 .txt ---\nVsc Dc Line Data \u2014\nVsc Dc Line Data\u00b6\navscdcchar\nreturn an array of character values for subsystem VSC dc lines.\navscdccount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line data family.\navscdccplx\nreturn an array of complex values for subsystem VSC dc lines.\navscdcint\nreturn an array of integer values for subsystem VSC dc lines.\navscdcreal\nreturn an array of real values for subsystem VSC dc lines.\navscdctypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line data family (aVscDcInt, aVscDcReal, aVscDcCplx and aVscDcChar).\n--- Wind Related Models \u2014 .txt ---\nWind Related Models \u2014\nWind Related Models\u00b6\nadd_wind_model\nadd a renewable related model of a designated type to a specified renewable machine.\nchange_wnmod_chricn\nchange the value of a character ICON (i.e., an element of the CHRICN array) of a designated renewable related model at a specified renewable machine.\nchange_wnmod_con\nchange the value of a CON of a designated renewable machine related model at a specified renewable machine.\nchange_wnmod_icon\nchange the value of an integer ICON of a designated renewable machine related model at a specified renewable machine.\nchange_wnmod_var\nchange the value of a VAR of a designated renewable machine related model at a specified renewable machine.\nwnmod_consistency\ncheck consistency among the renewable machine related models referenced at each machine.\nwnmod_pack\nremove entries that are marked as unused from the wind model connection tables and the renewable machine model array allocation tables.\nwnmod_remove\nremove a renewable machine related model of a designated type from a specified renewable machine.\nwnmod_status\nchange the status of a renewable machine related model of a designated type at a specified renewable machine.\nwnmod_unconnected\nlist or remove from dynamics working memory those renewable machine related models that are assigned to renewable machines that are not present in the current power flow working case (unconnected).\nwnmod_user\nlist user-written renewable machine model definitions or to remove user-written renewable machine model definitions that are not assigned to any renewable machines (unused) from the user model definition tables.\n--- Zero Sequence Mutuals Data \u2014 .txt ---\nZero Sequence Mutuals Data \u2014\nZero Sequence Mutuals Data\u00b6\nazmutchar\nreturn an array of character values for subsystem zero sequence mutual branches.\nazmutcount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the branch zero sequence mutual data family.\nazmutcplx\nreturn an array of complex values for subsystem zero sequence mutual branches.\nazmutint\nreturn an array of integer values for subsystem zero sequence mutual branches.\nazmutreal\nreturn an array of real values for subsystem zero sequence mutual branches.\nazmuttypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch zero sequence mutual data family (aZmutInt, aZmutReal, aZmutCplx and aZmutChar).\n--- Zone Data \u2014 .txt ---\nZone Data \u2014\nZone Data\u00b6\nazonechar\nreturn an array of character values for subsystem zones.\nazonecount\nreturn the number of array entries required to accommodate the data to be returned by the remaining members of the zone data family.\nazonecplx\nreturn an array of complex values for subsystem zones.\nazoneint\nreturn an array of integer values for subsystem zones.\nazonereal\nreturn an array of real values for subsystem zones.\nazonetypes\nreturn an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the zone data family (aZoneInt, aZoneReal, aZoneCplx and aZoneChar).\n--- Zone Subsystems \u2014 .txt ---\nZone Subsystems \u2014\nZone Subsystems\u00b6\nzsys\ndefine a zone subsystem.\nzsysdef\nset the definition of an zone subsystem.\nzsysinit\ninitialize or re-initialize a zone subsystem.\n#[accc_reports.py]  GET ACCC SOLUTION IN ARRAYS and CREATE CUSTOM REPORTS\n# ====================================================================================================\n'''\nThis is an example file showing how to use ACCC Solution Array fetch APIs\nfrom Python to generate custom accc solution reports.\nFollowing ACCC solutions can be retrieved:\n- post-contingency solution,\n- post-tripping solution, or\n- post-corrective action solution\nThese ACCC solutions can be obtained in Python lists for:\n- single contingency,\n- multiple contingencies, or\n- all contingencies\nThe APIs used in this program are part of python \"arrbox.accc_pp\" module.\naccobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)\nFollowing methods are defined for accobj.\n- accobj.summary and accobj.solution methods return ACCC solution\nin python object, which can be used to create custom reports, or\n- accobj.summary_report, accobj.solution_report or accobj.violations_report\nmethods can be used to get pre-defined reports.\nGet more info on as:\nhelp(arrbox.accc_pp.CONTINGENCY_PP)\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call funtion\nrun_accc_reports()\nYou may want to change input arguments when you call this function.\nrun_accc_reports(accfile, rptfile)\n---------------------------------------------------------------------------------\nAlternatively, use either of the following menu items to export ACCC file output to Excel.\n- from Windows Start>Programs>PSSExx>Export Results to Excel OR\n- from PSSE GUI, Power Flow>Reports>Export Results to Excel\n'''\n# ----------------------------------------------------------------------------------------------------\nimport sys, os, random, time\n# ----------------------------------------------------------------------------------------------------\ndef create_accc_reports(accfile, rptfile):\nimport psspy, arrbox.accc_pp\nif not os.path.exists(accfile):\nprgmsg = \" Error: Input accfile '{0}' does not exist\".format(accfile)\nprint(prgmsg)\nreturn\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:"
  },
  {
    "id": "chunk_031",
    "text": "x = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfpath, rptext = os.path.splitext(rptfile)\n# ----------------------------------------------------------------------------------------------------\n# common variables values (assumed)\nbusmsm    = 0.5\nsysmsm    = 5.0\nrating    = 'a'\nflowlimit = 80.0\nstype_cnt = 'contingency'\nstype_trp = 'tripping'\nstype_cact= 'caction'\n# ----------------------------------------------------------------------------------------------------\n# (1) Create object\naccobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)\nif accobj.ierr:\nprgmsg = \" Error {0:d} creating 'accobj'.\".format(accobj.ierr)\nprint(prgmsg)\nreturn\n# ----------------------------------------------------------------------------------------------------\n# (2) ACCC summary report\nsumfile = None\nif rptfile:  sumfile = rptfpath + '_summary' + rptext\naccobj.summary_report(rptfile=sumfile)\n# ----------------------------------------------------------------------------------------------------\n# (3) ACCC post contingency solution report\naccobj.solution_options(stype=stype_cnt,busmsm=busmsm,sysmsm=sysmsm,rating=rating,flowlimit=flowlimit)\ncntsolnfile = None\nif rptfile:  cntsolnfile = rptfpath + '_solution_cnt' + rptext\naccobj.solution_report(colabels=None,rptfile=cntsolnfile)\n# ----------------------------------------------------------------------------------------------------\n# (4) ACCC post tripping solution report\ntrpsolnfile = None\nif rptfile:  trpsolnfile = rptfpath + '_solution_trp' + rptext\naccobj.solution_options(stype=stype_trp)    # changed only solution type, other options remain same\naccobj.solution_report(colabels=None,rptfile=trpsolnfile)\n# ----------------------------------------------------------------------------------------------------\n# (5) ACCC post corrective action solution report\ncactsolnfile = None\nif rptfile:  cactsolnfile = rptfpath + '_solution_cact' + rptext\naccobj.solution_options(stype=stype_cact)    # changed only solution type, other options remain same\naccobj.solution_report(colabels=None,rptfile=cactsolnfile)\n# ----------------------------------------------------------------------------------------------------\n# (6) ACCC post contingency violations report\ncntviofile = None\nif rptfile:  cntviofile = rptfpath + '_violations_cnt' + rptext\naccobj.solution_options(stype=stype_cnt)\naccobj.violations_report(rptfile=cntviofile)\n# ----------------------------------------------------------------------------------------------------\n# (7) ACCC post tripping violations report\ntrpviofile = None\nif rptfile:  trpviofile = rptfpath + '_violations_trp' + rptext\naccobj.solution_options(stype=stype_trp)\naccobj.violations_report(rptfile=trpviofile)\n# ----------------------------------------------------------------------------------------------------\n# (8) ACCC post corrective action violations report\ncactviofile = None\nif rptfile:  cactviofile = rptfpath + '_violations_cact' + rptext\naccobj.solution_options(stype=stype_cact)\naccobj.violations_report(rptfile=cactviofile)\n# ----------------------------------------------------------------------------------------------------\n# (9) Getting summary arrays and printing contingency lables in PSS(R)E progress window\nsmryobj = accobj.summary()\n# note: returned \"smryobj\" is used in the following (10) to (16) examples of this program.\npsspy.progress('\\n Contingency Labels:\\n')\nfor each in smryobj.colabel:\npsspy.progress('    '+each+'\\n')\n# ----------------------------------------------------------------------------------------------------\n# (10) Getting solution arrays for one contingency and printing monitored element MVA and AMP flows\n#      in PSS(R)E progress window\nidx   = random.sample(list(range(len(smryobj.colabel))),1)   # select one contingency randomly\ncolbl = smryobj.colabel[idx[0]]\naccobj.solution_options(stype=stype_cnt)\nsolnobj  = accobj.solution(colabel=colbl)\nif solnobj!=None:        # contingency solution found/error, proceed\nrating = rating.strip().lower()\ntry:\nrate = smryobj.rating.rating\nexcept:\nrate = smryobj.rating.a\npsspy.progress(\"\\n Monitored Element Flows for contingency '%12s':\\n\" % colbl)\npsspy.progress(\"<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \\\n<AMPFLOW> <PCTFLOW>\\n\")\nfor i in range(len(solnobj.mvaflow)):\nelmt    = \"%54s\" % smryobj.melement[i]\nmvaflow = \"%9.2f\" % solnobj.mvaflow[i]\nif i < smryobj.acccsize.nmline:\nampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\npctflow = abs(solnobj.ampflow[i])\nelse:\nampflow = 9*' '                 # for interfaces, no AMP flow\npctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\nif rate[i]:\nelmt_rate = \"%8.2f\" % rate[i]\npctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\nelse:   # if rating is not provided, don't calculate %flow\nelmt_rate = 8*' '\npctflow   = 9*' '\ntxtstr = \"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars()\npsspy.progress(txtstr)\n# ----------------------------------------------------------------------------------------------------\n# (11) Getting solution arrays for three contingency and printing monitored element MVA and AMP flows\n#      in PSS(R)E progress window for converged contingencies\n# select upto maximum of 3 contingencies randomly\nidx    = random.sample(list(range(len(smryobj.colabel))),min(len(smryobj.colabel),3))\ncolbls = [smryobj.colabel[x] for x in idx]\nrating = rating.strip().lower()\ntry:\nrate = smryobj.rating.rating\nexcept:\nrate = smryobj.rating.a\nfor lbl in colbls:\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue          # contingency solution not found, move to next\nif not solnobj.cnvflag: continue    # contingency solution not converged, move to next\npsspy.progress(\"\\n Monitored Element Flows for contingency '%12s':\\n\" % lbl)\npsspy.progress(\"<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \\\n<AMPFLOW> <PCTFLOW>\\n\")\nfor i in range(len(solnobj.mvaflow)):\nelmt    = \"%54s\" % smryobj.melement[i]\nmvaflow = \"%9.2f\" % solnobj.mvaflow[i]\nif i < smryobj.acccsize.nmline:\nampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\npctflow = abs(solnobj.ampflow[i])\nelse:\nampflow = 9*' '                 # for interfaces, no AMP flow\npctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\nif rate[i]:\nelmt_rate = \"%8.2f\" % rate[i]\npctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\nelse:   # if rating is not provided, don't calculate %flow\nelmt_rate = 8*' '\npctflow   = 9*' '\ntxtstr = \"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars()\npsspy.progress(txtstr)\npsspy.progress('\\n')\n# ----------------------------------------------------------------------------------------------------\n# (12) Creating Overload report (similar to PSS(R)E ACCC Spreadsheet Overload Report) in\n#      PSS(R)E progress window\nrating = rating.strip().lower()\ntry:\nrate = smryobj.rating.rating\nexcept:\nrate = smryobj.rating.a\npsspy.progress(\"\\n OVERLOAD Report\\n\")\nfor lbl in smryobj.colabel:\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue         # contingency solution not found, move to next\nif not solnobj.cnvflag: continue   # contingency solution not converged, move to next\npsspy.progress(\" Monitored Element Flows above %g%% for contingency '%12s':\\n\" % (flowlimit,lbl))\npsspy.progress(\"<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \\\n<AMPFLOW> <PCTFLOW>\\n\")\nfor i in range(len(solnobj.mvaflow)):\nelmt    = \"%54s\" % smryobj.melement[i]\nmvaflow = \"%9.2f\" % solnobj.mvaflow[i]\nif i < smryobj.acccsize.nmline:\nampflow = \"%9.2f\" % solnobj.ampflow[i] # AMP flow exists for nmlines only.\npctflow = abs(solnobj.ampflow[i])\nelse:\nampflow = 9*' '                 # for interfaces, no AMP flow\npctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered\nif rate[i]:\nelmt_rate = \"%8.2f\" % rate[i]\npctflow_v = pctflow*100.0/rate[i]\npctflow   = \"%9.2f\" % (pctflow*100.0/rate[i])\nelse:   # if rating is not provided, don't calculate %flow\nelmt_rate = 8*' '\npctflow   = 9*' '\npctflow_v = 0\nif pctflow_v >= flowlimit:\npsspy.progress(\"%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \\n\" %vars())\npsspy.progress('\\n')\n# ----------------------------------------------------------------------------------------------------\n# (13) Creating Voltage Violations report in Text file, if provided\nif rptfile:  sumfile = rptfpath + '_summary' + rptext\nif rptfile:\nvviofpath, vviofext = os.path.splitext(rptfile)\nif not vviofext: vviofext = '.txt'\nvviofile   = vviofpath + '_vvio' + vviofext\nvviofile_h = open(vviofile,'w')\nreport     = vviofile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nreport(\"\\n Post Contingency VOLTAGE VIOLATIONS Report\\n\")\n# get base case solution\nsolnobj_basecase = accobj.solution(colabel=\"BASE CASE\")\nif solnobj_basecase==None or not solnobj_basecase.cnvflag:\nreport(\"    BASE CASE not converged\\n\")\nelse:\n# remaining contingencies\nfor lbl in smryobj.colabel[1:]:   # skipped \"BASE CASE\"\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue          # contingency solution not found, move to next\nif not solnobj.cnvflag: continue    # contingency solution not converged, move to next\nvvio_exists = False\nfor r in range(len(solnobj.volts)):\nif solnobj.volts[r] == 0.0: continue # disconnected bus, move to next\nif smryobj.mvrectype[r]=='RANGE':\nif smryobj.mvrecmin[r] and solnobj.volts[r] < smryobj.mvrecmin[r]:\nvvio = solnobj.volts[r] - smryobj.mvrecmin[r]\nelif smryobj.mvrecmax[r] and solnobj.volts[r] > smryobj.mvrecmax[r]:\nvvio = solnobj.volts[r] - smryobj.mvrecmax[r]\nelse:\nvvio = 0"
  },
  {
    "id": "chunk_032",
    "text": "else: # DEVIATION\ndelta = solnobj.volts[r] - solnobj_basecase.volts[r]\nif delta < 0:\nif smryobj.mvrecmin[r] and abs(delta) > smryobj.mvrecmin[r]:\nvvio =  delta + smryobj.mvrecmin[r]\nelse:\nvvio = 0\nelse:\nif smryobj.mvrecmax[r] and delta > smryobj.mvrecmax[r]:\nvvio = delta - smryobj.mvrecmax[r]\nelse:\nvvio = 0\nif vvio:\nif not vvio_exists:\nreport(\" Voltage Violations for contingency '%12s':\\n\" % (lbl))\nreport(\"<-----MONITORED BUS-----> <--MONITOR LABEL---> <--TYPE-> <-VMIN-> <-VMAX-> <-VINIT-> \\\n<-VOLT--> <-VVIO-->\\n\")\nvvio_exists = True\nmvbuslabel     = smryobj.mvbuslabel[r]\nmvreclabel     = smryobj.mvreclabel[r]\nmvrectype      = smryobj.mvrectype[r]\nif smryobj.mvrecmin[r]:\nmvrecmin   = \"%8.5f\" % smryobj.mvrecmin[r]\nelse:\nmvrecmin   = '   --   '\nif smryobj.mvrecmax[r]:\nmvrecmax   = \"%8.5f\" % smryobj.mvrecmax[r]\nelse:\nmvrecmax   = '   --   '\nmvrecvolts_init= solnobj_basecase.volts[r]\nmvrecvolts     = solnobj.volts[r]\nreport(\"%(mvbuslabel)25s %(mvreclabel)20s %(mvrectype)9s %(mvrecmin)s \\\n%(mvrecmax)s %(mvrecvolts_init)9.5f %(mvrecvolts)9.5f %(vvio)9.5f \\n\" %  vars())\nif vvio_exists: report('\\n')\nif rptfile:\nvviofile_h.close()\nprint('\\n Voltage Violations Report saved to file %s' % vviofile)\nelse:\nprint('\\n Voltage Violations Report created in Report window.')\n# ----------------------------------------------------------------------------------------------------\n# (14) Creating Post-Contingency Solution Load Shedding report in progress\nreport = psspy.progress\nload_curtailment_exists = False\nreport('\\n Post-Contingency LOAD CURTAILMENTS Report\\n')\nstype = stype_cnt\nfor lbl in smryobj.colabel:\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue              # contingency solution not found, move to next\nif not solnobj.cnvflag: continue        # contingency solution not converged, move to next\nif not len(solnobj.lshedbus): continue  # no load shedding, move to next\nreport(\"\\n Load Curtailments for contingency '%12s':\\n\" % (lbl))\nif not load_curtailment_exists:\nif stype=='contingency' or stype=='tripping':\nreport(\"<----------BUS----------> <LDSHED(MW)> <CONTINGENCY>\\n\")\nelse:\nreport(\"<----------BUS----------> <INITLD(MW)>  <LDSHED(MW)> <CONTINGENCY>\\n\")\nload_curtailment_exists = True\nfor c in range(len(solnobj.lshedbus)):\nif stype=='contingency' or stype=='tripping':\nreport(\"%25s %12.2f %-12s\\n\" % (solnobj.lshedbus[c],solnobj.loadshed[c],lbl))\nelse:\nreport(\"%25s %12.2f %12.2f %-12s\\n\" % (solnobj.lshedbus[c],solnobj.loadshed[0][c],\nsolnobj.loadshed[1][c],lbl))\nif not load_curtailment_exists:\nreport('    None\\n')\n# ----------------------------------------------------------------------------------------------------\n# (15) Creating Corrective Action Solution Generation Dispatch report in progress\naccobj.solution_options(stype=stype_cact)\nreport = psspy.progress\ngen_disp_exists = False\nreport('\\n Corrective Action GENERATION DISPATCH  Report\\n')\nfor lbl in smryobj.colabel:\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue              # contingency solution not found, move to next\nif not solnobj.cnvflag: continue        # contingency solution not converged, move to next\nif not len(solnobj.gdispbus): continue  # no generation dispatch, move to next\nif not gen_disp_exists:\nreport(\"<----------BUS----------> <INITGEN(MW)>  <GENDISP(MW)> <CONTINGENCY>\\n\")\ngen_disp_exists = True\nfor c in range(len(solnobj.gdispbus)):\nreport(\"%25s %9.2f %s %9.2f %s %-12s\\n\" % (solnobj.gdispbus[c],solnobj.gendisp[0][c],4*' ',\nsolnobj.gendisp[1][c],3*' ',lbl))\nif not gen_disp_exists:\nreport('    None\\n')\n# ----------------------------------------------------------------------------------------------------\n# (16) Creating Corrective Action Solution Phase Shifter Angle report in progress\naccobj.solution_options(stype=stype_cact)\nreport = psspy.progress\nphsftr_exists = False\nreport('\\n Corrective Action PHASE SHIFTER ANGLE Report\\n')\nfor lbl in smryobj.colabel:\nsolnobj  = accobj.solution(colabel=lbl)\nif solnobj==None: continue              # contingency solution not found, move to next\nif not solnobj.cnvflag: continue        # contingency solution not converged, move to next\nif not len(solnobj.phsftr): continue    # no generation dispatch, move to next\nif not phsftr_exists:\nreport(\"<-------FROM BUS------------------TO BUS-----------ID> <INITANG(deg)> <NEWANG(deg)> \\\n<CONTINGENCY>\\n\")\nphsftr_exists = True\nfor c in range(len(solnobj.phsftr)):\nreport(\"%54s %9.2f %s %9.2f %s %-12s\\n\" % (solnobj.phsftr[c],solnobj.phsftrang[0][c],5*' ',\nsolnobj.phsftrang[1][c],3*' ',lbl))\nif not phsftr_exists:\nreport('    None\\n')\n# =====================================================================================================\ndef check_psse_example_folder(rptfile):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nrptpath, rptfnam = os.path.split(rptfile)\nif not rptpath:\nrptpath = os.getcwd()\ncwd = rptpath.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(os.getcwd(), 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\nrptfile  = os.path.join(outdir, rptfnam)\nreturn rptfile\n# =====================================================================================================\ndef run_accc_reports(accfile='savnw.acc', rptfile='accc_reports_savnw.txt'):\nrptfile  = check_psse_example_folder(rptfile)\ncreate_accc_reports(accfile, rptfile)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun_accc_reports()\n# ====================================================================================================\n#[ascc_demo.py]   Fault Calculations using ASCC\n# =====================================================================================================\n'''There are three different ways to calculate faults using ASCC.\n1) Using activity ASCC (psspy.ascc_3)\nRuns all types of faults, creates text reports, but no access to results from Python script.\n2) Using Python module arrbox.ascc.ascc_currents\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain both phase and sequence fault currents.\nb) contain faults currents for bus faults only.\nc) does not contain faults currents for linout and linend faults.\n3) Using Python module arrbox.fault.FAULT_SUMMARY\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain only total fault currents for faults calculated.\nb) contain faults currents for bus, linout and linend faults.\nThis is an example file showing how to run ASCC fault calculations using either of these methods.\n---------------------------------------------------------------------------------\nHow to use this file?\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\nimport psse35\nB) This file contain following functions that uses savnw.sav file run ASCC calculations.\nrun_ascc_3_savnw(..)\nrun_ascc_currents_savnw_txtrpt(..)\nrun_ascc_currents_savnw_xls(..)\nrun_fault_summary_ascc_savnw(..)\nRun either of these functions under  __main__ to see how they work.\nC) Create similar functions for the network case and faults you want to run.\n'''\n# ========================================================================================\n#\n\"\"\"\nUse any of these keywords to run psspy.ascc or arrbox.ascc.ascc_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default      Description\n# STATUS array\nfltlg     = 0          # 1  0=>omit, 1=>include\nlinout    = 0          # 2  0=>omit, 1=>include\nlinend    = 0          # 3  0=>omit, 1=>include\nvoltop    = 0          # 4  0=>from PF, 1=>at specified for all buses, 2=>at specified faulted bus\ngenxop    = 0          # 5  0=>X'' 1=>X', 2=>Xs\nrptop     = -1         # 6  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl    = 0          # 7  number of contribution levels\ntpunty    = 0          # 8  0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged, 3=>N unchanged and phi=0\ndcload    = 1          # 9  0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec    = 1          # 10 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\nflt3ph    = 0          # 11 0=>omit, 1=>include\nfltllg    = 0          # 12 0=>omit, 1=>include\nfltll     = 0          # 13 0=>omit, 1=>include\nlnchrg    = 0          # 14 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop    = 0          # 15 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\nloadop    = 0          # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\nmachpq    = 0          # 17 0=>from PF, 1=>0.0 (generator/motor PQ output)"
  },
  {
    "id": "chunk_033",
    "text": "# VALUES array\nvolts     = 1.0        # 1  specified bus voltage, used when voltop=1 or 2\n# File args\nrelfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n# ========================================================================================\nimport sys, os, time, math\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n'owners':[], 'zones':[]}\ndef fault_bsys(sid, **kwds):\nimport psspy\nif sid==0: return\nactv_kwds = {}  # activity keywords\nfor k, v in bsys_kwds.items():\nif k in kwds:\nactv_kwds[k] = kwds[k]\nelse:\nactv_kwds[k] = v\nactv_kwds['sid']      = sid\nactv_kwds['numarea']  = len(actv_kwds['areas'])\nactv_kwds['numbus']   = len(actv_kwds['buses'])\nactv_kwds['numowner'] = len(actv_kwds['owners'])\nactv_kwds['numzone']  = len(actv_kwds['zones'])\nierr = psspy.bsys(**actv_kwds)\nreturn ierr\n# ========================================================================================\ndef set_prg_rpt(prgfile='', rptfile=''):\nimport psspy\npsspy.lines_per_page_one_device(1,10000000)\nif prgfile: psspy.progress_output(2,prgfile,[0,0])\nif rptfile: psspy.report_output(2,rptfile,[0,0])\n# ========================================================================================\ndef reset_prg_rpt():\nimport psspy\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,'',[0,0])\npsspy.report_output(1,'',[0,0])\n# ========================================================================================\nclass ASCC_DEMO:\n\"\"\" Run PSSE ASCC Calculations\"\"\"\ndef __init__(self):\nimport psspy\nself.ierr = psspy.psseinit(buses=150000)\n# ------------------------------------------------------------------------------------\ndef _frmted_z(self, cnum):\nr=cnum.real\nx=cnum.imag\ncsign='+j'\nif x<0:\ncsign='-j'\nx=abs(x)\nif r==0:\nrstr=''\nelse:\nrstr=\"%9.6f\" % r\nif x==0:\nxstr=''\ncsign=''\nelse:\nxstr=\"%9.6f\" % x\nzstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\nreturn zstr\n# ------------------------------------------------------------------------------------\ndef _frmted_z_xbyr(self, cnum):\nzstr = self._frmted_z(cnum)\nr=cnum.real\nx=abs(cnum.imag)\nif r==0:\nxbyr=''\nelse:\nxbyr=\"%9.6f\" % (x/r)\ncstr=\"%(zstr)s, %(xbyr)s\" % vars()\nreturn cstr\n# ------------------------------------------------------------------------------------\ndef _crnt_mag(self, fmt, cval):\nif fmt=='rectangular':\nreturn abs(cval)\nelse:\nreturn cval.real\n# ------------------------------------------------------------------------------------\ndef _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\nif scfmt=='rectangular':\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\ncrnt = abs(crnt)\nelse:\ncval = cval.real\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\nmva  = math.sqrt(3.0)*basekv*crnt/1000.0\nreturn crnt, mva\n# ------------------------------------------------------------------------------------\ndef run_ascc_api(self, sid, allbus, **kwds):\nimport psspy\nierr = psspy.ascc_3(sid, allbus, **kwds)\n# ------------------------------------------------------------------------------------\ndef run_ascc_currents(self, sid, allbus, **kwds):\nimport psspy, arrbox.ascc\nrlst = arrbox.ascc.ascc_currents(sid, allbus, **kwds)\nif rlst.ierr!=0:\nraise Exception(\"arrbox.ascc.ascc_currents error= {}\\n\".format(rlst.ierr))\nreturn rlst\n# ------------------------------------------------------------------------------------\ndef run_fault_summary(self, sid, allbus, **kwds):\nimport psspy, arrbox.fault\nfltobj = arrbox.fault.FAULT_SUMMARY('ASCC', sid, allbus, **kwds)\nif fltobj.ierr!=0:\nraise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\nreturn fltobj\n# ------------------------------------------------------------------------------------\ndef report_ascc_currents(self, rlst, rptfile=''):\nimport psspy\nif rlst.ierr: return\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:\nx = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nnfbus=len(rlst.fltbus)\ntxtlst = []\nif not rptfile: txtlst.append('')\nttlstr=\"PSS(R)E ASCC SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\nln1str,ln2str=psspy.titldt()\nmaxlen=max(len(ttlstr),len(ln1str),len(ln2str))\ntxtlst.append(ttlstr.center(maxlen))\ntxtlst.append(ln1str.center(maxlen))\ntxtlst.append(ln2str.center(maxlen))\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nscunit = rlst.scunit\nscfmt  = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nif scunit == 'pu':\nunits = 'PU'\nelse:\nunits = 'AMP'\nunitstr   = units.center(10)\nclnhdr    = \"   BUS     \" + 6*unitstr\nfor i in range(nfbus):\ntxtlst = []\ntxtlst.append('')\ntxtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\ntxtlst.append(clnhdr)\nfbus   = rlst.fltbus[i]\nif flt3ph:\nttxt   = \"%6d\" % fbus\nspc    = '3PH'\nia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\nib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\nic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltlg:\nif flt3ph:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = ' LG'\nia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltllg:\nif flt3ph or fltlg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = 'LLG'\nia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltll:\nif flt3ph or fltlg or fltllg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc     = ' LL'\nia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\nif scunit_z!='pu':\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\ntmptxt=110*'-'\ntxtlst.append(tmptxt)\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\n# Maximum Fault Currents\ninam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\nunitstr   = units.center(11)\nunitstr = ''\nfor each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\nt = each+'('+units+')'\nt = ' ' + t.center(9) + ' '\nunitstr += t\ntxtlst = []\ntxtlst.append('')\nclnhdr    = \"   BUS  \" + unitstr + \"  Description\"\ntxtlst.append(\"BREAKER DUTY CURRENTS\")\ntxtlst.append(clnhdr)\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nfor i in range(nfbus):\nfbus   = rlst.fltbus[i]\nia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\nib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\nic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\ndsc    = rlst.maxfltdsc[i]\nif rptfile: report('\\n')\ntmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\nreport(tmptxt)\n# ------------------------------------------------------------------------------------------------\nif rptfile:\nrptfile_h.close()\nprint('\\n Done .... ASCC FAULT Report saved to file %s' % rptfile)\n# ------------------------------------------------------------------------------------\ndef excel_ascc_currents(self, rlst, faults_applied, xlsfile=''):\nimport psspy\nimport excelpy\nif rlst.ierr: return\n# bus data\nsid  = -1   # consider subsystem of all buses\nflag = 1    # consider only in-service buses\nierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\nierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\nierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\nierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\nbus_data = {}\nfor bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\nbus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nscunit   = rlst.scunit\nscfmt    = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nnfbus=len(rlst.fltbus)\nxlswbk = excelpy.workbook(xlsfile)\nxlswbk.show()\nsavfile, snpfile = psspy.sfiles()\nline1, line2 = psspy.titldt()\nttl      = r\"PSSE Short Circuit Calculations Using ASCC\"\nttl      = ttl + 5*' ' + time.ctime()"
  },
  {
    "id": "chunk_034",
    "text": "ttl_file = savfile\nttl_line1= line1.strip()\nttl_line2= line2.strip()\ncln_mrglst = []\ncln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\ncln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\nfor fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\nif fltok:\ncln_mrglst.append(len(cln_heads_r1)+1)\ncln_heads_r1.extend([clnnam, ''])\ncln_heads_r2.extend(['MVA', 'AMP'])\ncln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\ncln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\ncolheads = [cln_heads_r1, cln_heads_r2]\nrow = 7\ncln = 1\nsbase = psspy.sysmva()\nfor i in range(nfbus):\nrowdata = []\nfbus    = rlst.fltbus[i]\nbasekv  = bus_data[fbus]['basekv']\nprefltv = bus_data[fbus]['prefltv']\nrowdata.append(fbus)\nrowdata.append(bus_data[fbus]['name'])\nrowdata.append(basekv)\nrowdata.append(basekv*abs(prefltv))\nif flt3ph:\ncval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nif fltlg:\ncval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([3*mva, 3*crnt])\nif fltllg:\ncval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([3*mva, 3*crnt])\nif fltll:\ncval = rlst.fltll[i].ib   # Ifault=Ib\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nzpos  = rlst.thevzpu[i].z1\nzneg  = rlst.thevzpu[i].z2\nzzero = rlst.thevzpu[i].z0\ns_zpos  = self._frmted_z(zpos)\ns_zneg  = self._frmted_z(zneg)\ns_zzero = self._frmted_z(zzero)\nrowdata.extend([s_zpos, s_zneg, s_zzero])\nbrow,rcln = xlswbk.set_range(row,cln,rowdata)\nrow = brow + 1\nxlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\nxlswbk.autofit_columns((6,9,brow,rcln))\nxlswbk.align((6,9,brow,rcln),'right')\n# headings and column titles\nxlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nxlswbk.merge((1,1,1,rcln))\nxlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((2,1,2,rcln))\nxlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((3,1,3,rcln))\nxlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((4,1,4,rcln))\nbrow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\nxlswbk.merge((5,1,5,2))\nfor cln in cln_mrglst:\nxlswbk.merge((5,cln,5,cln+1))\nxlswbk.merge((5,rcln-2,5,rcln))\nxlswbk.align((1,1),'h_center')\nxlswbk.align_rows((1,1,6,1),'h_center')\nif xlsfile: xlswbk.save(xlsfile)\n# ========================================================================================\ndef run_ascc_3_savnw(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile = 'savnw.sav'\nsid, allbus = 3, 0\nbuses = [153, 154]\nrptfile = ''\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_savnw_ascc_3_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\nset_prg_rpt(rptfile=rptfile)\n# set short circuit options\npsspy.short_circuit_units(unt)      # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\nasccobj = ASCC_DEMO()\nasccobj.run_ascc_api(sid, allbus, **kwds)\nreset_prg_rpt()\n# ========================================================================================\ndef run_ascc_currents_savnw_txtrpt(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile = 'savnw.sav'\nsid, allbus = 3, 0\nbuses = [153, 154]\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_savnw_ascc_currents_{}.txt\".format(nam_unt[unt])\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)      # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\nasccobj = ASCC_DEMO()\nrlst = asccobj.run_ascc_currents(sid, allbus, **kwds)\nasccobj.report_ascc_currents(rlst, rptfile)\n# ========================================================================================\ndef run_ascc_currents_savnw_xls(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile = 'savnw.sav'\nsid, allbus = 3, 0\nbuses = [153, 154]\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nxlsfile = \"z_savnw_ascc_currents_{}\".format(nam_unt[unt])\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)      # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\nasccobj = ASCC_DEMO()\nrlst = asccobj.run_ascc_currents(sid, allbus, **kwds)\nasccobj.excel_ascc_currents(rlst, xlsfile)\n# ========================================================================================\ndef run_fault_summary_ascc_savnw(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile = 'savnw.sav'\nsid, allbus = 3, 0\nbuses = [153, 154]\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_savnw_ascc_fault_summary_{}.txt\".format(nam_unt[unt])\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)      # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings\nasccobj = ASCC_DEMO()\nfltobj = asccobj.run_fault_summary(sid, allbus, **kwds)\nfltobj.text_report(rptfile)\n# ========================================================================================\ndef _temp():\n# Run either of these functions under  __main__ to see how they work.\nrun_ascc_3_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_ascc_currents_savnw_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\nrun_ascc_currents_savnw_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\nrun_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\nrun_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\n# ========================================================================================\nif __name__=='__main__':\npass\nimport psse35\n#[ascc_report.py]    Get ASCC fault currents in arrays and create custom report\n# =====================================================================================================\n'''\nThis is an example file showing how to use \"ascc_currents\" function from pssarrays module.\nASCC_CURRENTS function returns ASCC short circuit currents for each faulted bus and\neach type of fault applied. They are:\nia1   = Positive Sequence Current\nia2   = Negative Sequence Current\nia0   = Zero Sequence Current\nia    = Phase A current\nib    = Phase B current\nic    = Phase C current\nThe APIs used in this program are part of python \"pssarrays\" module.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call function\nrun_ascc_report()\nYou may want to change inputs specified in this function.\nrun_ascc_report(savfile, fltbuses, rptfile)\nDefaults:\nsavfile  = 'savnw.sav'\nfltbuses = [151,154]\nrptfile  = 'ascc_report_savnw.txt'\nWhen this script is called from PSSE's Example Folder,\nreport is created in subfolder 'Output_Pyscript'\n'''\n# =====================================================================================================\nimport os, time, math\n# =====================================================================================================\ndef encode_complex_number_xbyr(cnum):\nr=cnum.real\nx=cnum.imag\ncsign='+j'\nif x<0:\ncsign='-j'\nx=abs(x)\nif r==0:\nrstr=''\nxbyr=''\nelse:\nrstr=\"%9.6f\" % r\nxbyr=\"%9.6f\" % (x/r)\nif x==0:\nxstr=''\ncsign=''\nelse:\nxstr=\"%9.6f\" % x\ncstr=\"%(rstr)s%(csign)s%(xstr)s, %(xbyr)s\" % vars()\nreturn cstr\n# =====================================================================================================\ndef get_cplx_mag(fmt, cmplxvalue):\nif fmt == 'rectangular':\nreturn abs(cmplxvalue)\nelse:\nreturn cmplxvalue.real\n# =====================================================================================================\ndef create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,\ntpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,\nsavfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):\nimport psspy, arrbox.ascc\n# open case\nif savfile: psspy.case(savfile)\n# Save pre-fault voltages\nsid  = -1\nflag = 2\nierr, (buslst,)           = psspy.abusint(sid,  flag, ['NUMBER'])\nierr, (busvltlst_preflt,) = psspy.abuscplx(sid, flag, ['VOLTAGE'])\nierr, (busvltlst_base,)   = psspy.abusreal(sid, flag, ['BASE'])\nbusdata_dict = {}\nfor n, vpf, vnm in zip(buslst, busvltlst_preflt, busvltlst_base):\nbusdata_dict[n] = {'prefltv': vpf, 'basekv': vnm}\n# set sc units and format\npsspy.short_circuit_units(1)         # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(0)   # 0=rectangular, 1=polar\nsid = 3\nif fltbuses:\npsspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])\nbusall = 0\nelse:\nbusall = 1\n# call pssarrays routine\nrlst = arrbox.ascc.ascc_currents(sid, busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,\nfltll=fltll, linout=linout, linend=linend, voltop=voltop, genxop=genxop, tpunty=tpunty,\ndcload=dcload, zcorec= zcorec, lnchrg=lnchrg, shntop=shntop, loadop=loadop, machpq=machpq,\nvolts=volts, relfile=relfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)\nif rlst.ierr!=0:\nraise Exception(\"arrbox.ascc.ascc_currents error= %d\\n\" % rlst.ierr)\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:\nx = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nnfbus=len(rlst.fltbus)\nttlstr=\"PSS(R)E ASCC SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\nln1str,ln2str=psspy.titldt()\nmaxlen=max(len(ttlstr),len(ln1str),len(ln2str))\nreport(ttlstr.center(maxlen))\nreport(\"\\n\")\nreport(ln1str.center(maxlen))\nreport(\"\\n\")\nreport(ln2str.center(maxlen))\nreport(\"\\n\\n\")\nsbase  = psspy.sysmva()\nscunit = rlst.scunit\nscfmt  = rlst.scfmt\nif scunit == 'pu':\nunits = 'PU'\nelse:\nunits = 'AMP'\nunitstr   = units.center(10)\nclnhdr    = \"   BUS     \" + 6*unitstr + \"\\n\"\nfor i in range(nfbus):\nreport(\"           <-SCMVA-> <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\\n\")\nreport(clnhdr)\nfbus   = rlst.fltbus[i]\nbasekv = busdata_dict[fbus]['basekv']\nbaseamp = (1000.0 * sbase) / (math.sqrt(3.0) * basekv)"
  },
  {
    "id": "chunk_035",
    "text": "if flt3ph:\nttxt   = \"%6d\" % fbus\nspc    = '3PH'\nia1    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia1)\nia2    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia2)\nia0    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia0)\nia     = get_cplx_mag(scfmt,rlst.flt3ph[i].ia)\nib     = get_cplx_mag(scfmt,rlst.flt3ph[i].ib)\nic     = get_cplx_mag(scfmt,rlst.flt3ph[i].ic)\nscmva  = math.sqrt(3.0) * basekv * rlst.flt3ph[i].ia1 / 1000.0\nif scunit == 'pu': scmva = scmva*baseamp\nscmva  = get_cplx_mag(scfmt,scmva)\ntmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltlg:\nif flt3ph:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = ' LG'\nia1    = get_cplx_mag(scfmt,rlst.fltlg[i].ia1)\nia2    = get_cplx_mag(scfmt,rlst.fltlg[i].ia2)\nia0    = get_cplx_mag(scfmt,3*rlst.fltlg[i].ia0)\nia     = get_cplx_mag(scfmt,rlst.fltlg[i].ia)\nib     = get_cplx_mag(scfmt,rlst.fltlg[i].ib)\nic     = get_cplx_mag(scfmt,rlst.fltlg[i].ic)\nscmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltlg[i].ia0 / 1000.0\nif scunit == 'pu': scmva = scmva*baseamp\nscmva  = get_cplx_mag(scfmt,scmva)\ntmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltllg:\nif flt3ph or fltlg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = 'LLG'\nia1    = get_cplx_mag(scfmt,rlst.fltllg[i].ia1)\nia2    = get_cplx_mag(scfmt,rlst.fltllg[i].ia2)\nia0    = get_cplx_mag(scfmt,3*rlst.fltllg[i].ia0)\nia     = get_cplx_mag(scfmt,rlst.fltllg[i].ia)\nib     = get_cplx_mag(scfmt,rlst.fltllg[i].ib)\nic     = get_cplx_mag(scfmt,rlst.fltllg[i].ic)\nscmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltllg[i].ia0 / 1000.0\nif scunit == 'pu': scmva = scmva*baseamp\nscmva  = get_cplx_mag(scfmt,scmva)\ntmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltll:\nif flt3ph or fltlg or fltllg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc     = ' LL'\nia1    = get_cplx_mag(scfmt,rlst.fltll[i].ia1)\nia2    = get_cplx_mag(scfmt,rlst.fltll[i].ia2)\nia0    = get_cplx_mag(scfmt,rlst.fltll[i].ia0)\nia     = get_cplx_mag(scfmt,rlst.fltll[i].ia)\nib     = get_cplx_mag(scfmt,rlst.fltll[i].ib)\nic     = get_cplx_mag(scfmt,rlst.fltll[i].ic)\nscmva  = math.sqrt(3.0) * basekv * rlst.fltll[i].ib / 1000.0\nif scunit == 'pu': scmva = scmva*baseamp\nscmva  = get_cplx_mag(scfmt,scmva)\ntmptxt = \"%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \\n\" % vars()\nreport(tmptxt)\nreport(\"\\nTHEVENIN IMPEDANCE (pu), X/R\\n\")\nz1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\nelse:\ntmptxt=\"%(z1str)s\\n\" % vars()\nreport(tmptxt)\nif scunit != 'pu':\nreport(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\\n\")\nz1str = encode_complex_number_xbyr(rlst.thevz[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = encode_complex_number_xbyr(rlst.thevz[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = encode_complex_number_xbyr(rlst.thevz[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\nelse:\ntmptxt=\"%(z1str)s\\n\" % vars()\nreport(tmptxt)\ntmptxt=110*'-'\nreport(tmptxt)\nreport(\"\\n\")\n# Maximum Fault Currents\ninam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\nunitstr   = units.center(11)\nunitstr = ''\nfor each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\nt = each+'('+units+')'\nt = ' ' + t.center(9) + ' '\nunitstr += t\nclnhdr    = \"   BUS  \" + unitstr + \"  Description\\n\"\nreport(\"\\nBREAKER DUTY CURRENTS\\n\")\nreport(clnhdr)\nfor i in range(nfbus):\nfbus   = rlst.fltbus[i]\nia1    = get_cplx_mag(scfmt,rlst.maxflt[i].ia1)\nia2    = get_cplx_mag(scfmt,rlst.maxflt[i].ia2)\nia0    = get_cplx_mag(scfmt,rlst.maxflt[i].ia0)\nia     = get_cplx_mag(scfmt,rlst.maxflt[i].ia)\nib     = get_cplx_mag(scfmt,rlst.maxflt[i].ib)\nic     = get_cplx_mag(scfmt,rlst.maxflt[i].ic)\ndsc    = rlst.maxfltdsc[i]\ntmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\\n\" % vars()\nreport(tmptxt)\n# ------------------------------------------------------------------------------------------------\nif rptfile:\nrptfile_h.close()\nprint('\\n Done .... ASCC FAULT Report saved to file %s' % rptfile)\nelse:\nprint('\\n Done .... ASCC FAULT Report created in Report window.')\n# =====================================================================================================\ndef check_psse_example_folder(rptfile):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nrptpath, rptfnam = os.path.split(rptfile)\nif not rptpath:\nrptpath = os.getcwd()\ncwd = rptpath.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(os.getcwd(), 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\nrptfile  = os.path.join(outdir, rptfnam)\nreturn rptfile\n# =====================================================================================================\ndef run_ascc_report(savfile=\"savnw.sav\", fltbuses=[151,154], rptfile='ascc_report_savnw.txt'):\nimport psspy\npsspy.psseinit()\n# Inputs, change as required\nflt3ph  = 1       #\nfltlg   = 1       #\nfltllg  = 1       #\nfltll   = 1       #\nlinout  = 0       #\nlinend  = 0       #\nvoltop  = 0       #\ngenxop  = 0       #\ntpunty  = 0       #\ndcload  = 1       #\nzcorec  = 1       #\nlnchrg  = 0       #\nshntop  = 0       #\nloadop  = 0       #\nmachpq  = 0       #\nvolts   = 1.0     #\nrptfile = check_psse_example_folder(rptfile)\nrelfile = \"\"\nfcdfile = \"\"\nscfile  = \"\"\nrprtyp  = -1      # no report\nrprlvl  = 0       # number of contribution levels\ncreate_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,\ntpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,\nsavfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun_ascc_report()\n# ====================================================================================================\nimport os\nimport string\nfrom math import sqrt\n# ----------------------------------------------------------------------------------------------------\ndef isfloat(str):\n\"\"\"Checks if the string is a floating point number.\"\"\"\ntry:\nfloat(str)\nreturn True\t\t\t#Returns true if the string is a floating point number\nexcept (ValueError, TypeError) as e:\nreturn False\t\t\t#Returns false otherwise\n# ----------------------------------------------------------------------------------------------------\ndef isint(str):\n\"\"\"Checks if the string is an integer.\"\"\"\ntry:\nint(str)\nreturn True\t\t\t#Returns true if the string is an integer\nexcept (ValueError, TypeError) as e:\nreturn False\t\t\t#Returns false otherwise\n# ----------------------------------------------------------------------------------------------------\ndef OpenFile():\n\"\"\"Opens the BPA file specified in prompt.\"\"\"\npsspy.prompt(\"Enter the BPA file path, followed by its name:\\n\")\nierr, fnamestr = psspy.userin()\t\t#User types in the path name\nif ierr != 0: return\nfpath, fext = os.path.splitext(fnamestr)\nif not fext: fnamestr = fpath + '.dat'\t#To add the extension if left blank\nif os.path.isfile(fnamestr) == False:\npsspy.alert(\"The specified path or file name is invalid\\n\")\nreturn\nbpa_file = open(fnamestr, 'r')\t\t#Opens the file in read mode\nreturn bpa_file\n# ----------------------------------------------------------------------------------------------------\ndef GetMVA(bpa_file, bpa_str):\n\"\"\"Gets the base MVA in the BPA file.\"\"\"\npos = string.find(bpa_str, \"MVA_BASE\")\nif pos != -1:\nbpa_file.seek(pos)\nbpa_file.readline()\t\t\t#Just to position on to the next line\nmva_base_str = bpa_file.readline()\nmva_base_str = mva_base_str.replace(' ', '')\t#To delete any spaces\nmva_base_str = mva_base_str.strip()\t#To remove trailing and leading whitespaces\nmva_base_str = mva_base_str[10:]\t#To remove the \"/MVA_BASE=\" part\nbasemva = float(mva_base_str[:-1])\nelse:\nbasemva = 100.0\t\t\t\t#The default base MVA in BPA is 100 MVA\nreturn basemva\n# ----------------------------------------------------------------------------------------------------\ndef GetTitles(bpa_file, bpa_str):\n\"\"\"Gets the titles from the BPA file.\"\"\"\npos = string.find(bpa_str, \"CASEID\")\t#To find title1\nif pos != -1:\nbpa_file.seek(pos)\ntitle_data = bpa_file.readline()\npos1 = string.find(title_data, '=')\npos2 = string.find(title_data, ',')\ncase_id = title_data[pos1 + 1 : pos2]\ncase_id = case_id.strip()\t\t#To remove trailing and leading whitespaces\nelse:\ncase_id = \"\"\t\t\t\t#Title1 is blank by default\npos = string.find(bpa_str, \"PROJECT\")\t#To find title2\nif pos != -1:\nbpa_file.seek(pos)\ntitle_data = bpa_file.readline()\npos1 = string.find(title_data, '=')"
  },
  {
    "id": "chunk_036",
    "text": "pos2 = string.find(title_data, ',')\nif pos2 == -1:\t\t\t\t#If there are no other parameters, the line finishes with ')'\npos2 = string.find(title_data, ')')\nproject_id = title_data[pos1 + 1 : pos2]\nproject_id = project_id.strip()\t\t#To remove trailing and leading whitespaces\nelse:\nproject_id = \"\"\t\t\t\t#Title2 is blank by default\nreturn case_id, project_id\n# ----------------------------------------------------------------------------------------------------\ndef GetPCard(bpa_str_ar):\n\"\"\"Gets the scale data from the BPA file.\"\"\"\nscale_str = []\nfor line in bpa_str_ar:\t\t\t#Loop over every line of the BPA file\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t\t#To continue if it is a blank line\nif line[0] == 'P' and line[2] == ' ':\t#If the line is a P card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\nscale_str.append(line)\nreturn scale_str\t\t\t\t#Returns an array of P cards\n# ----------------------------------------------------------------------------------------------------\ndef GetScaleData(scale_str, owner_name, zone_name, type_code):\n\"\"\"Gets the scale factors for each load and generator.\"\"\"\nscale_ar = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\t\t#Default factors are unit factors\nfor line in scale_str:\t\t\t\t\t#For each P card\nif line[1] == 'O' and line[3:6].strip() == owner_name:\nif zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\nor zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\nor zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\nor zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\nif isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\nif isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\nelif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\nif isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\nif isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\nelif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t#Generation Q factor is generation P factor\nelif line[1] == 'Z' and line[3:5].strip() == zone_name or line[1] == 'N' and line[3:5].strip() == zone_name and type_code == 'N':\nif owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\nor owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\nor owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\nif isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\nif isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\nelif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\nif isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\nif isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\nelif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t#Generation Q factor is generation P factor\nelif line[1] == 'A':\nif isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])\t\t#Load P factor\nif isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])\t\t#Load Q factor\nelif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])\t\t#Load Q factor is load P factor\nif isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])\t\t#Generation P factor\nif isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])\t\t#Generation Q factor\nelif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])\t\t#Generation Q factor is generation P factor\nelif line[1] == 'B' and type_code == 'X' and line[3:6].strip() == owner_name:\nif zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\nor zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\nor zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\nor zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\nif isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])\t\t#Constant current load P factor\nif isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])\t\t#Constant current load Q factor\nelif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])\t\t#Constant current load Q factor is load P factor\nif isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\nif isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\nelif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\nelif line[1] == 'B' and type_code == 'Y' and line[3:6].strip() == owner_name:\nif zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\\\nor zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\\\nor zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\\\nor zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == \"\":\nif isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\nif isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\nelif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\nelif line[1] == 'C' and type_code == 'X' and line[3:5].strip() == zone_name:\nif owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\nor owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\nor owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\nif isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])\t\t#Constant current load P factor\nif isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])\t\t#Constant current load Q factor\nelif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])\t\t#Constant current load Q factor is load P factor\nif isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor\nif isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\nelif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\nelif line[1] == 'C' and type_code == 'Y' and line[3:5].strip() == zone_name:\nif owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\\\nor owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\\\nor owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == \"\":\nif isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])\t\t#Constant admittance load P factor"
  },
  {
    "id": "chunk_037",
    "text": "if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])\t\t#Constant admittance load Q factor\nelif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])\t#Constant admittance load Q factor is load P factor\nreturn scale_ar\t\t#Returns the scale factors\n# ----------------------------------------------------------------------------------------------------\ndef CheckICard(bpa_str_ar, area_name):\n\"\"\"To check if there is an I card with the specified area name.\"\"\"\nfor line in bpa_str_ar:\t\t\t#Loop over every line of the BPA file\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t\t#To continue if it is a blank line\nif line[0] == 'I' and line[2] == ' ':\t#If it is an I card\nline = line + ' '*(34-len(line))\t#To pad each line with spaces up to 34 records\nif line[3:13].strip() == area_name or line[14:24].strip() == area_name: return True\t\t#Returns true if the area is found in an I card\nreturn False\t\t\t#Returns false if the area has not been found in I cards\n# ----------------------------------------------------------------------------------------------------\ndef GetXCard(bpa_str_ar, bus_name, Vmax, Vmin, remote_bus_name, RMPCT, remote_bus_nbr, bus_nbr):\n\"\"\"Gets the switched shunts attached to the specified bus.\"\"\"\nfor line in bpa_str_ar:\t\t#This loop is used to get the corresponding switched shunts\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#To continue if it is a blank line\n#--------------#\n#Default values#\n#--------------#\nintgar = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]\nrealar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]\nif isfloat(line[28:32]): remote_kv = float(line[28:32])\t#The remote bus base voltage\nelse: remote_kv = 0.0\nif line[0] == 'X' and bus_name == (line[6:14].strip() + str(float(line[14:18]))) and remote_bus_name == (line[20:28].strip() + str(remote_kv)):\nif line[2] == ' ':\t\t\t\t\t#The modification code for a new record\nline = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\nif isint(line[32]): intgar[0] = int(line[32])\t#Number of steps for block 1\nif isint(line[38]): intgar[1] = int(line[38])\t#Number of steps for block 2\nif isint(line[44]): intgar[2] = int(line[44])\t#Number of steps for block 3\nif isint(line[50]): intgar[3] = int(line[50])\t#Number of steps for block 4\nif isint(line[56]): intgar[4] = int(line[56])\t#Number of steps for block 5\nif isint(line[62]): intgar[5] = int(line[62])\t#Number of steps for block 6\nif isint(line[68]): intgar[6] = int(line[68])\t#Number of steps for block 7\nif isint(line[74]): intgar[7] = int(line[74])\t#Number of steps for block 8\nif isfloat(line[33:38]): realar[0] = float(line[33:38])\t#Admittance increment for block 1\nif isfloat(line[39:44]): realar[1] = float(line[39:44])\t#Admittance increment for block 2\nif isfloat(line[45:50]): realar[2] = float(line[45:50])\t#Admittance increment for block 3\nif isfloat(line[51:56]): realar[3] = float(line[51:56])\t#Admittance increment for block 4\nif isfloat(line[57:62]): realar[4] = float(line[57:62])\t#Admittance increment for block 5\nif isfloat(line[63:68]): realar[5] = float(line[63:68])\t#Admittance increment for block 6\nif isfloat(line[69:74]): realar[6] = float(line[69:74])\t#Admittance increment for block 7\nif isfloat(line[75:80]): realar[7] = float(line[75:80])\t#Admittance increment for block 8\nif isfloat(Vmax): realar[8] = float(Vmax)\t#Upper voltage limit\nif isfloat(Vmin): realar[9] = float(Vmin)\t#Lower voltage limit\nif isfloat(RMPCT):\nrealar[11] = float(RMPCT)\t#The RMPCT\nif realar[11] > 1.0: realar[11] = realar[11] / 100.0\t#To bring back the RMPCT from percent to unit\nintgar[9] = remote_bus_nbr\ncount_nbr = -1\nfor nbr in realar[0:8]:\t\t#This loop is used to get the reactors first in the list for PSS/E to work\ncount_nbr = count_nbr + 1\nif nbr < 0.0 and count_nbr != 0:\t#If the admittance is negative (reactor) and it is not already first in the list\nrealar.insert(0, nbr)\nrealar.pop(count_nbr + 1)\nintgar.insert(0, intgar[count_nbr])\nintgar.pop(count_nbr + 1)\nierr = psspy.switched_shunt_data(bus_nbr, intgar, realar, '')\t#The API used to load switched shunts in PSS/E\n# ----------------------------------------------------------------------------------------------------\ndef GetACard(bpa_str_ar, zone_str, bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr):\n\"Gets the area data from the BPA file.\"\"\"\nif zone_str != \"\":\t\t\t#Only look for area number if the zone is not blank\nfor line in bpa_str_ar:\t\t#This loop is used to get the corresponding area data\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t#To continue if the line is blank\nif line[0] == 'A' and line[1] != 'O':\nif line[2] == ' ':\t\t\t#The modification code for a new record\nline = line + ' '*(95-len(line))\t#To pad each line with spaces up to 95 records\nif zone_str == line[35:37].strip() or zone_str == line[38:40].strip() or zone_str == line[41:43].strip() or zone_str == line[44:46].strip()\\\nor zone_str == line[47:49].strip() or zone_str == line[50:52].strip() or zone_str == line[53:55].strip() or zone_str == line[56:58].strip()\\\nor zone_str == line[59:61].strip() or zone_str == line[62:64].strip() or zone_str == line[65:67].strip() or zone_str == line[68:70].strip()\\\nor zone_str == line[71:73].strip() or zone_str == line[74:76].strip() or zone_str == line[77:79].strip() or zone_str == line[80:82].strip()\\\nor zone_str == line[83:85].strip() or zone_str == line[86:88].strip() or zone_str == line[89:91].strip() or zone_str == line[92:94].strip():\nif line[13:21].strip() + str(float(line[21:25])) not in bus_str:\t#If the bus is not in the list, add it\nbus_nbr = bus_nbr + 1\nbus_str[line[13:21].strip() + str(float(line[21:25]))] = bus_nbr\t#A new dictionnary entry\nbus_flag = True\t\t\t\t\t\t\t#True if the bus number has been incremented\nelse:\nbus_nbr = bus_str[line[13:21].strip() + str(float(line[21:25]))]\t#Get the bus number\nbus_flag = False\t\t\t\t\t\t\t#False if the bus number hasn't been incremented\nif isfloat(line[26:34]):\t\t\t\t\t#If the value of interchange is specified\nif CheckICard(bpa_str_ar, line[3:13].strip()):\t\t#If there is an I card, do not include interchange given\nif (line[3:13].strip(), 0.0) not in area_str:\t#If the area is not in the list, add it\narea_nbr = area_nbr + 1\narea_str[(line[3:13].strip(), 0.0)] = area_nbr\narea_slack_nbr.append(bus_nbr)\t\t\t#An array with slack bus numbers for each area\nelse:\narea_nbr = area_str[(line[3:13].strip(), 0.0)]\t#Get the area number\nelse:\t\t\t\t\t\t\t#If there is no I card, include the interchange value given\nif (line[3:13].strip(),float(line[26:34])) not in area_str:\t#If the area is not in the list, add it\narea_nbr = area_nbr + 1\narea_str[(line[3:13].strip(), float(line[26:34]))] = area_nbr\narea_slack_nbr.append(bus_nbr)\t\t\t#Add the corresponding slack bus number\nelse:\narea_nbr = area_str[(line[3:13].strip(),float(line[26:34]))]\t#Get the area number\nelse:\t\t\t\t#If there is no value of interchange specified\nif (line[3:13].strip(), 0.0) not in area_str:\t\t#If the area is not in the list, add it\narea_nbr = area_nbr + 1\narea_str[(line[3:13].strip(), 0.0)] = area_nbr\narea_slack_nbr.append(bus_nbr)\t\t\t\t#Add the corresponding slack bus number\nelse:\narea_nbr = area_str[(line[3:13].strip(), 0.0)]\t\t#Get the area number\narea_flag = True\t\t#True if the zone name has a corresponding area card"
  },
  {
    "id": "chunk_038",
    "text": "return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr\narea_flag = False\t\t#The zone name has no corresponding area card\nbus_flag = False\t\t#The bus number hasn't changed\nreturn area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr\n# ----------------------------------------------------------------------------------------------------\ndef GetBCard(bpa_str_ar, base_mva, scale_str):\n\"\"\"Gets the AC bus data from the BPA file.\"\"\"\nbus_data_str = []\t\t\t#The array to contain all AC bus lines\nbus_str = {}\t\t\t#A dictionnary with bus names and the corresponding bus numbers\nbus_owner_nbr = [0]\t\t\t#An array with the owner number for each bus\nbus_zone_str = [\"0\"]\t\t#An array with the zone of each bus\nload_id_ar = [0]\t\t\t#An array used to determine the load CKT for each bus\nmachine_id_ar = [0]\t\t\t#An array used to determine the machine CKT for each bus\nowner_str = {'DEFAULT': 1}\t\t#The default owner\nzone_str = {'DEFAULT': 1}\t\t#The default zone\narea_str = {(\"DEFAULT\", 0.0): 1}\t#The default area is used for zones without A cards or for data without zones\narea_slack_nbr = [0]\t\t#An array with the slack bus of each area\nbus_nbr = 0\t\t\t\t#The bus number\nowner_nbr = 1\t\t\t#The owner number\nzone_nbr = 1\t\t\t#The zone number\narea_nbr = 1\t\t\t#The area number\nfor line in bpa_str_ar:\t\t#This loop is used to fill the bus data array with each line of bus data\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'B':\t\t#If it is a bus\nif line[1] != 'D' and line[1] != 'M':\t#But not a DC bus\nbus_data_str.append(line)\t\t#Add the line to the array\nfor line in bus_data_str:\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nbus_intgar = [1, 0, 1, 0]\nload_intgar = [1, 1, 1, 1]\nmachine_intgar = [0, 0, 0, 0, 0]\nbus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]\nload_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nmachine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\nplant_realar = [1.0, 1.0]\nremote_bus_nbr = 0\nremote_kv = 0.0\nif line[2] == ' ':\t\t\t#The modification code for a new record\nif line[1] == ' ' or line[1] == 'T' or line[1] == 'C' or line[1] == 'V' or line[1] == 'F' or line[1] == 'J' or line [1] == 'X':\nbus_intgar[0] = 1\t\t#The bus type code for a PQ bus\nelif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G' or line[1] == 'K' or line[1] == 'L':\nbus_intgar[0] = 2\t\t#The bus type code for a PV bus\nelif line[1] == 'S':\nbus_intgar[0] = 3\t\t#The bus type code for a swing bus\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\nbus_intgar[3] = owner_nbr\t\t\t#The owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nbus_intgar[3] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\nbus_intgar[3] = 1\t\t\t\t#The default owner number\nbus_namear = line[6:14].strip()\t\t#The bus name\nbus_realar[2] = float(line[14:18])\t\t#The bus base voltage in kV\nif bus_namear + str(bus_realar[2]) not in bus_str:\t#If the bus is not in the list, add it (the bus could be in the list if assigned as a remote for another bus)\nbus_nbr = bus_nbr + 1\nbus_str[bus_namear + str(bus_realar[2])] = bus_nbr\t#A new dictionnary entry\nelse:\nbus_nbr = bus_str[bus_namear + str(bus_realar[2])]\t#Get the bus number\nbus_owner_nbr.insert(bus_nbr + 1, bus_intgar[3])\t\t#Insert the corresponding owner of the bus\nload_id_ar.append(0)\t#To initialize the load CKT number\nmachine_id_ar.append(0)\t#To initialize the machine CKT number\nif line[18:20] != \"  \":\t#If the zone is not blank\nif line[18:20].strip() not in zone_str:\t#If the zone is not in the list, add it\nzone_nbr = zone_nbr + 1\nzone_str[line[18:20].strip()] = zone_nbr\nbus_intgar[2] = zone_nbr\t\t#The zone number\nelse:\nbus_intgar[2] =  zone_str[line[18:20].strip()]\t#Get the zone number\nbus_zone_str.insert(bus_nbr + 1, line[18:20].strip())\t#Insert the corresponding zone of the bus\nif isfloat(line[20:25]): load_realar[0] = float(line[20:25])\t#Load P in MW\nif isfloat(line[25:30]): load_realar[1] = float(line[25:30])\t#Load Q in Mvar\nif isfloat(line[30:34]): bus_realar[0] = float(line[30:34])\t\t#Fixed bus shunt active load\nif isfloat(line[34:38]): bus_realar[1] = float(line[34:38])\t\t#Fixed bus shunt reactive load\nif isfloat(line[38:42]): machine_realar[4] = float(line[38:42])\t#Maximum active power generation\nif isfloat(line[42:47]): machine_realar[0] = float(line[42:47])\t#Actual active power generation\nif line[1] != ' ' and line[1] != 'C' and line[1] != 'T' and line[1] != 'V':\t#If not a PQ bus\nif isfloat(line[47:52]): machine_realar[2] = float(line[47:52])\t#Machine reactive upper limit\nif isfloat(line[52:57]): machine_realar[3] = float(line[52:57])\t#Machine reactive lower limit\nif line[1] == ' ' or line[1] == 'C' or line[1] == 'T' or line[1] == 'V':\t#If it is a PQ bus\nif isfloat(line[47:52]):\nmachine_realar[2] = float(line[47:52])\t#Machine reactive upper limit\nmachine_realar[3] = machine_realar[2]\t#Machine reactive lower limit\nmachine_realar[1] = machine_realar[2]\t#Machine reactive power output\nelif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G':\t\t#If it is a PV bus\nif isfloat(line[57:61]):\nplant_realar[0] = float(line[57:61])\t\t\t#Scheduled voltage\nbus_realar[3] = float(line[57:61])\t\t\t\t#Bus voltage magnitude\nelif line[1] == 'S':\t\t\t\t\t\t#If it is a swing bus\nif isfloat(line[57:61]):\nplant_realar[0] = float(line[57:61])\t\t\t#Scheduled voltage\nbus_realar[3] = float(line[57:61])\t\t\t\t#Bus voltage magnitude\nif isfloat(line[61:65]): bus_realar[4] = float(line[61:65])\t#The voltage phase angle\nif line[65:73] != \"        \":\t\t\t\t\t#If there is a remote bus\nremote_kv = float(line[73:77])\t\t\t\t\t#The remote bus base voltage\nif line[65:73].strip() + str(remote_kv) not in bus_str:\t#If the remote bus name is not in the list, add it\nremote_bus_nbr = bus_nbr + 1\nbus_str[line[65:73].strip() + str(remote_kv)] = remote_bus_nbr\nelse:\nremote_bus_nbr = bus_str[line[65:73].strip() + str(remote_kv)]\t#Get the remote bus number\nif isfloat(line[77:80]):\nplant_realar[1] = float(line[77:80])\t#The RMPCT\nif plant_realar[1] > 1.0: plant_realar[1] = plant_realar[1] / 100.0\t#To bring back the RMPCT from percent to unit\narea_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)\nif bus_flag == True: bus_nbr = swing_bus_nbr\t#To change the bus number if it has been incremented\nif area_flag == True:\t\t#To assign the area number to the buses and loads"
  },
  {
    "id": "chunk_039",
    "text": "bus_intgar[1] = area_nbr\nload_intgar[1] = area_nbr\nelse:\t\t\t\t#The default area number\nbus_intgar[1] = 1\nload_intgar[1] = 1\nierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t#Loads the bus data in PSS/E\nif line[1] == 'X': GetXCard(bpa_str_ar, bus_namear + str(bus_realar[2]), line[57:61], line[61:65], line[65:73].strip() + str(remote_kv), line[77:80], remote_bus_nbr, bus_nbr)\nscale_ar = GetScaleData(scale_str, line[3:6].strip(), line[18:20].strip(), 'N')\t#To get the scale factors\nload_realar[0] = load_realar[0] * scale_ar[0]\t\t#To scale the load P\nload_realar[1] = load_realar[1] * scale_ar[1]\t\t#To scale the load Q\nmachine_realar[0] = machine_realar[0] * scale_ar[6]\t\t#To scale the machine P\nmachine_realar[1] = machine_realar[1] * scale_ar[7]\t\t#To scale the machine Q\nif load_realar[0] != 0.0 or load_realar[1] != 0.0: \t\t\t#If there is a load\nload_intgar[2] = bus_intgar[2]\t\t#The zone number\nload_intgar[3] = bus_intgar[3]\t\t#The owner number\nload_id_ar[bus_nbr] = 1\t\t\t#The load CKT number is now 1\nierr = psspy.load_data(bus_nbr, '1', load_intgar, load_realar)\t#Loads the load data in PSS/E\nif machine_realar[0] != 0.0:\t\t#If there is a generator\nmachine_intgar[0] = 1\t\t\t#The machine status\nmachine_intgar[1] = bus_intgar[3]\t#The owner number\nmachine_id_ar[bus_nbr] = 1\t\t#The machine CKT number is now 1\nierr = psspy.plant_data(bus_nbr, remote_bus_nbr, plant_realar)\t#First load the plant data\nierr = psspy.machine_data(bus_nbr, '1', machine_intgar, machine_realar)\t#After add the generator data\nif remote_bus_nbr == bus_nbr + 1: bus_nbr = bus_nbr + 1\t#To change the actual bus number\nreturn area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str\n# ----------------------------------------------------------------------------------------------------\ndef GetRCard(bpa_str_ar, from_bus, to_bus, bus_str):\n\"\"\"Gets the regulation parameters for the two-winding transformers.\"\"\"\n#--------------#\n#Default values#\n#--------------#\n#Only the returned values are useful\nintgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\nrealari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'R' and line[1] != 'Z':\t#If it is a R card but not RZ\nif line[2] == ' ' and from_bus == (line[6:14].strip() + str(float(line[14:18]))) and to_bus == (line[19:27].strip() + str(float(line[27:31]))):\nline = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\nif line[33:41] != \"        \": intgar[9] = bus_str[line[33:41].strip() + str(float(line[41:45]))]\t#Controlled bus number\nif isfloat(line[45:50]): realari[17] = float(line[45:50])\t#Winding one ratio/angle high limit\nif isfloat(line[50:55]): realari[18] = float(line[50:55])\t#Winding one ratio/angle low limit\nif isint(line[55:57]): intgar[6] = int(line[55:57])\t\t#Number of tap positions\nif line[1] == ' ':\t#If it is a R card\nintgar[11] = 1\t#Control mode = 1\nelif line[1] == 'V':\t#If it is a RV card\nintgar[11] = 1\t#Control mode = 1\nelif line[1] == 'Q':\t#If it is a RQ card\nintgar[11] = 2\t#Control mode = 2\nelif line[1] == 'N':\t#If it is a RN card\nintgar[11] = 2\t#Control mode = 2\nif isfloat(line[57:62]): realari[19] = float(line[57:62])\t#Voltage or flow upper limit\nelse: realari[19] = 0.0\t\t\t\t\t#Default\nif isfloat(line[62:67]): realari[20] = float(line[62:67])\t#Voltage or flow lower limit\nelse: realari[20] = 0.0\t\t\t\t\t#Default\nelif line[1] == 'P':\t#If it is a RP card\nintgar[11] = 3\t#Control mode = 3\nelif line[1] == 'M':\t#If it is a RM card\nintgar[11] = 3\t#Control mode = 3\nif isfloat(line[57:62]): realari[19] = float(line[57:62])\t#Voltage or flow upper limit\nelse: realari[19] = 0.0\t\t\t\t\t#Default\nif isfloat(line[62:67]): realari[20] = float(line[62:67])\t#Voltage or flow lower limit\nelse: realari[19] = 0.0\t\t\t\t\t#Default\nreturn intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]\nreturn intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]\n# ----------------------------------------------------------------------------------------------------\ndef GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva):\n\"\"\"To get the multi-section line data from BPA.\nThis function is recursive.\n\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\n#--------------#\n#Default values#\n#--------------#\nbus_intgar = [1, 1, 1, owner_nbr]\nbus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]\nline_intgar = [1, 0, 1, 0, 0, 0]\nline_realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\ntrans_intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\ntrans_realari = [0.0, 0.0, base_mva, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\nif line[0] == 'L' and line[1] == ' ' and line[2] == ' ' or line[0] == 'E' and line[1] == ' ' and line[2] == ' ':\nif iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:\nline = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\nsection_nbr = section_nbr + 1\t\t\t#To increment the section number\ndummy_nbr = dummy_nbr + 1\t\t\t#To increment the dummy bus number\nbus_nbr = bus_nbr + 1\t\t\t\t#To increment the bus number\nbus_namear = \"DUMMY #\" + str(dummy_nbr)\t\t#The name of the new dummy bus\nbus_str[bus_namear] = bus_nbr\t\t\t#Add the bus to the dictionnary\nbus_owner_nbr.insert(bus_nbr + 1, owner_nbr)\t#Insert the owner number of that bus\nif isfloat(line[14:18]): bus_realar[2] = float(line[14:18])\t#The bus base voltage\nmulti_intgar[section_nbr - 2] = bus_nbr\t\t#The bus number of the dummy bus\nfrom_bus = bus_nbr\t\t\t\t#To remember the value of the from bus before recalling this function\nierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t\t#Loads the bus data in PSS/E\nto_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)\t#Recursive function\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t\t#A new dictionnary entry\nline_intgar[2] = owner_nbr\t\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nline_intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\nline_intgar[2] = 1\t\t\t#The default owner\nline_intgar[1] = from_bus\t\t#Every section of the line is set as metered from (default)"
  },
  {
    "id": "chunk_040",
    "text": "if isfloat(line[33:37]) and isfloat(line[14:18]): line_realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0\t#The Rate A in MVA\nif line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\nelse: ckt = '1'\t\t\t#If none is mentionned, the default is 1\nif isfloat(line[38:44]): line_realar[0] = float(line[38:44])\t\t\t#Nominal branch resistance\nif isfloat(line[44:50]) and float(line[44:50]) != 0.0: line_realar[1] = float(line[44:50])\t#Nominal branch reactance\nif line[0] == 'L':\t\t#If it is an L card\nif isfloat(line[50:56]):\nline_realar[6] = float(line[50:56])/2.0\t\t\t\t\t#Real line shunt at bus IARG end\nline_realar[8] = line_realar[6]\t\t\t\t\t\t#Real line shunt at bus JARG end\nif isfloat(line[56:62]): line_realar[2] = float(line[56:62])*2.0\t\t#Total line charging\nif isfloat(line[62:66]): line_realar[10] = float(line[62:66])\t\t#Line's length in miles\nelse:\t\t\t\t#If it is an E card\nif isfloat(line[50:56]): line_realar[6] = float(line[50:56])\t\t#Real line shunt at bus IARG end\nif isfloat(line[56:62]): line_realar[7] = float(line[56:62])\t\t#Reactive line shunt at bus IARG end\nif isfloat(line[62:68]): line_realar[8] = float(line[62:68])\t\t#Real line shunt at bus JARG end\nif isfloat(line[68:74]): line_realar[9] = float(line[68:74])\t\t#Reactive line shunt at bus JARG end\n#It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual\n#if line[77:80] != \"   \": line_intgar[0] = 0\t\t#If there is an out of service date, the status is offline\nierr = psspy.branch_data(from_bus, to_bus, ckt, line_intgar, line_realar)\t#The API to load branch data in PSS/E\nreturn from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\nif line[0] == 'T' and line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:\nif iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:\nline = line + ' '*(80-len(line))\t\t#To pad each line with spaces up to 80 records\nsection_nbr = section_nbr + 1\t\t\t#To increment the section number\ndummy_nbr = dummy_nbr + 1\t\t\t#To increment the dummy bus number\nbus_nbr = bus_nbr + 1\t\t\t\t#To increment the bus number\nbus_namear = \"DUMMY #\" + str(dummy_nbr)\t\t#The name of the dummy bus\nbus_str[bus_namear] = bus_nbr\t\t\t#A new dictionnary entry\nbus_owner_nbr.insert(bus_nbr + 1, owner_nbr)\t#Insert the owner of this bus\nif isfloat(line[14:18]): bus_realar[2] = float(line[14:18])\t#The bus base voltage\nmulti_intgar[section_nbr - 2] = bus_nbr\t\t#The bus number of the dummy bus\nfrom_bus = bus_nbr\nierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)\t#Loads the bus data in PSS/E\nto_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)\t#Recursive function\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\ntrans_intgar[2] = owner_nbr\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\ntrans_intgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\ntrans_intgar[2] = 1\t\t\t#The default owner\ntrans_intgar[1] = from_bus\t\t#Every section of the line is set as metered from (default)\ntrans_intgar[8] = from_bus\t\t#The winding one side\nif isfloat(line[14:18]): trans_realari[4] = float(line[14:18])\t\t#Winding one nominal voltage\nif isfloat(line[27:31]): trans_realari[7] = float(line[27:31])\t\t#Winding two nominal voltage\nif isfloat(line[33:37]): trans_realari[8] = float(line[33:37])\t\t#The Rate A in MVA\nif line[31] != ' ': ckt = line[31]\t#The circuit identifier\nelse: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\nif isfloat(line[38:44]): trans_realari[0] = float(line[38:44])\t#Nominal transformer resistance\nif isfloat(line[44:50]) and float(line[44:50]) != 0.0: trans_realari[1] = float(line[44:50])\t#Nominal transformer reactance\nif isfloat(line[50:56]): trans_realari[15] = float(line[50:56])\t\t#The magnetizing conductance\nif isfloat(line[56:62]): trans_realari[16] = float(line[56:62])\t\t#The magnetization susceptance\nif line[1] == ' ':\nif isfloat(line[62:67]): trans_realari[3] = float(line[62:67])\t\t#The winding one ratio/voltage\nif isfloat(line[67:72]): trans_realari[6] = float(line[67:72])\t\t#The winding one ratio/voltage\nelse:\t\t#For the phase shifting transformer\nif isfloat(line[62:67]): trans_realari[5] = float(line[62:67])\t\t#The winding one phase shift angle\ntrans_realari[3] = trans_realari[4]\ntrans_realari[6] = trans_realari[7]\n#It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual\n#if line[77:80] != \"   \": trans_intgar[0] = 0\t\t#If there is an out of service date, the status is offline\ntrans_intgar[11], trans_intgar[9], trans_realari[17], trans_realari[18], trans_intgar[6], trans_realari[19], trans_realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)\nierr, realaro  = psspy.two_winding_data(from_bus, to_bus, ckt, trans_intgar, trans_realari, \"\")\t#The API to load transformer data in PSS/E\nreturn from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\nreturn jarg, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar\n# ----------------------------------------------------------------------------------------------------\ndef GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, base_mva):\n\"\"\"Gets the symmetrical and asymmetrical lines from BPA.\"\"\"\nline_str = []\t#An array to contain all AC line data\ndummy_nbr = 0\t#The dummy bus number for multi-section lines\nfor line in bpa_str_ar:\t\t#This loop is used to fill the branch data array with each line of branch data\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'L' and line[1] == ' ' or line[0] == 'E' and line[1] == ' ': line_str.append(line)\nfor line in line_str:\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nintgar = [1, 0, 1, 0, 0, 0]\nrealar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\nif line[2] == ' ':\t\t\t#The modification code for a new record\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\nintgar[2] = owner_nbr\t\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nintgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\nintgar[2] = 1\t\t\t\t\t#The default owner\niarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#From bus\njarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]\t\t#To bus\nif line[18] == '1': intgar[1] = iarg\t#The metered end is IARG\nelif line[18] == '2': intgar[1] = jarg\t#The metered end is JARG\nelif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\nif bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg\t\t#If both ends have the same owner, IARG is the metered end"
  },
  {
    "id": "chunk_041",
    "text": "elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg\t\t\t#Else the end that has a different owner from the line is the metered end\nelif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg\nif isfloat(line[33:37]) and intgar[1] == iarg and isfloat(line[14:18]): realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0\t#The Rate A in MVA\nelif isfloat(line[33:37]) and intgar[1] == jarg and isfloat(line[27:31]): realar[3] = sqrt(3)*float(line[33:37])*float(line[27:31])/1000.0\t#The Rate A in MVA\nif line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\nelse: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\nif isfloat(line[38:44]): realar[0] = float(line[38:44])\t\t\t#Nominal branch resistance\nif isfloat(line[44:50]) and float(line[44:50]) != 0.0: realar[1] = float(line[44:50])\t#Nominal branch reactance\nif line[0] == 'L':\t\t#If it is an L card\nif isfloat(line[50:56]):\nrealar[6] = float(line[50:56])/2.0\t\t\t\t\t#Real line shunt at bus IARG end\nrealar[8] = realar[6]\t\t\t\t\t\t#Real line shunt at bus JARG end\nif isfloat(line[56:62]): realar[2] = float(line[56:62])*2.0\t\t#Total line charging\nif isfloat(line[62:66]): realar[10] = float(line[62:66])\t\t#Line's length in miles\nelse:\t\t\t#If it is an E card\nif isfloat(line[50:56]): realar[6] = float(line[50:56])\t\t#Real line shunt at bus IARG end\nif isfloat(line[56:62]): realar[7] = float(line[56:62])\t\t#Reactive line shunt at bus IARG end\nif isfloat(line[62:68]): realar[8] = float(line[62:68])\t\t#Real line shunt at bus JARG end\nif isfloat(line[68:74]): realar[9] = float(line[68:74])\t\t#Reactive line shunt at bus JARG end\n#It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual\n#if line[77:80] != \"   \": intgar[0] = 0\t\t#If there is an out of service date, the status is offline\nif line[32] == ' ': ierr = psspy.branch_data(iarg, jarg, ckt, intgar, realar)\t#The API to load branch data in PSS/E\nelif line[32] == '1':\t#If the branch is the section number 1\nmulti_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]\nsection_nbr = 2\t\t#To search for a section number 2\nto_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)\nintgar[1] = iarg\t#The metered end is IARG\nierr = psspy.branch_data(iarg, to_bus, ckt, intgar, realar)\t#The API to load branch data in PSS/E\nif multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, \"&\" + ckt, multi_intgar)\t#The API to load the multi-section line data in PSS/E\nreturn owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr\n# ----------------------------------------------------------------------------------------------------\ndef GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, base_mva):\n\"\"\"Gets the two-winding transformer data from BPA.\"\"\"\ntransformer_str = []\t#An array to contain all lines with two-winding transformers connecting AC buses\nfor line in bpa_str_ar:\t\t#This loop is used to fill the transformer data array with each line of transformer data\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'T' and line[1] == ' ' or line[0] == 'T' and line[1] == 'P': transformer_str.append(line)\nfor line in transformer_str:\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nintgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]\nrealari = [0.0, 0.0, basemva, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]\nif line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\nintgar[2] = owner_nbr\t\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nintgar[2] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\nintgar[2] = 1\t\t\t\t\t#The default owner\niarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#From bus\njarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]\t\t#To bus\nintgar[8] = iarg\t\t\t\t\t\t#The winding one side\nif isfloat(line[14:18]): realari[4] = float(line[14:18])\t#Winding one nominal voltage\nif line[18] == '1': intgar[1] = iarg\t#The metered end is IARG\nelif line[18] == '2': intgar[1] = jarg\t#The metered end is JARG\nelif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\nif bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg\t\t#If both ends have the same owner, IARG is the metered end\nelif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg\t\t\t#Else the end that has a different owner from the line is the metered end\nelif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg\nif isfloat(line[27:31]): realari[7] = float(line[27:31])\t#Winding two nominal voltage\nif isfloat(line[33:37]): realari[8] = float(line[33:37])\t#The Rate A in MVA\nif line[31] != ' ': ckt = line[31]\t\t#The circuit identifier\nelse: ckt = '1'\t\t\t\t#If none is mentionned, the default is 1\nif isfloat(line[38:44]): realari[0] = float(line[38:44])\t\t\t#Nominal transformer resistance\nif isfloat(line[44:50]) and float(line[44:50]) != 0.0: realari[1] = float(line[44:50])\t#Nominal transformer reactance\nif isfloat(line[50:56]): realari[15] = float(line[50:56])\t\t#The magnetizing conductance\nif isfloat(line[56:62]): realari[16] = float(line[56:62])\t\t#The magnetizing susceptance\nif line[1] == ' ':\nif isfloat(line[62:67]): realari[3] = float(line[62:67])\t#The winding one ratio/voltage\nif isfloat(line[67:72]): realari[6] = float(line[67:72])\t#The winding two ratio/voltage\nelse:\nif isfloat(line[62:67]): realari[5] = float(line[62:67])\t#The winding one phase shift angle\nrealari[3] = realari[4]\t\t\t\t\t\t#The winding one ratio/voltage\nrealari[6] = realari[7]\t\t\t\t\t\t#The winding two ratio/voltage\n#It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual\n#if line[77:80] != \"   \": intgar[0] = 0\t\t#If there is an out of service date, the status is offline\nintgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)\nif line[32] == ' ': ierr, realaro  = psspy.two_winding_data(iarg, jarg, ckt, intgar, realari, \"\")\t#The API to load transformer data in PSS/E\nelif line[32] == '1':\t#If the transformer is section number 1\nmulti_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]\nsection_nbr = 2\t\t#To search for section number 2\nto_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)\nintgar[1] = iarg\t#The metered end is IARG\nierr, realaro  = psspy.two_winding_data(iarg, to_bus, ckt, intgar, realari, \"\")\t\t#The API used to load two-winding data in PSS/E"
  },
  {
    "id": "chunk_042",
    "text": "if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, \"&\" + ckt, multi_intgar)\t#The API used to load multi-section line in PSS/E\nreturn owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr\n# ----------------------------------------------------------------------------------------------------\ndef GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, base_mva, scale_str, bus_zone_str):\n\"\"\"Gets the bus supplement data from BPA.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\n#--------------#\n#Default values#\n#--------------#\nload_intgar = [1, 1, 1, 1]\nmachine_intgar = [0, 0, 0, 0, 0]\nload_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nmachine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]\nplant_realar = [1.0, 1.0]\nif line[0] == '+' and line[2] == ' ':\t#If it is a + card\nline = line + ' '*(77-len(line))\t#To pad each line with spaces up to 77 records\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t#A new dictionnary entry\nload_intgar[3] = owner_nbr\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nload_intgar[3] =  owner_str[line[3:6].strip()]\t#Get the owner number\nelif line[3:6] == \"   \":\nload_intgar[3] = 1\t\t\t\t#The default owner\niarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]\t#The from bus number\nif line[18:20] == \"*I\" or line[18:20] == \"01\":\t\t\t#If it is a constant current load\nif isfloat(line[20:25]): load_realar[2] = float(line[20:25])\t#Constant current load P\nif isfloat(line[25:30]): load_realar[3] = float(line[25:30])\t#Constant current load Q\nelif line[18:20] == \"*P\" or line[18:20] == \"02\":\t\t\t#If it is a constant power load\nif isfloat(line[20:25]): load_realar[0] = float(line[20:25])\t#Constant power load P\nif isfloat(line[25:30]): load_realar[1] = float(line[25:30])\t#Constant power load Q\nif isfloat(line[30:34]): load_realar[4] = float(line[30:34])\t#Constant impedance load P\nif isfloat(line[34:38]): load_realar[5] = float(line[34:38])\t#Constant impedance load Q\nif isfloat(line[42:47]): machine_realar[0] = float(line[42:47])\t#Generation P\nif isfloat(line[47:52]): machine_realar[1] = float(line[47:52])\t#Generation Q\nif line[1] != 'A' and line[1] != 'F' and line[1] != 'I' and line[1] != 'P': type_code = 'N'\t#Non-industrial load or generation\nelif line[1] == 'F' or line[1] == 'I' or line[1] == 'P': type_code = 'I'\t\t\t#Industrial load\nelif line[1] == 'A' and line[18:20] == \"*I\" or line[18:20] == \"01\": type_code = 'X'\t\t#If it is a +A card with constant current load\nelif line[1] == 'A' and line[18:20] == \"*P\" or line[18:20] == \"02\": type_code = 'Y'\t\t#If is is a +A card with constant power load\nscale_ar = GetScaleData(scale_str, line[3:6].strip(), bus_zone_str[iarg], type_code)\t#To get the scale factors\nload_realar[0] = load_realar[0] * scale_ar[0]\t\t#To scale the constant power load P\nload_realar[1] = load_realar[1] * scale_ar[1]\t\t#To scale the constant power load Q\nload_realar[2] = load_realar[2] * scale_ar[2]\t\t#To scale the constant current load P\nload_realar[3] = load_realar[3] * scale_ar[3]\t\t#To scale the constant current load Q\nload_realar[4] = load_realar[4] * scale_ar[4]\t\t#To scale the constant impedance load P\nload_realar[5] = load_realar[5] * scale_ar[5]\t\t#To scale the constant impedance load Q\nmachine_realar[0] = machine_realar[0] * scale_ar[6]\t\t#To scale the generation P\nmachine_realar[1] = machine_realar[1] * scale_ar[7]\t\t#To scale the generation Q\nif load_realar[0] != 0.0 or load_realar[1] != 0.0 or load_realar[2] != 0.0 or load_realar[3] != 0.0 or load_realar[4] != 0.0 or load_realar[5] != 0.0:\nload_id_ar[iarg] = load_id_ar[iarg] + 1\t\t#To increment the load CKT\nierr = psspy.load_data(iarg, str(load_id_ar[iarg]), load_intgar, load_realar)\t#Loads the load data in PSS/E\nif machine_realar[0] != 0.0 or machine_realar[1] != 0.0:\t#If there is a generator\nmachine_id_ar[iarg] = machine_id_ar[iarg] + 1\t\t#To increment the machine CKT\nmachine_intgar[0] = 1\t\t\t\t\t#The machine status\nmachine_intgar[1] = owner_nbr\t\t\t\t#The owner number\nif machine_id_ar[iarg] == 1:\t\t\t\t#If it is the first generator on this bus\nierr = psspy.plant_data(iarg, 0, plant_realar)\t#First load the plant data\nierr = psspy.machine_data(iarg, str(machine_id_ar[iarg]), machine_intgar, machine_realar)\t#After add the generator data\nreturn owner_str, owner_nbr\n# ----------------------------------------------------------------------------------------------------\ndef GetICard(bpa_str_ar, area_str, area_slack_nbr):\n\"\"\"Gets the inter-area transfer data from BPA.\"\"\"\ninter_nbr = 48\t\t\t#In order to start to the character '1' in the transfer ID\nfor line in bpa_str_ar:\t\t#This loop is used to get the inter-area transfer data\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if it is a blank line\n#--------------#\n#Default values#\n#--------------#\nia = 1\t\t\t\t#Default area number\nja = 1\t\t\t\t#Default area number\nrealar = [0.0]\t\t\t#Default transfer\nif line[0] == 'I' and line[2] == ' ':\t\t#If it is an I card\nline = line + ' '*(34-len(line))\t\t#To pad each line with spaces up to 34 records\nfor (x,y), z in area_str.items():\nif x == line[3:13].strip(): ia = z\t#The 'from' area number\nif x == line[14:24].strip(): ja = z\t#The 'to' area number\nif isfloat(line[26:34]): realar[0] = float(line[26:34])\t#The amount of MW in the transfer\ninter_nbr = inter_nbr + 1\t#To increment the transfer ID\nif inter_nbr == 123:\t#After the 'Z' character, PSS/E do not accept the other ASCII characters\npsspy.alert(\" WARNING: MAXIMUM NUMBER OF INTER-AREA TRANSFERS REACHED\\n\")\nreturn\nierr = psspy.transfer_data(1, ia, ja, chr(inter_nbr), realar[0])\t#The transfer data API\n# ----------------------------------------------------------------------------------------------------\ndef GetRZCard(bpa_str_ar):\n\"\"\"Gets the line series compensation from BPA.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'R' and line[1] == 'Z':\t#If it is an RZ card\nline = line + ' '*(60-len(line))\t#To pad each line with spaces up to 60 records\n#Found no equivalent way to model this series compensation device in PSS/E\npsspy.alert(\" WARNING: THE RZ CARD GOING FROM BUS [\" + line[6:18] + \"] TO BUS [\" + line[19:31] + \"] CANNOT BE IMPORTED\\n\")\n# ----------------------------------------------------------------------------------------------------\ndef GetZCard(bpa_str_ar, zone_str):\n\"\"\"Gets the renamed zone names from BPA.\"\"\"\nzone_str_temp = {}\t\t#A dictionnary containing the modified zone names\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\nif line[0] == 'Z':\nline = line + ' '*(77-len(line))\t#To pad each line with spaces up to 77 records\nfor x, y in zone_str.items():\nif x == line[3:5].strip(): zone_str_temp[line[5:7].strip()] = y\nelif x == line[8:10].strip(): zone_str_temp[line[10:12].strip()] = y"
  },
  {
    "id": "chunk_043",
    "text": "elif x == line[13:15].strip(): zone_str_temp[line[15:17].strip()] = y\nelif x == line[18:20].strip(): zone_str_temp[line[20:22].strip()] = y\nelif x == line[23:25].strip(): zone_str_temp[line[25:27].strip()] = y\nelif x == line[28:30].strip(): zone_str_temp[line[30:32].strip()] = y\nelif x == line[33:35].strip(): zone_str_temp[line[35:37].strip()] = y\nelif x == line[38:40].strip(): zone_str_temp[line[40:42].strip()] = y\nelif x == line[43:45].strip(): zone_str_temp[line[45:47].strip()] = y\nelif x == line[48:50].strip(): zone_str_temp[line[50:52].strip()] = y\nelif x == line[53:55].strip(): zone_str_temp[line[55:57].strip()] = y\nelif x == line[58:60].strip(): zone_str_temp[line[60:62].strip()] = y\nelif x == line[63:65].strip(): zone_str_temp[line[65:67].strip()] = y\nelif x == line[68:70].strip(): zone_str_temp[line[70:72].strip()] = y\nelif x == line[73:75].strip(): zone_str_temp[line[75:77].strip()] = y\nelse: zone_str_temp[x] = y\nzone_str.clear()\t\t\t#To clear the dictionnary\nzone_str.update(zone_str_temp)\t#To copy the contents of the temporary dictionnary\nreturn zone_str\n# ----------------------------------------------------------------------------------------------------\ndef GetDZCard(bpa_str_ar, zone_str):\n\"\"\"Gets the deleted zone names from BPA and remove connected buses and equipment.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'D' and line[1] == 'Z':\t#If it is a DZ card\nline = line + ' '*(5-len(line))\t#To pad each line with spaces up to 5 records\nif line[3:5].strip() in zone_str:\nierr = psspy.bsys(0, 0, [0.0,0.0], 0, [], 0, [], 0, [], 1, [zone_str[line[3:5].strip()]])\t#A bus subsystem of this zone\nierr = psspy.extr(0, 0, [1, 0])\t\t\t\t\t\t#To delete this subsystem\nierr = psspy.bsys(0, 1, [0.0, 9999.], 0, [], 0, [], 0, [], 0, [])\t#To bring back the original unfiltered view\ndel zone_str[line[3:5].strip()]\t\t\t\t\t\t#To delete the zone\nelse: psspy.alert(\" WARNING: THE ZONE [\" +  line[3:5].strip() + \"] SPECIFIED IN THE DZ CARD CANNOT BE FOUND\\n\")\t#If the zone is not found\nreturn zone_str\n# ----------------------------------------------------------------------------------------------------\ndef GetDCOwners(bpa_str_ar, from_bus, to_bus):\n\"\"\"Gets the owners of the DC buses for the two-terminal DC lines in BPA.\"\"\"\nowner_1 = \"\"\t#The owner of bus 'converter 1'\nowner_2 = \"\"\t#The owner of bus 'converter 2'\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'B' and line[1] == 'D' and line[2] == ' ':\t#If it is a BD card\nif from_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_1 = line[3:6].strip()\nelif to_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_2 = line[3:6].strip()\nreturn owner_1, owner_2\n# ----------------------------------------------------------------------------------------------------\ndef GetTwoTermConv(bpa_str_ar, from_bus, to_bus, dc_line_nbr, flow_flag, bus_str):\n\"\"\"Gets the converter data for two-terminal lines in BPA.\"\"\"\n#--------------#\n#Default values#\n#--------------#\nintgar_1 = [0, 0, 0, 0, 0]\nrealari_1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nintgar_2 = [0, 0, 0, 0, 0]\nrealari_2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t\t#Continue if the line is blank\nif line[0] == 'B' and line[1] == 'D' and line[2] == ' ':\t#If it is a BD card\nline = line + ' '*(62-len(line))\t#To pad each line with spaces up to 62 records\nif from_bus == line[6:14].strip() + str(float(line[14:18])):\t#If the bus is converter 1\nif flow_flag: cnvflg_1 = 1\t#If the flow is positive, the converter 1 is a rectifier\nelse: cnvflg_1 = 2\t\t#If the flow is negative, the converter 1 is an inverter\nif line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_1[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter 1 bus number\nif isint(line[23:25]): intgar_1[1] = int(line[23:25])\t\t#Number of bridges in series\nif isfloat(line[30:35]): realari_1[0] = float(line[30:35])\t#Minimum firing angle\nif isfloat(line[35:40]): realari_1[1] = float(line[35:40])\t#Maximum firing angle\nelif to_bus == line[6:14].strip() + str(float(line[14:18])):\t#If the bus is converter 2\nif flow_flag: cnvflg_2 = 2\t#If the flow is positive, the converter 2 is an inverter\nelse: cnvflg_2 = 1\t\t#If the flow is negative, the converter 2 is a rectifier\nif line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_2[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter 2 bus number\nif isint(line[23:25]): intgar_2[1] = int(line[23:25])\t\t#Number of bridges in series\nif isfloat(line[30:35]): realari_2[0] = float(line[30:35])\t#Minimum firing angle\nif isfloat(line[35:40]): realari_2[1] = float(line[35:40])\t#Maximum firing angle\nif line[0] == 'T' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a T card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\nif from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[38:44]): realari_1[2] = float(line[38:44])\t#Commutating resistance\nif isfloat(line[44:50]): realari_1[3] = float(line[44:50])\t#Commutating reactance\nrealari_1[4] = float(line[14:18])\t\t\t\t#Primary base voltage\nif isfloat(line[67:72]): realari_1[5] = float(line[67:72])\t#Transformer ratio\nif isfloat(line[62:67]): realari_1[6] = float(line[62:67])\t#Tap setting\nelif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[38:44]): realari_2[2] = float(line[38:44])\t#Commutating resistance\nif isfloat(line[44:50]): realari_2[3] = float(line[44:50])\t#Commutating reactance\nrealari_2[4] = float(line[14:18])\t\t\t\t#Primary base voltage\nif isfloat(line[67:72]): realari_2[5] = float(line[67:72])\t#Transformer ratio\nif isfloat(line[62:67]): realari_2[6] = float(line[62:67])\t#Tap setting\nif line[0] == 'R' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a R card\nline = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\nif from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[45:50]): realari_1[7] = float(line[45:50])\t#Maximum tap setting\nif isfloat(line[50:55]): realari_1[8] = float(line[50:55])\t#Minimum tap setting\nif isint(line[55:57]) and int(line[55:57]) != 0: realari_1[9] = (realari_1[7] - realari_1[8])/int(line[55:57])\t#Tap step\nelif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[45:50]): realari_2[7] = float(line[45:50])\t#Maximum tap setting\nif isfloat(line[50:55]): realari_2[8] = float(line[50:55])\t#Minimum tap setting\nif isint(line[55:57]) and int(line[55:57]) != 0: realari_2[9] = (realari_2[7] - realari_2[8])/int(line[55:57])\t#Tap step\nierr,realaro = psspy.two_term_dc_convr_data(cnvflg_1, dc_line_nbr, intgar_1, realari_1, \"\")\t#To load the converter 1 in PSS/E\nierr,realaro = psspy.two_term_dc_convr_data(cnvflg_2, dc_line_nbr, intgar_2, realari_2, \"\")\t#To load the converter 2 in PSS/E\n# ----------------------------------------------------------------------------------------------------\ndef GetTwoTermLine(bpa_str_ar, bus_str):\n\"\"\"Gets the two-terminal DC line data from BPA.\"\"\"\ndc_line_nbr = 0\t#The two-terminal DC line number\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'L' and line[1] == 'D' and line[2] == ' ':\t#If it is a LD card\nline = line + ' '*(78-len(line))\t#To pad each line with spaces up to 78 records"
  },
  {
    "id": "chunk_044",
    "text": "#--------------#\n#Default values#\n#--------------#\nintgar = [1, 0]\nrealari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\ndc_line_nbr = dc_line_nbr + 1\t#To increment the DC line number\nif isfloat(line[56:61]): realari[0] = float(line[56:61])\t#Scheduled power demand\nif isfloat(line[61:66]): realari[1] = float(line[61:66])\t#Scheduled DC voltage\nif isfloat(line[37:43]): realari[4] = float(line[37:43])\t#DC line resistance\nif line[55] == 'I': realari[5] = 0\t\t\t#Compounding resistance = 0 if Vdc is controlled at the inverter\nelif line[55] == 'R': realari[5] = realari[4]\t#Compounding resistance = Rdc if Vdc is controlled at the rectifier\nif line[18] == '1':\t\t\t\t#If the metered side is converter 1\nif realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\nelse: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\nelif line[18] == '2':\t\t\t#If the metered side is converter 2\nif realari[0] >= 0.0: metrar = 'I'\t#The metered side is the inverter if the flow is positive\nelse: metrar = 'R'\t\t\t#The metered side is the rectifier if the flow is negative\nelif line[18] == ' ':\t\t\t#If the metered side is left blank, BPA chooses\nowner_1, owner_2 = GetDCOwners(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])))\nif owner_1 == owner_2:\t\t#If both DC buses have the same owner\nif realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\nelse: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\nelif owner_1 == line[3:6].strip():  #If the owner of converter 1 is the same as the line\nif realari[0] >= 0.0: metrar = 'I'\t#The metered side is the inverter if the flow is positive\nelse: metrar = 'R'\t\t\t#The metered side is the rectifier if the flow is negative\nelif owner_2 == line[3:6].strip():  #If the owner of converter 2 is the same as the line\nif realari[0] >= 0.0: metrar = 'R'\t#The metered side is the rectifier if the flow is positive\nelse: metrar = 'I'\t\t\t#The metered side is the inverter if the flow is negative\nierr, realaro = psspy.two_terminal_dc_line_data(dc_line_nbr, intgar, realari, metrar)\t#The API to load two-terminal DC line in PSS/E\nGetTwoTermConv(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), dc_line_nbr, realari[0] >= 0.0, bus_str)\t#To get the 2 converters data\n# ----------------------------------------------------------------------------------------------------\ndef GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, bus_name):\n\"\"\"Gets the T and R card corresponding to the converter bus specified.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'T' and line[1] == ' ' and line[2] == ' ':\t#If it is a T card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\nif bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[67:72]): conv_realari[3] = float(line[67:72])\t#Transformer ratio\nif isfloat(line[38:44]): conv_realari[4] = float(line[38:44])\t#Commutating resistance\nif isfloat(line[44:50]): conv_realari[5] = float(line[44:50])\t#Commutating reactance\nconv_realari[6] = float(line[14:18])\t\t\t\t#Winding one base voltage\nif isfloat(line[62:67]): conv_realari[7] = float(line[62:67])\t#Tap setting\nif line[0] == 'R' and line[1] == ' ' and line[2] == ' ':\t\t#If it is a R card\nline = line + ' '*(67-len(line))\t#To pad each line with spaces up to 67 records\nif bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):\nif isfloat(line[45:50]): conv_realari[8] = float(line[45:50])\t#Maximum tap setting\nif isfloat(line[50:55]): conv_realari[9] = float(line[50:55])\t#Minimum tap setting\nif isint(line[55:57]) and int(line[55:57]) != 0: conv_realari[10] = (conv_realari[8] - conv_realari[9])/int(line[55:57])\t#Tap step\nreturn conv_intgar, conv_realari\n# ----------------------------------------------------------------------------------------------------\ndef GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr):\n\"\"\"Gets the converter data for multi-terminal lines and creates DC buses.\"\"\"\ndc_bus_nbr = 0\t\t#The DC bus number for multi-terminal lines\ndc_bus_str = {}\t\t#The dictionnary to contain DC bus names and numbers\ndc_bus_owner = [\"DEFAULT\"]\t#An array of the owners of each DC bus\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'B' and line[1] == 'M' and line[2] == ' ':\t#If it is a BM card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nconv_intgar = [0, 0, 0, 0]\nconv_realari = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.5, 0.51, 0.00625, 0.0, 1.0]\nbus_intgar = [0, 0, 0, 0, 0]\nbus_realari = 0.0\nif line[6:14].strip() + str(float(line[14:18])) not in dc_bus_str:\t\t#If the bus is not in the list, add it\ndc_bus_nbr = dc_bus_nbr + 1\ndc_bus_str[line[6:14].strip() + str(float(line[14:18]))] = dc_bus_nbr\t\t#A new dictionnary entry\nelse:\ndc_bus_nbr = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]\t\t#Get the bus number\nif line[3:6] != \"   \" and line[3:6].strip() not in owner_str:\t#If the owner is not in the list, add it to the list with a new number\nowner_nbr = owner_nbr + 1\nowner_str[line[3:6].strip()] = owner_nbr\t\t#A new dictionnary entry\nbus_intgar[3] = owner_nbr\t\t\t\t#The new owner number\nelif line[3:6] != \"   \" and line[3:6].strip() in owner_str:\nbus_intgar[3] =  owner_str[line[3:6].strip()]\t\t#Get the owner number\nelif line[3:6] == \"   \":\nbus_intgar[3] = 1\t\t\t\t\t#The default owner\ndc_bus_owner.insert(dc_bus_nbr + 1, line[3:6].strip())\t#Insert the owner number of this bus\nif line[18:20] != \"  \":\nif line[18:20].strip() not in zone_str:\t\t#If the zone is not in the list, add it\nzone_nbr = zone_nbr + 1\nzone_str[line[18:20].strip()] = zone_nbr\t\t#A new dictionnary entry\nbus_intgar[2] = zone_nbr\t\t\t\t#The new zone number\nelse:\nbus_intgar[2] =  zone_str[line[18:20].strip()]\t#Get the zone number\narea_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)\nif area_flag == True:\t\t#To assign the area number to the DC buses\nbus_intgar[1] = area_nbr\nelse:\t\t\t\t#The default area number\nbus_intgar[1] = 1\nif line[62] != ' ':\t\t\t#If it is not a passive DC bus\nconv_intgar[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]\t#Converter bus number\nbus_intgar[0] = conv_intgar[0]\t\t\t\t\t\t#Converter bus number\nif isint(line[23:25]): conv_intgar[1] = int(line[23:25])\t\t#Number of bridges in series\nif isfloat(line[69:75]):\nif float(line[69:75]) != 0.0: conv_realari[0] = float(line[69:75])\t#Scheduled power\nelif isfloat(line[75:80]): conv_realari[0] = float(line[75:80])\t#Scheduled voltage\nif line[62] == 'R' and isfloat(line[30:35]): conv_realari[1] = float(line[30:35])\t#Minimum firing angle"
  },
  {
    "id": "chunk_045",
    "text": "elif line[62] == 'I' and isfloat(line[66:69]) or line[62] == 'M' and isfloat(line[66:69]):\nconv_realari[1] = float(line[66:69])\t\t\t#Minimum extinction angle\nif isfloat(line[35:40]): conv_realari[2] = float(line[35:40])\t#Maximum firing angle\nconv_intgar, conv_realari = GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, line[6:14].strip() + str(float(line[14:18])))\t#To get the corresponding T and R parameters\nierr,realaro = psspy.multi_term_dc_convr_data(1, conv_intgar, conv_realari)\t#The API to load multi-terminal DC line converter data in PSS/E\nierr,realaro = psspy.multi_term_dc_bus_data(1, dc_bus_nbr, bus_intgar, bus_realari, line[6:14].strip())\t#The API to load multi-terminal DC line bus data in PSS/E\nreturn dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr\n# ----------------------------------------------------------------------------------------------------\ndef GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner):\n\"\"\"Gets the multi-terminal link data from the BPA file.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'L' and line[1] == 'M' and line[2] == ' ':\t#If it is a LM card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nintgar = 0\nrealar = [0.0, 0.0]\nibus = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]\t#The from bus\njbus = dc_bus_str[line[19:27].strip() + str(float(line[27:31]))]\t#The to bus\nif line[18] == '1': intgar = ibus\t\t#The metered end is IBUS\nelif line[18] == '2': intgar = jbus\t\t#The metered end is JBUS\nelif line[18] == ' ':\t\t\t#If the metered end is left blank, BPA chooses\nif dc_bus_owner[ibus] == dc_bus_owner[jbus]: intgar = ibus\t#If both ends have the same owner, IBUS is the metered end\nelif dc_bus_owner[ibus] == line[3:6].strip(): intgar = jbus\t#Else the end that has a different owner from the line is the metered end\nelif dc_bus_owner[jbus] == line[3:6].strip(): intgar = ibus\nif isfloat(line[37:43]): realar[0] = float(line[37:43])\t#DC link resistance\nif isfloat(line[43:49]): realar[1] = float(line[43:49])\t#DC link inductance\nierr = psspy.multi_term_dc_link_data(1, ibus, jbus, '1', intgar, realar)\t#The API used to load multi-terminal DC line link data in PSS/E\n# ----------------------------------------------------------------------------------------------------\ndef GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr):\n\"\"\"Gets the multi-terminal lines from the BPA file.\"\"\"\nfor line in bpa_str_ar:\nline = line.lstrip()\nline = line.rstrip('\\n')\nif line == \"\": continue\t\t#Continue if the line is blank\nif line[0] == 'L' and line[1] == 'M' and line[2] == ' ':\t#If it is a LM card\nline = line + ' '*(80-len(line))\t#To pad each line with spaces up to 80 records\n#--------------#\n#Default values#\n#--------------#\nintgari = 1\nrealar = 0.0\nierr, intgaro = psspy.multi_term_dc_line_data(1, intgari, realar)\t#The API used to load multi-terminal DC line data in PSS/E\n#To get the converter, DC bus and DC link data\ndc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr)\nGetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner)\nreturn zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr\nreturn zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr\n# ----------------------------------------------------------------------------------------------------\nbpa_file = OpenFile()\nif bpa_file:\t\t\t\t\t#If the file opened successfully\npsspy.progress(\"\\n\\nFile opened successfully, starting the conversion:\\n\")\nbpa_str = bpa_file.read()\t\t\t#The string containing the text file, to use the find() function\nbpa_file.seek(- bpa_file.tell(), 1)\t\t#To position back at the beginning\nbpa_str_ar = bpa_file.readlines()\t\t#The array that is containing all the lines of the BPA file\nbasemva = GetMVA(bpa_file, bpa_str)\t\t#To get the MVA base\npsspy.progress(\"\\n-Base MVA: \" + str(basemva))\ntitl1, titl2 = GetTitles(bpa_file, bpa_str)\t#To get the title data\npsspy.progress(\"\\n-Title 1: \" + titl1)\npsspy.progress(\"\\n-Title 2: \" + titl2 + \"\\n\")\nierr = psspy.newcas(basemva, titl1, titl2)\t#To create the new case\nscale_str = GetPCard(bpa_str_ar)\t\t#To get the P cards for scaling\narea_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str = GetBCard(bpa_str_ar, basemva, scale_str)\nowner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr = GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, basemva)\nowner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr = GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, basemva)\nowner_str, owner_nbr = GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, basemva, scale_str, bus_zone_str)\nGetTwoTermLine(bpa_str_ar, bus_str)\nzone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr)\nzone_str = GetZCard(bpa_str_ar, zone_str)\t#To get Z cards\nzone_str = GetDZCard(bpa_str_ar, zone_str)\t#To get DZ cards\nfor x, y in zone_str.items():\nierr = psspy.zone_data(y, x)\t#The API used to load zone data in PSS/E\nfor (x,y), z in area_str.items():\nierr = psspy.area_data(z, area_slack_nbr[z - 1], [y, 0.0], x)\t#The API used to load zone data in PSS/E\nGetICard(bpa_str_ar, area_str, area_slack_nbr)\t#To get the I cards\nfor x, y in owner_str.items():\nierr = psspy.owner_data(y, x)\t#The API used to load owner data in PSS/E\nGetRZCard(bpa_str_ar)\t#To get RZ cards\npsspy.progress(\"\\n\\nConversion completed\\n\")\nbpa_file.close()\t#To close the BPA file\n#[brnflows_csv.py]  Export BRANCH FLOWS to COMMA SEPARATED FILE (CSV)\n# ====================================================================================================\n'''\nThis is an example file showing how to use \"subsystem data retrieval APIs\nfrom Python to save branch flows to Comma Separated File.\nInput : Solved PSS(R)E saved case file name\nOutput: CSV file name to save\nWhen 'savfile' is provided, FNSL with default options is used to solve the case.\nWhen 'savfile' is not provided, it uses solved Case from PSS(R)E memory.\nWhen 'csvfile' is provided, branch flows is saved in ASCII text file 'csvfile'.\nWhen 'csvfile' is not provided, it produces report in PSS(R)E report window.\nThe subsystem data retrieval APIs return values as List of Lists. For example:\nWhen \"abusint\" API is called with \"istrings\" as defined below:\nistrings = ['number','type','area','zone','owner','dummy']\nierr, idata = psspy.abusint(sid, flag_bus, istrings)\nThe returned list will have format:\nidata=[[list of 'number'],[list of 'type'],[],[],[],[list of 'dummy']]\nThis example is written such that, such returned lists are converted into dictionary with\nkeys as strings specified in \"istrings\". This makes it easier to refer and use these lists.\nibuses = array2dict(istrings, idata)\nSo ibuses['number'] gives the bus numbers returned by \"abusint\".\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call function\nrun_brnflowscsv()\nYou may want to change input arguments when you call this function.\nrun_brnflowscsv(savfile, csvfile)\n'''\n# ----------------------------------------------------------------------------------------------------\nimport os\n# ----------------------------------------------------------------------------------------------------\ndef array2dict(dict_keys, dict_values):\n'''Convert array to dictionary of arrays.\nReturns dictionary as {dict_keys:dict_values}\n'''\ntmpdict = {}\nfor i in range(len(dict_keys)):"
  },
  {
    "id": "chunk_046",
    "text": "tmpdict[dict_keys[i].lower()] = dict_values[i]\nreturn tmpdict\n# ----------------------------------------------------------------------------------------------------\ndef busindexes(busnum, busnumlist):\n'''Find indexes of a bus in list of buses.\nReturns list with indexes of 'busnum' in 'busnumlist'.\n'''\nbusidxes = []\nstartidx = 0\nbuscounts = busnumlist.count(busnum)\nif buscounts:\nfor i in range(buscounts):\ntmpidx = busnumlist.index(busnum,startidx)\nbusidxes.append(tmpidx)\nstartidx = tmpidx+1\nreturn busidxes\n# ----------------------------------------------------------------------------------------------------\ndef splitstring_commaspace(tmpstr):\n'''Split string first at comma and then by space. Example:\nInput  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\nOutput strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n'''\nstrlst = []\ncommalst = tmpstr.split(',')\nfor each in commalst:\neachlst = each.split()\nif eachlst:\nstrlst.extend(eachlst)\nelse:\nstrlst.extend(' ')\nreturn strlst\n# ----------------------------------------------------------------------------------------------------\ndef brnflows_csv(savfile,csvfile):\n'''Generates power flow result report.\nWhen 'savfile' is provided, FNSL with default options is used to solve the case.\nWhen 'savfile' is not provided, it uses solved Case from PSS(R)E memory.\nWhen 'csvfile' is provided, report is saved in ASCII text file 'csvfile'.\nWhen 'csvfile' is not provided, it produces report in PSS(R)E report window.\n'''\nimport psspy\npsspy.psseinit()\n# Set Save and CSV files according to input file names\nif savfile:\nierr = psspy.case(savfile)\nif ierr != 0: return\nfpath, fext = os.path.splitext(savfile)\nif not fext: savfile = fpath + '.sav'\nelse:   # saved case file not provided, check if working case is in memory\nierr, nbuses = psspy.abuscount(-1,2)\nif ierr != 0:\nprint('\\n No working case in memory.')\nprint(' Either provide a Saved case file name or open Saved case in PSSE.')\nreturn\nsavfile, snapfile = psspy.sfiles()\nif csvfile:  # open CSV file to write\ncsvfile_h = open(csvfile,'w')\nreport    = csvfile_h.write\nelse:        # send results to PSS(R)E report window\npsspy.beginreport()\nreport = psspy.report\n# ================================================================================================\n# PART 1: Get the required results data\n# ================================================================================================\n# Select what to report\nif psspy.bsysisdef(0):\nsid = 0\nelse:   # Select subsytem with all buses\nsid = -1\nflag_brflow  = 1    # in-service\nowner_brflow = 1    # use bus ownership, ignored if sid is -ve\nties_brflow  = 5    # ignored if sid is -ve\n# ------------------------------------------------------------------------------------------------\n# Branch Flow Data\n# Branch Flow Data - Integer\nistrings = ['fromnumber','tonumber','status','nmeternumber','owners','own1','own2','own3','own4']\nierr, idata = psspy.aflowint(sid, owner_brflow, ties_brflow, flag_brflow, istrings)\nif ierr != 0: return\niflow = array2dict(istrings, idata)\n# Branch Flow Data - Real\nrstrings = ['amps','pucur','pctrate','pctratea','pctrateb','pctratec','pctmvarate',\n'pctmvaratea','pctmvarateb',#'pctmvaratec','fract1','fract2','fract3',\n'fract4','rate','ratea','rateb','ratec',\n'p','q','mva','ploss','qloss',\n'o_p','o_q','o_mva','o_ploss','o_qloss'\n]\nierr, rdata = psspy.aflowreal(sid, owner_brflow, ties_brflow, flag_brflow, rstrings)\nif ierr != 0: return\nrflow = array2dict(rstrings, rdata)\n# Branch Flow Data - Complex\nxstrings = ['pq','pqloss','o_pq','o_pqloss']\nierr, xdata = psspy.aflowcplx(sid, owner_brflow, ties_brflow, flag_brflow, xstrings)\nif ierr != 0: return\nxflow = array2dict(xstrings, xdata)\n# Branch Flow Data - Character\ncstrings = ['id','fromname','fromexname','toname','toexname','nmetername','nmeterexname']\nierr, cdata = psspy.aflowchar(sid, owner_brflow, ties_brflow, flag_brflow, cstrings)\nif ierr != 0: return\ncflow = array2dict(cstrings, cdata)\n# ================================================================================================\n# PART 2: Write acquired results to Report file\n# ================================================================================================\nreport(\"Branch flows from Saved case: %s\\n\" %savfile)\nclnttls = \"%6s,%18s,%6s,%18s,%3s,%3s,%9s,%9s,%9s,%6s,%8s,%8s\\n\" %('FRMBUS',\n'FROMBUSEXNAME','TOBUS','TOBUSEXNAME','CKT','STS','MW','MVAR','MVA','%I','MWLOSS','MVARLOSS')\nreport(clnttls)\nfor i in range(len(iflow['fromnumber'])):\nfromnum    = iflow['fromnumber'][i]\nfromexname = cflow['fromexname'][i]\ntonum      = iflow['tonumber'][i]\ntoexname   = cflow['toexname'][i]\nckt        = cflow['id'][i]\nstatus     = iflow['status'][i]\np          = rflow['p'][i]\nq          = rflow['q'][i]\nmva        = rflow['mva'][i]\nploss      = rflow['ploss'][i]\nqloss      = rflow['qloss'][i]\npcti       = rflow['pctrate'][i]\nreport(\"%(fromnum)6d,%(fromexname)18s,%(tonum)6d,%(toexname)18s,%(ckt)3s,%(status)3d,\\\n%(p)9.2F,%(q)9.2F,%(mva)9.2F,%(pcti)6.2F,%(ploss)8.2F,%(qloss)8.2F\\n\" %vars())\n# ------------------------------------------------------------------------------------------------\nif csvfile:\ncsvfile_h.close()\nprint('\\n Done .... Power Flow Results Report saved to file %s' % csvfile)\nelse:\nprint('\\n Done .... Power Flow Results Report created in Report window.')\n# =====================================================================================================\ndef check_psse_example_folder(csvfile):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nrptpath, rptfnam = os.path.split(csvfile)\nif not rptpath:\nrptpath = os.getcwd()\ncwd = rptpath.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(os.getcwd(), 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncsvfile  = os.path.join(outdir, rptfnam)\nreturn csvfile\n# =====================================================================================================\ndef run_brnflows_csv(savfile='savnw.sav', csvfile='brnflows_csv_savnw.csv'):\ncsvfile  = check_psse_example_folder(csvfile)\nbrnflows_csv(savfile, csvfile)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun_brnflows_csv()\n# ====================================================================================================\n#[dyntools_demo.py]  Demo for using functions from dyntools module\n# ====================================================================================================\n'''\n'dyntools' module provide access to data in PSS(R)E Dynamic Simulation Channel Output file.\nThis module has functions:\n- to get channel data in Python scripts for further processing\n- to get channel information and their min/max range\n- to export data to text files, excel spreadsheets\n- to open multiple channel output files and post process their data using Python scripts\n- to plot selected channels\n- to plot and insert plots in word document\nThis is an example file showing how to use various functions available in dyntools module.\nOther Python modules 'matplotlib', 'numpy' and 'python win32 extension' are required to be\nable to use 'dyntools' module.\nSelf installation EXE files for these modules are available at:\nPSSE User Support Web Page and follow link 'Python Modules used by PSSE Python Utilities'.\n- This version of the dyntools module is developed and tested using these open source modules.\nPython 3.7.3 [64 bit]\nmatplotlib-3.1.1\nnumpy-1.16.4\npywin32-224\nVersions later than these may work.\n---------------------------------------------------------------------------------\nHow to use this file?\n- Open Python IDLE (or any Python Interpreter shell)\n- Open this file\n- run (F5)\nNote: Do NOT run this file from PSS(R)E GUI. The 'xyplots' function from dyntools can\nsave plots to eps, png, pdf or ps files. However, creating only 'eps' files from inside\nPSS(R)E GUI works. This is because different backends matplotlib uses to create different\nplot types.\nWhen run from any Python interpreter (outside PSS(R)E GUI) plots can be saved to any of\nthese four (eps, png, pdf or ps) file types.\nGet information on functions available in dyntools as:\nimport dyntools\nhelp(dyntools)\n---------------------------------------------------------------------------------\nHow to use PSSE and Python modules like numpy, matplotlib together?\n(a) In your python script, call following function before any of these modules are imported.\npsspy.set_fpcw_py()\n(b) Call following function before exiting your python script.\npsspy.set_fpcw_psse()\nTo get details why this is needed, get help(..) on either of these functions.\nRefer function test2_subplots_one_trace(..) in this script for usage of these functions.\n'''\nimport os, sys, collections\n# =============================================================================================\ndef get_demotest_file_names(outdir, outvrsn):\nif outvrsn==0:\nextn = '.out'\nprgfile  = os.path.join(outdir,'progress.txt')"
  },
  {
    "id": "chunk_047",
    "text": "else:\nextn = '.outx'\nprgfile  = os.path.join(outdir,'progressX.txt')\noutfile1 = os.path.join(outdir,'bus154_fault{}'.format(extn))\noutfile2 = os.path.join(outdir,'bus3018_gentrip{}'.format(extn))\noutfile3 = os.path.join(outdir,'brn3005_3007_trip{}'.format(extn))\nreturn outfile1, outfile2, outfile3, prgfile\n# =============================================================================================\n# PSSE version Example folder\ndef get_example_folder():\nimport psspy\npn = os.path.dirname(psspy.__file__)\np, jnk = os.path.split(pn)\nexamdir = os.path.join(p, 'Example')\nreturn examdir\n# =============================================================================================\n# Run Dynamic simulation on SAVNW to generate .out files\ndef run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn):\nimport psspy\npsspy.psseinit()\nexamdir = get_example_folder()\nsavfile = 'savcnv.sav'\nsnpfile = 'savnw.snp'\nif not datapath: datapath = get_example_folder()\nsavfile = os.path.join(datapath, savfile)\nsnpfile = os.path.join(datapath, snpfile)\npsspy.lines_per_page_one_device(1,10000000)\npsspy.progress_output(2,prgfile,[0,0])\nierr = psspy.case(savfile)\nif ierr:\npsspy.progress_output(1,\"\",[0,0])\nprint(\" psspy.case Error\")\nreturn\nierr = psspy.rstr(snpfile)\nif ierr:\npsspy.progress_output(1,\"\",[0,0])\nprint(\" psspy.rstr Error\")\nreturn\npsspy.set_chnfil_type(outvrsn)\npsspy.strt(0,outfile1)\npsspy.run(0, 1.0,1000,1,0)\npsspy.dist_bus_fault(154,1, 230.0,[0.0,-0.2E+10])\npsspy.run(0, 1.05,1000,1,0)\npsspy.dist_clear_fault(1)\npsspy.run(0, 5.0,1000,1,0)\npsspy.case(savfile)\npsspy.rstr(snpfile)\npsspy.strt(0,outfile2)\npsspy.run(0, 1.0,1000,1,0)\npsspy.dist_machine_trip(3018,'1')\npsspy.run(0, 5.0,1000,1,0)\npsspy.case(savfile)\npsspy.rstr(snpfile)\npsspy.strt(0,outfile3)\npsspy.run(0, 1.0,1000,1,0)\npsspy.dist_branch_trip(3005,3007,'1')\npsspy.run(0, 5.0,1000,1,0)\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,\"\",[0,0])\n# =============================================================================================\n# 0. Run savnw dynamics simulation to create .out files\ndef test0_run_simulation(datapath=None, outpath=None, outvrsn=0):\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\nrun_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn)\nprint(\" Test0:Done SAVNW dynamics simulation\")\n# =============================================================================================\n# 1. Data extraction/information\ndef test1_data_extraction(outpath=None, show=True, outvrsn=0, prg2file=True):\nimport psspy\nimport dyntools\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\n# create object\nchnfobj = dyntools.CHNF(outfile1, outvrsn=outvrsn)\nif chnfobj.ierr: return\nif prg2file:\np, nx = os.path.split(outfile1)\nn, x  = os.path.split(nx)\nrptnam = \"{}_test1_output.txt\".format(n)\nif outpath:\nrptfile = os.path.join(outpath, rptnam)\nelse:\nrptfile = os.path.join(p, rptnam)\nrptfile_h = open(rptfile,'w')\nreport = rptfile_h.write\nelse:\nreport = sys.stdout.write\nreport('\\n Test1:Testing call to get_data\\n')\n#sh_ttl, ch_id, ch_data = chnfobj.get_data()\nsh_ttl, ch_id, ch_data = chnfobj.get_data(['time', 4, 5, 55])\n#sh_ttl, ch_id, ch_data = chnfobj.get_data('')\n#sh_ttl, ch_id, ch_data = chnfobj.get_data([4, 5, 55])\ns_in = [str(ch) for ch in ch_data.keys()]\ns_ch = ', '.join(s_in)\nreport(sh_ttl)\nreport(\"{}\".format(ch_id))\nreport(\" Test1:Data extracted for Channels = {}\\n\".format(s_ch))\nreport('\\n Test1:Testing call to get_id\\n')\nsh_ttl, ch_id = chnfobj.get_id()\nreport(sh_ttl)\nreport(\"{}\".format(ch_id))\nreport('\\n')\nreport('\\n Test1:Testing call to get_range\\n')\nch_range = chnfobj.get_range()\nreport(\"{}\".format(ch_range))\nreport('\\n')\nreport('\\n Test1:Testing call to get_scale\\n')\nch_scale = chnfobj.get_scale()\nreport(\"{}\".format(ch_scale))\nreport('\\n')\nif not prg2file:\nreport('\\n Test1:Testing call to print_scale\\n')\nchnfobj.print_scale()\nreport('\\n')\npn, x = os.path.splitext(outfile1)\nreport('\\n Test1:Testing call to txtout\\n')\nchnfobj.txtout(channels=[1,4], txtfile=pn)\nreport('\\n')\nreport('\\n Test1:Testing call to csvout\\n')\nchnfobj.csvout(channels=[1,4,41,5], csvfile=pn)\nreport('\\n')\nreport('\\n Test1:Testing call to xlsout\\n')\ntry:\nchnfobj.xlsout(channels=[2,3,4,7,8,10], show=show, xlsfile=pn)\nexcept:\npass\nif prg2file:\nrptfile_h.close()\ntxt = ' Test1_data_extraction report saved to file:\\n    {}\\n'.format(rptfile)\nprint(txt)\n# =============================================================================================\n# 2. Multiple subplots in a figure, but one trace in each subplot\n#    Channels specified with normal dictionary\n# See how \"set_plot_legend_options\" method can be used to place and format legends\ndef test2_subplots_one_trace(outpath=None, show=True, outvrsn=0):\nimport psspy\nimport dyntools\npsspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\nchnfobj = dyntools.CHNF(outfile1, outfile2, outvrsn=outvrsn)\nchnfobj.set_plot_page_options(size='letter', orientation='portrait')\nchnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n'circle', 'star', 'hexagon1')\nchnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\nchnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\noptnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':True, 'showoutfnam':True, 'showlogo':True,\n'legendtype':1, 'addmarker':True}\noptnchn1 = {1:{'chns':6,                'title':'Ch#6,bus154_fault, P(pu)'},\n2:{'chns':[6, 'v*100'],     'title':'Ch#6,bus154_fault, P(MW)'},\n3:{'chns':11,               'title':'Ch#11,bus154_fault'},\n4:{'chns':40,               'title':'Ch#40,bus154_fault'},\n5:{'chns':26,               'title':'Ch#26,bus154_fault, Frequency (pu)'},\n6:{'chns':[26, '(1+v)*60'], 'title':'Ch#26,bus154_fault, Frequency (Hz)'},\n}\npn,x     = os.path.splitext(outfile1)\npltfile1 = pn+'.pdf'\noptnchn2 = {1:{'chns':{outfile2:6},                'title':'Channel 6 from bus3018_gentrip, P(pu)'},\n2:{'chns':{outfile2:[6, 'v*100']},     'title':'Channel 6 from bus3018_gentrip, P(MW)'},\n3:{'chns':{outfile2:11}},\n4:{'chns':{outfile2:16}},\n5:{'chns':{outfile2:26},               'title':'Ch#26,bus3018_gentrip, Frequency (pu)'},\n6:{'chns':{outfile2:[26, '(1+v)*60']}, 'title':'Ch#26,bus3018_gentrip, Frequency (Hz)'},\n}\npn,x     = os.path.splitext(outfile2)\npltfile2 = pn+'.png'\nfigfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)\nchnfobj.set_plot_legend_options(loc='lower center', borderpad=0.2, labelspacing=0.5,\nhandlelength=1.5, handletextpad=0.5, fontsize=8, frame=False)\noptnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n'legendtype':2, 'addmarker':False}\nfigfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)\nif figfiles1 or figfiles2:\ntxt = ' Test2:Plot files saved:\\n'\nif figfiles1: txt += \"     {}\\n\".format(figfiles1[0])\nif figfiles2: txt += \"     {}\\n\".format(figfiles2[0])\nprint(txt)\nif show:\nchnfobj.plots_show()\nelse:\nchnfobj.plots_close()\npsspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n# =============================================================================================\n# 3. Multiple subplots in a figure and more than one trace in each subplot\n#    Channels specified with normal dictionary\ndef test3_subplots_mult_trace(outpath=None, show=True, outvrsn=0):\nimport psspy\nimport dyntools\npsspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\nchnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\nchnfobj.set_plot_page_options(size='letter', orientation='portrait')\nchnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n'circle', 'star', 'hexagon1')\nchnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\nchnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\noptnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n'legendtype':2, 'addmarker':True}\noptnchn1 = {1:{'chns':[1]},2:{'chns':[2]},3:{'chns':[3]},4:{'chns':[4]},5:{'chns':[5]}}\npn,x     = os.path.splitext(outfile1)\npltfile1 = pn+'.png'\noptnchn2 = {1:{'chns':{outfile2:1}},\n2:{'chns':{'v82_test1_bus_fault.out':3}},\n3:{'chns':4},\n4:{'chns':[5]}\n}\npn,x     = os.path.splitext(outfile2)\npltfile2 = pn+'.pdf'\noptnchn3 = {1:{'chns':{outfile1:1}},\n2:{'chns':{outfile2:[1,5]}},\n3:{'chns':{outfile3:3}},\n4:{'chns':[4,'v-v0',5,'v-v0']},  # arbitrary function\n}\npn,x     = os.path.splitext(outfile3)\npltfile3 = pn+'.png'\nfigfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)\nfigfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)\nfigfiles3 = chnfobj.xyplots(optnchn3,optnfmt,pltfile3)\nfigfiles = figfiles1[:]\nfigfiles.extend(figfiles2)\nfigfiles.extend(figfiles3)\nif figfiles:\ntxt = ' Test3:Plot files saved:\\n'\nfor f in figfiles:\ntxt += \"    {}\\n\".format(f)\nprint(txt)\nif show:\nchnfobj.plots_show()\nelse:\nchnfobj.plots_close()\npsspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n# =============================================================================================\n# 4. Multiple subplots in a figure, but one trace in each subplot\n#    Channels specified with Ordered dictionary\ndef test4_subplots_mult_trace_OrderedDict(outpath=None, show=True, outvrsn=0):\nimport psspy\nimport dyntools\npsspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\nchnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\nchnfobj.set_plot_page_options(size='letter', orientation='portrait')\nchnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',\n'circle', 'star', 'hexagon1')\nchnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')\nchnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')\noptnfmt  = {'rows':2,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,\n'legendtype':2, 'addmarker':True}\noptnchn  = {1:{'chns':collections.OrderedDict([(outfile1,26), (outfile2,26), (outfile3,26)]),\n'title':'Frequency(pu)'},\n2:{'chns':collections.OrderedDict([(outfile1,[26, '(1+v)*60']),\n(outfile2,[26, '(1+v)*60']),\n(outfile3,[26, '(1+v)*60'])]),\n'title':'Frequency(Hz)'}\n}\np,nx     = os.path.split(outfile1)\npltfile  = os.path.join(p, 'plot_chns_ordereddict.png')\nfigfiles = chnfobj.xyplots(optnchn,optnfmt,pltfile)\nif figfiles:\ntxt = ' Test4:Plot files saved:\\n'\nfor f in figfiles:\ntxt += \"    {}\\n\".format(f)\nprint(txt)\nif show:\nchnfobj.plots_show()\nelse:\nchnfobj.plots_close()\npsspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n# =============================================================================================\n# 5. Do XY plots and insert them into word file\n# Does not work because win32 API to Word does not work.\ndef test5_plots2word(outpath=None, show=True, outvrsn=0):\nimport psspy\nimport dyntools\npsspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\noutfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)\nchnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)\np,nx       = os.path.split(outfile1)\ndocfile    = os.path.join(p,'savnw_response')\noverwrite  = True\ncaption    = True\nalign      = 'center'\ncaptionpos = 'below'\nheight     = 0.0\nwidth      = 0.0\nrotate     = 0.0\noptnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':True}\noptnchn  = {1:{'chns':{outfile1:1,  outfile2:1,  outfile3:1} },\n2:{'chns':{outfile1:[7,'v*100'],  outfile2:[7,'v*100'],  outfile3:[7,'v*100']} },\n3:{'chns':{outfile1:17, outfile2:17, outfile3:17} },"
  },
  {
    "id": "chunk_048",
    "text": "4:{'chns':[1,2,3,4,5]},\n5:{'chns':{outfile2:[26,'(1+v)*60',27,'(1+v)*60',28,'(1+v)*60',29,'(1+v)*60']},\n'title':'Frequency(Hz)'},\n6:{'chns':{outfile3:[1,2,3,4,5]} },\n}\nierr, docfile = chnfobj.xyplots2doc(optnchn,optnfmt,docfile,show,overwrite,caption,align,\ncaptionpos,height,width,rotate)\nif not ierr:\ntxt  = ' Test5:Plots saved to file:\\n    {}'.format(docfile)\nprint(txt)\nelse:\ntxt  = ' Test5:Error saving plots to Word = {}'.format(ierr)\nprint(txt)\npsspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n# =============================================================================================\n# Run all tests and save plot and report files.\ndef run_all_tests(outvrsn, datapath=None, prg2file=True):\nshow = False\nrun_tests('all', outvrsn, show, datapath=datapath, prg2file=prg2file)\n# =============================================================================================\ndef run_tests(which, outvrsn, show, datapath=None, prg2file=True):\nimport psspy\ndatapath = datapath\noutdnam  = \"dyntools_demo_output_outvrn{}\".format(outvrsn)\noutpath  = os.path.join(os.getcwd(), outdnam)\nif not os.path.exists(outpath): os.mkdir(outpath)\nif which in [0, 'all']:\nprint(\" <<<<<< Begin TEST=0 >>>>>>\")\ntest0_run_simulation(datapath, outpath, outvrsn)\nprint(\" Output files folder:{}\".format(outpath))\nif which in [1, 'all']:\nprint(\" <<<<<< Begin TEST=1 >>>>>>\")\ntest1_data_extraction(outpath=outpath, show=show, outvrsn=outvrsn, prg2file=prg2file)\nif which in [2, 'all']:\nprint(\" <<<<<< Begin TEST=2 >>>>>>\")\ntest2_subplots_one_trace(outpath, show, outvrsn)\nif which in [3, 'all']:\nprint(\" <<<<<< Begin TEST=3 >>>>>>\")\ntest3_subplots_mult_trace(outpath, show, outvrsn)\nif which in [4, 'all']:\nprint(\" <<<<<< Begin TEST=4 >>>>>>\")\ntest4_subplots_mult_trace_OrderedDict(outpath, show, outvrsn)\nif which in [5, 'all']:\nprint(\" <<<<<< Begin TEST=5 >>>>>>\")\ntry:\ntest5_plots2word(outpath, show, outvrsn)\nexcept:\npass\n# =============================================================================================\nif __name__ == '__main__':\nimport psse35\nshow = True     # True  --> create, save and show Excel spreadsheets and Plots when done\n# False --> create, save but do not show Excel spreadsheets and Plots when done\n# Channel file format\noutvrsn = 0     # =0, for no Extended Channel output file type (.out)\n# =1, for Extended Channel output file type (.outx) (default)\nprg2file = False\n#(a) Run one test a time\n#\n# 1) which=0\n# Need to run \"test0_run_simulation(..)\" before running other tests.\n#\n# 2)\n# which = 1 or 2 or 3 or 4 or 5\n# After running \"test0_run_simulation(..)\", run other tests one at a time with\n# which = 0\n# run_tests(which, outvrsn, show, prg2file)\n#(b) Run all tests\n#    Just uncomment next line to run all tests in this file.\n#run_all_tests(outvrsn)\n# =============================================================================================\n#[excelpy_howto_qv_export.py]  Get QV solution and Export to Excel using excelpy Module\n# ====================================================================================================\n'''\nThis is an example file showing how to use excelpy Module to populate Excel Spreadsheets.\nAs an example, here PSSE QV solution is exported to Excel.\nGet more info on as:\nhelp(arrbox.qv_pp.QV_PP)\nhelp(excelpy)\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psseXX\nwhere XX is PSSE version number like 34, 35, 3500, 3501.\n- call funtion\nrun_export(qvfile)\nor\nrun_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd())\nExcel file is saved to a file name derived from qvfile name.\n'''\nimport os\nshtlst = ['bus voltage', 'summary', 'generator dispatch', 'mismatch']\n# ====================================================================================================\ndef qv_summary(xlsobj,sheet,smry):\n'''\nUse this to create ->\nQV worksheet: 'Summary'\n'''\nxlsobj.set_active_sheet(sheet)\nrow, col = 1, 1\nxlsobj.set_cell((row,col),\"QV SOLUTION RESULTS\",fontStyle=\"bold\",fontSize=14, fontColor=\"blue\")\ntmplst=[\nsmry.casetitle.line1,\nsmry.casetitle.line2,\n'QV output file                             = %s' % smry.file.qv,\n'Saved Case file                            = %s' % smry.file.sav]\nif smry.file.thr:\ntmplst.append('Load throwover file                        = %s' % smry.file.thr)\ntlst = [\n'DFAX file                                  = %s' % smry.file.dfx,\n'Subsystem file                             = %s' % smry.file.sub,\n'Monitored Element file                     = %s' % smry.file.mon,\n'Contingency Description file               = %s' % smry.file.con]\ntmplst.extend(tlst)\nif smry.file.inl:\ntmplst.append('Inertia and Governor Response file         = %s' % smry.file.inl)\nif smry.file.zip:\ntmplst.append('Incremental Save Case Archive file         = %s' % smry.file.zip)\ntlst = [\n' ',                                                                       # blank row\n'Number of Contingencies+Base Case          = %d' % smry.qvsize.ncase,\n'Number of Monitored Generators(Plants)     = %d' % smry.qvsize.nmgnbus,\n'Number of Voltage Monitored Buses          = %d' % smry.qvsize.nmvbus,\n'Number of Voltage Monitored Records        = %d' % smry.qvsize.nmvrec,\n'Number of maximum voltage setpoint changes = %d' % smry.qvsize.nmxvstp,\n]\ntmplst.extend(tlst)\nrow_optn_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+opt ttl\njnklst=[' ', 'QV Solution Options:']\nfor i in range(len(smry.options)):\nj=smry.options[i]\nti=str(i+1).rjust(2)\ntj=str(j)\nt1=arrbox.qv_pp._QV_INT_OPTIONS_NAMES[i]\nif (i+1)==arrbox.qv_pp._QV_INT_OPTIONS_STUDY_BUS_INDEX:\njnklst.append(\"option(%(ti)s): %(t1)s =%(tj)s\" % vars())\nelse:\nt2=arrbox.qv_pp._QV_INT_OPTIONS_LIST[i][j]\njnklst.append(\"option(%(ti)s): %(t1)s =%(tj)s =%(t2)s\" % vars())\ntmplst.extend(jnklst)\nrow_vals_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+val ttl\njnklst=[' ', 'QV Solution Values:']\nfor i in range(len(smry.realvalues)):\nti=str(i+1)\ntn=arrbox.qv_pp._QV_REAL_VALUES_NAMES[i]\ntv=\"%g\" % smry.realvalues[i]\njnklst.append(\"value(%(ti)s): %(tn)s =%(tv)s\" % vars())\ntmplst.extend(jnklst)\ndel jnklst\nrow += 2\nbottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True)\nxlsobj.font_color((row,col,row+1,col),'brown')\nxlsobj.font_color((row_optn_ttl,col),'red')\nxlsobj.font_color((row_vals_ttl,col),'red')\nif smry.qvsize.ncase:\nrow = bottomRow+2\nxlsobj.set_cell((row,col),\"QV Contingencies\",fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nconlst = [['CON#', 'LABEL', 'Min Vstp', 'Max Vstp', 'Min MVAR', 'Max MVAR',\n'Max Mismatch', 'DESCRIPTION']]\n# determine rows for which QV is failed maxmsm>smry.realvalues[0]\nrfrm = row+1\nrto  = row+1\nfailrows = []\nfor i in range(smry.qvsize.ncase):\nrfrm += 1\nrto  += 1\nif i==0:\nsrnum = ' '\nelse:\nsrnum = str(i)\nnam  = smry.colabel[i]\nminvstp = smry.minvstp[i]\nmaxvstp = smry.maxvstp[i]\nminmvar = smry.minmvar[i]\nmaxmvar = smry.maxmvar[i]\nmaxmsm  = smry.maxmsm[i]\nfor j in range(len(smry.codesc[i])):\ndsc = smry.codesc[i][j]\nif j==0:\nconlst.append([srnum,nam,minvstp,maxvstp,minmvar,maxmvar,maxmsm,dsc])\nelse:\nconlst.append(['' ,'' ,'' ,'' ,'' ,'' ,'' ,dsc])\nrto += 1\nif maxmsm>smry.realvalues[0]:\nfailrows.append([rfrm, rto])\nelse:\nfailrows.append([0, 0])\nrfrm = rto\nrow += 1\nbottomRow,rightCol = xlsobj.set_range(row,col,conlst)\nxlsobj.font_color((row,col,row,rightCol), \"dgreen\")\nxlsobj.font((row,col+2,bottomRow,col+3),numberFormat='0.00')  # Min Vstp and Max Vstp\nxlsobj.font((row,col+4,bottomRow,col+6),numberFormat='0.000') # Min MVAR, Max MVAR and Max MSM\nxlsobj.align((row,col),'right')\nxlsobj.font((row,col,row,rightCol),fontStyle=('Bold',))\nxlsobj.autofit_columns((row,col+1,row,rightCol))\nfor each in failrows:\nr1 = each[0]\nr2 = each[1]\nif r1 and r2:\nxlsobj.font((r1,col,r2,rightCol),fontColor=\"cyan\",fontStyle='bold')\nelse:\nxlsobj.set_cell((row,col),\"No Contingencies..\",fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\n# ====================================================================================================\ndef qv_mismath(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,mvaworst,mvatotal,cnvflag,cnvcond):\n'''\nUse this to create ->\nQV worksheet: 'Mismatch'\n'''\n# assemble data in columns: 1st=MW Transfer, 2nd=MVAWORST and 3rd=MVATOTAL\ncontitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label\ncnvyesno = []\nnoclns   = []\ni = 1\nfor each in cnvflag:\ni += 1\nif each:\ncnvyesno.append('YES')\nnoclns.append(0)\nelse:\ncnvyesno.append('NO')\nnoclns.append(i)\ntmplst = [ rowttl ]\nfor i in range(len(mwtransfer)):\ntmplst.append([mwtransfer[i],mvaworst[i],mvatotal[i],cnvyesno[i],cnvcond[i]])\nxlsobj.set_active_sheet(sheet)\ncol = 1\n# added 1 to row in violation check for 'contitle' row\nxlsobj.set_cell((row,col+1),contitle,fontStyle='bold',fontSize=12,fontColor=\"dgreen\")\nrow += 1\nbottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True,numberFormat=\"0.00000\")\nxlsobj.font((row,col,row,rightCol),fontColor=\"red\",fontStyle='bold',numberFormat=\"0.000\")\nxlsobj.align((row,col,row,rightCol),'h_center')\nxlsobj.align((row+3,col,row+3,rightCol),'h_center')\nxlsobj.align((row,col,bottomRow,col),'right')\nxlsobj.font((row+1,col,bottomRow,col),fontColor=\"blue\",fontStyle='bold')\nfor each in noclns:\nif each:\nxlsobj.font((row+3,each,bottomRow,each),fontColor=\"cyan\",fontStyle='bold')\nrow = bottomRow + 2 # one blank row\nreturn row\n# ====================================================================================================\ndef qv_one(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,solnvalue,options,cnvflag=[]):\n'''\nUse this to create ->\nQV worksheets: 'Bus Voltage', 'Generator Dispatch'\n'''\ncontitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label\nnamesplit = options[0]\nnttlclns  = options[1]"
  },
  {
    "id": "chunk_049",
    "text": "transpose = options[2]\n# determine non-converged solution columns\nnoclns = []\ni = nttlclns\nfor each in cnvflag:\ni += 1\nif each:\nnoclns.append(0)\nelse:\nnoclns.append(i)\n# assemble data in columns: 1st=MW Transfer, rest=solution values\nt = []\nfor i in range(len(mwtransfer)):\nt1 = list(solnvalue[i])\nt1.insert(0,mwtransfer[i])\nt.append(t1)\ntmplst = t\ntmplst.insert(0,rowttl)\nxlsobj.set_active_sheet(sheet)\ncol = 1\nxlsobj.set_cell((row,col+nttlclns),contitle,fontStyle='bold',fontSize=12,fontColor=\"dgreen\")\nrow += 1\nbottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=transpose)\nxlsobj.font((row,col+nttlclns-1,row,rightCol),fontColor=\"red\",fontStyle='bold')\nxlsobj.font((row,col+nttlclns,bottomRow,rightCol),numberFormat=\"0.000\")\nxlsobj.align((row,col,row,rightCol),'h_center')\nif namesplit: xlsobj.merge((row,col,row,nttlclns))\nxlsobj.align((row,col),'right')\nxlsobj.font((row+1,col,bottomRow,nttlclns),fontColor=\"blue\",fontStyle='bold')\nfor each in noclns:\nif each:\nxlsobj.font((row+1,each,bottomRow,each),fontColor=\"cyan\")\nrow = bottomRow + 2 # one blank row\nreturn row\n# ====================================================================================================\ndef run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd()):\nimport arrbox.qv_pp\nimport excelpy\nif not os.path.exists(qvfile):\nmsgstr = \" Error - QV file does not exist, no export.\\n     {}.\" .format(qvfile)\nprint(msgstr)\nreturn\np, nx = os.path.split(qvfile)\nxlnam, x = os.path.splitext(nx)\nxlnam = \"{}_qv\".format(xlnam)\nxlsfile = os.path.join(outpath, xlnam)\n# -----------------------------------------------------------\nxlsobj = excelpy.workbook(xlsfile, shtlst[0], overwritesheet=overwritesheet)\nif show:\nxlsobj.show()\nelse:\nxlsobj.hide()\nxlsobj.show_alerts(0) # do not show pop-up alerts\nxlsfnam = xlsobj.XLSFNAM\nfor shtnam in shtlst[1:]:\nxlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)\nxlsobj.page_format(orientation=\"landscape\",left=1.0,right=1.0,\ntop=0.5,bottom=0.5,header=0.25,footer=0.25)\nxlsobj.page_footer(left='page number of page total', right='date, time')\nxlsobj.page_header(center='file name:sheet name')\nxlsobj.font_sheet()\n# -----------------------------------------------------------\n# Retrive QV data\nqvobj = arrbox.qv_pp.QV_PP(qvfile)\nsmry = qvobj.summary()\nqv_summary(xlsobj, 'summary', smry)\nrow_msm = 1\nmsmlabel = ['VOLTAGE SETPOINT->', 'LARGEST MVA MISMATCH', 'TOTAL MVA MISMATCH', 'CONVERGED', 'CONVERGE CONDITION']\nrow_vlt = 1\noptions_vlt = [False,1,True]\nmvbuslabel = list(smry.mvbuslabel)\nmvbuslabel.insert(0,'VOLTAGE SETPOINT->')\nrow_gen = 1\noptions_gen = [False,1,True]\nmgenbuslabel = list(smry.mgenbus)\nmgenbuslabel.insert(0,'VOLTAGE SETPOINT->')\nret_ierr = 0\nfor lbl in smry.colabel:\nsoln = qvobj.solution(lbl)\nif soln==None: continue                 # contingency solution not found, move to next\nif soln.ierr !=0: ret_ierr = soln.ierr  # return any non-zero ierr\nrow_msm = qv_mismath(xlsobj, 'mismatch',lbl,'Mismatch (MVA)',\nrow_msm,msmlabel,soln.vsetpoint,soln.mvaworst,soln.mvatotal,\nsoln.cnvflag, soln.cnvcond)\nrow_vlt = qv_one(xlsobj,'bus voltage',lbl,'Voltage (pu)',\nrow_vlt,mvbuslabel,soln.vsetpoint,soln.volts,options_vlt,soln.cnvflag)\nrow_gen = qv_one(xlsobj,'generator dispatch',lbl,'Plant (MVAR)',\nrow_gen,mgenbuslabel,soln.vsetpoint,soln.mgenmvar,options_gen,soln.cnvflag)\n# --------------------------------------\n# Format worksheets\nxlsobj.autofit_columns((1,1),'mismatch')\nxlsobj.autofit_columns((1,1),'bus voltage')\nxlsobj.autofit_columns((1,1),'generator dispatch')\nif show: xlsobj.set_active_sheet('bus voltage')\n# -----------------------------------------------------------\n# Save the workbook and close the Excel application\nxlsfile = xlsobj.save()\nif not show:\nxlsobj.close()\nmsgstr = \"\\n Done ...QV Export saved to file:\\n     {}.\" .format(xlsfnam)\nprint(msgstr)\n# ====================================================================================================\nif (__name__ == \"__main__\"):\npass\n# Change appropriately 'psseXX' and 'qvfile' values below.\nimport psseXX\nqvfile = \"savnw.qv\"\nrun_export(qvfile, overwritesheet=True, show=True)\n#[gic_demo.py]    GIC Analysis in PSSE\n# =====================================================================================================\n'''This is an example file showing how to run different GIC Events with and without supplemental\nevent moving boxes.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\nimport psseXX\n- call function\nRun various functions from this file as desired.\nSee notes in _run_one_test_api(..) (end of this file).\n'''\n\"\"\"\nUse any of these keywords to run GIC_8.\nKeyword               Default          Description\n# INTGOPTNS[]\ntielevels           = 0              #  1  Number of levels of inter-tie buses to add to study subsystem\nstudy_year          = 0              #  2  Year number to scale benchmark event GMD storm. These scaling factors account in the influence of geomagnetic latitude on the estimated geoelectric field magnitude and are provided in NERC TPL-007.\nsid_supp            = 0              #  3  Subsystem sid for supplemental GMD event\nthermal_ana_optn    = 0              #  4  Option for Transformer Thermal Analysis\ndegscan_pf_optn     = 0              #  5  Option to run power flow for each degree scan calculation\nboundary_trn        = 0              #  6  Option to include buses of boundary transformers in study subsystem\nworstcase_trn       = 0              #  7  Option for Transformers to include in worst case determination\nsupp_evt            = 0              #  8  Option for Supplemental event and moving box\nsupp_box_num        = 0              #  9  Option for number of Supplemental event moving boxes. It is not used when intgoptns(8)=0 and intgoptns(8)=4\nbrn_seg_efld        = 0              # 10  Option for treatment of the transmission line that intersect with Supplemental event moving box\n# REALOPTNS[]\nefield_mag          = 8.0            #  1  electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform or supplemental\nefield_deg          = 0              #  2  electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform or supplemental\nsubstation_r        = 0.1            #  3  substation grounding dc resistance in ohms\nbranch_xbyr         = 30             #  4  transmission line X/R ratio, must be > 0, used to calculate branch DC resistance if R=0.0 in network data\ntransformer_xbyr    = 30             #  5  transformer winding X/R ratio, must be > 0, used to calculate winding DC resistance if R=0.0 in network data\nefield_mag_supp     = 12.0           #  6  supplemental event electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform\nefield_deg_supp     = 0.0            #  7  local GMD hot spots electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform\nbranch_rac2rdc      = 1.0            #  8  transmission line AC to DC resistance conversion factor, must be > 0\ntransformer_rac2rdc = 1.0            #  9  transformer winding AC to DC resistance conversion factor, must be > 0\ndegscan_step        = 10.0           # 10  Degree Scan step size, range 1.0 to 180 degrees\nmagscan_step        = 4.0            # 11   Magnitude Scan step size, must be > 1.0 V/km\npf_qpct_step        = 100.0          # 12   Percent GMD Mvar loss step size. Total GMD Mvar losses added incrementally to the base case to obtain power flow solution, must be > 1.0\nmagscan_max         = 20.0           # 13   Magnitude Scan maximum storm strength, must be > 1.0\nsupp_box_ns_km      = 100.0          # 14   Supplemental event moving box North-South length in km, must be > 1.0, used when intgoptns(8)>0\nsupp_box_ew_km      = 500.0          # 15   Supplemental event moving box East-West length in km, must be > 1.0, used when intgoptns(8)>0\nsupp_box_lon_c      = 0.0            # 16   Supplemental event moving box center point longitude in degrees, used only when intgoptns(8)=4\nsupp_box_lat_c      = 0.0            # 17   Supplemental event moving box center point latitude in degrees, used only when intgoptns(8)=4\n# CHAROPTNS[]\nefield_type         = \"uniform\"      #  1  Electric Field Type\nefield_unit         = \"v/km\"         #  2  Units of Electric Field Magnitude\naddfile_optn        = \"rdch\"         #  3  Option to add GIC updates to base case\ngic2mvar_optn       = \"kfactors\"     #  4  Option to select method for GIC to Mvar Calculation\nearth_model_name    = \"\"             #  5  Earth Model Name. A Standard or User defined model name must be provided when Benchmark Event or Non-uniform electric field is to be modeled or Transformer Thermal Analysis is to be performed."
  },
  {
    "id": "chunk_050",
    "text": "scan_storm_event    = \"\"             #  6  Option to scan storm event scenarios\npower_flow_optn     = \"\"             #  7 Option to solve Power Flow with GIC losses added to the base case\n# EJETOPTNS[]\nejet_million_amps   = 1.0            #  1  eletrojet current in million amperes, must be > 0\nejet_halfwidth_km   = 200.0          #  2  Cauchy distribution half-width in km, must be > 0\nejet_period_min     = 5.0            #  3  period of variation in minutes, must be > 0\nejet_height_km      = 100.0          #  4  height of current in km, must be > 0\nejet_center_deg     = 54.0           #  5  latitude of center of electrojet in degrees\n# FILEOPTNS[]\naddfile             = \"\"             #  2  GIC updates to Base Case file name (output).\npurgfile            = \"\"             #  3  RDCH file to remove GIC updates from GIC updated case in working memory to set it back to Base Case network condition (output).\nrnwkfile            = \"\"             #  4  GIC dc resistive network raw file. This represents the dc network used to calculate GIC flow (output).\npygicfile           = \"nooutput\"     #  5  GIC Results map data file for given Efield magnitude and degrees OR Efield magnitude and degrees scans which give maximum Var losses when scans are performed (output).  This is used by GICMAPS to plot GIC results on network map.\ngictfile            = \"nooutput\"     #  6  Transformer Thermal Analysis GIC(t) CSV file (output).\n# REPTOPTNS[]\nrptoptn             = -1             #  1  what to report\nrptbrn_indv         = 1              #  2  report induced branch voltages\nrptdc_busv          = 1              #  3  report DC bus voltages\nrptbrn_gic          = 1              #  4  report branch GIC flows\nrpttrn_gic          = 1              #  5  report transformer GIC flows\nrptstn_gic          = 1              #  6  report substation GIC flows\nrpttrn_q            = 1              #  7  report transformer losses\nrpt_sid             = 0              #  8  Subsystem sid for report\n\"\"\"\nimport sys, os, time, collections\n# =========================================================================\ndef start_timer():\n'''start_time = start_timer()\nStart timer and return time in seconds since the Epoch.\n'''\nstart_time = time.time()\nreturn start_time\n# -------------------------------------------------------------------------\ndef finish_timer(start_time):\n'''timstr = finish_timer(start_time)\nFinish timer and return elapsed time as string.\nwhere start_time is value returned by start_timer().\n'''\nfinish_time = time.time()\nelapsed_sec = finish_time - start_time\nhr,mn1 = divmod(elapsed_sec,3600)\nmn,sc  = divmod(mn1,60)\ntimstr = \" Elapsed time: Hours=%d , Minutes=%d, Seconds=%g\\n\" % (hr, mn, sc)\nreturn timstr\n# =========================================================================\n# PSSE version Example folder\ndef get_example_folder():\nimport psspy\npn = os.path.dirname(psspy.__file__)\np, jnk = os.path.split(pn)\nexamdir = os.path.join(p, 'Example')\nreturn examdir\n# -------------------------------------------------------------------------\ndef get_output_dir(outpath=''):\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.path.dirname(__file__)\noutdir = os.path.join(outdir, 'gic_demo_output')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# -------------------------------------------------------------------------\ndef get_output_filename(fname, outpath=''):\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fname)\nreturn retvfile\n# =========================================================================\ndef run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds):\nimport psspy\n_i = psspy.getdefaultint()\n_f = psspy.getdefaultreal()\nname,major,minor,modlvl,date,stat = psspy.psseversion()\nvrsn = \"v{}{}{}\".format(major,minor,modlvl)\nif 'efield_type' not in kwds: kwds['efield_type'] = \"benchmark\"\n# add suffix to prg/rpt names (to make them unique, so they are not overwritten.)\noptn_nam_dict = collections.OrderedDict([\n('efield_deg'      , 'deg' ),\n('scan_storm_event', ''    ),\n('power_flow_optn' , ''    ),\n('boundary_trn'    , 'btrn'),\n('worstcase_trn'   , 'wtrn'),\n('supp_evt'        , 'optnbx' ),\n('brn_seg_efld'    , 'brnseg'),\n])\nsid_supp, supp_evt, brn_seg = 0, 0, 0\nif 'sid_supp' in kwds: sid_supp = kwds['sid_supp']\nif 'supp_evt' in kwds: supp_evt = kwds['supp_evt']\nif 'supp_box_num' in kwds: supp_box_num = kwds['supp_box_num']\nif 'supp_box_lon_c' in kwds: supp_box_lon_c = kwds['supp_box_lon_c']\nif 'supp_box_lat_c' in kwds: supp_box_lat_c = kwds['supp_box_lat_c']\nif 'brn_seg_efld' in kwds:brn_seg = kwds['brn_seg_efld']\ns_brnseg = ''\nsubdir = ''\noutfsfx = kwds['efield_type'][0]\nif (supp_evt==1 and sid_supp>0)             or \\\n(supp_evt in [2,3,4] and supp_box_num>0) or \\\n(supp_evt==5 and abs(supp_box_lon_c)>0 and abs(supp_box_lat_c)>0):\noutfsfx += \"+s\"\ns_brnseg = \"bseg{}\".format(brn_seg)\nif supp_evt in [2,3] and supp_box_num>0:\nsubdir = \"supp_opbx{}_numbx{}_brnseg{}\".format(supp_evt, supp_box_num, brn_seg)\nfor k, s_nam in optn_nam_dict.items():\nif k in kwds:\nvin = kwds[k]\nif vin:\nif s_nam:\nif supp_evt==1:\noutfsfx += \"_sid\"\nelse:\noutfsfx += \"_{}{}\".format(s_nam, vin)\nelse:\noutfsfx += \"_{}\".format(vin)\nif s_brnseg:\noutfsfx += \"_{}\".format(s_brnseg)\noutdir = get_output_dir(outdir)\nif subdir:\noutdir = os.path.join(outdir, subdir)\nif not os.path.exists(outdir): os.mkdir(outdir)\nif prg2file:\nnam = \"{}_{}_progress.txt\".format(outnam, outfsfx)\nprgfile = os.path.join(outdir, nam)\nif rpt2file:\nnam = \"{}_{}_report.txt\".format(outnam, outfsfx)\nrptfile = os.path.join(outdir, nam)\n# Create output file names when they are not provided\nfor sfx in ['add', 'purg', 'rnwk', 'pygic', 'gict']:\nk = \"{}file\".format(sfx)\nif k not in kwds:\ns0 = sfx\nif sfx=='pygic': s0 = 'map'\nfnam = \"{}_{}_{}\".format(outnam, outfsfx, s0)\nkwds[k] = os.path.join(outdir, fnam)\n# run activity gic_8\nif prg2file: psspy.progress_output(2,prgfile,[0,0])\nif rpt2file: psspy.report_output(2,rptfile,[0,0])\nstart_time = start_timer()\npsspy.gic_8(sid, allbus, **kwds)\ntimstr = finish_timer(start_time)\nif prg2file: psspy.progress_output(1,\"\",[0,0])\nif rpt2file: psspy.report_output(1,\"\",[0,0])\nprint(timstr)\nif rpt2file:\nprint(\"  --------- Report saved to: {} \".format(rptfile))\n# =========================================================================\ndef run_test_sample(**optns):\nimport psspy\npsspy.psseinit()\ngicfilevrsn = optns.get('gicfilevrsn', 4)\nif gicfilevrsn>4:\nsavfnam = r'sample_nb.sav'      # SAV file with Node Breaker Modeling\ngicfnam = r'sample_fv5.gic'     # GIC file version 5\nelse:\nsavfnam = r'sample.sav'         # SAV file with NO Node Breaker Modeling\ngicfnam = r'sample_fv4.gic'     # GIC file version 4\nexamdir = get_example_folder()\nsavfile = os.path.join(examdir, savfnam)\ngicfile = os.path.join(examdir, gicfnam)\nsid      = 0\nallbus   = 1\noutnam, jnk = os.path.splitext(savfnam)\noutdir   = get_output_dir()\nprg2file = True\nrpt2file = True\nstudy_year = 2019\nearth_model_name = 'SHIELD'\nkwds = {}\nkwds['study_year'] = study_year\nkwds['earth_model_name'] = earth_model_name\nkwds['addfile']  = ''\nkwds['purgfile'] = ''\nfor k, v in optns.items():\nif k=='gicfilevrsn': continue\nkwds[k] = v\nif 'thermal_ana_optn' not in kwds:\nkwds['thermal_ana_optn'] = -1\npsspy.case(savfile)\npsspy.gic_read(gicfile)\nif 'sid_supp' in kwds:\nkwds['sid_supp'] = 4\nareas = [5]\nierr = psspy.bsys(kwds['sid_supp'], numarea=len(areas), areas=areas)\nrun_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds)\n# =========================================================================\ndef run_gicmaps(pygicfile):\nimport arrbox.gicmaps\noutdir   = get_output_dir()\nfpth, nx = os.path.split(pygicfile)\noutnam, fxtn = os.path.splitext(nx)\nif not fpth: pygicfile = os.path.join(outdir, pygicfile)\noutdir_maps = os.path.join(outdir, 'maps')\nif not os.path.exists(outdir_maps): os.mkdir(outdir_maps)\ngicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)\nif gicmapsobj.ierr: return\ngicmapsobj.enable_draw_supp_box()\npngfile = get_output_filename(\"{}_ssflow.png\".format(outnam), outdir_maps)\nsublst = list(gicmapsobj.pygicobj.substation.keys())\ngicmapsobj.annotate_substations(sublst, color='blue', fontsize=10)\nax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(pngfile, markersize=20)\noufile_seg = get_output_filename(\"{}_brnsegments.txt\".format(outnam), outdir_maps)\ngicmapsobj.report_supp_box_line_segments(rptfile=oufile_seg)\noufile_evt = get_output_filename(\"{}_element_events.txt\".format(outnam), outdir_maps)\ngicmapsobj.report_network_element_events(rptfile=oufile_evt)\ngicmapsobj.plots_show()\n# =========================================================================\ndef _template_sample():\n# 1) Benchmark event\n#    No storm scan, No supplemental event, No power flow solution\nrun_test_sample(efield_type='benchmark', gicfilevrsn=5)\n# 2) Supplemental event\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='supplemental', gicfilevrsn=5)\n# 3) Benchmark + Supplemental event"
  },
  {
    "id": "chunk_051",
    "text": "#    Supplemental event defined by subsystem\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4, gicfilevrsn=5)\n# 4) Benchmark + Supplemental event\n#    Supplemental event defined by Moving Box,\n#    Rank substations with maximum GIC flows as center of the moving box\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2, gicfilevrsn=5)\n# 5) Benchmark + Supplemental event\n#    Supplemental event defined by Moving Box,\n#    Rank transformers with maximum GIC flows as center of the moving box\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2, gicfilevrsn=5)\n# 6) Benchmark + Supplemental event\n#    Supplemental event defined by Moving Box,\n#    Use substation number provided as center of the moving box\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10, gicfilevrsn=5)\n# 7) Benchmark + Supplemental event\n#    Supplemental event defined by Moving Box,\n#    Use location provided as center of the moving box\n#    No storm scan, No power flow solution\nrun_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0, gicfilevrsn=5)\n# 8) Benchmark + Supplemental event\n#    Supplemental event defined by Moving Box,\n#    Rank substations with maximum GIC flows as center of the moving box\n#    Degree Scan with specified settings [step=1 deg, add Qloss in steps of 100%]\n#    FDNS - run PowerFlow for each scan step\n#       Number of degree scans = 1+ 180/degscan_step = 181\n#       Number PF due % Qstep = 100/pf_qpct_step = 5\n#       Number PF due to moving boxes = supp_box_num = 20\n#    Number of GIC calculations = 181 (for ranking) + 181*20 (one each supp box) = 3801\n#    Number of PF solved = 181*20*5 = 18100\n##    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,\n##                    scan_storm_event=\"scan_deg\", power_flow_optn='fdns',\n##                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20,\n##                    gicfilevrsn=5)\nprint(\" all done - _template_sample\")\n# =========================================================================\ndef _run_one_test_api():\n# Just run one of these calls as desired.\nrun_test_sample(efield_type='benchmark')\nrun_test_sample(efield_type='benchmark', gicfilevrsn=5)\nrun_test_sample(efield_type='benchmark', gicfilevrsn=4)\nrun_test_sample(efield_type='supplemental')\nrun_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4)\nrun_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2)\nrun_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2)\nrun_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10)\nrun_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0)\nrun_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,\nscan_storm_event=\"scan_deg\", power_flow_optn='fdns',\ndegscan_pf_optn=1, degscan_step=1, pf_qpct_step=20)\n# Creat a function similar to \"run_test_sample(..)\"\n# - to use any power flow study cases\n# - define common arguments\n# - output directory etc\n# Then use that function to run the GIC study of interest.\n# =========================================================================\ndef _run_one_test_maps():\n# Just run one of these calls as desired.\n# The 'pygic' files created by tests in \"_run_one_test_api\" serve as input\n# for these tests.\nrun_gicmaps(r\"sample_b+s_sid_bseg0_map(deg)-oldVrsn.pygic\")\nrun_gicmaps(r\"sample_b_map(deg).pygic\")\nrun_gicmaps(r\"sample_s_map(deg).pygic\")\nrun_gicmaps(r\"sample_b+s_sid_bseg0_map(deg).pygic\")\nrun_gicmaps(r\"sample_b+s_optnbx4_bseg0_map(deg).pygic\")\nrun_gicmaps(r\"sample_b+s_optnbx5_bseg0_map(deg).pygic\")\nrun_gicmaps(r\".\\gic_demo_output\\supp_opbx2_numbx2_brnseg0\\sample_b+s_optnbx2_bseg0_map(deg)_supp_box1.pygic\")\nrun_gicmaps(r\".\\gic_demo_output\\supp_opbx2_numbx2_brnseg0\\sample_b+s_optnbx2_bseg0_map(deg)_supp_box2.pygic\")\nrun_gicmaps(r\".\\gic_demo_output\\supp_opbx3_numbx2_brnseg0\\sample_b+s_optnbx3_bseg0_map(deg)_supp_box1.pygic\")\nrun_gicmaps(r\".\\gic_demo_output\\supp_opbx3_numbx2_brnseg0\\sample_b+s_optnbx3_bseg0_map(deg)_supp_box2.pygic\")\n# =========================================================================\nif __name__==\"__main__\":\npass\n#import psse35\n#[gic_report.py]    GIC Analysis in PSSE\n# =====================================================================================================\n'''This is an example file showing how to:\n- Create GIC data file templates in Excel spreadsheets and create GIC data file from those\nExcel spredsheets\n- Perform GIC analysis, post process GIC results, create customized GIC analysis reports\n- Perform GIC analysis, post process GIC results, export GIC analysis results to Excel\n- Map GIC results on network maps\nPython module \"gicdata\" is used for creating GIC data files.\nSee help(gicdata) for details.\nResult retrival Python module \"pssarrays\" is converted to Python package \"arrbox\".\nThis is done to provide object access instead of function access.\nUsing Python package \"arrbox\" it is possible to create multiple objects and compare\nPSSE results.\nNow Python module 'pssarrays' provide aliases to modules in package \"arrbox\".\nGIC related objects 'GIC' and 'GICMAPS' in module 'pssarrays' will work as is (that is\nwithout any code changes in your script). However, better way to access them is from\npackage arrbox as shown in this script.\nSee detailed help on GIC related objects in arrbox as:\nimport arrbox.gic;help(arrbox.gic.GIC)\nimport arrbox.gicmaps;help(arrbox.gicmaps.GICMAPS)\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call funtion\nRun various functions from this file as desired. See notes in _run_one_test(..) (end of this file).\nSee function gic_results_on_network_map_custom(..) to know how you can decorate default plots with\ndata point annotations or any other custom settings.\n---------------------------------------------------------------------------------\nHow to use PSSE and Python modules like numpy, matplotlib, Basemap together?\n(a) In your python script, call following function before any of these modules are imported.\npsspy.set_fpcw_py()\n(b) Call following function before exiting your python script.\npsspy.set_fpcw_psse()\nTo get details why this is needed, get help(..) on either of these functions.\nRefer function gic_results_on_network_map(..) in this script for usage of these functions.\n'''\n# -----------------------------------------------------------------------------------------------------\nimport sys, os, time\n# -----------------------------------------------------------------------------------------------------\n# PSSE version Example folder\ndef get_example_folder():\nimport psspy\npn = os.path.dirname(psspy.__file__)\np, jnk = os.path.split(pn)\nexamdir = os.path.join(p, 'Example')\nreturn examdir\n# -----------------------------------------------------------------------------------------------------\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\noutdir = os.path.join(outdir, 'gic_report_output')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# -----------------------------------------------------------------------------------------------------\ndef get_output_filename(outpath, fname):\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fname)\nreturn retvfile\n# -----------------------------------------------------------------------------------------------------\ndef _get_outfnam_event(pfx, efield_type, efield_mag, efield_deg, scan_storm_event):\nif efield_type=='nonuniform':\noutfnam = r\"{}_{}\".format(pfx, efield_type[0])\nelse:\nif scan_storm_event:\noutfnam = r\"{}_{}_{:g}(mag)_{:g}(deg)_{}\".format(pfx, efield_type[0], efield_mag, efield_deg, scan_storm_event)\nelse:\noutfnam = r\"{}_{}_{:g}(mag)_{:g}(deg)\".format(pfx, efield_type[0], efield_mag, efield_deg)\nreturn outfnam\n# -----------------------------------------------------------------------------------------------------\ndef _get_formatted_real_value(vin):\nif vin<_BIGREL:\nrstr = \"{:12.5f}\".format(vin)\nelse:\nrstr = \"{:12s}\".format(' ')\nreturn rstr\n# -----------------------------------------------------------------------------------------------------\ndef _get_filenam_sfx(areas):\nif areas:\ns_lst = [\"{}\".format(e) for e in areas[:3]]\ns_sfx = \"\".join(s_lst)\nelse:\ns_sfx = 'all'\nreturn s_sfx\n# -----------------------------------------------------------------------------------------------------\ndef create_gicdata_template_sample(datapath=None, outpath=None, areas=[], showexcel=True):\n\"\"\" Create GIC data Excel template using sample.sav file from PSSE Example folder.\n\"\"\"\nimport psspy, gicdata\nf_sfx = _get_filenam_sfx(areas)\nsavfile   = 'sample.sav'\nexcelfile = 'gicdata_sample_template_{}'.format(f_sfx)\nif not datapath: datapath = get_example_folder()\nsavfile = os.path.join(datapath, savfile)\nexcelfile = get_output_filename(outpath, excelfile)\nbasekv    = []\nareas     = areas\nbuses     = []\nowners    = []\nzones     = []\ntielevels = 0\npsspy.psseinit()\nexcelfile = gicdata.template_excel(savfile, excelfile, basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\ntielevels=tielevels, showexcel=showexcel)\nreturn excelfile\n# -----------------------------------------------------------------------------------------------------\ndef transfer_gicdata_sample(datapath=None, outpath=None, areas=[], showexcel=True):\n\"\"\" Transfer GIC data from .gic file into blank GIC data Excel template.\n\"\"\"\nimport psspy, gicdata\nf_sfx = _get_filenam_sfx(areas)\ngicfile_in   = 'sample_fv4.gic'\ntmplfile_in  = 'gicdata_sample_template_{}.xlsx'.format(f_sfx)\nexcelfile_ou = 'gicdata_sample_{}.xlsx'.format(f_sfx)\nif not datapath: datapath = get_example_folder()"
  },
  {
    "id": "chunk_052",
    "text": "gicfile_in   = os.path.join(datapath, gicfile_in)\ntmplfile_in  = get_output_filename(outpath, tmplfile_in)\nexcelfile_ou = get_output_filename(outpath, excelfile_ou)\nshowexcel = showexcel\ndbgout    = False\nprgfile   = None\nxlsfile = gicdata.transfer_data(gicfile_in, tmplfile_in, excelfile_ou,\nshowexcel=showexcel, prgfile=prgfile, dbgout=dbgout)\nreturn xlsfile\n# -----------------------------------------------------------------------------------------------------\ndef gicdata_excel2gicfile(outpath=None, areas=[]):\n\"\"\" Create GIC data text file (.gic) from GIC data Excel file.\n\"\"\"\nimport gicdata\nf_sfx = _get_filenam_sfx(areas)\nexcelfile = 'gicdata_sample_{}.xlsx'.format(f_sfx)\ngicfile = 'gicdata_sample_{}.gic'.format(f_sfx)\nexcelfile = get_output_filename(outpath, excelfile)\ngicfile = get_output_filename(outpath, gicfile)\ngicdata.excel2gicfile(excelfile, gicfile)\nreturn gicfile\n# -----------------------------------------------------------------------------------------------------\ndef gicdata_gicfile2excel(outpath=None, areas=[], showexcel=True):\n\"\"\" Create GIC data Excel file from GIC data text file (.gic).\n\"\"\"\nimport gicdata\nf_sfx = _get_filenam_sfx(areas)\ngicfile = 'gicdata_sample_{}.gic'.format(f_sfx)\nexcelfile = 'gicdata_sample_{}(txt2xl).xlsx'.format(f_sfx)\ngicfile = get_output_filename(outpath, gicfile)\nexcelfile = get_output_filename(outpath, excelfile)\ngicdata.gicfile2excel(gicfile, excelfile, showexcel=showexcel)\nreturn gicfile\n# -----------------------------------------------------------------------------------------------------\ndef gicdata_merge(outpath=None, showexcel=True):\n\"\"\" Merge GIC data Excel files into one GIC data Excel file.\n\"\"\"\nimport gicdata\nflist = ['gicdata_sample_123.xlsx', 'gicdata_sample_456.xlsx']\nxl_list = []\nfor fnam in flist:\nfou = get_output_filename(outpath, fnam)\nxl_list.append(fou)\noutxlnam   = \"merged_sample.xlsx\"\nprgfnam    = \"merged_sample_progress.txt\"\noutexcel = get_output_filename(outpath, outxlnam)\nprgfile  = get_output_filename(outpath, prgfnam)\ndbgout   = False\n#Allowed kwds: outexcel='', showexcel=False, prgfile=None, dbgout=False\nxlsfile = gicdata.merge_data_excel(*xl_list, outexcel=outexcel, showexcel=showexcel,\nprgfile=prgfile, dbgout=dbgout)\nreturn xlsfile\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):\n\"\"\" Use IEEE GIC Test Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.\nReturns results in gicboj.\n\"\"\"\nimport psspy\nimport arrbox.gic\nsavfile = 'ieee_gic_test_case.sav'\ngicfile = 'ieee_gic_test_case.gic'\nif not datapath: datapath = get_example_folder()\nsavfile = os.path.join(datapath, savfile)\ngicfile = os.path.join(datapath, gicfile)\noutdir = get_output_dir(outpath)\nif efield_type=='benchmark':\nefield_mag = 8.0\nelse:\nefield_mag = 1.0\nefield_deg = 0.0\noutfnam   = _get_outfnam_event(\"ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\nprgfile   = os.path.join(outdir, outfnam+'progress.txt')\npygicfile = os.path.join(outdir, outfnam+'_map.pygic')\ngictfile  = os.path.join(outdir, outfnam+'_gict.csv')\nejet_million_amps = 1.0\nejet_halfwidth_km = 200.0\nejet_period_min   = 5.0\nejet_height_km    = 100.0\nejet_center_deg   = 54.0\nearth_model_name = 'shield'\nefield_unit      = 'V/km'\nsubstation_r     = 0.1\nbranch_xbyr      = 30.0\ntransformer_xbyr = 30.0\naddfile          = ''\naddfile_optn     = 'rdch'\npurgfile         = ''\nrnwkfile         = ''\nbasekv    = []  # specify subsystem options\nareas     = []\nbuses     = []\nowners    = []\nzones     = []\ntielevels = 0\npower_flow_optn  = ''   # specify power flow solution options\npf_itmxn   = 100\npf_toln    = 0.1\npf_tap     = 0\npf_area    = 0\npf_phshft  = 0\npf_dctap   = 1\npf_swsh    = 1\npf_flat    = 0\npf_varlmt  = 99\npf_nondiv  = 0\npsspy.psseinit()\npsspy.lines_per_page_one_device(1,10000000)\npsspy.progress_output(2,prgfile,[0,0])\npsspy.alert_output(2,prgfile,[0,0])\npsspy.case(savfile)\npsspy.gic_read(gicfile)\nsid = 0\nbusall = 1\n# run gic analysis\ngicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,\ntielevels=tielevels, study_year=0, thermal_ana_optn=-1,\nsubstation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,\nefield_mag_local=0.0, efield_deg_local=0.0,\nbranch_rac2rdc=1.0, transformer_rac2rdc=1.0,\nefield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,\ngic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,\npower_flow_optn=power_flow_optn,\nejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,\nejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,\naddfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,\nbasekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\nbasekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],\npf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,\npf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,\npf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,\npf_nondiv=pf_nondiv,\n)\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,\"\",[0,0])\npsspy.alert_output(1,\"\",[0,0])\nreturn gicobj\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):\n\"\"\" Use sample Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.\nReturns results in gicboj.\n\"\"\"\nimport psspy\nimport arrbox.gic\nsavfile = 'sample.sav'\ngicfile = 'sample_fv4.gic'\noutdir = get_output_dir(outpath)\nif not datapath: datapath = get_example_folder()\nsavfile = os.path.join(datapath, savfile)\ngicfile = os.path.join(datapath, gicfile)\nif efield_type=='benchmark':\nefield_mag = 8.0\nelse:\nefield_mag = 1.0\nefield_deg = 0.0\noutfnam   = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\nprgfile   = os.path.join(outdir, outfnam+'progress.txt')\npygicfile = os.path.join(outdir, outfnam+'_map.pygic')\ngictfile  = os.path.join(outdir, outfnam+'_gict.csv')\nejet_million_amps = 1.0\nejet_halfwidth_km = 200.0\nejet_period_min   = 5.0\nejet_height_km    = 100.0\nejet_center_deg   = 54.0\nearth_model_name = 'shield'\nefield_unit      = 'V/km'\nsubstation_r     = 0.1\nbranch_xbyr      = 30.0\ntransformer_xbyr = 30.0\naddfile          = ''\naddfile_optn     = 'rdch'\npurgfile         = ''\nrnwkfile         = ''\nbasekv    = []  # specify subsystem options\nareas     = []\nbuses     = []\nowners    = []\nzones     = []\ntielevels = 0\npf_itmxn   = 100    # specify power flow solution options\npf_toln    = 0.1\npf_tap     = 0\npf_area    = 0\npf_phshft  = 0\npf_dctap   = 1\npf_swsh    = 1\npf_flat    = 0\npf_varlmt  = 99\npf_nondiv  = 0\npsspy.psseinit()\npsspy.lines_per_page_one_device(1,10000000)\npsspy.progress_output(2,prgfile,[0,0])\nprint(savfile)\nprint(gicfile)\npsspy.case(savfile)\npsspy.gic_read(gicfile)\nsid = 0\nbusall = 1\n# run gic analysis\ngicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,\ntielevels=tielevels, study_year=0, thermal_ana_optn=-1,\nsubstation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,\nefield_mag_local=0.0, efield_deg_local=0.0,\nbranch_rac2rdc=1.0, transformer_rac2rdc=1.0,\nefield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,\ngic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,\npower_flow_optn=power_flow_optn,\nejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,\nejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,\naddfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,\nbasekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,\nbasekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],\npf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,\npf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,\npf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,\npf_nondiv=pf_nondiv,\n)\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,\"\",[0,0])\nreturn gicobj\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):\n\"\"\" Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and create text report.\n\"\"\"\ngicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\nif gicobj.ierr: return\noutdir = get_output_dir(outpath)\nrptnam = _get_outfnam_event(\"ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\nrptfile  = os.path.join(outdir, rptnam+'.txt')\nqrptfile = os.path.join(outdir, rptnam+'_qloss.txt')\ngicobj.text_report(rptfile)\ngicobj.qtotal_report(qrptfile)\nmsg = \" Report created in file: {:s}\".format(rptfile)\nprint(msg)\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_ieee_text_report_DIY(datapath=None, outpath=None):\n\"\"\" Run GIC Analysis on IEEE GIC Test Case provided in PSSE Example folder and create customized report.\n\"\"\"\nglobal _BIGREL\nimport psspy\n_BIGREL = psspy.getdefaultreal()     # Largest real value\nefield_mag = 1.0\nefield_deg = 0.0\nefield_type = 'uniform'\nscan_storm_event = ''\ngicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\nif gicobj.ierr: return\noutdir = get_output_dir(outpath)\nrptnam = _get_outfnam_event(\"DIY_ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\nrptfile = os.path.join(outdir, rptnam+'.txt')\nrptfobj = open(rptfile, 'w')\nreport  = rptfobj.write\nelecfld_mag = \"{:10.2f}\".format(gicobj.misc.efield_mag)\nelecfld_mag = elecfld_mag.strip()\nelecfld_unt = gicobj.misc.efield_unit\nelecfld_deg = \"{:10.2f}\".format(gicobj.misc.efield_deg)\nelecfld_deg = elecfld_deg.strip()\ntxt  = \"\\n GMD Event: Uniform Electric Field, {} {}, {} deg\\n\".format(elecfld_mag, elecfld_unt, elecfld_deg)\ntxt += \"\\n GIC data file: {}\\n\".format(gicobj.gicfile)\ntxt += \" Power flow data file: {}\\n\".format(gicobj.savfile)\nif gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:\ntxt += \"\\n Subsystem used for GIC studiies is defined as:\\n\"\nif gicobj.basekv: txt += \"     Voltage = {}\\n\".format(str(gicobj.basekv))\nif gicobj.areas:  txt += \"     Areas   = {}\\n\".format(str(gicobj.areas))\nif gicobj.buses:  txt += \"     Buses   = {}\\n\".format(str(gicobj.buses))\nif gicobj.owners: txt += \"     Owners  = {}\\n\".format(str(gicobj.owners))\nif gicobj.zones:  txt += \"     Zones   = {}\\n\".format(str(gicobj.zones))\ntxt += \"     Subsystem Inter tie Levels = {}\\n\".format(gicobj.tielevels)\nelse:\ntxt += \"\\n Subsystem used for GIC studiies comprises entire network.\\n\"\ntxt += \"\\n Number of buses in study subsystem        = {}\\n\".format(gicobj.misc.nbus_study)\ntxt += \" Number of substations in study subsystem  = {}\\n\".format(gicobj.misc.nsubstation_study)"
  },
  {
    "id": "chunk_053",
    "text": "txt += \" Number of branches in study subsystem     = {}\\n\".format(gicobj.misc.nbranch_study)\ntxt += \" Number of transformers in study subsystem = {}\\n\".format(gicobj.misc.ntransformer_study)\nreport(txt)\ntxt  = '\\n Bus DC Voltages\\n'\ntxt += \"    Bus Substation DC Voltage(V)\\n\"\nreport(txt)\nbuslist = list(gicobj.bus.keys())\nbuslist.sort()\nfor eachbus in buslist:\n# all of these work, shows how to use them\n#print \"attr lower-->\", eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts\n#print \"dict lower-->\", eachbus, gicobj.bus[eachbus]['substation'], gicobj.bus[eachbus]['dcvolts']\n#print \"attr mixed-->\", eachbus, gicobj.bus[eachbus].suBSTation, gicobj.bus[eachbus].dcVolts\n#print \"dict mixed-->\", eachbus, gicobj.bus[eachbus]['subStation'], gicobj.bus[eachbus]['DCvolts']\ntxt = \" {:6d}     {:6d}  {:12.5f}\\n\".format(eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts)\nreport(txt)\ntxt  = '\\n Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground\\n'\ntxt += \" Substation Name         Latitude(deg) Longitude(deg) DC Voltage(V)    GIC(Amps)\\n\"\nreport(txt)\nsslist = list(gicobj.substation.keys())\nsslist.sort()\nfor ss in sslist:\ntxt = \"     {:6d} {:12s}  {:12.6f}   {:12.6f}  {:12.5f} {:12.5f}\\n\".format(ss, gicobj.substation[ss].name,\ngicobj.substation[ss].latitude, gicobj.substation[ss].longitude,\ngicobj.substation[ss].dcvolts, gicobj.substation[ss].gic)\nreport(txt)\n# Non-Transformer Branches\ntxt  = '\\n GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus\\n'\ntxt += \" FromBus  ToBus Ckt  Distance(km) per-Phase(A)   3-Phase(A)\\n\"\nreport(txt)\nbrnlist = list(gicobj.branch.keys())\nbrnlist.sort()\nfor brn in brnlist:\ntxt = \"  {:6d} {:6d}  {:2s}  {:12.5f} {:12.5f} {:12.5f}\\n\".format(brn[0], brn[1], brn[2],\ngicobj.branch[brn].distance, gicobj.branch[brn].gic,\n3*gicobj.branch[brn].gic)\nreport(txt)\n# Transformers\ntrnlist = list(gicobj.transformer.keys())\ntrnlist.sort()\nno_2wdg_nrml = \"\\n     No two winding transformers in GIC studied network.\\n\"\nno_2wdg_auto = \"\\n     No two winding auto transformers in GIC studied network.\\n\"\nno_3wdg_nrml = \"\\n     No three winding transformers in GIC studied network.\\n\"\nno_3wdg_auto = \"\\n     No three winding auto transformers in GIC studied network.\\n\"\n# Two Winding Transformers - normal\ntxt  = '\\n Two Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\ntxt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\ntxt += \"   Ibus   Jbus Ckt       Igic(A)      Jgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\nreport(txt)\nfor trn in trnlist:\nkbus  = trn[2]\nif kbus: continue\nautoi = gicobj.transformer[trn].wdg1_auto\nautoj = gicobj.transformer[trn].wdg2_auto\nif (autoi or autoj): continue\nigic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\njgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\neffgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\nqloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\nkftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\ntxt = \" {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(trn[0], trn[1], trn[3], igic, jgic, effgic,\ngicobj.transformer[trn].kfactor, kftrtyp, qloss)\nreport(txt)\nif no_2wdg_nrml: no_2wdg_nrml=''\nif no_2wdg_nrml: report(no_2wdg_nrml)\n# Two Winding Transformers - auto\ntxt  = '\\n Two Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\ntxt += \" Reactive power loss, represented as constant current load on Series Winding bus in power flow\\n\"\ntxt += \" Common Series Ckt Common gic(A) Series gic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\nreport(txt)\nfor trn in trnlist:\nkbus  = trn[2]\nif kbus: continue\nautoi = gicobj.transformer[trn].wdg1_auto\nautoj = gicobj.transformer[trn].wdg2_auto\nif ( (not autoi) or (not autoj) ): continue\nif autoi==1:\nibus = trn[0]\njbus = trn[1]\nelse:\nibus = trn[1]\njbus = trn[0]\nigic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\njgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\neffgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\nqloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\nkftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\ntxt = \" {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(ibus, jbus, trn[3], igic, jgic, effgic,\ngicobj.transformer[trn].kfactor, kftrtyp, qloss)\nreport(txt)\nif no_2wdg_auto: no_2wdg_auto=''\nif no_2wdg_auto: report(no_2wdg_auto)\n# Three Winding Transformers - normal\ntxt  = '\\n Three Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\ntxt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\ntxt += \"   Ibus   Jbus   Kbus Ckt       Igic(A)      Jgic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\nreport(txt)\nfor trn in trnlist:\nkbus  = trn[2]\nif not kbus: continue\nautoi = gicobj.transformer[trn].wdg1_auto\nautoj = gicobj.transformer[trn].wdg2_auto\nautok = gicobj.transformer[trn].wdg3_auto\nif (autoi or autoj or autok): continue\nigic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\njgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\nkgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)\neffgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\nqloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\nkftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\ntxt = \" {:6d} {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(trn[0], trn[1], trn[2], trn[3], igic, jgic, kgic, effgic,\ngicobj.transformer[trn].kfactor, kftrtyp, qloss)\nreport(txt)\nif no_3wdg_nrml: no_3wdg_nrml=''\nif no_3wdg_nrml: report(no_3wdg_nrml)\n# Three Winding Transformers - auto\ntxt  = '\\n Three Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\\n'\ntxt += \" Reactive power loss, represented as constant current load on highest voltage bus in power flow\\n\"\ntxt += \" Common Series   Kbus Ckt Common gic(A) Series gic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\\n\"\nreport(txt)\nfor trn in trnlist:\nkbus  = trn[2]\nif not kbus: continue\nautoi = gicobj.transformer[trn].wdg1_auto\nautoj = gicobj.transformer[trn].wdg2_auto\nif ( (not autoi) or (not autoj) ): continue\nif autoi==1:\nibus = trn[0]\njbus = trn[1]\nelse:\nibus = trn[1]\njbus = trn[0]\nigic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)\njgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)\nkgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)\neffgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)\nqloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)\nkftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\ntxt = \" {:6d} {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\\n\".format(ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic,\ngicobj.transformer[trn].kfactor, kftrtyp, qloss)\nreport(txt)\nif no_3wdg_auto: no_3wdg_auto=''\nif no_3wdg_auto: report(no_3wdg_auto)\n# Total Qloss\nif no_2wdg_nrml:\nqwdg2_nrml = '        None'\nelse:\nqwdg2_nrml = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg2_normal)\nif no_2wdg_auto:\nqwdg2_auto = '        None'\nelse:\nqwdg2_auto = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg2_auto)\nif no_3wdg_nrml:\nqwdg3_nrml = '        None'\nelse:\nqwdg3_nrml = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg3_normal)\nif no_3wdg_auto:\nqwdg3_auto = '        None'\nelse:\nqwdg3_auto = \"{:12.5f} Mvar\".format(gicobj.qtotal.wdg3_auto)\ntxt  = '\\n Transformer Reactive Power Loss Summary\\n'\ntxt += ' Two Winding Transformers        = {:s}\\n'.format(qwdg2_nrml)\ntxt += ' Two Winding Auto Transformers   = {:s}\\n'.format(qwdg2_auto)\ntxt += ' Three Winding Transformers      = {:s}\\n'.format(qwdg3_nrml)\ntxt += ' Three Winding Auto Transformers = {:s}\\n'.format(qwdg3_auto)\ntxt += '                           Total = {:12.5f} Mvar\\n'.format(gicobj.qtotal.total)\nreport(txt)\n# done - close report file\nif rptfile:\nrptfobj.close()\ntxt = \"\\n GIC analysis output report saved to file: {:s}\\n\".format(rptfile)\nsys.stdout.write(txt)\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_ieee_excel_export_DIY(datapath=None, outpath=None, show=True):\n\"\"\" Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.\n\"\"\"\nimport psspy\nimport excelpy\n_BIGREL = psspy.getdefaultreal()     # Largest real value\nefield_mag = 1.0\nefield_deg = 0.0\nefield_type = 'uniform'\nscan_storm_event = ''\ngicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)\nif gicobj.ierr: return\noutdir = get_output_dir(outpath)\nrptnam = _get_outfnam_event(\"DIY_ieee\", efield_type, efield_mag, efield_deg, scan_storm_event)\nxlsfile = os.path.join(outdir, rptnam)\n# What to export?\noverwritesheet = True\ndo_sheets = ['optn', 'bus', 'sub', 'brn', 'trn']\n_EXPORT_QTY_GIC   = {\n'optn': 'options'     ,\n'bus' : 'bus'         ,\n'sub' : 'substation'  ,"
  },
  {
    "id": "chunk_054",
    "text": "'brn' : 'branch'      ,\n'trn' : 'transformer' ,\n}\n_WORKSHT_SEQ_GIC = ['optn','bus','sub','brn','trn']\n_WORKSHT_COLUMN_LABELS_GIC = {\n'bus': ['Bus', 'Substation', 'DC Voltage(V)'],\n'sub': ['Substation', 'Name', 'Latitude(deg)', 'Longitude(deg)', 'DC Voltage(V)', 'GIC(Amps)'],\n'brn': ['FromBus', 'ToBus', 'Ckt', 'Distance(km)', 'per-Phase(A)', '3-Phase(A)'],\n'trn_nrml': ['Ibus', 'Jbus', 'Kbus', 'Ckt', 'Igic(A)', 'Jgic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],\n'trn_auto': ['Common', 'Series', 'Kbus', 'Ckt', 'Common gic(A)', 'Series gic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],\n}\n_WORKSHT_INFO_TXT_GIC = {\n'bus': ['Bus DC Voltages'],\n'sub': ['Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground'],\n'brn': ['GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus'],\n'trn_nrml': ['Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',\n'Reactive power loss, represented as constant current load on highest voltage bus in power flow'],\n'trn_auto': ['Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',\n'Reactive power loss, represented as constant current load on Series Winding bus in power flow'],\n}\ngicshts = []\nfor each in _WORKSHT_SEQ_GIC:\nif each in do_sheets:\nif each=='trn':\ngicshts.extend( [ _EXPORT_QTY_GIC[each], 'auto '+_EXPORT_QTY_GIC[each] ] )\nelse:\ngicshts.append(_EXPORT_QTY_GIC[each])\nfor i, shtnam in enumerate(gicshts):\nif i==0:\nxlsobj = excelpy.workbook(xlsfile, shtnam, overwritesheet=overwritesheet)\nif show:\nxlsobj.show()\nelse:\nxlsobj.hide()\nxlsobj.show_alerts(0) # do not show pop-up alerts\nxlsfnam = xlsobj.XLSFNAM\nelse:\nxlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)\nxlsobj.page_format(orientation=\"landscape\",left=1.0,right=1.0,\ntop=0.5,bottom=0.5,header=0.25,footer=0.25)\nxlsobj.page_footer(left='page number of page total', right='date, time')\nxlsobj.page_header(center='file name:sheet name')\nxlsobj.font_sheet()\nif not xlsobj:\nprint(\"Excel file and worksheets not created.\\n\")\n# Options\ndo_key = 'optn'\nif do_key in do_sheets:\nelecfld_mag = \"{:10.2f}\".format(gicobj.misc.efield_mag)\nelecfld_mag = elecfld_mag.strip()\nelecfld_unt = gicobj.misc.efield_unit\nelecfld_deg = \"{:10.2f}\".format(gicobj.misc.efield_deg)\nelecfld_deg = elecfld_deg.strip()\ntxt  = \"\\n GMD Event: Uniform Electric Field, {:s} {:s}, {:s} deg\\n\".format(elecfld_mag, elecfld_unt, elecfld_deg)\ntxt += \"\\n GIC data file: {:s}\\n\".format(gicobj.gicfile)\ntxt += \" Power flow data file: {:s}\\n\".format(gicobj.savfile)\nif gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:\ntxt += \"\\n Subsystem used for GIC studies is defined as:\\n\"\nif gicobj.basekv: txt += \"     Voltage = {:s}\\n\".format(str(gicobj.basekv))\nif gicobj.areas:  txt += \"     Areas   = {:s}\\n\".format(str(gicobj.areas))\nif gicobj.buses:  txt += \"     Buses   = {:s}\\n\".format(str(gicobj.buses))\nif gicobj.owners: txt += \"     Owners  = {:s}\\n\".format(str(gicobj.owners))\nif gicobj.zones:  txt += \"     Zones   = {:s}\\n\".format(str(gicobj.zones))\ntxt += \"     Subsystem Inter tie Levels = {:d}\\n\".format(gicobj.tielevels)\nelse:\ntxt += \"\\n Subsystem used for GIC studies comprises entire network.\\n\"\ntxt += \"\\n Number of buses in study subsystem        = {:d}\\n\".format(gicobj.misc.nbus_study)\ntxt += \" Number of substations in study subsystem  = {:d}\\n\".format(gicobj.misc.nsubstation_study)\ntxt += \" Number of branches in study subsystem     = {:d}\\n\".format(gicobj.misc.nbranch_study)\ntxt += \" Number of transformers in study subsystem = {:d}\\n\".format(gicobj.misc.ntransformer_study)\noptnlist = txt.split(\"\\n\")\nxlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\nbr, rc = 1, 1\nbr, rc = xlsobj.set_range(br, rc, optnlist, transpose=True)\n# DC Bus voltages\ndo_key = 'bus'\nif do_key in do_sheets:\nbuslist = list(gicobj.bus.keys())\nbuslist.sort()\nrowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\nfor eachbus in buslist:\ntlst = [eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts]\nrowdata.append(tlst)\nxlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\nbr0, rc0 = 3, 1\nbr, rc = xlsobj.set_range(br0, rc0, rowdata)\ndel rowdata\nxlsobj.autofit_columns((br0,rc0,br0,rc))\nxlsobj.font_color((br0,rc0,br0,rc),\"red\")\nxlsobj.align_rows((br0, rc0),alignv='right')    #label row\nxlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n# Substation\ndo_key = 'sub'\nif do_key in do_sheets:\nsslist = list(gicobj.substation.keys())\nsslist.sort()\nrowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\nfor ss in sslist:\ntlst = [ss, gicobj.substation[ss].name, gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,\ngicobj.substation[ss].dcvolts, gicobj.substation[ss].gic]\nrowdata.append(tlst)\nxlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\nbr0, rc0 = 3, 1\nbr, rc = xlsobj.set_range(br0, rc0, rowdata)\ndel rowdata\nxlsobj.autofit_columns((br0,rc0,br0,rc))\nxlsobj.font_color((br0,rc0,br0,rc),\"red\")\nxlsobj.align_rows((br0, rc0),alignv='right')    #label row\nxlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n# Non-Transformer Branches\ndo_key = 'brn'\nif do_key in do_sheets:\nbrnlist = list(gicobj.branch.keys())\nbrnlist.sort()\nrowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]\nfor brn in brnlist:\ntlst = [brn[0], brn[1], brn[2], gicobj.branch[brn].distance, gicobj.branch[brn].gic,3*gicobj.branch[brn].gic]\nrowdata.append(tlst)\nxlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\nbr0, rc0 = 3, 1\nbr, rc = xlsobj.set_range(br0, rc0, rowdata)\ndel rowdata\nxlsobj.autofit_columns((br0,rc0,br0,rc))\nxlsobj.font_color((br0,rc0,br0,rc),\"red\")\nxlsobj.align_rows((br0, rc0),alignv='right')    #label row\nxlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\n# Transformers\ndo_key = 'trn'\nif do_key in do_sheets:\ndo_key_nrml = 'trn_nrml'\ndo_key_auto = 'trn_auto'\ntrnlist = list(gicobj.transformer.keys())\ntrnlist.sort()\nrowdata_nrml = [_WORKSHT_COLUMN_LABELS_GIC[do_key_nrml]]\nrowdata_auto = [_WORKSHT_COLUMN_LABELS_GIC[do_key_auto]]\nfor trn in trnlist:\nkbus  = trn[2]\nigic  = gicobj.transformer[trn].wdg1_gic\njgic  = gicobj.transformer[trn].wdg2_gic\nif kbus:\nkgic = gicobj.transformer[trn].wdg3_gic\nelse:\nkgic = None\neffgic  = gicobj.transformer[trn].eff_gic\nqloss   = gicobj.transformer[trn].qloss\nkftr    = gicobj.transformer[trn].kfactor\nkftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)\nautoi = gicobj.transformer[trn].wdg1_auto\nautoj = gicobj.transformer[trn].wdg2_auto\nif autoi or autoj:\nif autoi==1:\nibus = trn[0]\njbus = trn[1]\nelse:\nibus = trn[1]\njbus = trn[0]\nelse:\nibus = trn[0]\njbus = trn[1]\nif igic:\nif igic>=_BIGREL: igic = ''\nelse:\nigic = ''\nif jgic:\nif jgic>=_BIGREL: jgic = ''\nelse:\njgic = ''\nif kgic:\nif kgic>=_BIGREL: kgic = ''\nelse:\nkgic = ''\nif effgic:\nif effgic>=_BIGREL: effgic = ''\nelse:\neffgic = ''\nif qloss:\nif qloss>=_BIGREL: qloss = ''\nelse:\nqloss = ''\ntlst = [ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic, kftr, kftrtyp, qloss]\nif autoi or autoj:\nrowdata_auto.append(tlst)\nelse:\nrowdata_nrml.append(tlst)\n# Total Qloss\ntxt  = ' Transformer Reactive Power Loss Summary\\n'\ntxt += ' Two Winding Transformers        = {:g} Mvar\\n' .format(gicobj.qtotal.wdg2_normal)\ntxt += ' Two Winding Auto Transformers   = {:g} Mvar\\n' .format(gicobj.qtotal.wdg2_auto)\ntxt += ' Three Winding Transformers      = {:g} Mvar\\n' .format(gicobj.qtotal.wdg3_normal)\ntxt += ' Three Winding Auto Transformers = {:g} Mvar\\n' .format(gicobj.qtotal.wdg3_auto)\ntxt += '                           Total = {:g} Mvar'   .format(gicobj.qtotal.total)\nqlosslist = txt.split(\"\\n\")\n# normal transformers\nxlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])\nbr0, rc0 = 4, 1\nbr, rc = xlsobj.set_range(br0, rc0, rowdata_nrml)\ndel rowdata_nrml\nxlsobj.autofit_columns((br0,rc0,br0,rc))\nxlsobj.font_color((br0,rc0,br0,rc),\"red\")\nxlsobj.align_rows((br0, rc0),alignv='right')    #label row\nxlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\nxlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][1],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\nbr, rc = br+2, 1\nbr, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)\n# auto transformers\nxlsobj.set_active_sheet('auto '+_EXPORT_QTY_GIC[do_key])\nbr0, rc0 = 4, 1\nbr, rc = xlsobj.set_range(br0, rc0, rowdata_auto)\ndel rowdata_auto\nxlsobj.autofit_columns((br0,rc0,br0,rc))\nxlsobj.font_color((br0,rc0,br0,rc),\"red\")\nxlsobj.align_rows((br0, rc0),alignv='right')    #label row\nxlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][0],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\nxlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][1],fontStyle=\"bold\",fontSize=12, fontColor=\"blue\")\nbr, rc = br+2, 1\nbr, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)\n# done exporting\nxlsobj.save(xlsfile)\nif not show:\ntxt = \"\\n GIC analysis output report saved to file: \\n    {0}\\n\".format(xlsobj.XLSFNAM)\nxlsobj.close()\nsys.stdout.write(txt)\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_sample_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):\n\"\"\" Use sample Case provided in PSSE Example folder, run GIC calculations and create text report.\n\"\"\"\ngicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)\nif gicobj.ierr: return\noutdir = get_output_dir(outpath)\nrptnam = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\nif power_flow_optn:  rptnam += '_pf'\nrptfile  = os.path.join(outdir, rptnam+'.txt')\nqrptfile = os.path.join(outdir, rptnam+'_qloss.txt')\ngicobj.text_report(rptfile)\ngicobj.qtotal_report(qrptfile)\nmsg = \"\\n Report created in file: {:s}\".format(rptfile)\nprint(msg)\n# -----------------------------------------------------------------------------------------------------\ndef run_gic_sample_excel_export(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, show=True,\ndatapath=None, outpath=None):\n\"\"\" Use sample Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet."
  },
  {
    "id": "chunk_055",
    "text": "\"\"\"\ngicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)\nif gicobj.ierr: return\noutdir = get_output_dir(outpath)\nrptnam = _get_outfnam_event(\"sample\", efield_type, efield_mag, efield_deg, scan_storm_event)\nif power_flow_optn:  rptnam += '_pf'\nxlfile = os.path.join(outdir, rptnam)\nstring = ''\noverwritesheet = True\nxlfile = gicobj.excel_export(string, xlfile, show, overwritesheet)\nmsg = \"\\n Spreadsheet created in file:\\n    {0}\".format(xlfile)\nprint(msg)\n# -----------------------------------------------------------------------------------------------------\ndef gic_results_on_network_map(pygicfile, outpath=None, outfext='.pdf', show=True):\n\"\"\" Plot GIC results on map.\n\"\"\"\nimport collections\nimport psspy\npsspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.\nimport arrbox.gicmaps\noutdir = get_output_dir(outpath)\np, nx = os.path.split(pygicfile)\npyfnam, x = os.path.splitext(nx)\nif not p:\nif not os.path.exists(pygicfile):\npygicfile = os.path.join(outdir, pygicfile)\npltfiles = collections.OrderedDict()\nfor k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',\n'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:\nif outfext=='.pdf':\npltfiles[k] = None\nelse:\nfnam = \"{}_{}{}\".format(pyfnam, k, outfext)\npltfiles[k] = os.path.join(outdir, fnam)\ngicmapsobj  = arrbox.gicmaps.GICMAPS(pygicfile)\nif gicmapsobj.ierr: return\nif outfext=='.pdf':\nfnam = \"{}_allplots{}\".format(pyfnam, outfext)\npdffile = os.path.join(outdir, fnam)\ngicmapsobj.pdf_open(pdffile)\ngicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_base'], case='base', limit='min', markersize=100)\ngicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_gic'], case='gic', limit='min', markersize=100)\n# combine substations GICs flowing in and out on one legend\ngicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic1'], markersize=20)\n# separate substations GICs flowing in and out on two legends\ngicmapsobj.set_legend_options_ss_gic_values(loc=None)\ngicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic2'], markersize=20)\ngicmapsobj.plot_branch_gicflows(figfile=pltfiles['brngic'])\ngicmapsobj.plot_qtotal(figfile=pltfiles['qtline'])\ngicmapsobj.plot_qtotal_barchart(figfile=pltfiles['qtbar'])\ngicmapsobj.plot_effgic(figfile=pltfiles['effgic'], gicmax=False)\ngicmapsobj.plot_effgic(figfile=pltfiles['effgicmax'], gicmax=True)\nif show:\ngicmapsobj.plots_show()\nelse:\ngicmapsobj.plots_close()\nif outfext=='.pdf':\ngicmapsobj.pdf_close()\nif outfext=='.pdf':\nmsg  = \"\\n GIC analysis custom plots saved in file:\\n    {}\\n\".format(pdffile)\nelse:\nmsg  = \"\\n GIC analysis custom plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\nprint(msg)\npsspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.\n# -----------------------------------------------------------------------------------------------------\ndef gic_results_on_network_map_custom(pygicfile, outpath=None, outfext='.pdf', show=True):\n\"\"\" Plot GIC results on map with custom legends, annotations.\n\"\"\"\nimport collections\nimport psspy\npsspy.set_fpcw_py()\nimport arrbox.gicmaps\noutdir = get_output_dir(outpath)\np, nx = os.path.split(pygicfile)\npyfnam, x = os.path.splitext(nx)\nif not p:\nif not os.path.exists(pygicfile):\npygicfile = os.path.join(outdir, pygicfile)\noutnam  = '{}_custom'.format(pyfnam)\npltfiles = collections.OrderedDict()\nfor k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',\n'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:\nif outfext!='.pdf':\nfnam = \"{}_{}{}\".format(outnam, k, outfext)\npltfiles[k] = os.path.join(outdir, fnam)\ngicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)\nif gicmapsobj.ierr: return\nif outfext=='.pdf':\nfnam = \"{}_allplots{}\".format(outnam, outfext)\npdffile = os.path.join(outdir, fnam)\npdf2fobj = gicmapsobj.pdf2_open(pdffile)  # open pdf2 object to save custom plots to pdf file\ngicmapsobj.set_figure_size(6,4.8)\ngicmapsobj.set_state_boundary_options(show=True, color='#CCCCCC', linewidth=1.0)\ngicmapsobj.set_latitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 1], fontsize=10)\ngicmapsobj.set_longitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 3], fontsize=10)\ngicmapsobj.annotate_substations([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], color='blue', fontsize=10)\n# Plot1 - GIC case bus voltage\npf_flag = gicmapsobj.pygicobj.power_flow_solution_flag\nif pf_flag==0:\ncase = 'gic'\nif outfext!='.pdf': figfile = pltfiles['busvpu_gic']\nttl = 'Bus Voltages - GIC Case'\nelse:\ncase = 'base'\nif outfext!='.pdf': figfile = pltfiles['busvpu_base']\nttl = 'Bus Voltages - Base Case'\nax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None, case=case, limit='min', markersize=100,\ntitle=ttl)\nif ax is None:\nif outfext=='.pdf':\ngicmapsobj.pdf_close()\nreturn\n# data point annotation\nanptobj.set_options(xytext=(-15,-40), textcoords='offset points')\nanptobj.set_annote_from_key(5)                          # use SS number as key\n#anptobj.set_annote_from_key('ss05_mississippi')        # use SS name as key\nanptobj.set_options(xytext=(-40,-100), textcoords='offset points')\nanptobj.set_annote_from_key(7)                          # use SS number as key\n#anptobj.set_annote_from_key('ss07_yukon')\nanptobj.set_options(xytext=(-20,25), textcoords='offset points')\nanptobj.set_annote_from_key(13)                         # use SS number as key\n#anptobj.set_annote_from_key('ss13_oxus')               # use SS number as key\nanptobj.set_options(xytext=(-40,25), textcoords='offset points')\n#anptobj.set_annote_from_key(15)                        # use SS number as key\nanptobj.set_annote_from_key('ss15_heilong')             # use SS number as key\n# custom annotation\ngicmapsobj.annotate_text('LabelLeft', -89, 30.2, ax, basemap, xycoords='long_lat', color='cyan', fontsize=15)\nx, y = gicmapsobj.datapoint_xy_from_longitude_latiude(basemap, -84, 30.2)\ngicmapsobj.annotate_text('LabelRight', x, y, ax, basemap, xycoords='data', color='magenta', fontsize=15)\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)               # add custom plot to pdf file\nelse:\nfig.savefig(figfile, dpi=300, bbox_inches='tight')   # save custom plot to file\n# Plot2 - Base case bus voltage\nif pf_flag==0:\nax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None,  case='base', limit='min', markersize=100,\ntitle='Bus Voltages - Base Case')\nanptobj.set_options(xytext=(-50,-50), textcoords='offset points')\nanptobj.set_annote_from_key(15)\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)\nelse:\nfig.savefig(pltfiles['busvpu_base'], dpi=300, bbox_inches='tight')\n# Plot3 - substations GICs (combine GICs flowing in and out on one legend)\nax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)\nanptobj.set_options(xytext=(-65,40), textcoords='offset points')\nanptobj.set_annote_from_key('ss01_nile')\nanptobj.set_options(xytext=(-60,-70), textcoords='offset points')\nanptobj.set_annote_from_key('ss02_yangtze')\nanptobj.set_options(xytext=(-60,-70), textcoords='offset points')\nanptobj.set_annote_from_key('ss03_arkansas')\nanptobj.set_options(xytext=(-20,-35), textcoords='offset points')\nanptobj.set_annote_from_key('ss09_indus')\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)\nelse:\nfig.savefig(pltfiles['ssgic1'], dpi=300, bbox_inches='tight')\n# Plot4 - substations GICs (separate GICs flowing in and out on two legends)\ngicmapsobj.set_legend_options_ss_gic_values(loc=None)\nax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)\nanptobj.set_options(xytext=(-50,-50), textcoords='offset points')\nanptobj.set_annote_from_key(1)\nanptobj.set_annote_from_key(3)\nanptobj.set_annote_from_key(8)\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)\nelse:\nfig.savefig(pltfiles['ssgic2'], dpi=300, bbox_inches='tight')\n# Plot5 - Effective GIC\nax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=False)\nanptobj.set_options(xytext=(-30,-30), textcoords='offset points')\nanptobj.set_annote_from_key('catdog_xmer')          # use transformer name as key\nanptobj.set_annote_from_key((3018, 3008, '11'))     # use transformer id tuple: (wdg1bus, wdg2bus, 'ckt')\n# or (wdg1bus, wdg2bus, wdg3bus, 'ckt')\nanptobj.set_options(xytext=(-65,30), textcoords='offset points')\nanptobj.set_annote_from_key((203, 202, 't7'))\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)\nelse:\nfig.savefig(pltfiles['effgic'], dpi=300, bbox_inches='tight')\n# Plot6 - Maximum Effective GIC\nax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=True)\nanptobj.set_options(xytext=(-30,-40), textcoords='offset points')\nanptobj.set_annote_from_key('catdog_xmer')\nanptobj.set_options(xytext=(-30,-60), textcoords='offset points')\nanptobj.set_annote_from_key(('urb tx'))\nanptobj.set_options(xytext=(-10,20), textcoords='offset points')\nanptobj.set_annote_from_key(('mid ltc'))\nif outfext=='.pdf':\ngicmapsobj.pdf2_add_figure(pdf2fobj, fig)\nelse:\nfig.savefig(pltfiles['effgicmax'], dpi=300, bbox_inches='tight')\nif show:\ngicmapsobj.plots_show()\nelse:\ngicmapsobj.plots_close()\nif outfext=='.pdf':\ngicmapsobj.pdf2_close(pdf2fobj)\nif outfext=='.pdf':\nmsg  = \"\\n GIC analysis custom plots saved in file:\\n    {}\\n\".format(pdffile)\nelse:\nmsg  = \"\\n GIC analysis custom plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\nprint(msg)\npsspy.set_fpcw_psse()\n# -----------------------------------------------------------------------------------------------------\ndef gict_result_plots(gictfile, outpath=None, top_trn=10, nrows=2, ncols=2, outfext='.pdf', show=True):\n\"\"\" Plot GIC Thermal results.\ntop_trn - plot so many transformers with maximum GICs\nnrows   - numbers of rows in plot figure\nncols   - numbers of columns in plot figure\nnrows X ncols subplots are drawn on one figure.\n\"\"\"\nimport collections\nimport psspy\npsspy.set_fpcw_py()\nimport arrbox.gicthermal\noutdir = get_output_dir(outpath)\np, nx = os.path.split(gictfile)\npyfnam, x = os.path.splitext(nx)\nif not p:\nif not os.path.exists(gictfile):\ngictfile = os.path.join(outdir, gictfile)\noutnam  = '{}'.format(pyfnam)\npltfiles = collections.OrderedDict()\nfor k in ['evt','trn']:\nif outfext=='.pdf':\npltfiles[k] = None\nelse:\nfnam = \"{}_{}{}\".format(outnam, k, outfext)\npltfiles[k] = os.path.join(outdir, fnam)\nthermalobj = arrbox.gicthermal.GICTHERMAL(gictfile)\nif thermalobj.ierr: return\nif outfext=='.pdf':\nfnam = \"{}_allplots{}\".format(outnam, outfext)\npdffile = os.path.join(outdir, fnam)\nthermalobj.pdf_open(pdffile)\nevtnamlst, figdict, axdict = thermalobj.plot_events(figfile=pltfiles['evt'], show=show)\nfiglst, axdict = thermalobj.plot_transformer_gict(figfile=pltfiles['trn'], top=top_trn, nrows=nrows, ncols=ncols, show=show)\nif show:\nthermalobj.plots_show()\nelse:\nthermalobj.plots_close()\nif outfext=='.pdf':\nthermalobj.pdf_close()\nif outfext=='.pdf':\nmsg  = \"\\n GIC Transformer Thermal GICT(t) profile plots saved in file:\\n    {}\\n\".format(pdffile)\nelse:\nmsg  = \"\\n GIC Transformer Thermal GICT(t) profile plot [{}] files saved in folder:\\n    {}\\n\".format(outfext, outdir)\nprint(msg)\npsspy.set_fpcw_psse()\n# =============================================================================================================\ndef run_all_tests(datapath=None, outpath=None, efields='ubn', scan='d', pf='fdns', outfext='.pdf'):\noutdir = get_output_dir(outpath)\nefield_type_lst = []\nscan_lst = []\npf_lst = []\nif efields:\ns_efld = efields.lower()\nif 'u' in s_efld: efield_type_lst.append('uniform')\nif 'b' in s_efld: efield_type_lst.append('benchmark')\nif 'n' in s_efld: efield_type_lst.append('nonuniform')\nif scan:\ns_scan = scan.lower()"
  },
  {
    "id": "chunk_056",
    "text": "if 'd' in s_scan: scan_lst.append('scan_deg')\nif 'm' in s_scan: scan_lst.append('scan_mag')\nif 'd_m' in s_scan: scan_lst.append('scan_d_m')\nif pf:\npf_lst.append(pf)\nif not efield_type_lst: efield_type_lst = ['uniform']\nif not scan_lst: scan_lst = ['']\nif not pf_lst: pf_lst = ['']\n# -----------------------------------------\nprint (\"\\n >>>>>>>>>>>>> Running create_gicdata_template_sample\")\nexcelfile = create_gicdata_template_sample(datapath, outpath, showexcel=False)\nprint (\"\\n >>>>>>>>>>>>> Running excel2gicfile\")\ngicdata_excel2gicfile(outpath)\nefield_mag = 1.0\nefield_deg = 0.0\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_text_report\")\nfor efield_type in efield_type_lst:\nfor scan_storm_event in scan_lst:\nrun_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event,datapath, outpath)\nbreak\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_sample_text_report\")\nfor efield_type in efield_type_lst:\nfor scan_storm_event in scan_lst:\nfor power_flow_optn in pf_lst:\nrun_gic_sample_text_report(efield_mag, efield_deg, efield_type,\nscan_storm_event, power_flow_optn, datapath, outpath)\nbreak\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_text_report_DIY\")\nrun_gic_ieee_text_report_DIY(datapath, outpath)\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_ieee_excel_export_DIY\")\nrun_gic_ieee_excel_export_DIY(datapath, outpath, show=False)\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, no scan, no powerflow\")\nrun_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='',\npower_flow_optn='',     show=False, datapath=datapath, outpath=outpath)\nprint (\"\\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, scan_deg, fdns\")\nrun_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='scan_deg',\npower_flow_optn='fdns', show=False, datapath=datapath, outpath=outpath)\npygicfile = ''\nfor fnam in os.listdir(outdir):\nn, x = os.path.splitext(fnam)\nif x=='.pygic':\ni = n.find('sample')\nif i>=0:\npygicfile = os.path.join(outdir, fnam)\nbreak\nprint (\"\\n >>>>>>>>>>>>> Running gic_results_on_network_map\")\nif pygicfile:\ngic_results_on_network_map(pygicfile, outpath, outfext=outfext, show=False)\nelse:\nprint (\"    mapdata file does not exist.\\n    {}\\n\".format(pygicfile))\nprint (\"\\n >>>>>>>>>>>>> Running gic_results_on_network_map_custom\")\nif pygicfile:\ngic_results_on_network_map_custom(pygicfile, outpath, outfext=outfext, show=False)\nelse:\nprint (\"    mapdata file does not exist.\\n    {}\\n\".format(pygicfile))\ngictfile = ''\nfor fnam in os.listdir(outdir):\nn, x = os.path.splitext(fnam)\nif x=='.csv':\ni = n.find('sample')\nif i>=0:\ngictfile = os.path.join(outdir, fnam)\nbreak\nprint (\"\\n >>>>>>>>>>>>> Running gicthermal\")\nif gictfile:\ngict_result_plots(gictfile, outpath, outfext=outfext, show=False)\nelse:\nprint (\"    GIC results gict CSV file does not exist.\\n\")\n# =============================================================================================================\ndef run_gicdata_templates(outpath=None):\nexcelfile = create_gicdata_template_sample(outpath=outpath, areas=[], showexcel=True)\nexcelfile = create_gicdata_template_sample(outpath=outpath, areas=[1,2,3], showexcel=False)\nexcelfile = create_gicdata_template_sample(outpath=outpath, areas=[4,5,6], showexcel=False)\n# =============================================================================================================\ndef run_gicdata_transfer(outpath=None):\nexcelfile = transfer_gicdata_sample(outpath=outpath, areas=[], showexcel=False)\nexcelfile = transfer_gicdata_sample(outpath=outpath, areas=[1,2,3], showexcel=False)\nexcelfile = transfer_gicdata_sample(outpath=outpath, areas=[4,5,6], showexcel=False)\n# =============================================================================================================\ndef run_gicdata_excel2gicfile(outpath=None):\ngicfile = gicdata_excel2gicfile(outpath=outpath, areas=[])\ngicfile = gicdata_excel2gicfile(outpath=outpath, areas=[1,2,3])\ngicfile = gicdata_excel2gicfile(outpath=outpath, areas=[4,5,6])\n# =============================================================================================================\ndef run_gicdata_gicfile2excel(outpath=None):\nexcelfile = gicdata_gicfile2excel(outpath=outpath, areas=[], showexcel=False)\nexcelfile = gicdata_gicfile2excel(outpath=outpath, areas=[1,2,3], showexcel=False)\nexcelfile = gicdata_gicfile2excel(outpath=outpath, areas=[4,5,6], showexcel=False)\n# =============================================================================================================\ndef run_gicdata_merge(outpath=None):\nexcelfile = gicdata_merge(outpath=outpath, showexcel=False)\n# =============================================================================================================\ndef run_gicdata_all(outpath=None):\n\"\"\" Run all gicdata tests.\n\"\"\"\nrun_gicdata_templates(outpath)\nrun_gicdata_transfer(outpath)\nrun_gicdata_excel2gicfile(outpath)\nrun_gicdata_gicfile2excel(outpath)\nrun_gicdata_merge(outpath)\n# =============================================================================================================\ndef _run_one_test():\n# Run these one by one in __main__ (just copy each line in __main__ and run).\n#\n# - Function create_gicdata_template_sample() must be run before running gicdata_excel2gicfile().\n# - Functions run_gic_ieee_text_report(..) and run_gic_sample_text_report(..) return pygicfile name.\n#   Use that as input to gic_results_on_network_map(..) and gic_results_on_network_map_custom(..).\n# GIC data tests\nrun_gicdata_templates()\nrun_gicdata_transfer()\nrun_gicdata_excel2gicfile()\nrun_gicdata_gicfile2excel()\nrun_gicdata_merge()\n# GIC calculation tests\nrun_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='')\nrun_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg')\nrun_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='')\nrun_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg')\nrun_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='')\nrun_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg')    # scan not allowed, so does not scan\nrun_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='',         power_flow_optn='')\nrun_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg', power_flow_optn='fdns')\nrun_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='',         power_flow_optn='')\nrun_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg', power_flow_optn='fdns')\nrun_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_mag', power_flow_optn='fdns')\nrun_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_d_m', power_flow_optn='fdns')\nrun_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='',         power_flow_optn='')\nrun_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg', power_flow_optn='fdns') # scan not allowed, so does not scan\nrun_gic_ieee_text_report_DIY()\nrun_gic_ieee_excel_export_DIY(show=True)\nrun_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',   scan_storm_event='',         power_flow_optn='',     show=True)\nrun_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_deg', power_flow_optn='fdns', show=True)\nrun_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_d_m', power_flow_optn='fdns', show=True)\npygicfile = r\"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic\"\ngic_results_on_network_map(pygicfile, show=False)\npygicfile = r\"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic\"\ngic_results_on_network_map_custom(pygicfile, show=False)\n# ---------------------------------\nrun_all_tests(datapath=datapath, outpath=outpath, efields='ubn', scan='d_m', pf='fdns')\nrun_all_tests(datapath=None, outpath=None, efields='b', scan='', pf='', outfext='.png')\n# =============================================================================================================\nif __name__ == '__main__':\npass\nimport psse35\n#[harmonics_demo.py]    Harmonics Analysis in PSSE\n# =====================================================================================================\n'''This is an example file showing how to run Harmonics Analysis.\nPlot frequency scan results.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\nimport psseXX\n- call function\nRun various functions from this file as desired.\nRefer test1(..) ... functions towards end of this file.\n'''\n\"\"\"\nUse any of these keywords to run har_analysis_2.\nKeyword     Default     Description\n# INTGAR[]\nfscanoptn   = 1       # 1 frequency scan option: 0 no; =1 yes\ndstnoptn    = 1       # 2 distortion calculations option: 0 no; =1 yes\nlinmdl      = 0       # 3 line model option:  =0 nominal pi; =1 long line with skin effect;\n#                       =2 long line but no skin effect\ndstnbuop    = 0       # 4 bus option in dstn: =0 all buses; =1 only study subsystem buses\ndstnrptop   = 0       # 5 bus option in dstn: =0 only THDs; =1 THDs + contributions\nimachimpop  = 0       # 6 induction machine impedance option =0 from power flow data; =1 from sequene data\ndcimpop     = 0       # 7 2TDC, VSCDC and MTDC equivalent impedance option in fscan =0 block; 1=consider\ntriplenop   = 0       # 8 Triplen Harmonics Option in distortion calculations =0 ignore; =1 consider\ngenimpop    = 0       # 9 generatir impedance option:  =0 Use ZSORCE impedance from power flow data\n#                                =1 Use subtransient impedance from sequence data\n#                                =2 Use transient impedance from sequence data\n#                                =3 Use synchronous impedance from sequence data\n#                                =4 Use negative sequence impedance from sequence data\nmdltypop    = 0       # 10 harmonics Model Type Option, allowed 0 or 1\nload_mdltyp = 0       # 11 load model type\ngen_mdltyp  = 0       # 12 gen model type\nbrnsh_mdltyp= 0       # 13 branch shunt model type\ntrn_mdltyp  = 0       # 14 trn model type\nfctsh_mdltyp= 0       # 15 facts shunt model type\nfctse_mdltyp= 0       # 16 facts series model type\nimach_mdltyp= 0       # 17 induction machine model type\n# REALAR[]\nhord_min    =  0.1    # 1 Minimum Harmonic Order\nhord_max    = 50.0    # 2 Maximum Harmonic Order\nhord_stp    =  0.1    # 3 Harmonic Order Step\n# FILEAR[]\nhrsfile     = ''      # 1 Binary Results File Name (.hrs)\ndstnfile    = ''      # 2 Distortion Calculation Report File Name (.txt)\nresnfile    = ''      # 3 Frequency Scan Resonance Report File Name (.txt)\n\"\"\"\nimport sys, os, math, traceback, textwrap\n_COLOR_PREFERENCE = ['orange', 'green', 'blue', 'red']\n_COLOR_PREFERENCE_BUS = ['red', 'blue']\n_ALLOWED_FIG_FILE_TYPES = ['eps', 'jpeg', 'jpg', 'pdf', 'pgf', 'png', 'ps', 'raw', 'rgba', 'svg', 'svgz', 'tif', 'tiff']\n# ==============================================================================\n# This data is from file CASE1TB.XLS of IEEE Task Force on Harmonics Modeling & Simulation"
  },
  {
    "id": "chunk_057",
    "text": "# Frequency Scan Thevenin Impedance\n# Distributed Line Model: ZRdist, ZXdist, Zdist\n# Pi Line Model: Zpi\n#    HORD       , ZRdist        ,  ZXdist       , Zdist , Zpi\n_ieee_tf_scan_results = [\n[1.00\t, 0.0534\t, 0.2197\t, 0.226\t, 0.226  ],\n[1.33\t, 0.0793\t, 0.3239\t, 0.334\t, 0.334  ],\n[1.67\t, 0.1371\t, 0.4711\t, 0.491\t, 0.492  ],\n[2.00\t, 0.2075\t, 0.5667\t, 0.603\t, 0.606  ],\n[2.33\t, 0.5381\t, 0.9926\t, 1.129\t, 1.136  ],\n[2.67\t, 1.7230\t, 1.1320\t, 2.062\t, 2.081  ],\n[3.00\t, 2.0150\t, -0.9333\t, 2.221\t, 2.217  ],\n[3.33\t, 0.7628\t, -1.0731\t, 1.317\t, 1.312  ],\n[3.67\t, 0.3951\t, -0.7590\t, 0.856\t, 0.855  ],\n[4.00\t, 0.3626\t, -0.5387\t, 0.649\t, 0.652  ],\n[4.33\t, 0.3141\t, -0.7507\t, 0.814\t, 0.806  ],\n[4.67\t, 0.0891\t, -0.5594\t, 0.566\t, 0.564  ],\n[5.00\t, 0.0570\t, -0.4405\t, 0.444\t, 0.443  ],\n[5.33\t, 0.0460\t, -0.3673\t, 0.370\t, 0.370  ],\n[5.67\t, 0.0430\t, -0.3170\t, 0.320\t, 0.320  ],\n[6.00\t, 0.0378\t, -0.2885\t, 0.291\t, 0.291  ],\n[6.33\t, 0.0219\t, -0.2551\t, 0.256\t, 0.256  ],\n[6.67\t, 0.0166\t, -0.2223\t, 0.223\t, 0.224  ],\n[7.00\t, 0.0144\t, -0.1957\t, 0.196\t, 0.197  ],\n[7.33\t, 0.0131\t, -0.1732\t, 0.174\t, 0.175  ],\n[7.67\t, 0.0122\t, -0.1537\t, 0.154\t, 0.155  ],\n[8.00\t, 0.0116\t, -0.1364\t, 0.137\t, 0.138  ],\n[8.33\t, 0.0112\t, -0.1211\t, 0.122\t, 0.123  ],\n[8.67\t, 0.0105\t, -0.1076\t, 0.108\t, 0.109  ],\n[9.00\t, 0.0091\t, -0.0949\t, 0.095\t, 0.096  ],\n[9.33\t, 0.0077\t, -0.0823\t, 0.083\t, 0.084  ],\n[9.67\t, 0.0072\t, -0.0702\t, 0.071\t, 0.071  ],\n[10.00\t, 0.0071\t, -0.0593\t, 0.060\t, 0.060  ],\n[10.33\t, 0.0067\t, -0.0498\t, 0.050\t, 0.050  ],\n[10.67\t, 0.0051\t, -0.0409\t, 0.041\t, 0.041  ],\n[11.00\t, 0.0029\t, -0.0311\t, 0.031\t, 0.031  ],\n[11.33\t, 0.0014\t, -0.0207\t, 0.021\t, 0.021  ],\n[11.67\t, 0.0008\t, -0.0105\t, 0.011\t, 0.010  ],\n[12.00\t, 0.0007\t, -0.0009\t, 0.001\t, 0.001  ],\n[12.33\t, 0.0007\t, 0.0081\t, 0.008\t, 0.008  ],\n[12.67\t, 0.0008\t, 0.0168\t, 0.017\t, 0.017  ],\n[13.00\t, 0.0008\t, 0.0251\t, 0.025\t, 0.025  ],\n[13.33\t, 0.0009\t, 0.0331\t, 0.033\t, 0.033  ],\n[13.67\t, 0.0010\t, 0.0410\t, 0.041\t, 0.041  ],\n[14.00\t, 0.0010\t, 0.0487\t, 0.049\t, 0.049  ],\n[14.33\t, 0.0010\t, 0.0562\t, 0.056\t, 0.057  ],\n[14.67\t, 0.0010\t, 0.0636\t, 0.064\t, 0.065  ],\n[15.00\t, 0.0010\t, 0.0709\t, 0.071\t, 0.072  ],\n[15.33\t, 0.0010\t, 0.0782\t, 0.078\t, 0.080  ],\n[15.67\t, 0.0009\t, 0.0855\t, 0.085\t, 0.087  ],\n[16.00\t, 0.0009\t, 0.0927\t, 0.093\t, 0.095  ],\n[16.33\t, 0.0009\t, 0.0998\t, 0.100\t, 0.102  ],\n[16.67\t, 0.0009\t, 0.1070\t, 0.107\t, 0.110  ],\n[17.00\t, 0.0010\t, 0.1141\t, 0.114\t, 0.117  ],\n[17.33\t, 0.0010\t, 0.1213\t, 0.121\t, 0.124  ],\n[17.66\t, 0.0010\t, 0.1285\t, 0.129\t, 0.132  ],\n[18.00\t, 0.0010\t, 0.1357\t, 0.136\t, 0.139  ],\n[18.33\t, 0.0011\t, 0.1430\t, 0.143\t, 0.147  ],\n[18.66\t, 0.0011\t, 0.1504\t, 0.150\t, 0.154  ],\n[19.00\t, 0.0012\t, 0.1579\t, 0.158\t, 0.162  ],\n[19.33\t, 0.0012\t, 0.1654\t, 0.165\t, 0.170  ],\n[19.66\t, 0.0013\t, 0.1732\t, 0.173\t, 0.178  ],\n[20.00\t, 0.0014\t, 0.1811\t, 0.181\t, 0.186  ],\n[20.33\t, 0.0015\t, 0.1892\t, 0.189\t, 0.194  ],\n[20.66\t, 0.0016\t, 0.1975\t, 0.198\t, 0.203  ],\n[21.00\t, 0.0018\t, 0.2062\t, 0.206\t, 0.211  ],\n[21.33\t, 0.0019\t, 0.2153\t, 0.215\t, 0.218  ],\n[21.66\t, 0.0022\t, 0.2247\t, 0.225\t, 0.224  ],\n[22.00\t, 0.0025\t, 0.2348\t, 0.235\t, 0.229  ],\n[22.33\t, 0.0029\t, 0.2456\t, 0.246\t, 0.236  ],\n[22.66\t, 0.0034\t, 0.2573\t, 0.257\t, 0.245  ],\n[23.00\t, 0.0041\t, 0.2703\t, 0.270\t, 0.254  ],\n[23.33\t, 0.0052\t, 0.2850\t, 0.285\t, 0.263  ],\n[23.66\t, 0.0068\t, 0.3023\t, 0.302\t, 0.273  ],\n[24.00\t, 0.0094\t, 0.3239\t, 0.324\t, 0.282  ],\n[24.33\t, 0.0142\t, 0.3530\t, 0.353\t, 0.292  ],\n[24.66\t, 0.0258\t, 0.3988\t, 0.400\t, 0.302  ],\n[25.00\t, 0.0767\t, 0.4914\t, 0.497\t, 0.313  ],\n[25.33\t, 0.3804\t, 0.4516\t, 0.590\t, 0.324  ],\n[25.66\t, 0.2886\t, 0.2076\t, 0.355\t, 0.336  ],\n[26.00\t, 0.1861\t, 0.1507\t, 0.239\t, 0.350  ],\n[26.33\t, 0.0983\t, 0.1640\t, 0.191\t, 0.366  ],\n[26.66\t, 0.0543\t, 0.2017\t, 0.209\t, 0.391  ],\n[27.00\t, 0.0341\t, 0.2359\t, 0.238\t, 0.384  ],\n[27.33\t, 0.0239\t, 0.2646\t, 0.266\t, 0.348  ],\n[27.66\t, 0.0184\t, 0.2898\t, 0.290\t, 0.374  ],\n[28.00\t, 0.0152\t, 0.3130\t, 0.313\t, 0.392  ],\n[28.33\t, 0.0133\t, 0.3355\t, 0.336\t, 0.407  ],\n[28.66\t, 0.0122\t, 0.3581\t, 0.358\t, 0.422  ],\n[29.00\t, 0.0117\t, 0.3815\t, 0.382\t, 0.437  ],\n[29.33\t, 0.0118\t, 0.4067\t, 0.407\t, 0.451  ],\n[29.66\t, 0.0123\t, 0.4343\t, 0.434\t, 0.466  ],\n[30.00\t, 0.0133\t, 0.4655\t, 0.466\t, 0.481  ],\n[30.33\t, 0.0151\t, 0.5019\t, 0.502\t, 0.497  ],\n[30.66\t, 0.0179\t, 0.5456\t, 0.546\t, 0.513  ],\n[31.00\t, 0.0225\t, 0.6004\t, 0.601\t, 0.530  ],\n[31.33\t, 0.0301\t, 0.6723\t, 0.673\t, 0.547  ],\n[31.66\t, 0.0439\t, 0.7735\t, 0.775\t, 0.565  ],\n[32.00\t, 0.0731\t, 0.9304\t, 0.933\t, 0.583  ],\n[32.33\t, 0.1517\t, 1.2148\t, 1.224\t, 0.603  ],\n[32.66\t, 0.5070\t, 1.8932\t, 1.960\t, 0.623  ],\n[33.00\t, 4.5494\t, 1.5400\t, 4.803\t, 0.645  ],"
  },
  {
    "id": "chunk_058",
    "text": "[33.33\t, 0.7725\t, -1.1678\t, 1.400\t, 0.667  ],\n[33.66\t, 0.2861\t, -0.3206\t, 0.430\t, 0.691  ],\n[34.00\t, 0.3196\t, 0.1241\t, 0.343\t, 0.716  ],\n[34.33\t, 0.9273\t, 0.2502\t, 0.960\t, 0.743  ],\n[34.66\t, 0.5444\t, -0.5749\t, 0.792\t, 0.771  ],\n[35.00\t, 0.1669\t, -0.3331\t, 0.373\t, 0.801  ],\n[35.33\t, 0.0812\t, -0.1640\t, 0.183\t, 0.834  ],\n[35.66\t, 0.0508\t, -0.0578\t, 0.077\t, 0.870  ],\n[36.00\t, 0.0367\t, 0.0179\t, 0.041\t, 0.909  ],\n[36.33\t, 0.0293\t, 0.0777\t, 0.083\t, 0.952  ],\n[36.66\t, 0.0255\t, 0.1291\t, 0.132\t, 1.001  ],\n[37.00\t, 0.0242\t, 0.1773\t, 0.179\t, 1.058  ],\n[37.33\t, 0.0257\t, 0.2270\t, 0.228\t, 1.125  ],\n[37.66\t, 0.0320\t, 0.2852\t, 0.287\t, 1.201  ],\n[38.00\t, 0.0506\t, 0.3663\t, 0.370\t, 1.266  ],\n[38.33\t, 0.1213\t, 0.5124\t, 0.527\t, 1.224  ],\n[38.66\t, 0.6464\t, 0.7361\t, 0.980\t, 1.079  ],\n[39.00\t, 0.4533\t, -0.3164\t, 0.553\t, 1.047  ],\n[39.33\t, 0.1071\t, -0.0794\t, 0.133\t, 1.102  ],\n[39.66\t, 0.0490\t, 0.0401\t, 0.063\t, 1.178  ],\n[40.00\t, 0.0302\t, 0.1057\t, 0.110\t, 1.260  ],\n]\n# Reference:\n# \"Test Systems for Harmonics Modeling and Simulation\",\n# IEEE Transactions on Power Delivery, Vol. 11, No. 1, January 1996, Pages 466-474\n#     Bus, Nominal kV,  LF Volts pu, LF Ang deg,  THD%\n_ieee_tf_dstn_pf_thd_results = [\n[   1,      230.0,       1.0600,       0.00,  1.767 ],\n[   2,      230.0,       1.0450,      -5.68,  2.177 ],\n[   3,      230.0,       1.0427,     -15.30,  1.516 ],\n[   4,      230.0,       1.0282,     -11.41,  0.755 ],\n[   5,      230.0,       1.0337,      -9.82,  1.462 ],\n[   6,      115.0,       1.0700,     -15.87,  0.468 ],\n[   7,      230.0,       1.0193,     -14.47,  0.423 ],\n[   8,       13.8,       1.0209,     -14.49,  0.522 ],\n[   9,      115.0,       1.0147,     -16.09,  0.482 ],\n[  10,      115.0,       1.0168,     -16.33,  0.421 ],\n[  11,      115.0,       1.0394,     -16.21,  0.394 ],\n[  12,      115.0,       1.0528,     -16.72,  0.391 ],\n[  13,      115.0,       1.0458,     -16.73,  0.376 ],\n[  14,      115.0,       1.0154,     -17.39,  0.343 ],\n[ 301,       35.4,       1.0417,     -16.18,  9.169 ],\n[ 302,       35.4,       1.0417,     -16.18,  9.169 ],\n]\n#   Hord,   %mag,    deg\n_ieee_tf_dstn_cursrc_hvdc = [\n[  1, 100.00, -49.56 ],\n[  5,  19.41, -67.77 ],\n[  7,  13.09,  11.9  ],\n[ 11,   7.58,  -7.13 ],\n[ 13,   5.86,  68.57 ],\n[ 17,   3.79,  46.53 ],\n[ 19,   3.29, 116.46 ],\n[ 23,   2.26,  87.47 ],\n[ 25,   2.41, 159.32 ],\n[ 29,   1.93, 126.79 ],\n]\n_ieee_tf_dstn_cursrc_tcr = [\n[  1, 100.00,   46.92 ],\n[  5,   7.02, -124.40 ],\n[  7,   2.50,  -29.87 ],\n[ 11,   1.36,  -23.75 ],\n[ 13,   0.75,   71.50 ],\n[ 17,   0.62,   77.12 ],\n[ 19,   0.32,  173.43 ],\n[ 23,   0.43,  178.02 ],\n[ 25,   0.13,  -83.45 ],\n[ 29,   0.40,  -80.45 ],\n]\n# ===========================================================================================\n# IEEE 519-2022 and IEEE 519-2014\n#\n# Table 1 - Voltage Distortion Limits\n# All values should be in percent of the rated power frequency voltage at the PCC.\n# Applies to voltage harmonics whose frequencies are integer multiples of the power frequency.\n_ieee519_table1_thd_limits = {\n1.0  : {'indv': 5.0, 'thd': 8.0},                   # V <= 1.0 kV\n69.0 : {'indv': 3.0, 'thd': 5.0},                   # 1 kV < V <= 69.0 kV\n161.0: {'indv': 1.5, 'thd': 2.5},                   # 69.0 kV < V <= 161.0 kV\n999.0: {'indv': 1.0, 'thd': 1.5, 'thd_hvdc': 2.0},  # 161.0 kV < V\n}\n_ieee519_vlimits = list(_ieee519_table1_thd_limits.keys())\n_ieee519_vlimits.sort()\n# ==============================================================================\ndef get_ieee_tf_scan_results():\n\"\"\"Get IEEE Harmonics Task Force Test Case Frequency Scan Results.\n\"\"\"\nhord_lst, zcal_lst, zdst_lst, zpi_lst = [], [], [], []\nfor eachlist in _ieee_tf_scan_results:\nh, zr, zx, z1d, z1pi = eachlist\nzrx = complex(zr, zx)\nz = abs(zrx)\nhord_lst.append(h)\nzcal_lst.append(z)\nzdst_lst.append(z1d)\nzpi_lst.append(z1pi)\nreturn hord_lst, zcal_lst, zdst_lst, zpi_lst\n# ==============================================================================\ndef get_ieee_tf_dstn_pf_thd_results():\n\"\"\"Get IEEE Harmonics Task Force Test Case Distortion Calculation Results.\n\"\"\"\ntf_keytup = ('bus', 'basekv', 'vmag', 'vang', 'thd')\ntfresults_pf_thd_dict = {}\nfor row in _ieee_tf_dstn_pf_thd_results:\nfor dk, val in zip(tf_keytup, row):\nif dk=='bus':\nbus = val\ntfresults_pf_thd_dict[bus] = {}\nelse:\ntfresults_pf_thd_dict[bus][dk] = val\nreturn tfresults_pf_thd_dict\n# ==============================================================================\ndef get_ieee_tf_dstn_cursrc():\n\"\"\"Get IEEE Harmonics Task Force Test Case Harmonic Current Source Spectrum.\n\"\"\"\ntfresults_cursrc_dict = {'hvdc':{}, 'tcr':{}}\nfor eachrow in _ieee_tf_dstn_cursrc_hvdc:\nhord, imag, iang = eachrow\ntfresults_cursrc_dict['hvdc'][hord] = {'imag':imag, 'iang':iang}\ntfresults_cursrc_tcr_dict = {}\nfor eachrow in _ieee_tf_dstn_cursrc_tcr:\nhord, imag, iang = eachrow\ntfresults_cursrc_dict['tcr'][hord] = {'imag':imag, 'iang':iang}\nreturn tfresults_cursrc_dict\n# ==============================================================================\ndef get_resn_legends(peak_lst_h, peak_lst_rx, valley_lst_h=None, valley_lst_rx=None):\n\"\"\"Get Frequency Scan Resonance legends.\n\"\"\"\ntxtlst = []\ntxtlst.append(\"\")\ntxtlst.append(\"Parallel (peaks)\")\nif peak_lst_rx:\ntxtlst.append(\"Hord, Z\")\nfor h, pu in zip(peak_lst_h, peak_lst_rx):\ntxt = \"{:g}, {:g}\".format(h, pu)\ntxtlst.append(txt)\nelse:\ntxt = \" None\"\ntxtlst.append(txt)\nif valley_lst_h:\ntxtlst.append(\"\")\ntxtlst.append(\"Series (valleys)\")\nif valley_lst_rx:\ntxtlst.append(\"H,  Z\")\nfor h, pu in zip(valley_lst_h, valley_lst_rx):\ntxt = \"{:4.2f}, {:5.3f}\".format(h, pu)\ntxtlst.append(txt)\nelse:\ntxt = \" None\"\ntxtlst.append(txt)\nreturn txtlst\n# ==============================================================================\ndef _write_verbose_report(txt, report):\nif report is not None:\nreport(txt)\nclass _SimpleObject(object):\n\"\"\"Used for creating dummy object and set attributes as needed.\n\"\"\"\npass\ndef _set_rsn_object(**kwds):\nrsnobj = _SimpleObject()\nfor k in ['x1', 'y1', 'x2', 'y2', 'inam', 'hidx', 'rflg']:\nsetattr(rsnobj, k, kwds[k])\nreturn rsnobj\ndef _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=None, dltn=None):\nok1, ok2 = False, False\nok_pctc1 = pctc>=pctmx1\nok_pctc2 = pctc>=pctmx2\nif dltp is not None:\nok_dltp1 = dltp>=dpctpn1\nok_dltp2 = dltp>=dpctpn2\nif dltn is not None:\nok_dltn1 = dltn>=dpctpn1\nok_dltn2 = dltn>=dpctpn2\nif dltp is None:\nok1 = ok_pctc1 and ok_dltn1\nok2 = ok_pctc2 and ok_dltn2\nelif dltn is None:\nok1 = ok_pctc1 and ok_dltp1\nok2 = ok_pctc2 and ok_dltp2\nelse:\nok1 = ok_pctc1 and (ok_dltp1 or ok_dltn1)\nok2 = ok_pctc2 and (ok_dltp2 or ok_dltn2)\nfound = ok1 or ok2\nreturn found\ndef _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report):\nresn_pks_hord, resn_pks_zmag = [], []\ntxtlst = []\ntxtlst.append(\"\")\ntxtlst.append(\"Parallel (peaks)\")\nif not resn_pkvls:\ntxt = \" None\"\ntxtlst.append(txt)\ntxt = \"\\n\".join(txtlst)\n_write_verbose_report(txt, report)\nreturn resn_pks_hord, resn_pks_zmag\n# ------------\nnnlst = len(resn_pkvls)\ntxtlst.append(\"   X1,     Y1,     X2,     Y2,  %Ymax,  %dltY,  Found\")\nfor ii in range(nnlst):\npt_crnt = resn_pkvls[ii]\ninam = pt_crnt.inam\nif inam!='peak': continue\nipt_p = False\nipt_n = False"
  },
  {
    "id": "chunk_059",
    "text": "if ii==0:\nif nnlst>1:\nipt_n = True\npt_next = resn_pkvls[ii+1]\nelif ii==nnlst-1:\nipt_p = True\npt_prev = resn_pkvls[ii-1]\nelse:\nipt_p = True\nipt_n = True\npt_prev = resn_pkvls[ii-1]\npt_next = resn_pkvls[ii+1]\npctc = pt_crnt.y2*100/ymxpk                 # current value in percent of max\nfound = False\nif ii==0:\nif ipt_n:\ndltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2\nfound = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltn=dltn)\nelif ii==nnlst-1:\ndltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2\nfound = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp)\nelse:\ndltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2\ndltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2\nfound = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp, dltn=dltn)\nif found:\nresn_pkvls[ii].rflg = 1\nif ipt_p:\ntxt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}\".format(pt_prev.x1, pt_prev.y1, pt_prev.x2, pt_prev.y2, '', dltp)\ntxtlst.append(txt)\ntxt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6.2f}, {:6s},  {}\".format(pt_crnt.x1, pt_crnt.y1, pt_crnt.x2, pt_crnt.y2, pctc, '', found)\ntxtlst.append(txt)\nif ipt_n:\ntxt = \" {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}\".format(pt_next.x1, pt_next.y1, pt_next.x2, pt_next.y2, '', dltn)\ntxtlst.append(txt)\ntxtlst.append(\"\")\ntxt = \"\\n\".join(txtlst)\n_write_verbose_report(txt, report)\n# done filtering\nfor rsnobj in resn_pkvls:\ninam = rsnobj.inam\nrflg = rsnobj.rflg\nif inam=='peak' and rflg==1:\nresn_pks_hord.append(rsnobj.x2)\nresn_pks_zmag.append(rsnobj.y2)\nreturn resn_pks_hord, resn_pks_zmag\ndef check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=None):\n\"\"\"Check and find Frequency Scan Resonances.\n\"\"\"\nresn_pkvls = []\nnhord = len(hlst)\nfor hh in range(nhord):\nhord = hlst[hh]\nzmag = zlst[hh]\nif hh==0:\nx1, y1 = hord, zmag\nxb, yb = hord, zmag    # beginning point\nymxpk  = zmag\nelse:\nx2, y2 = hord, zmag\nm2 = (y1-y2)/(x1-x2)\nif hh>1:\nif m1>0 and m2<0:           # found peak\ninam = 'peak'\nif y1>y2:\npt = 0\nelse:\npt = 1\nelif m1<0 and m2>0:         # found valley\ninam = 'valy'\nif y1<y2:\npt = 0\nelse:\npt = 1\nelse:\ninam = 'none'\nif inam!='none':\nif pt==0:\nxn = x1\nyn = y1\nhidx = hh-1\nelse:\nxn = x2\nyn = y2\nhidx = hh\nif inam=='peak' and yn>ymxpk:\nymxpk = yn\nrsnobj = _set_rsn_object(x1=xb, y1=yb, x2=xn, y2=yn, inam=inam, hidx=hidx, rflg=0)\nresn_pkvls.append(rsnobj)\n# next segment begin point\nxb, yb = xn, yn\n# update and go to next point\nm1, x1, y1 = m2, x2, y2\n# Filter Peak Resonance Points\nresn_pks_hord, resn_pks_zmag = _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report)\n_write_verbose_report('\\n', report)\nreturn resn_pks_hord, resn_pks_zmag\n# ==============================================================================\ndef get_fscan_csvdata(csvfile):\n\"\"\"Get frequency scan Thevenin Impedance data from PSSE results file.\n\"\"\"\nimport csv\nthevz_dict = {}\nwith open(csvfile, newline='') as fobj:\nreader = csv.reader(fobj)\nfor row in reader:\nbus   = row[0]\nsec   = row[1]\nnam   = row[2]\nbasekv= row[3]\ndesc  = row[4].strip()\nif desc=='HORD':\nthevz_dict['hord'] = [float(v) for v in row[5:]]\nelse:\niext = int(bus)\ntry:\nisec = int(sec)\nexcept:\nisec = 0\nif isec>0:\ndkey = (iext, isec)\nelse:\ndkey = iext\nif desc=='pu abs(thevz)':\nbnam = nam.strip()\nbkv  = float(basekv)\nthevz_dict[dkey] = {'basekv': bkv, 'name': bnam}\nthevz_dict[dkey]['mag'] = [float(v) for v in row[5:]]\nelif desc=='deg phase(thevz)':\nthevz_dict[dkey]['phase'] = [float(v) for v in row[5:]]\nelse:\ntxt = \"Reading Harmonics FSCAN CSVFILE error, should not come here.\"\nraise Exception(txt)\nreturn thevz_dict\n# ==============================================================================\ndef get_hord_thevz_list(thevz_dict, busnum=None):\n\"\"\"Get frequency scan Thevenin impedance harmonic orders.\n\"\"\"\nfound = False\nklst = list(thevz_dict.keys())\nfor k in klst:\nif k=='hord': continue\nif busnum is None:\nbusnum = k\nfound = True\nbreak\nelse:\nif k==busnum:\nfound = True\nbreak\nif found:\nhord_lst = thevz_dict['hord'][:]\nthevz_mag_lst = thevz_dict[busnum]['mag'][:]\nthevz_phs_lst = thevz_dict[busnum]['phase'][:]\nierr = False\nelse:\nierr = True\nhord_lst, thevz_mag_lst, thevz_phs_lst = [], [], []\nreturn ierr, hord_lst, thevz_mag_lst, thevz_phs_lst\n# ==============================================================================\ndef get_dstn_csvdata_volt(csvfile):\n\"\"\"Get Distortion Calculations Bus Voltage THD data from PSSE results file.\n\"\"\"\nimport csv\ndkeytup = ('hord', 'bus', 'sec', 'basekv', 'vrpu', 'vxpu', 'vmagpu', 'vangdeg', 'thd_indv')\ndtyptup = ('r'   , 'i'  , 'i'  , 'r'     , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       )\nerrmsg0 = \" Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile)\n_NCLNS = len(dkeytup)\nvolt_dict = {}\nwith open(csvfile, newline='') as fobj:\nreader = csv.reader(fobj)\nnrow = 0\nfor row in reader:\nnrow += 1\nif nrow==1: continue # skip column header line\nnclns = len(row)\nif nclns!=_NCLNS:\ntxt = \"    ROW {} has {} data items. It should have {} data items.\".format(nrow, nclns, _NCLNS)\nerrmsg = \"{}{}\".format(errmsg0, txt)\nraise Exception(errmsg)\ntempdct = {}\nfor dk, dt, v0 in zip(dkeytup, dtyptup, row):\nif dt=='s':\nval = v0\nelif dt=='i':\nif dk=='sec':\ntry:\nval = int(v0)\nexcept:\nval = 0\nelse:\nval = int(v0)\nelse:\nval = float(v0)\ntempdct[dk] = val\nhord = tempdct['hord']\nibus = tempdct['bus']\nisec = tempdct['sec']\nbus_sec = (ibus, isec)\nif bus_sec not in volt_dict:\nvolt_dict[bus_sec] = {}\nif hord not in volt_dict[bus_sec]:\nvolt_dict[bus_sec][hord] = {}\nelse:\ntxt = \"    Duplicate harmonic order={} data found for '{}', at {}\".format(hord, desc, srcktup)\nerrmsg = \"{}{}\".format(errmsg0, txt)\nraise Exception(errmsg)\nif hord==1.0:\nkk = 'thd'\nelse:\nkk = 'indv'\nvolt_dict[bus_sec][hord]['basekv'] = tempdct['basekv']\nvolt_dict[bus_sec][hord]['vmag']   = tempdct['vmagpu']\nvolt_dict[bus_sec][hord]['vang']   = tempdct['vangdeg']\n# When hord=1.0, pct is THD, else pct is indv\nvolt_dict[bus_sec][hord]['pct']    = tempdct['thd_indv']\n# add this test here\n##    txt = \"    Fundamental harmonic order data not found for bus={}, section={}\".format(ibus, isec)\n##    errmsg = \"{}{}\".format(errmsg0, txt)\n##    raise Exception(errmsg)\nreturn volt_dict\n# ==================================================================================================\ndef get_dstn_csvdata_cursrc(csvfile):\n\"\"\"Get Distortion Calculations Harmonic Current Source Spectrum data from PSSE results file.\n\"\"\"\nimport csv\ndkeytup = ('hord', 'ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec', 'ckt', 'irpu', 'ixpu', 'imagpu', 'iangdeg', 'thd_indv', 'desc')\ndtyptup = ('r'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 's'  , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       , 's'   )\nerrmsg0 = \" Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile)\n_NCLNS = len(dkeytup)\ncursrc_dict = {}\nwith open(csvfile, newline='') as fobj:\nreader = csv.reader(fobj)\nnrow = 0\nfor row in reader:\nnrow += 1\nif nrow==1: continue # skip column header line\nnclns = len(row)\nif nclns!=_NCLNS:\ntxt = \"    ROW {} has {} data items. It should have {} data items.\".format(nrow, nclns, _NCLNS)\nerrmsg = \"{}{}\".format(errmsg0, txt)\nraise Exception(errmsg)\ntempdct = {}\nsrcklst = []\nfor dk, dt, v0 in zip(dkeytup, dtyptup, row):\nif dt=='s':\nval = v0.strip().lower()\nelif dt=='i':\nif dk in ['isec', 'jbus', 'jsec', 'kbus', 'ksec']:"
  },
  {
    "id": "chunk_060",
    "text": "try:\nval = int(v0)\nexcept:\nval = 0\nelse:\nval = int(v0)\nelse:\nval = float(v0)\nif dk in ['ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec']:\nif val>0:\nsrcklst.append(val)\nelif dk in ['ckt']:\nif val:\nsrcklst.append(val)\nelse:\ntempdct[dk] = val\nsrcktup = tuple(srcklst)\nhord = tempdct['hord']\ndesc = tempdct['desc']\nif desc not in cursrc_dict:\ncursrc_dict[desc] = {}\nif srcktup not in cursrc_dict[desc]:\ncursrc_dict[desc][srcktup] = {}\nif hord not in cursrc_dict[desc][srcktup]:\ncursrc_dict[desc][srcktup][hord] = {}\nelse:\ntxt = \"    Duplicate harmonic order={} data found for '{}', at {}\".format(hord, desc, srcktup)\nerrmsg = \"{}{}\".format(errmsg0, txt)\nraise Exception(errmsg)\nif hord==1.0:\nkk = 'thd'\nelse:\nkk = 'indv'\ncursrc_dict[desc][srcktup][hord]['imag'] = tempdct['imagpu']\ncursrc_dict[desc][srcktup][hord]['iang'] = tempdct['iangdeg']\ncursrc_dict[desc][srcktup][hord][kk]     = tempdct['thd_indv']\n# add this test here\n##    txt = \"    Fundamental harmonic order data not found for '{}', at {}\".format(desc, srcktup)\n##    errmsg = \"{}{}\".format(errmsg0, txt)\n##    raise Exception(errmsg)\nreturn cursrc_dict\n# ==================================================================================================\ndef _get_dstn_volt_ieee519_busgrps(volt_dict):\nhord = 1.0  # just consider HORD=1.0 to get bus information\nierr = 0\nieee519_vlmt_dict  = {}\ncase_bus_vlmt_dict = {}\nfor ii, lmtkv in enumerate(_ieee519_vlimits):\nif ii==0:\nvmn, vmx = 0, lmtkv\nelse:\nvmn, vmx = _ieee519_vlimits[ii-1], lmtkv\nif vmn<=0.0:\ns_lmt = \"kV <= {}\".format(vmx)\nelif vmx>=999.0:\ns_lmt = \"{} < kV\".format(vmn)\nelse:\ns_lmt = \"{} < kV <= {}\".format(vmn, vmx)\nieee519_vlmt_dict[ii] = {'lmtkv':lmtkv, 'vmin':vmn, 'vmax':vmx, 'lmt_lgd':s_lmt}\nbuses_not_added_to_grps = []\nfor bus_sec, vdict in volt_dict.items():\nbuskv = vdict[hord]['basekv']\nfound = False\nfor ii, lmtkv in enumerate(_ieee519_vlimits):\nif ii==0:\nvmn, vmx = 0, lmtkv\nelse:\nvmn, vmx = _ieee519_vlimits[ii-1], lmtkv\nif buskv>vmn and buskv<=vmx:\ncase_bus_vlmt_dict[bus_sec] = ii\nfound = True\nbreak\nif not found:\nbuses_not_added_to_grps.append(bus_sec) # should never happen\nif buses_not_added_to_grps:\ntxtlst = []\nfor each in buses_not_added_to_grps:\ntxt = \"{}\".format(each)\ntxtlst.append(txt)\ntxt = \" Error - These (bus, sec) are not added to IEEE 519 Voltage THD Bus Groups:\"\nprint(txt)\nalltxt = \", \".join(txtlst)\ntlnlst = textwrap.wrap(alltxt, width=90, initial_indent=\"    \", subsequent_indent=\"    \")\ntlntxt = \"\\n\".join(tlnlst)\nprint(tlntxt)\nif not case_bus_vlmt_dict:\nierr = 1\nreturn ierr, ieee519_vlmt_dict, case_bus_vlmt_dict\n# =========================================================================\ndef get_dstn_volt_study_bus_results(volt_dict, *buses):\n\"\"\"Return distortion results assembled in arrays for XY plots for specified study buses.\nierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)\n\"\"\"\nierr = 0\neach_bus_xy = {}\nall_bus_xy = {}\nierr, ieee519_vlmt_dict, case_bus_vlmt_dict = _get_dstn_volt_ieee519_busgrps(volt_dict)\nif ierr:\nreturn ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy\ncase_bus_exst_dict = {}\nfor bus_sec, lmtidx in case_bus_vlmt_dict.items():\nbus, sec = bus_sec\ncase_bus_exst_dict[bus] = 1\nif not buses: buses = [-1]\nstdy_bus_dict = {}\nif len(buses)==1 and buses[0]==-1:\nfor bus, flag in case_bus_exst_dict.items():\nstdy_bus_dict[bus] = 1\nelse:\nfor bus in buses:\nif bus in case_bus_exst_dict:\nstdy_bus_dict[bus] = 1\nfor bus_sec, vdict in volt_dict.items():\nbus, sec = bus_sec\nif bus not in stdy_bus_dict: continue\nif sec:\nxt = \"{}-{}\".format(bus, sec)\nelse:\nxt = \"{}\".format(bus)\nidx = case_bus_vlmt_dict[bus_sec]\n# Each bus THD and INDV for all HORD\n# 'pct' key contains both THD and INDV\neach_bus_xy[bus_sec] = {'xnam':xt, 'hord':[], 'pct':[], 'lmtidx':idx}\nfor hord, vdct2 in vdict.items():\neach_bus_xy[bus_sec]['hord'].append(hord)\neach_bus_xy[bus_sec]['pct'].append(vdct2['pct'])\n# THD and max INDV for all buses\nfor kk in ['bus_sec', 'xnam', 'thd', 'indv', 'indv_hord', 'lmtidx']:\nall_bus_xy[kk] = []\nfor bus_sec, vdict in each_bus_xy.items():\nall_bus_xy['bus_sec'].append(bus_sec)\nall_bus_xy['xnam'].append(vdict['xnam'])\nall_bus_xy['lmtidx'].append(vdict['lmtidx'])\nmx_indv = 0.0\nmx_indv_hord = 0.0\nfor hord, pct in zip(vdict['hord'], vdict['pct']):\nif hord==1.0:\nthd = pct\nelse:\nif pct>mx_indv:\nmx_indv = pct\nmx_indv_hord = hord\nall_bus_xy['thd'].append(thd)\nall_bus_xy['indv'].append(mx_indv)\nall_bus_xy['indv_hord'].append(mx_indv_hord)\n##    print(\"\\n each_bus_xy\\n\", each_bus_xy)\n##    print(\"\\n all_bus_xy\\n\",  all_bus_xy)\nreturn ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy\n# ==================================================================================================\ndef compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc):\n# Compare PSSE Distortion Calculation Results and IEEE Task Force Results\nif not os.path.exists(csvfile_volt):\nmsg0 = \" Distortion Calculation comparison table for IEEE Test case not done.\"\nmsg  = \" File not found.{}\\n    {}\".format(msg0, csvfile_volt)\nprint(msg)\nreturn\n# get task force results table in dictionary\ntfresults_pf_thd_dict = get_ieee_tf_dstn_pf_thd_results()\ntfresults_cursrc_dict = get_ieee_tf_dstn_cursrc()\n# get distotion bus volts CSV data in dictionary\nvolt_dict   = get_dstn_csvdata_volt(csvfile_volt)\ncursrc_dict = get_dstn_csvdata_cursrc(csvfile_cursrc)\n# create comparison table\nerrmsg0 = \" Error: Processing Harmonics Distortion Calculations Bus Voltage CSV file:\\n    {}\\n\".format(csvfile_volt)\nhdr1 = \" IEEE Task Force (TF) Harmonics Test Case: TF and PSSE Results Comparison\\n\"\nhdr2 = \" (1) Power Flow Solution Bus Voltages and Harmonics %THD\\n\"\nhdr3 = \"    Bus |nominal| IEEE TF| IEEE TF|IEEE TF|  PSSE  |  PSSE  | PSSE  |   DIFF   |   DIFF   |   DIFF   |\"\nhdr4 = \" Number |  kV   |  V pu  |  V deg | THD % |  V pu  |  V deg | THD % |   V pu   |   V deg  |   THD %  |\\n\"\noubflst = []\noubflst.append(hdr1)\noubflst.append(hdr2)\noubflst.append(hdr3)\noubflst.append(hdr4)\nbuslist = list(tfresults_pf_thd_dict.keys())\nbuslist.sort()\nfor bus in buslist:\ntfdct = tfresults_pf_thd_dict[bus]\ntf_basekv = tfdct['basekv']\ntf_mag    = tfdct['vmag']\ntf_ang    = tfdct['vang']\ntf_thd    = tfdct['thd']\nsec = 0\nbus_sec = (bus, sec)\ndstndct = volt_dict[bus_sec]\nhord = 1.0\np_basekv = dstndct[hord]['basekv']\np_mag    = dstndct[hord]['vmag']\np_ang    = dstndct[hord]['vang']\np_thd    = dstndct[hord]['pct']\nif p_basekv!=tf_basekv:\ntxt1 = \"    Nominal bus voltage does not match for bus={}\\n\".format(bus)\ntxt2 = \"    Bus voltage (kV)  TF paper={}, PSSE case={}\\n\".format(tf_basekv, p_basekv)\nerrmsg = \"{}{}{}\".format(errmsg0, txt1, txt2)\nraise Exception(errmsg)\ntf_txt = \"{:6d} | {:5.1f} | {:6.4f} | {:6.2f} | {:5.3f} |\".format(bus, tf_basekv, tf_mag, tf_ang, tf_thd)\np_txt  = \"{:6.4f} | {:6.2f} | {:5.3f} |\".format(p_mag, p_ang, p_thd)\ndf_mag = tf_mag - p_mag\ndf_ang = tf_ang - p_ang\ndf_thd = tf_thd - p_thd\ndf_txt = \"{:8.5f} | {:8.4f} | {:8.5f} |\".format(df_mag, df_ang, df_thd)\ntxt = \" {} {} {}\".format(tf_txt, p_txt, df_txt)\noubflst.append(txt)\nhdr1 = \"\\n (2) Harmonic Current Source Spectrum applied for Distortion Calculations\\n\"\nhdr2 = \" Hord |    Bus |  IEEE TF |  IEEE TF |   PSSE   |   PSSE   |   DIFF   |\"\nhdr3 = \"      | Number |   %I     |   I deg  |   %I     |   I deg  |   %I     |\\n\"\noubflst.append(hdr1)\noubflst.append(hdr2)\noubflst.append(hdr3)\np_keylist = list(cursrc_dict['load'].keys())\nbuslist.sort()\ntf_hord_list = list(tfresults_cursrc_dict['hvdc'].keys())\np_elmt = 'load'\nfor hord in tf_hord_list:\nfor srcktup in p_keylist:\nibus = srcktup[0]\nif ibus==8:\ntfk = 'tcr'\nelse:\ntfk = 'hvdc'\np_imag  = cursrc_dict[p_elmt][srcktup][hord]['imag']\np1_imag = cursrc_dict[p_elmt][srcktup][1.0]['imag']\np_pct   = p_imag*100/p1_imag\np_iang  = cursrc_dict[p_elmt][srcktup][hord]['iang']\ntf_imag = tfresults_cursrc_dict[tfk][hord]['imag']\ntf_iang = tfresults_cursrc_dict[tfk][hord]['iang']\ndf_pct  = tf_imag - p_pct\ntxt = \" {:4.1f} | {:6d} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.5f} |\".format(hord, ibus, tf_imag, tf_iang, p_pct, p_iang, df_pct)\noubflst.append(txt)\n#\ntxt1 = \"\\n For multiple harmonic sources, the phase angles of harmonic current injections are\""
  },
  {
    "id": "chunk_061",
    "text": "txt2 = \" re-calculated considering power flow solution phase angle, spectrum phase angles and\"\ntxt3 = \" harmonic order. Hence TF spectrum phase angles and PSSE phase angles are different.\"\noubflst.extend([txt1, txt2, txt3])\n# write to output file\npth, nx  = os.path.split(csvfile_volt)\nnam, xtn = os.path.splitext(nx)\noufname = \"{}_tf_THD_compare.txt\".format(nam)\noutfile = os.path.join(outpath, oufname)\noutfobj = open(outfile, 'w')\noubflst.append(\"\")\nalltxt = \"\\n\".join(oubflst)\noutfobj.write(alltxt)\noutfobj.close()\nmsg = \" IEEE Task Force Harmonics Test Case: TF and PSSE Results Comparison saved to file:\\n    {}\\n\".format(outfile)\nprint(msg)\n# ==============================================================================\ndef plot_main_fscan_ieee_test_and_tf(outpath, **kwds):\n\"\"\"Plot IEEE Test Case frequency scan impedance.\nResults from PSSE and IEEE Task Force are plotted.\n\"\"\"\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nfiletyp = kwds.get('filetyp', 'png')\nverbose = kwds.get('verbose', False)\npctmx1  = kwds.get('pctmx1',  60.0)\ndpctpn1 = kwds.get('dpctpn1', 75.0)\npctmx2  = kwds.get('pctmx2',  20.0)\ndpctpn2 = kwds.get('dpctpn2', 85.0)\nflag_show = kwds.get('flag_show', True)\ncasnam = \"ieee_tf_psse\"\nbusnum = 3\nhmajor = []\nfor ii in range(0, 41, 5):\nhmajor.append(ii)\nymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\ncsv_dict = {\n1: {'nam': \"ieee_testcase_linmdl=0_fscan.csv\", 'ttl': \"nominal PI\"},\n2: {'nam': \"ieee_testcase_linmdl=1_fscan.csv\", 'ttl': \"long line distibuted with skin effect\"},\n3: {'nam': \"ieee_testcase_linmdl=2_fscan.csv\", 'ttl': \"long line distibuted but no skin effect\"},\n}\ncsv_exists_dict = {}\nfor k, vdict in csv_dict.items():\nnam = vdict['nam']\ncsvfile = os.path.join(outpath, nam)\nif os.path.exists(csvfile):\ncsv_exists_dict[k] = vdict\nif not csv_exists_dict:\nmsg = \"\\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\n# PSSE results\nierr_pi, ierr_dst_skin, ierr_dst = True, True, True\nii = 0\nfor k, vdict in csv_exists_dict.items():\nnam = vdict['nam']\nttl = vdict['ttl']\ncsvfile = os.path.join(outpath, nam)\nthevz_dict = get_fscan_csvdata(csvfile)\nierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\nif not ierr:\nif ii==0:\nhlst_pi = hlst[:]\nzlst_pi = zlst[:]\nttl_pi = ttl\nierr_pi = False\nelif ii==1:\nhlst_dst_skin = hlst[:]\nzlst_dst_skin = zlst[:]\nttl_dst_skin = ttl\nierr_dst_skin = False\nelif ii==2:\nhlst_dst = hlst[:]\nzlst_dst = zlst[:]\nttl_dst  = ttl\nierr_dst = False\nii += 1\nif ierr_pi or ierr_dst:\nprint(\" Error -- PSSE getting results data\")\nreturn\ntf_hlst, tf_zlst_cal, tf_zlst_dst, tf_zlst_pi = get_ieee_tf_scan_results()\npeak_lst_h, peak_lst_rx = check_resonance(hlst_dst, zlst_dst, pctmx1, dpctpn1, pctmx2, dpctpn2)\nresn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\nresn_lgd_lst.insert(0, \"Resonance: distibuted but no skin\")\nresn_lgd = \"\\n\".join(resn_lgd_lst)\nclr_lst = ['red', 'blue', 'black', 'green', 'magenta']\nsty_lst = ['-', ':', '--', '-.', '-']\nwdt_lst = [2, 2, 1, 1, 1]\nfig, ax = plt.subplots(1,1)\nfig.set_size_inches(8.0, 9.0)\nii=0\nax.plot(hlst_dst, zlst_dst, label=ttl_dst+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\nii=1\nax.plot(tf_hlst, tf_zlst_dst, label=ttl_dst+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\nii=2\nax.plot(hlst_pi, zlst_pi, label=ttl_pi+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\nii=3\nax.plot(tf_hlst, tf_zlst_pi, label=ttl_pi+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\nax.set_xticks(hmajor)\nax.set_yticks(ymajor)\n#ax.set_yscale('log')\nax.set_xlabel(\"Harmonic Order\")\nax.set_ylabel(\"Harmonic Impedance (pu)\")\nax.set_title(\"IEEE 14 Bus Harmonics Test System\")\nax.grid(True, which='both')\nax.legend()\nax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')\nif filetyp=='pdf':\npdffile = os.path.join(outpath, \"{}.pdf\".format(casnam))\npdfobj  = PdfPages(pdffile)\nelse:\nfigfile = os.path.join(outpath, \"{}.png\".format(casnam))\nif filetyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\npdfobj.close()\nprint(\" Plots saved: {}\".format(pdffile))\nelse:\nfig.savefig(figfile, bbox_inches='tight')\nprint(\" Plots saved: {}\".format(figfile))\nif filetyp!='pdf':\nif flag_show:\nplt.show()\nelse:\nplt.close('all')\n# ==============================================================================\ndef plot_main_fscan_ieee_test(outpath, **kwds):\n\"\"\"Plot IEEE Test Case frequency scan Thevenin impedance.\n\"\"\"\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nfiletyp = kwds.get('filetyp', 'png')\nverbose = kwds.get('verbose', False)\npctmx1  = kwds.get('pctmx1',  60.0)\ndpctpn1 = kwds.get('dpctpn1', 75.0)\npctmx2  = kwds.get('pctmx2',  20.0)\ndpctpn2 = kwds.get('dpctpn2', 85.0)\nflag_show = kwds.get('flag_show', True)\nif verbose:\nreport = sys.stdout.write\nelse:\nreport = None\ncsv_dict = {\n1: {'nam': \"ieee_testcase_linmdl=0_fscan.csv\", 'ttl': \"nominal PI\"},\n2: {'nam': \"ieee_testcase_linmdl=1_fscan.csv\", 'ttl': \"long line distibuted with skin effect\"},\n3: {'nam': \"ieee_testcase_linmdl=2_fscan.csv\", 'ttl': \"long line distibuted but no skin effect\"},\n}\ncsv_exists_dict = {}\nfor k, vdict in csv_dict.items():\nnam = vdict['nam']\ncsvfile = os.path.join(outpath, nam)\nif os.path.exists(csvfile):\ncsv_exists_dict[k] = vdict\nif not csv_exists_dict:\nmsg = \"\\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\nhmajor = []\nfor ii in range(0, 41, 5):\nhmajor.append(ii)\nymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]\nbusnum = 3\nclr_lst = ['black', 'green', 'red']\nsty_lst = ['--', ':', '-']\nwdt_lst = [2, 3, 1]\nresn_lgd = ''\nfig, ax = plt.subplots(1,1)\nfig.set_size_inches(8.0, 9.0)\nii = 0\nfor k, vdict in csv_exists_dict.items():\nnam = vdict['nam']\nttl = vdict['ttl']\ncsvfile = os.path.join(outpath, nam)\nthevz_dict = get_fscan_csvdata(csvfile)\nierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\nif not ierr:\nax.plot(hlst, zlst, label=ttl, color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])\nif k==3:\npeak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=report)\nresn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\nresn_lgd_lst.insert(0, \"Resonance: linmdl-distibuted but no skin\")\nresn_lgd = \"\\n\".join(resn_lgd_lst)\nii += 1\nax.set_xticks(hmajor)\nax.set_yticks(ymajor)\n#ax.set_yscale('log')\nax.set_xlabel(\"Harmonic Order\")\nax.set_ylabel(\"Harmonic Impedance (pu)\")\nax.set_title(\"IEEE 14 Bus Harmonics Test System\")\nax.grid(True, which='both')\nax.legend()\nif resn_lgd: ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')\ncasnam = 'ieee_test'\nif filetyp=='pdf':\npdffile = os.path.join(outpath, \"{}_fscan.pdf\".format(casnam))\npdfobj  = PdfPages(pdffile)\nelse:\nfigfile = os.path.join(outpath, \"{}_fscan.png\".format(casnam))\nif filetyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\npdfobj.close()\nprint(\" Plots saved: {}\".format(pdffile))\nelse:\nfig.savefig(figfile, bbox_inches='tight')\nprint(\" Plots saved: {}\".format(figfile))\nif filetyp!='pdf':\nif flag_show:\nplt.show()\nelse:\nplt.close('all')\n# =========================================================================\ndef _har_ana_ieee_test(**kwds):\n\"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\nAllowed kwds:\noutpath  = os.getcwd(), Folder name to save outfile files\nrpt2file = False, Save Report to file\nThresholds to filter Thevenin Impedance\ndft_thresholds = True, Use defualt thresholds\npctmx1  = kwds.get('pctmx1' , 60.0)\ndpctpn1 = kwds.get('dpctpn1', 75.0)\npctmx2  = kwds.get('pctmx2' , 20.0)\ndpctpn2 = kwds.get('dpctpn2', 85.0)\n\"\"\"\nimport psspy\nname,major,minor,modlvl,date,stat = psspy.psseversion()\nkwds_api = {}\nkwds_api['anaoptn'   ] = 0\nkwds_api['dstnbuop'  ] = 0\nkwds_api['dstnrptop' ] = 1\nkwds_api['imachimpop'] = 0\nkwds_api['dcimpop'   ] = 0\nkwds_api['triplenop' ] = 0\nkwds_api['genimpop'  ] = 0\nkwds_api['hord_min' ] = 0.0\nkwds_api['hord_max' ] = 40.0\nkwds_api['hord_stp' ] = 0.33\nkwds_api['hrsfile'  ] = ''\nfscan_buslist = [3]\nsid = 3\nbusall = 0\npsspy.bsys(sid, numbus=len(fscan_buslist), buses=fscan_buslist)\noutpath = kwds.get('outpath', os.getcwd())\nrpt2file = kwds.get('rpt2file', False)\ndft_thresholds = kwds.get('dft_thresholds', True)\ninherit = kwds.get('inherit', False)\nif inherit:\nkwds_api['load_mdltyp'] = 7\nif not dft_thresholds:\npctmx1  = kwds.get('pctmx1' , 60.0)\ndpctpn1 = kwds.get('dpctpn1', 75.0)\npctmx2  = kwds.get('pctmx2' , 20.0)\ndpctpn2 = kwds.get('dpctpn2', 85.0)\ns_pctmx1  = \"{:g}\".format(pctmx1)\ns_dpctpn1 = \"{:g}\".format(dpctpn1)\ns_pctmx2  = \"{:g}\".format(pctmx2)\ns_dpctpn2 = \"{:g}\".format(dpctpn2)\nusr_thresholds = \"thresholds_usr_{}_{}_{}_{}\".format(s_pctmx1, dpctpn1, s_pctmx2, dpctpn2)\nfor linmdl in [0, 1, 2]:\noutnam = \"ieee_testcase_linmdl={}\".format(linmdl)\nif dft_thresholds:\nif not inherit:\noutpath1 = os.path.join(outpath,\"dft_thresholds\")"
  },
  {
    "id": "chunk_062",
    "text": "else:\noutpath1 = os.path.join(outpath,\"dft_thresholds_inherit\")\nelse:\noutpath1 = os.path.join(outpath,usr_thresholds)\nif not os.path.exists(outpath1): os.makedirs(outpath1)\nif rpt2file:\ndstnfile = os.path.join(outpath1, \"{}_dstn.txt\".format(outnam))\nresnfile = os.path.join(outpath1, \"{}_resn.txt\".format(outnam))\nelse:\ndstnfile = ''\nresnfile = ''\nkwds_api['linmdl']   = linmdl\nkwds_api['dstnfile'] = dstnfile\nkwds_api['resnfile'] = resnfile\nif dft_thresholds:\npsspy.har_set_resn_thresholds_default()\nelse:\npsspy.har_set_resn_thresholds(pctmx1=pctmx1, dpctpn1=dpctpn1, pctmx2=pctmx2, dpctpn2=dpctpn2)\nierr = psspy.har_analysis_2(sid, busall, **kwds_api)\nif not ierr:\nif kwds_api['anaoptn'] in [0, 1]:\nfscan_csvfile = os.path.join(outpath1, \"{}_fscan.csv\".format(outnam))\npsspy.har_export_fscan(fscan_csvfile)\nmsg = \"\\n Frequency Scan Thevenin impedance exported to file:\\n    {}\".format(fscan_csvfile)\nprint(msg)\nok350402 = major==35 and minor>=4 and modlvl>=2\nok3505   = major>=35 and minor>=5\nok3600   = major>=36\nif ok350402 or ok3505 or ok3600:\nif kwds_api['anaoptn'] in [0, 2]:\ndstn_csvfile = os.path.join(outpath1, \"{}_dstn.csv\".format(outnam))\nvoltoptn, flowoptn, cursrcoptn = 2, 2, 2\npsspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )\npn, xtn = os.path.splitext(dstn_csvfile)\nmsg  = \"\\n Distortion calculation results exported to files:\\n\"\nmsg += \"    {}_volt{}\\n\".format(pn, xtn)\nmsg += \"    {}_flow{}\\n\".format(pn, xtn)\nmsg += \"    {}_cursrc{}\\n\".format(pn, xtn)\nprint(msg)\n# =========================================================================\ndef _ieee_test_get_names(datapath, outpath):\nif datapath is None:        # use Example folder\nexampath = os.path.dirname(__file__)\ndatapath = exampath\nsavfile = os.path.join(datapath, 'ieee_harmonics_test_case.sav')\nharfile = os.path.join(datapath, 'ieee_harmonics_test_case_har.rawx')\nif not os.path.exists(savfile):\nmsg = \"\\n Error- File not found, terminated:\\n    {}\".format(savfile)\nprint(msg)\nif not os.path.exists(harfile):\nmsg = \"\\n Error- File not found, terminated:\\n    {}\".format(harfile)\nprint(msg)\nif outpath is None:\nexampath = os.path.dirname(__file__)\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee')\nif not os.path.exists(outpath): os.makedirs(outpath)\nreturn savfile, harfile, outpath\n# =========================================================================\ndef run_ieee_test(datapath=None, outpath=None):\n\"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n\"\"\"\nimport psspy\npsspy.psseinit()\nsavfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\npsspy.case(savfile)\npsspy.readrawx(harfile, 'harmonics', 'new')\n_har_ana_ieee_test(outpath=outpath, rpt2file=True)\n# =========================================================================\ndef run_ieee_test_inherit(datapath=None, outpath=None):\n\"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n\"\"\"\nimport psspy\npsspy.psseinit()\nsavfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\nhnam, hext = os.path.splitext(harfile)\nharfile = \"{}_inherit{}\".format(hnam, hext)\nif not os.path.exists(harfile):\nmsg = \" Error - harmonics data file not found, calculations terminated\\n    {}\".format(harfile)\nprint(msg)\npsspy.case(savfile)\npsspy.readrawx(harfile, 'harmonics', 'new')\n_har_ana_ieee_test(outpath=outpath, rpt2file=True, inherit=True)\n# =========================================================================\ndef run_ieee_test_thevz_thresholds(datapath=None, outpath=None):\n\"\"\"Run PSSE Harmonic Analysis using IEEE Test Case.\n\"\"\"\nimport psspy\npsspy.psseinit()\nsavfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)\npsspy.case(savfile)\npsspy.readrawx(harfile, 'harmonics', 'new')\nkwds = {}\nkwds['outpath' ] = outpath\nkwds['rpt2file' ] = True\nkwds['dft_thresholds' ] = False\nkwds['pctmx1' ] = 60.0\nkwds['dpctpn1'] = 75.0\nkwds['pctmx2' ] = 20.0\nkwds['dpctpn2'] = 65.0\n_har_ana_ieee_test(**kwds)\n# =========================================================================\ndef plot_fscan_ieee_test(outpath=None, **kwds):\n\"\"\"Plot PSSE Harmonic Analysis Frequency Scan results of IEEE Test Case.\n\"\"\"\nif outpath is None:\nexampath = os.path.dirname(__file__)\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\nif not os.path.exists(outpath):\nmsg = \"\\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\n##    kwds = {}\n##    kwds['filetyp'] = 'png'\n##    kwds['verbose'] = verbose\n##    kwds['pctmx1' ] = pctmx1\n##    kwds['dpctpn1'] = dpctpn1\n##    kwds['pctmx2' ] = pctmx2\n##    kwds['dpctpn2'] = dpctpn2\nplot_main_fscan_ieee_test(outpath, **kwds)\n# =========================================================================\ndef plot_fscan_ieee_test_tf_psse(outpath=None, **kwds):\n\"\"\"Plot Frequency Scan results of PSSE Harmonic Analysis and IEEE Task Force for IEEE Test Case.\n\"\"\"\nif outpath is None:\nexampath = os.path.dirname(__file__)\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\nif not os.path.exists(outpath):\nmsg = \"\\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\n##    kwds = {}\n##    kwds['filetyp'] = 'png'\n##    kwds['verbose'] = verbose\n##    kwds['pctmx1' ] = pctmx1\n##    kwds['dpctpn1'] = dpctpn1\n##    kwds['pctmx2' ] = pctmx2\n##    kwds['dpctpn2'] = dpctpn2\nplot_main_fscan_ieee_test_and_tf(outpath, **kwds)\n# =========================================================================\ndef compare_dstn_ieee_test(outpath=None, inherit=False):\nif outpath is None:\nexampath = os.path.dirname(__file__)\nif not inherit:\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\nelse:\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds_inherit')\nif not os.path.exists(outpath):\nmsg = \"\\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\ncsvnam_volt   = \"ieee_testcase_linmdl=2_dstn_volt.csv\"\ncsvnam_flow   = \"ieee_testcase_linmdl=2_dstn_flow.csv\"\ncsvnam_cursrc = \"ieee_testcase_linmdl=2_dstn_cursrc.csv\"\ncsvfile_volt   = os.path.join(outpath, csvnam_volt)\ncsvfile_cursrc = os.path.join(outpath, csvnam_cursrc)\ncompare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc)\n# =========================================================================\ndef plot_dstn_ieee_test_volt_ieee519(outpath=None, *buses, **kwds):\n\"\"\"Plot PSSE Harmonic Distortion Calculations results of IEEE Test Case.\n\"\"\"\nif outpath is None:\nexampath = os.path.dirname(__file__)\noutpath  = os.path.join(exampath, r'output_harmonics_demo\\ieee\\dft_thresholds')\nif not os.path.exists(outpath):\nmsg = \"\\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\\n    {}\".format(outpath)\nprint(msg)\nreturn\ncsvfnam = r\"ieee_testcase_linmdl=2_dstn_volt.csv\"\ncsvfile = os.path.join(outpath, csvfnam)\nfigfnam = 'ieee_testcase_linmdl=2_dstn_volt'\nfigfile = os.path.join(outpath, figfnam)\nkwds2 = {}\nkwds2['figfiletyp'  ] = kwds.get('figfiletyp'  , 'pdf'   )\nkwds2['figfile'     ] = kwds.get('figfile'     , figfile )\nkwds2['flag_thd'    ] = kwds.get('flag_thd'    , True    )\nkwds2['flag_indv'   ] = kwds.get('flag_indv'   , True    )\nkwds2['flag_busgrps'] = kwds.get('flag_busgrps', False   )\nkwds2['plt_buses'   ] = kwds.get('plt_buses'   , [-1]    )\nkwds2['flag_show'   ] = kwds.get('flag_show'   , True    )\nplot_distortion_volt_ieee519(csvfile, *buses, **kwds2)\n# =========================================================================\ndef _run_har_ana_main(*fscanbuses, **kwds):\n# Run Harmonic Analysis using working case\nimport psspy\nname,major,minor,modlvl,date,stat = psspy.psseversion()\n# subsystem\nonezerobus = False\nif fscanbuses:\nif len(fscanbuses)==1:\nif fscanbuses[0]==0:\nonezerobus = True\nif fscanbuses:\nif not onezerobus:\nsid = 3\nbusall = 0\npsspy.bsys(sid, numbus=len(fscanbuses), buses=fscanbuses)\nelse:\n# no scan, just run distortion calculations\nsid = 0\nbusall = 0\nelse:\ntotbus = psspy.totbus()\n# if case has <100 buses, run scan on all buses\nif totbus<100:\nsid = 0\nbusall = 1\nelse:\n# no scan, just run distortion calculations\nsid = 0\nbusall = 0\nierr = True\noutfdict = {}\noutfdict['dstn'] = ''\noutfdict['resn'] = ''\noutfdict['scan'] = ''\nanaoptn = kwds.get('anaoptn', 0)\nif sid==0 and busall==0:\nif anaoptn==0:\nkwds['anaoptn'] = 2  # only distortion anlysis\nelif anaoptn==2:\npass\nelse:\nmsg = \"\\n Error- Specify frequency scan buses, terminated\"\nprint(msg)\nreturn ierr, outfdict\noutfnam  = kwds.get('outfnam' , '')\noutpath  = kwds.get('outpath' , '')\nif not outfnam:\nsavfile, snpfile = psspy.sfiles()\nif not savfile:\noutfnam = \"tmpout\"\nelse:\np, nx = os.path.split(savfile)\noutfnam, xtn = os.path.splitext(nx)\nif outpath:\nif not os.path.exists(outpath): os.makedirs(outpath)\ndstnfile = os.path.join(outpath, \"{}_dstn.txt\".format(outfnam))\nresnfile = os.path.join(outpath, \"{}_resn.txt\".format(outfnam))\nelse:\ndstnfile = ''\nresnfile = ''\nkwds['hrsfile']  = ''\nkwds['dstnfile'] = dstnfile\nkwds['resnfile'] = resnfile\nif 'outpath' in kwds: del kwds['outpath']\nif 'outfnam' in kwds: del kwds['outfnam']\nierr = psspy.har_analysis(sid, busall, **kwds)\nfscan_csvfile = ''\ndstn_volt_csvfile = ''\ndstn_flow_csvfile = ''\ndstn_cursrc_csvfile = ''\nif not ierr and outpath:\nif anaoptn in [0,1]:\nif not ierr and outpath:\nfscan_csvfile = os.path.join(outpath, \"{}_fscan.csv\".format(outfnam))\npsspy.har_export_fscan(fscan_csvfile)\nmsg = \"\\n Frequency Scan Thevenin impedance saved to file:\\n    {}\".format(fscan_csvfile)\nprint(msg)\nok350402 = major==35 and minor>=4 and modlvl>=2\nok3505   = major>=35 and minor>=5\nok3600   = major>=36\nif ok350402 or ok3505 or ok3600:\nif anaoptn in [0, 2]:\ndstn_csvfile = os.path.join(outpath, \"{}_dstn.csv\".format(outfnam))\nvoltoptn, flowoptn, cursrcoptn = 2, 2, 2"
  },
  {
    "id": "chunk_063",
    "text": "psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )\npn, xtn = os.path.splitext(dstn_csvfile)\ndstn_volt_csvfile = r\"{}_volt{}\".format(pn, xtn)\ndstn_flow_csvfile = r\"{}_flow{}\".format(pn, xtn)\ndstn_cursrc_csvfile = r\"{}_cursrc{}\".format(pn, xtn)\nmsg += r\"    {}\\n\".format(dstn_volt_csvfile)\nmsg += r\"    {}\\n\".format(dstn_flow_csvfile)\nmsg += r\"    {}\\n\".format(dstn_cursrc_csvfile)\nprint(msg)\noutfdict['dstn'] = dstnfile\noutfdict['resn'] = resnfile\noutfdict['scan'] = fscan_csvfile\noutfdict['dstn_volt'] = dstnfile\noutfdict['dstn_flow'] = resnfile\noutfdict['dstn_cursrc'] = fscan_csvfile\nreturn ierr, outfdict\n# =========================================================================\ndef run_har_analysis(savfile, *fscanbuses, **kwds):\n\"\"\"Run PSSE Harmonic Analysis using savfile and harfile provided.\nArguments:\nsavfile (str): PSSE Saved Case file name\nfscanbuses (int): One or bus numbers at which frequency scan done\nkwds (dict):  All PSSE har_analysis() API keywords plus followng\nare allowed key words.\nharfile (str) : PSSE harmonics data (.har) file\noutpath (str) : Output Results File Folder name\noutfnam (str) : Output Results File Name prefix\n\"\"\"\nimport psspy\nif not os.path.exists(savfile):\nmsg = \"\\n Error- File not found, terminated:\\n    {}\".format(savfile)\nprint(msg)\nreturn True, {}\nharfile = kwds.get('harfile', '')\nif harfile:\nif not os.path.exists(harfile):\nmsg = \"\\n Error- File not found, ignored:\\n    {}\".format(harfile)\nprint(msg)\nharfile = ''\npsspy.psseinit()\nierr = psspy.case(savfile)\nif ierr:\nmsg = \"\\n Error- reading SAV file, terminated:\\n    {}\".format(savfile)\nprint(msg)\nreturn True, {}\nif harfile:\nierr = psspy.readrawx(harfile, 'harmonics', 'new')\nif ierr:\nmsg = \"\\n Error- reading Harmonics data file, terminated:\\n    {}\".format(harfile)\nprint(msg)\nreturn True, {}\nif 'harfile' in kwds: del kwds['harfile']\nierr, outfdict = _run_har_ana_main(*fscanbuses, **kwds)\nreturn ierr, outfdict\n# ==============================================================================\ndef _plot_fscan_one(ax, hlst, zlst, **kwds):\n#  main plot function\nbasemva  = kwds.get('basemva' , 100.0)\nbasekv   = kwds.get('basekv'  , None)\nhmajor   = kwds.get('hmajor'  , [])\nymajor   = kwds.get('ymajor'  , [])\nplotzpu  = kwds.get('plotzpu' , False)\ntitle    = kwds.get('title'   , '')\nadd_xlbl = kwds.get('add_xlbl', None)\nadd_lgnd = kwds.get('add_lgnd', False)\nannot_xy = kwds.get('annot_xy', (0.5, 0.5))\npctmx1  = kwds.get('pctmx1' , 60.0)\ndpctpn1 = kwds.get('dpctpn1', 75.0)\npctmx2  = kwds.get('pctmx1' , 20.0)\ndpctpn2 = kwds.get('dpctpn1', 85.0)\nreport  = kwds.get('report' , None)\nif add_lgnd:\npeak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report)\nylbl = \"Thevenin Impedance (pu)\"\nif not plotzpu:\nif basemva and basekv:\nzbase = basekv*basekv/basemva\nzlst_ohm = [zbase*each for each in zlst]\nzlst = zlst_ohm[:]\ndel zlst_ohm\nylbl = \"Thevenin Impedance (ohm)\"\nif add_lgnd:\npeak_lst_rx_ohm = [zbase*each for each in peak_lst_rx]\npeak_lst_rx = peak_lst_rx_ohm[:]\ndel peak_lst_rx_ohm\nif add_lgnd:\nresn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)\nresn_lgd = \"\\n\".join(resn_lgd_lst)\nif add_lgnd:\nax.plot(hlst, zlst, label=resn_lgd)\nelse:\nax.plot(hlst, zlst)\n#ax.set_yscale('log')\nif hmajor: ax.set_xticks(hmajor)\nif ymajor: ax.set_yticks(ymajor)\nif (add_xlbl): ax.set_xlabel(\"Harmonic Order\")\nax.set_ylabel(ylbl)\nax.grid(True, which='both')\nif add_lgnd:\nax.legend(loc='best')\nif title: ax.set_title(title)\n# =========================================================================\ndef _set_output_figfile_name(outfigfile, figfiletyp):\nfigfiletyp_in = figfiletyp\nif figfiletyp_in:\nif figfiletyp_in not in _ALLOWED_FIG_FILE_TYPES:\nfigfiletyp_in = ''\nopth, nx = os.path.split(outfigfile)\nn, x = os.path.splitext(nx)\nif x:\nfigfiletyp_fl = ''\nxlw = x.lower().strip()\nif xlw:\nif xlw[1:] in _ALLOWED_FIG_FILE_TYPES:\nfigfiletyp_fl = xlw[1:]\nif figfiletyp_in:\nfigfiletyp = figfiletyp_in\nelif figfiletyp_fl:\nfigfiletyp = figfiletyp_fl\nelse:\nfigfiletyp = 'pdf'\nxlw = \".{}\".format(figfiletyp)\nif not opth: opth = os.getcwd()\noutfigfile = os.path.join(opth, \"{}{}\".format(n, xlw))\nreturn outfigfile, figfiletyp\n# =========================================================================\ndef plot_frequency_scan(busnum, *csvfiles, **kwds):\n\"\"\"Plot Harmonics Frequency Scan Thevenin Impedance.\nfor one bus from multiple Frequency Scan Result Files\nArguments:\nbusnum (int): Bus Number. The 'csvfiles' provided must have Thevenin Impedance\nfor this bus.\ncsvfiles (str): One or more CSV files that contain Frequency Scan results.\nThese files are created by api psspy.har_export_fscan(..).\nkwds (dict):  Followng are allowed key words.\n(A) These keywords are for plot figure options.\nfigfiletyp (str): File type to which plots are saved.\n='pdfobj' -- files are saved to already created pdfobj\n[Create pdfobj = PdfPages(pdffile). This is done so\nas to save many plots to one pdffile.]\n='pdf', 'png', 'jpg' etc. [all allowed file types].\n(default: '')\nfigfile (str)   : Name of the file or pdfobj to save plots\nWhen file name is not provided plot is not saved.\n(default: '')\nflag_show (bool): Flag (True or False), Option to show plots on screen or not.\n(default: True)\nbasemva (float) : Base MVA (used to calculate Thev Z in ohms)\n(default: 100.0)\nbasekv  (float) : Base kV of the bus (used to calculate Thev Z in ohms)\n(default: No default allowed)\nhmajor  (float) : List of Harmonics Orders (used to draw X axis grid)\n(default: [])\nymajor  (float) : List of Thev Z (used to draw X axis grid)\n(default: [])\nttl_lst (str)   : Title list (one for each csvfile provided)\nWhen one title is provided, same title is used for all.\n(default: [])\nplotzpu (bool)  : True for Plot PU Thev Z\n(default: False)\nadd_lgnd (bool) : True to add resonance rrequeny legend\n(default: False)\nannot_xy (tuple): Resonance Frequency legend location\nSpecify normalized (0 through 1) XY co-ordinates of a point\n(default: (0.5, 0.5))\nsubplts (bool)  : True, plot as subplots for more than one csvfiles.\n(default: True) Subplots are drawn with 3 rows and 1 column.\nfwidth  (float) : Figure Width in inches\n(default: matplotlib rcParms default figure width)\nfheight (float) : Figure Height in inches\n(default: matplotlib rcParms default figure height)\n(B) These keywords are for filtering and reporting Thevenin Impedance Peaks.\n- Criterion 1 to select Thevenin Impedance Peak - slow rising peak point\npctmx1 (float)     : current point in percent of maximum peak value\n(default:60.0)\ndpctpn1 (float)    : delta previous and delta next points in percent of current point\n(default:75.0)\n- Criterion 2 to select Thevenin Impedance Peak - fast rising peak point\npctmx2 (float)     : current point in percent of maximum peak value\n(default:20.0)\ndpctpn2 (float)    : delta previous and delta next points in percent of current point\n(default:85.0)\nverbose (bool)     : Show verbose (detailed) output of Thevenin Impedance filtering\n(default: False)\nverbose_file (str) : File name to write verbose output.\n(default: '')\n\"\"\"\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\n# Use outfigfile to save output figure file and\n# also use its path to find csvfile when csvfile path is not provided.\ncsvpath = ''\nfigfiletyp = kwds.get('figfiletyp', '')\nfigfiletyp = figfiletyp.lower()\noutfigfile = kwds.get('figfile', '')\nflag_show  = kwds.get('flag_show', True)\nif outfigfile:\nif figfiletyp=='pdfobj':\npass\nelse:\noutfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)\nelse:\nfigfiletyp = ''\ntitle = ''\nhas_ttl4each = False\nttl_lst = kwds.get('ttl_lst', [])\nnttl = len(ttl_lst)\nncsv = len(csvfiles)\nif nttl==ncsv:\nhas_ttl4each = True"
  },
  {
    "id": "chunk_064",
    "text": "elif nttl==1 and ncsv>1:\ntitle = ttl_lst[0]\nexists_csvfiles = []\nexists_titles   = []\nfor ii, csvnam in enumerate(csvfiles):\nif has_ttl4each:\nttl = ttl_lst[ii]\nelse:\nttl = title\nif os.path.exists(csvnam):\nexists_csvfiles.append(csvnam)\nexists_titles.append(ttl)\nelse:\np, nx = os.path.split(csvnam)\nif not p and csvpath:\ncsvnam2 = os.path.join(csvpath, nx)\nif os.path.exists(csvnam2):\nexists_csvfiles.append(csvnam2)\nexists_titles.append(ttl)\nelse:\nmsg = \" File not found: {}\".format(csvnam)\nprint(msg)\nif not exists_csvfiles:\nreturn\nfwidth  = kwds.get('fwidth',  None)\nfheight = kwds.get('fheight', None)\nsubplts = kwds.get('subplts', True)\nverbose  = kwds.get('verbose', False)\nverbose_file = kwds.get('verbose_file', '')\nreport = None\nif verbose:\nif verbose_file:\nverbose_fobj = open(verbose_file, 'w')\nreport = verbose_fobj.write\nelse:\nreport = sys.stdout.write\nif subplts:\nif fwidth is None or fheight is None:\nfwidth, fheight = 8.0, 9.0\nnfigs = len(exists_csvfiles)\nif not subplts:\nnpages = nfigs\nnrows = 1\nelse:\nif nfigs>3:\nnpages = int(math.ceil(nfigs/3.0))   # three subplots per page\nnrows = 3\nelse:\nnpages = 1\nnrows = nfigs\nif outfigfile and figfiletyp=='pdf':\npdffile = outfigfile\npdfobj = PdfPages(pdffile)\nelif outfigfile and figfiletyp=='pdfobj':\npdfobj = outfigfile\nnn = 0\nfor pp in range(npages):\nfig, axlst = plt.subplots(nrows,1)\nif nrows==1: axlst = [axlst]\nfig.subplots_adjust(hspace=0.25)\nif fwidth is not None or fheight is not None:\nfig.set_size_inches(fwidth, fheight)\nfor nr in range(nrows):\nii = pp*nrows + nr\nif ii<nfigs:\ncsvfile = exists_csvfiles[ii]\nttl = exists_titles[ii]\nax = axlst[nr]\nif (nr+1==nrows):\nadd_xlbl = True\nelse:\nadd_xlbl = False\nkwds['title'] = ttl\nkwds['add_xlbl'] = add_xlbl\nkwds['report'] = report\nthevz_dict = get_fscan_csvdata(csvfile)\nierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)\nif not ierr:\n_plot_fscan_one(ax, hlst, zlst, **kwds)\nelse:\naxlst[nr].set_visible(False)\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\nelif figfiletyp=='pdfobj':\ntry:\npdfobj.savefig(fig, bbox_inches='tight')\nexcept:\ntraceback.print_last()\nelse:\nif npages>1:\npn, x = os.path.splitext(outfigfile)\nzn = \"{}\".format(pp).zfill(2)\ntmpfnam = \"{}_{}{}\".format(pn,zn,x)\nelse:\ntmpfnam = outfigfile\nfig.savefig(tmpfnam, bbox_inches='tight')\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.close()\nif figfiletyp=='pdfobj':\nplt.close(fig=fig)\nelse:\nprint(\" Plots saved: {}\".format(outfigfile))\nif verbose:\nif verbose_file:\nverbose_fobj.close()\nif figfiletyp!='pdfobj':\nif flag_show:\nplt.show()\nelse:\nplt.close('all')\n# =========================================================================\ndef plot_distortion_volt_ieee519(csvfile, *buses, **kwds):\n\"\"\"Plot Distortion Calculations Bus Voltages THD and Individual Harmonic levels with\nIEEE 519 Voltage Distortion Limits.\nArguments:\ncsvfile (str): CSV file that contain Distortion Calculations Bus Voltages results.\nThis file is created by api psspy.har_export_dstn(..).\nNo default allowed.\nbuses (int): One or more Study Bus Numbers. THD and Individual harmonic levels are plotted\nfor these many buses when provided.\n(default - consider all buses)\nkwds (dict):  Followng are allowed key words.\n(A) These keywords are for plot figure options.\nfigfiletyp (str)   : File type to which plots are saved.\n='pdfobj' -- files are saved to already created pdfobj\n[Create pdfobj = PdfPages(pdffile). This is done so\nas to save many plots to one pdffile.]\n='pdf', 'png', 'jpg' etc. [all allowed file types].\n(default: '')\nfigfile (str)      : Name of the file or pdfobj to save plots\nWhen file name is not provided plot is not saved.\n(default: '')\nflag_thd (bool)    : Flag (True or False), Option to plot THD of all study buses.\n(default: True)\nflag_indv (bool)   : Flag (True or False), Option to plot maximum individual harmonic levels\nof all study buses. For each bus, maximum individual harmonic level among all\nharmonic orders is found and plotted.\n(default: True)\nflag_busgrps (bool): Flag (True or False) Option to plot bus THD and INDV of bus groups.\nTrue -- Group buses as per their nominal voltage and IEEE 519 - Table 1\nvoltage at PCC. Plot those bus groups in separate figures.\nFalse -- Plot all buses in one figure.\n(default: True)\nplt_buses (list)   : List of bus numbers (subset of Study Bus Numbers) to plot harmonic distortions.\nBus THD and INDV harmonic distortions are plotted on the same figure.\nA separate figure created for each bus.\nSpecify =[-1] or =-1 to plot all study buses.\n(default: [])\nflag_show (bool)   : Flag (True or False), Option to show plots on screen or not.\n(default: True)\nflag_xtick (bool)  : Flag (True or False), Option to Lable and Tick all X axis bus numbers.\n(default: True). Set this false if plotting for many numbers. Plot\nautomatically assigns few labels and ticks in that case.\n\"\"\"\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nif not os.path.exists(csvfile):\nmsg = \" Distortion Bus Volts file not found: {}\".format(csvfile)\nprint(msg)\nreturn\nvolt_dict = get_dstn_csvdata_volt(csvfile)\n# get organized Distortion results data\nierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)\nif ierr==1:\nmsg = \" IEEE 519 Bus Groups not found in Distortion Bus Volts file: {}\".format(csvfile)\nprint(msg)\nreturn\nall_xnam = all_bus_xy['xnam']\nall_xnum = range(len(all_xnam))\n# separate groups and plot their bars so as to have ONE legend lable for a group\nbar_grps = {}\nfor idx, xnum, thd, indv, indv_hord in zip(all_bus_xy['lmtidx'], all_xnum, all_bus_xy['thd'],\nall_bus_xy['indv'], all_bus_xy['indv_hord']):\nif idx not in bar_grps:\nbar_grps[idx] = {'xnum':[], 'thd':[], 'indv':[], 'indv_hord':[]}\nbar_grps[idx]['xnum'].append(xnum)\nbar_grps[idx]['thd'].append(thd)\nbar_grps[idx]['indv'].append(indv)\nbar_grps[idx]['indv_hord'].append(indv_hord)\n# preserve legend order\ngrpidx_ordr = list(bar_grps.keys())\ngrpidx_ordr.sort()\n# Use outfigfile to save output figure file and\n# also use its path to find csvfile when csvfile path is not provided.\nfigfiletyp = kwds.get('figfiletyp', '')\nfigfiletyp = figfiletyp.lower()\noutfigfile = kwds.get('figfile', '')\nflag_thd     = kwds.get('flag_thd', True)\nflag_indv    = kwds.get('flag_indv', True)\nflag_busgrps = kwds.get('flag_busgrps', False)\nplt_buses    = kwds.get('plt_buses', [])\nflag_show    = kwds.get('flag_show', True)\nflag_xtick   = kwds.get('flag_xtick', True)\n# validate plt_buses\nok_pltbus_list = []\nif plt_buses:\nbus_ok_dict = {}\nfor bus_sec, vdict in each_bus_xy.items():\nbus, sec = bus_sec\nif bus not in bus_ok_dict:\nbus_ok_dict[bus] = []\nbus_ok_dict[bus].append(bus_sec)\nif type(plt_buses)==int:\nbuslst = [plt_buses]\nelif type(plt_buses) in [list, tuple]:\nbuslst = plt_buses[:]\nelse:\nbuslst = []\nmsg = \" Invalid plt_buses={} specified, ignored. Individual Bus plots not done.\".format(plt_buses)\nprint(msg)\nif len(buslst)==1 and buslst[0]==-1:\nfor bus in bus_ok_dict:\nok_pltbus_list.extend(bus_ok_dict[bus])\nelse:\nbuslst.sort()\nfor bus in buslst:\nif bus not in bus_ok_dict:\nmsg = \" Invalid plt_bus={}, ignored. Bus does not exist in results.\".format(bus)\nprint(msg)\nelse:\nok_pltbus_list.extend(bus_ok_dict[bus])\nif outfigfile:\nif figfiletyp=='pdfobj':\npass\nelse:\noutfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)\nelse:\nfigfiletyp = ''\nif outfigfile and figfiletyp=='pdf':\npdffile = outfigfile\npdfobj = PdfPages(pdffile)\nelif outfigfile and figfiletyp=='pdfobj':\npdfobj = outfigfile\nfignum = 0\nif flag_thd:\nbgn_allbus_thd = False\nfor idx in grpidx_ordr:\nif flag_busgrps:\nfignum += 1\nfig = plt.figure(num=fignum)\nax = fig.add_subplot(111)\ndo_lbls = True\nelse:\nif not bgn_allbus_thd:\nbgn_allbus_thd = True"
  },
  {
    "id": "chunk_065",
    "text": "fignum += 1\nfig = plt.figure(num=fignum)\nax = fig.add_subplot(111)\nif idx==grpidx_ordr[-1]:\ndo_lbls = True\nelse:\ndo_lbls = False\nlbl     = ieee519_vlmt_dict[idx]['lmt_lgd']\nlmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\nlmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']\nlmt_hvdc = _ieee519_table1_thd_limits[lmtkv].get('thd_hvdc', 0.0)\nif lmt_hvdc>0.0:\nlbl = \"{} [{}] [with HVDC={}%]\".format(lmt_thd, lbl, lmt_hvdc)\nelse:\nlbl = \"{} [{}]\".format(lmt_thd, lbl)\nclr = _COLOR_PREFERENCE[idx]\nh = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['thd'], width=0.1, label=lbl, color=clr)\n# draw limit lines\nax.axhline(y=lmt_thd, color=clr, linestyle='--', linewidth=1.5)\nif lmt_hvdc>0.0:\nax.axhline(y=lmt_hvdc, color=clr, linestyle='--', linewidth=1.5)\n# labels and title\nif do_lbls:\nttl = \" Voltage THD\"\nax.set_title(ttl)\nax.set_xlabel(\"Bus Numbers\")\nax.set_ylabel(\"% THD\")\nif flag_xtick:\nax.set_xticks(all_xnum, all_xnam)\nh_lgd = ax.legend(title=\"IEEE 519 %THD Limits\")\nh_lgd.get_frame().set_linewidth(0)\nh_lgd.set_draggable(True)\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\nelif figfiletyp=='pdfobj':\ntry:\npdfobj.savefig(fig, bbox_inches='tight')\nexcept:\ntraceback.print_last()\nelse:\npn, x = os.path.splitext(outfigfile)\nif flag_busgrps:\ntmpfnam = \"{}_thd_{}{}\".format(pn,idx,x)\nelse:\ntmpfnam = \"{}_thd{}\".format(pn,x)\nfig.savefig(tmpfnam, bbox_inches='tight')\nif flag_indv:\nbgn_allbus_indv = False\nfor idx in grpidx_ordr:\nif flag_busgrps:\nfignum += 1\nfig = plt.figure(num=fignum)\nax = fig.add_subplot(111)\ndo_lbls = True\nelse:\nif not bgn_allbus_indv:\nbgn_allbus_indv = True\nfignum += 1\nfig = plt.figure(num=fignum)\nax = fig.add_subplot(111)\nif idx==grpidx_ordr[-1]:\ndo_lbls = True\nelse:\ndo_lbls = False\nlbl     = ieee519_vlmt_dict[idx]['lmt_lgd']\nlmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\nlmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']\nlbl     = \"{} [{}]\".format(lmt_indv, lbl)\nclr = _COLOR_PREFERENCE[idx]\nh = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['indv'], width=0.1, label=lbl, color=clr)\ndo_bar_lbl_nam = False\nif flag_busgrps:\ndo_bar_lbl_nam = True\nelse:\nif all_xnum[0]==bar_grps[idx]['xnum'][0]:\ndo_bar_lbl_nam = True\nlbls = []\nfor hord in bar_grps[idx]['indv_hord']:\nif do_bar_lbl_nam:\nlbls.append(\"HORD={}\".format(int(hord)))\ndo_bar_lbl_nam = False\nelse:\nlbls.append(\"{}\".format(int(hord)))\nif flag_xtick:\nax.bar_label(h, labels=lbls, padding=2)\n# draw limit lines\nax.axhline(y=lmt_indv, color=clr, linestyle='--', linewidth=1.5)\n# labels and title\nif do_lbls:\nttl = \" Voltage Individual Harmonic Levels (maximum)\"\nax.set_title(ttl)\nax.set_xlabel(\"Bus Numbers\")\nax.set_ylabel(\"% INDV\")\nif flag_xtick:\nax.set_xticks(all_xnum, all_xnam)\nh_lgd = ax.legend(title=\"IEEE 519 %INDV Limits\")\nh_lgd.get_frame().set_linewidth(0)\nh_lgd.set_draggable(True)\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\nelif figfiletyp=='pdfobj':\ntry:\npdfobj.savefig(fig, bbox_inches='tight')\nexcept:\ntraceback.print_last()\nelse:\npn, x = os.path.splitext(outfigfile)\nif flag_busgrps:\ntmpfnam = \"{}_indv_{}{}\".format(pn,idx,x)\nelse:\ntmpfnam = \"{}_indv{}\".format(pn,x)\nfig.savefig(tmpfnam, bbox_inches='tight')\nif ok_pltbus_list:\nfor bus_sec in ok_pltbus_list:\nvdict = each_bus_xy[bus_sec]\nxnam  = vdict['xnam']\nidx     = vdict['lmtidx']\nlmtkv   = ieee519_vlmt_dict[idx]['lmtkv']\nlmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']\nlmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']\nlbl_thd = \"%THD={}\".format(lmt_thd)\nlbl_indv = \"%INDV={}\".format(lmt_indv)\nfignum += 1\nfig = plt.figure(num=fignum)\nax = fig.add_subplot(111)\nclr_thd = _COLOR_PREFERENCE_BUS[0]\nh = ax.bar(vdict['hord'][0], vdict['pct'][0], width=0.3, label=lbl_thd, color=clr_thd)\nclr_indv = _COLOR_PREFERENCE_BUS[1]\nh = ax.bar(vdict['hord'][1:], vdict['pct'][1:], width=0.3, label=lbl_indv, color=clr_indv)\n# draw limit lines if any limit is violated\nmaxpct = max(vdict['pct'])\nif maxpct>lmt_thd or maxpct>lmt_indv:\nax.axhline(y=lmt_thd,  color=clr_thd, linestyle='--', linewidth=1.5)\nax.axhline(y=lmt_indv, color=clr_indv, linestyle='--', linewidth=1.5)\nttl = \" Bus={}, Voltage THD and Individual Harmonic Levels\".format(xnam)\nax.set_title(ttl)\nax.set_xlabel(\"Harmonic Order\")\nax.set_ylabel(\"%THD and % INDV\")\nif flag_xtick:\nax.set_xticks(vdict['hord'])\nh_lgd = ax.legend(title=\"IEEE 519 Limits\")\nh_lgd.get_frame().set_linewidth(0)\nh_lgd.set_draggable(True)\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.savefig(fig, bbox_inches='tight')\nelif figfiletyp=='pdfobj':\ntry:\npdfobj.savefig(fig, bbox_inches='tight')\nexcept:\ntraceback.print_last()\nelse:\npn, x = os.path.splitext(outfigfile)\ntmpfnam = \"{}_thd_bus_{}{}\".format(pn,xnam,x)\nfig.savefig(tmpfnam, bbox_inches='tight')\nif outfigfile:\nif figfiletyp=='pdf':\npdfobj.close()\nif figfiletyp=='pdfobj':\nplt.close(fig=fig)\nelse:\nif figfiletyp=='pdf':\nprint(\" Plots saved: {}\".format(outfigfile))\nelse:\npn, x = os.path.splitext(outfigfile)\nprint(\" Plots saved: {}..., File Type={}\".format(pn, x[1:]))\nif figfiletyp!='pdfobj':\nif flag_show:\nplt.show()\nelse:\nplt.close('all')\n# =========================================================================\ndef test1():\n\"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\nUses Example folder files.\nCompare PSSE and TF distortion calculation results.\n\"\"\"\nrun_ieee_test()\ncompare_dstn_ieee_test()\ndef test1A():\n\"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\nSpecify Load Models from API argument and specify them as inherit in harmonics data file.\nUses Example folder files.\n\"\"\"\nrun_ieee_test_inherit()\ncompare_dstn_ieee_test(inherit=True)\ndef test1B():\n\"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\nAlso specify thresholds to filter thevenin resonance frequencies.\nUses Example folder files.\n\"\"\"\nrun_ieee_test_thevz_thresholds()\ndef test2():\n\"\"\"Plot Harmonics Test PSSE Results.\nUses Example folder files.\n\"\"\"\nplot_fscan_ieee_test()\ndef test2A():\n\"\"\"Plot Harmonics Test PSSE Results.\nAlso specify thresholds to filter thevenin resonance frequencies.\nUses Example folder files.\n\"\"\"\nplot_fscan_ieee_test(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0)\ndef test3(figfiletyp='pdf', flag_show=True):\n\"\"\"Plot Harmonics Test PSSE and harmonics Task Force Results.\nAlso specify thresholds to filter thevenin resonance frequencies.\nPlot Distortion Calculation Results.\nUses Example folder files.\n\"\"\"\nplot_fscan_ieee_test_tf_psse(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0, figfiletyp=figfiletyp, flag_show=flag_show)\nplot_dstn_ieee_test_volt_ieee519(figfiletyp=figfiletyp, flag_show=flag_show)\ndef test3A():\n\"\"\"Plot Harmonics Test PSSE and harmonics Task Force Results.\nUses Example folder files.\n\"\"\"\nplot_fscan_ieee_test_tf_psse()\ndef test4():\n\"\"\"Run Harmonics Analysis on Example folder 'sample' case.\nOutput Reports created in Report Window\n\"\"\"\nworkdir  = os.path.dirname(__file__)\ndatapath = workdir\nsavfile  = os.path.join(datapath, \"sample.sav\")\nharfile  = os.path.join(datapath, \"sample_har.rawx\")\nrun_har_analysis(savfile, harfile=harfile)\ndef test5():\n\"\"\"Run Harmonics Analysis on Example folder 'sample_zils' case.\nOutput Reports created in 'outpath' folder with savfile name used for file name prefix.\n\"\"\"\nworkdir  = os.path.dirname(__file__)\ndatapath = workdir\nsavfile  = os.path.join(datapath, \"sample_zils.sav\")\nharfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\noutpath  = os.path.join(workdir,  \"output_harmonics_demo\", \"sample_zils\")\nrun_har_analysis(savfile, harfile=harfile, outpath=outpath)\ndef test6():\n\"\"\"Run Harmonics Analysis on Example folder 'sample_nb' case.\nOutput Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\n\"\"\"\nworkdir  = os.path.dirname(__file__)\ndatapath = workdir\nsavfile  = os.path.join(datapath, \"sample_nb.sav\")\nharfile  = os.path.join(datapath, \"sample_har.rawx\")\noutfnam  = \"sample_nbXX\"\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", outfnam)\nrun_har_analysis(savfile, harfile=harfile, outpath=outpath, outfnam=outfnam)\ndef test7():\n\"\"\"Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.\nOutput Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\nAlso specified values to some API arguments.\n\"\"\"\nworkdir  = os.path.dirname(__file__)\ndatapath = workdir\nsavfile  = os.path.join(datapath, \"sample_zils_nb_sec.sav\")\nharfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec\")\nrun_har_analysis(savfile, harfile=harfile, outpath=outpath, linmdl=1,\ndstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)\ndef test8():\n\"\"\"Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.\nOutput Reports created in 'outpath' folder with 'outfnam' used for file name prefix.\nAlso specified values to some API arguments.\nDo frequency scan on few buses.\n\"\"\"\nworkdir  = os.path.dirname(__file__)\ndatapath = workdir\nsavfile  = os.path.join(datapath, \"sample_zils_nb_sec.sav\")\nharfile  = os.path.join(datapath, \"sample_zils_har.rawx\")\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\nrun_har_analysis(savfile, 101, 212, 154, harfile=harfile, outpath=outpath, linmdl=1,\ndstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)\ndef test9():\n\"\"\"Plot Frequency Scan, one file\n\"\"\"\nkwds = {}\nkwds['basemva'] = 100.0\nkwds['basekv']  = 21.6\nkwds['basehz']  = 60.0\nkwds['hmajor']  = []\nkwds['ymajor']  = []\nkwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)']\nkwds['add_lgnd']= True\nkwds['plotzpu'] = False\nworkdir  = os.path.dirname(__file__)\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\ncsvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")\nkwds['figfile'] = os.path.join(outpath, \"fscan_bus101_ohms.png\")\nkwds['flag_show'] = True\nplot_frequency_scan(101, csvfile1, **kwds)\ndef test10():\n\"\"\"Plot Frequency Scan, two files\n\"\"\"\nkwds = {}\nkwds['basemva'] = 100.0\nkwds['basekv']  = 21.6\nkwds['basehz']  = 60.0\nkwds['hmajor']  = []\nkwds['ymajor']  = []\nkwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']\nkwds['add_lgnd']= True\nkwds['plotzpu'] = False\nworkdir  = os.path.dirname(__file__)\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\ncsvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")"
  },
  {
    "id": "chunk_066",
    "text": "outpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils\")\ncsvfile2 = os.path.join(outpath, \"sample_zils_fscan.csv\")\nkwds['figfile'] = os.path.join(outpath, \"fscan_bus101_ohms.pdf\")\nkwds['flag_show'] = True\nplot_frequency_scan(101, csvfile1, csvfile2, **kwds)\ndef test11():\n\"\"\"Plot Frequency Scan, two files, figfiletype=pdfobj\n\"\"\"\nfrom matplotlib.backends.backend_pdf import PdfPages\nkwds = {}\nkwds['basemva'] = 100.0\nkwds['basekv']  = 21.6\nkwds['basehz']  = 60.0\nkwds['hmajor']  = []\nkwds['ymajor']  = []\nkwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']\nkwds['add_lgnd']= True\nkwds['plotzpu'] = False\nworkdir  = os.path.dirname(__file__)\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils_nb_sec_few\")\ncsvfile1 = os.path.join(outpath, \"sample_zils_nb_sec_fscan.csv\")\noutpath  = os.path.join(workdir, \"output_harmonics_demo\", \"sample_zils\")\ncsvfile2 = os.path.join(outpath, \"sample_zils_fscan.csv\")\npdffile = os.path.join(outpath, \"fscan_bus101_ohms_2.pdf\")\npdfobj = PdfPages(pdffile)\nkwds['figfiletyp'] = 'pdfobj'\nkwds['figfile'] = pdfobj\nkwds['flag_show'] = True\nplot_frequency_scan(101, csvfile1, **kwds)\nplot_frequency_scan(101, csvfile2, **kwds)\npdfobj.close()\nprint(\" Plots saved: {}\".format(pdffile))\n# ----------------------------\ndef _temp():\npass\n# Available tests\n# Note 1: Run tests 2, 2A, 3, 3A, 9, 10, 11 from outside of PSSE GUI.\n# Note 2: Other tests can be run from inside as well as outside of PSSE GUI.\n# Note 3: Copy and Modify test4() and later tests to use on any SAV and HAR files.\n#\ntest1()    # (a) Run Harmonics Analysis using IEEE Test case\n# (b) Compare PSSE and TF distortion calculation results\ntest1A()   # (a) Run Harmonics Analysis using IEEE Test case, but use inherit load model in data file\n# (b) Compare PSSE and TF distortion calculation results\ntest1B()   # Run Harmonics Analysis using IEEE Test case and specify thresholds to filter thevenin resonance frequencies\ntest2()    # Plot IEEE Test case Frequency scan.\ntest2A()   # Plot IEEE Test case PSSE Results and specify thresholds to filter thevenin resonance frequencies\ntest3()    # (a) Plot Harmonics Test case PSSE and harmonics Task Force Frequency scan Results\n#     with thresholds specified to filter thevenin resonance frequencies.\n# (b) Plot distortion calculation results.\ntest3A()   # Plot IEEE Test case PSSE and harmonics Task Force Results (default thresholds)\ntest4()    # Run Harmonics Analysis on Example folder 'sample' case, Output Reports created in Report Window\ntest5()    # Run Harmonics Analysis on Example folder 'sample_zils' case, Output Reports created in files\ntest6()    # Run Harmonics Analysis on Example folder 'sample_nb' case\ntest7()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case\ntest8()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case and frequency scan on few buses\ntest9()    # Plot Frequency Scan, one file [sample_zils_nb_sec_few]\ntest10()   # Plot Frequency Scan, two files [sample_zils_nb_sec_fscan, sample_zils_fscan]\ntest11()   # Plot Frequency Scan, two files, figfiletype=pdfobj\n# To compare PSSE and IEEE Test Case Results, run following tests.\ntest1()    # Run Analysis\ntest3()    # Write DSTN results comparison report, plot FSCAN TF and PSSE results, plot DSTN results\n# or run test3() with\n# figfiletyp as below, so as to create png file that can be inserted into DOC report\n# flag_show as below to create and save plots to files, do not show plots to the screen\ntest3(figfiletyp='png')\ntest3(figfiletyp='png', flag_show=False)\n# ==============================================================================\nif __name__==\"__main__\":\npass\n# Modify following two lines as desired and run.\n#import psse3506\n#test1()    # Run Analysis\n#[harmonics_demo.py]    Harmonics Analysis in PSSE\n# =====================================================================================================\n'''This is an example file showing how to use arrbox.harmonics module to post process\nharmonic analysis results.\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example [where XX is psse version number]:\nimport psseXX\n- Refer ieee_test_pp function that shows\n- how to get frequency scan results in python object\n- how to get distortion calculation results in python object\n- set desired voltage distortion limits\n- create voltage distortion limits violations report\n- plot and decorate frequency scan and voltage distortion results\n- Refer API manual arrbox > HAR_PP object for all available methods.\n'''\nimport os\nimport sys\n# =========================================================================\ndef ieee_test_pp(do_fscan_plts=False, do_dstn_plts=False, show_plts=False):\n\"\"\"Run Harmonics Analysis using IEEE Harmonics Test case.\nUses Example folder files.\n\"\"\"\n# Use from Example folder to run har_analysis.\nimport harmonics_demo\nimport arrbox.harmonics\noutpath = os.path.dirname(__file__)\noutpath = os.path.join(outpath, \"output_har_demo_arrbox\")\nif not os.path.exists(outpath): os.makedirs(outpath)\nharmonics_demo.run_ieee_test(outpath=outpath)\noutpath2 = os.path.join(outpath, \"har_pp\")\nif not os.path.exists(outpath2): os.makedirs(outpath2)\nprgfile = os.path.join(outpath2, \"ieee_test_har_demo_arrbox_progress.txt\")\nprgfile_fobj = open(prgfile, 'w')\nprogress = prgfile_fobj.write\nharobj = arrbox.harmonics.HAR_PP(progress=progress)\n# Frequency Scan Results\nierr = harobj.fscan_obj()\nfscanobj = harobj.fscan\nbuses = list(fscanobj.bus.keys())\nprogress(\"fscanobj.ierr={}\\n\".format(fscanobj.ierr))\nprogress(\"fscanobj.hord=\\n{}\\n\".format(fscanobj.hord))\nfor b in buses:\nprogress(\"Scanned Bus={}\\n\".format(b))\nprogress(\"{}\\n\".format(fscanobj['bus'][b].keys()))\nprogress(\"name={}, basekv={}\\n\".format(fscanobj.bus[b].name, fscanobj.bus[b].basekv))\nprogress(\"{}\\n\".format(fscanobj.bus[b].mag))\nprogress(\"{}\\n\".format(fscanobj.bus[b].phase))\n# Distortion Calculation Results\nierr = harobj.dstn_obj()\ndstn_vltobj = harobj.dstn.volt\nprogress(\"dstn_vltobj.keys()={}\\n\".format(dstn_vltobj.keys()))\nprogress(\"dstn_vltobj.thd.bus={}\\n{}\\n\".format(len(dstn_vltobj.thd.bus), dstn_vltobj.thd.bus))\nprogress(\"dstn_vltobj.thd.pct={}\\n{}\\n\".format(len(dstn_vltobj.thd.pct), dstn_vltobj.thd.pct))\nprogress(\"dstn_vltobj.indv.bus={}\\n{}\\n\".format(len(dstn_vltobj.indv.bus), dstn_vltobj.indv.bus))\nprogress(\"dstn_vltobj.indv.hord_max={}\\n{}\\n\".format(len(dstn_vltobj.indv.hord_max), dstn_vltobj.indv.hord_max))\nprogress(\"dstn_vltobj.indv.pct_max={}\\n{}\\n\".format(len(dstn_vltobj.indv.pct_max), dstn_vltobj.indv.pct_max))\nprogress(\"dstn_vltobj.bus.keys()={}\\n\".format(dstn_vltobj.bus.keys()))\nbuslist = harobj.dstn.volt.bus\nfor bus in buslist:\nbasekv = harobj.dstn.volt.bus[bus].basekv\nlmt_thd = harobj.dstn.volt.bus[bus].lmt_thd\nlmt_indv = harobj.dstn.volt.bus[bus].lmt_indv\nvdict = harobj.dstn.volt.bus[bus].hord\nfor hord, vdc2 in  vdict.items():\nvr, vx, vmag, vang, pct  = vdc2.vr,  vdc2.vx, vdc2.vmag,  vdc2.vang, vdc2.pct\ntxt = \"{}, {}, {}, {}, {}, {}, {}, basekv={}, lmt_indv={}, lmt_thd={}\\n\".\\\nformat(bus, hord, vr, vx, vmag, vang, pct, basekv, lmt_indv, lmt_thd)\nprogress(txt)\nharobj.show_vlt_dstn_limits()\nvlmt_dict = harobj.get_vlt_dstn_limits()\nprogress(\"vlmt_dict\\n\")\nfor lmtkv, vdct in vlmt_dict.items():\nprogress(\"   key={}, value={}\\n\".format(lmtkv, vdct))\nprogress('\\n')\nprogress(\"\\nVoltage violations report - rptoptn=0\\n\")\nharobj.report_vlt_dstn_limits_violations(rptfile=None)\nprogress(\"\\nVoltage violations report - rptoptn=1\\n\")\nharobj.report_vlt_dstn_limits_violations(rptoptn=1, rptfile=None)\nprogress(\"\\nVoltage violations report - rptoptn=2\\n\")\nharobj.report_vlt_dstn_limits_violations(rptoptn=2, rptfile=None)\nprgfile_fobj.close()\nprint(\" Progress Saved to file: {}\".format(prgfile))\n# Frequency Scan Plots\nif do_fscan_plts:\nif not harobj.fscan.ierr:\nfig1, ax1 = harobj.plot_fscan_mag(3, color='r')\nfig1.savefig(\"zz_001.png\")\nfig1, ax1 = harobj.plot_fscan_mag(3, color='r', marker='D', markevery=(0, 0.2))\nharobj.plot_decorate(ax1, xmin=10)\nfig1.savefig(\"zz_001-1.png\")\nharobj.plot_decorate(ax1, add_legend=True)\nif show_plts:\nharobj.plot_show()\nelse:\nharobj.plot_close()\n# Distortion Calculation Plots\nif do_dstn_plts:\nif not harobj.dstn.ierr:\npdffile = os.path.join(outpath2, 'zplt_dstn_1.pdf')\nharobj.plot_pdf_open(pdffile)\nfig1, ax1 = harobj.plot_vlt_dstn_thd(0, 1, optn_lmtgrp=True, optn_lmtlin=True)\n#harobj.plot_decorate(ax1, add_legend=True)\n#harobj.plot_decorate(ax1, add_legend=True, xticks='all')\nharobj.plot_decorate(ax1, add_legend=True, xticks=[302, 301, 11, 3, 4])\nfig2, ax2 = harobj.plot_vlt_dstn_indv(0, 1, optn_lmtgrp=True, optn_lmtlin=True)\nharobj.plot_decorate(ax2, add_legend=True, xticks='all')\nfig3, ax3 = harobj.plot_vlt_dstn_bus(1)\nharobj.plot_decorate(ax3, xscale='log', yscale='log')\nharobj.plot_pdf_add_figure(fig1, fig2, fig3)\nharobj.plot_pdf_close()\nfigfile = os.path.join(outpath2, 'zplt_dstn_2.pdf')\nharobj.plot_save(figfile, fig1, fig2)\nfigfile = os.path.join(outpath2, 'zplt21_dstn')\nharobj.plot_save(figfile, fig1)\nfigfile = os.path.join(outpath2, 'zplt22_dstn')\nharobj.plot_save(figfile, fig1, fig2)\nfigfile = os.path.join(outpath2, 'zplt23_dstn')\nharobj.plot_save(figfile, fig1, fig2, fig3)\nif show_plts:\nharobj.plot_show()\nelse:\nharobj.plot_close()\n# =========================================================================\ndef _temp():\npass\nieee_test_pp()\nieee_test_pp(do_fscan_plts=True, do_dstn_plts=True, show_plts=True)\n# ==============================================================================\nif __name__==\"__main__\":\npass\n# Modify following two lines as desired and run.\n#import psse3506\n#ieee_test_pp()\n#[iec60909_testnetwork_calculations.py]    Calculation of IEC Test Network 3 Phase Fault Currents by Network Reduction\n# =====================================================================================================\n'''\nThis file calculates 3 Phase Fault Currents for IEC Test Network (IEC 60909-4, Figure 16) by network reduction."
  },
  {
    "id": "chunk_067",
    "text": "Refer to Program Application Guide, Volume I, Chapter 10 for schematics and equations.\nIt uses network data from IEC 60909-4 Table 11.\nThis impedance data (corrected if necessary) of the electrical equipment\n(see figure 16) is referred to the 110 kV side. Z(2) = Z(1) = Z\nResults from these calculations are compared against results from PSS(R)E and those provided in\nIEC 60909-4 Table 12.\n'''\nimport os, math, time\nsqrt3 = math.sqrt(3.0)\nsbase = 100.0     # MVA\nstr_time = time.strftime(\"%Y%m%d_%H%M%S_\", time.localtime())\nfnamout  = str_time + 'iec60909_testnetwork_calculations.txt'\nfnamout  = os.path.join(os.getcwd(),fnamout)\nfoutobj  = open(fnamout,'w')\n# =================================================================================\ndef format_complex(v):\nvre = v.real\nvim = abs(v.imag)\nif v.imag<0:\nsgn = '-'\nelse:\nsgn = '+'\nretv = '%-10.6g %s j %-10.6g' % (vre, sgn, vim)\nreturn retv\ndef format_z_ratio(vlst,method=None):\nretvlst = []\nfor v in vlst:\nvstr = format_complex(v)\nxbyr = v.imag/v.real\nif method=='C':\nxbyr = xbyr/0.4\nelif method=='DC':\nxbyr = xbyr/0.055\nretv = '%s, %-10.6g' % (vstr, xbyr)\nretvlst.append(retv)\nreturn retvlst\ndef print_complex(nam, v):\nvstr = format_complex(v)\nretv = '%-7s = %s\\n' % (nam, vstr)\n#print retv.strip()\nreturn retv\ndef print_impedance_xr_ratio(nam, v, adj=1.0):\nvstr = format_complex(v)\nxbyr = adj*v.imag/v.real\nif adj!=1.0:\nretv = '%-6s = %s  X/R adj = %-10.6g\\n' % (nam, vstr, xbyr)\nelse:\nretv = '%-6s = %s  X/R     = %-10.6g\\n' % (nam, vstr, xbyr)\nprint(retv.strip())\nreturn retv\ndef print_fault_current(nam,v):\nvrect = format_complex(v)\nvmag = abs(v)\nvang = math.degrees(math.atan(v.imag/v.real))\n#retv = '%-6s = %s    OR %-10.6g / %-5.2g deg\\n' % (nam, vrect, vmag, vang)\nretv = '%-6s = %-10.6g\\n' % (nam, vmag)\nprint(retv.strip())\nreturn retv\n# =================================================================================\ndef print_z():\ndat_from_table11 = True\ntxt = ''\ntxt  += print_complex('zq1',    zq1)\ntxt  += print_complex('zq1t',   zq1t)\ntxt  += print_complex('zq2',    zq2)\ntxt  += print_complex('zt3amv', zt3amv)\ntxt  += print_complex('zt3bmv', zt3bmv)\ntxt  += print_complex('zt3cmv', zt3cmv)\ntxt  += print_complex('zt5mv',  zt5mv)\nif not dat_from_table11:\ntxt  += print_complex('zt1mv',  zt1mv)\ntxt  += print_complex('zg1',    zg1)\ntxt  += print_complex('zg1t',   zg1t)\ntxt  += print_complex('zs1',     zs1)\nif not dat_from_table11:\ntxt  += print_complex('zt2mv',  zt2mv)\ntxt  += print_complex('zg2',    zg2)\ntxt  += print_complex('zg2t',   zg2t)\ntxt  += print_complex('zs2',    zs2)\ntxt  += print_complex('zg3',    zg3)\ntxt  += print_complex('zg3t',   zg3t)\ntxt  += print_complex('zm1',    zm1)\ntxt  += print_complex('zm1t',   zm1t)\ntxt  += print_complex('zm2',    zm2)\ntxt  += print_complex('zm2t',   zm2t)\ntxt  += print_complex('zl1',    zl1)\ntxt  += print_complex('zl2',    zl2)\ntxt  += print_complex('zl3',    zl3)\ntxt  += print_complex('zl4',    zl4)\ntxt  += print_complex('zl5',    zl5)\ntxt  += print_complex('zl6',    zl6)\ntxt  += print_complex('zl6t',   zl6t)\nreturn txt\ndef print_network_reduction_z(txstr,zdct):\nfor k,v in list(zdct.items()):\ntxstr += print_complex(k,v)\nreturn txstr\n# =================================================================================\ndef table11_data(xftr,peak=False):\n# peak = True, calculations are for Peak current, use Rgf for generators.\nglobal zq1, zq1t, zq2, zt3amv, zt3bmv, zt3cmv, zt5mv, zs1\nglobal zs2, zg3, zg3t, zm1, zm1t, zm2, zm2t\nglobal zl1, zl2, zl3, zl4, zl5, zl6, zl6t\n# TABLE 11 Data\nzq1    =  0.631933 +   6.319335j\nzq1t   =  0.056874 +   0.568740j\nzq2    =  0.434454 +   4.344543j\nzt3amv =  0.045714 +   8.096989j\nzt3bmv =  0.053563 -   0.079062j\nzt3cmv =  0.408568 +  20.292035j\nzt5mv  =  2.046454 +  49.072241j\n# power station unit 1 data\n#Ks       = 0.995975\n#zg1t     = (0.059977324263+12.3433333333j)\n#zg1t*Ks  = (0.0597359155329+12.2936514167j)\n#zt1mv*Ks = (0.439058979167+14.0430253611j)\n#zs1 = Ks*(zg1t + zt1mv) = (0.4987948947+26.3366767778j)\nKs1    =  0.995975\nzg1    =  0.059977 +  12.343333j\nzg1c   =  0.059736 +  12.293651j\nzt1c   =  0.439059 +  14.043025j\n#zs1    =  0.498795 +  26.336676j\nzs1    =  zg1c + zt1c\n# power station unit 2 data\n#Ks       = 0.876832\n#zg2t     = (0.65306122449+23.04j)\n#zg2t*Ks  = (0.572624979592+20.20220928j)\n#zt2mv*Ks = (0.63131904+15.1384987665j)\n#zs2 = Ks*(zg2t + zt2mv) = (1.20394401959+35.3407080465j)\nKs2    =  0.876832\nzg2    =  0.653061 +  23.04j\nzg2c   =  0.572625 +  20.202214j\nzt2c   =  0.631319 +  15.138499j\n#zs2    =  1.203944 +  35.340713j\nzs2    =  zg2c + zt2c\nzg3    =  0.017790 +   1.089623j\nzg3t   =  2.133964 + 130.705301j\nzm1    =  0.341497 +   3.414968j\nzm1t   = 40.964124 + 409.641243j\nzm2    =  0.412137 +   4.121368j\nzm2t   = 49.437719 + 494.377190j\nzl1    = 2.4   + 7.8j\nzl2    = 1.2   + 3.9j\nzl3    = 0.3   + 0.975j\nzl4    = 0.96  + 3.88j\nzl5    = 1.8   + 5.79j\nzl6    = 0.082 + 0.086j\nzl6t   = 9.836281 + 10.316100j\n# Fictitious resistances RGf may be used for the calculation of the peak short circuit current\n# RGf = 0.05 X''d for generators with UrG > 1 kV and SrG >= 100 MVA\n# RGf = 0.07 X''d for generators with UrG > 1 kV and SrG < 100 MVA\n# RGf = 0.15 X''d for generators with UrG <= 1 000 V\nif peak:\n# G1 -> 150 MVA, 21 kV\n# G2 -> 100 MVA, 10.5 kV\n# RGf = 0.05 X''d\nzg1  = complex(0.05*zg1.imag, zg1.imag)\nzg1c = zg1*Ks1\nzs1  = zg1c + zt1c\nzg2  = complex(0.05*zg2.imag, zg2.imag)\nzg2c = zg2*Ks2\nzs2  = zg2c + zt2c\nzg3  = complex(0.07*zg3.imag, zg3.imag)\nzg3t = complex(0.07*zg3t.imag, zg3t.imag)\nif xftr != 1.0:\nzq1    = complex(zq1.real,    zq1.imag*xftr)\nzq1t   = complex(zq1t.real,   zq1t.imag*xftr)\nzq2    = complex(zq2.real,    zq2.imag*xftr)\nzt3amv = complex(zt3amv.real, zt3amv.imag*xftr)\nzt3bmv = complex(zt3bmv.real, zt3bmv.imag*xftr)\nzt3cmv = complex(zt3cmv.real, zt3cmv.imag*xftr)\nzt5mv  = complex(zt5mv.real,  zt5mv.imag*xftr)\nzs1    = complex(zs1.real,    zs1.imag*xftr)\nzs2    = complex(zs2.real,    zs2.imag*xftr)\nzg3    = complex(zg3.real,    zg3.imag*xftr)\nzg3t   = complex(zg3t.real,   zg3t.imag*xftr)\nzm1    = complex(zm1.real,    zm1.imag*xftr)\nzm1t   = complex(zm1t.real,   zm1t.imag*xftr)\nzm2    = complex(zm2.real,    zm2.imag*xftr)\nzm2t   = complex(zm2t.real,   zm2t.imag*xftr)\nzl1    = complex(zl1.real,    zl1.imag*xftr)\nzl2    = complex(zl2.real,    zl2.imag*xftr)\nzl3    = complex(zl3.real,    zl3.imag*xftr)\nzl4    = complex(zl4.real,    zl4.imag*xftr)\nzl5    = complex(zl5.real,    zl5.imag*xftr)\nzl6    = complex(zl6.real,    zl6.imag*xftr)\nzl6t   = complex(zl6t.real,   zl6t.imag*xftr)\n# =================================================================================\ndef parallel(zp,zq):\nreturn (zp*zq)/(zp+zq)\ndef calculate_3ph_fault_zthev():\n# Reduction at Bus 5\nz7g  = parallel(zm1t, zm2t)\nz6g1 = zl6t + z7g\nz6g2 = parallel(zg3t, z6g1)\nz56  = zt5mv/2.0\nz5g1 = z56 + z6g2\nz5g2 = parallel(zq2, z5g1)\nrdzstr = ''\nrdzstr = print_network_reduction_z(rdzstr,{'z7g':z7g, 'z6g1':z6g1, 'z6g2':z6g2, 'z56':z56, 'z5g1':z5g1, 'z5g2':z5g2})\n# Reduction at Bus 2\nz12t3   = zt3amv + zt3bmv\nz12t3t4 = z12t3/2.0\nz2g1    = zq1t + z12t3t4\nrdzstr = print_network_reduction_z(rdzstr,{'z12t3':z12t3, 'z12t3t4':z12t3t4, 'z2g1':z2g1})\n# delta to star of buses 2, 3, 5, star point=N1\nzden1 = zl1 + zl3 + zl4\nza    = (zl1*zl3) / zden1\nzb    = (zl1*zl4) / zden1\nzc    = (zl3*zl4) / zden1\nrdzstr = print_network_reduction_z(rdzstr,{'za':za, 'zb':zb, 'zc':zc})\n# star to delta of buses N1, 3, 4, and ground\nznum1 = zb*zs2 + zb*zl2 + zs2*zl2\nzd = znum1/zs2\nze = znum1/zl2\nzf = znum1/zb\nrdzstr = print_network_reduction_z(rdzstr,{'zd':zd, 'ze':ze, 'zf':zf})\n# delta to star of buses N1, 4, 5, star point=N2"
  },
  {
    "id": "chunk_068",
    "text": "zden2 = zc + zd + zl5\nzg    = (zc*zd)  / zden2\nzh    = (zd*zl5) / zden2\nzi    = (zc*zl5) / zden2\nrdzstr = print_network_reduction_z(rdzstr,{'zg':zg, 'zh':zh, 'zi':zi})\n# Zthev at Bus 4\nz1    = z2g1 + za\nz2    = parallel(z1, ze)\nz3    = z2 + zg\nz4    = zi + z5g2\nz5    = parallel(z3, z4)\nz6    = z5 + zh\nz7    = parallel(z6,zf)\nzthv4 = parallel(z7, zs1)\nrdzstr = print_network_reduction_z(rdzstr,{'z1':z1, 'z2':z2, 'z3':z3, 'z4':z4, 'z5':z5, 'z6':z6, 'z7':z7})\n# Zthev at Bus 5\nz8    = parallel(zs1,zf)\nz9    = z8 + zh\nz10   = parallel(z3,z9)\nz11   = zi + z10\nzthv5 = parallel(z11, z5g2)\nrdzstr = print_network_reduction_z(rdzstr,{'z8':z8, 'z9':z9, 'z10':z10, 'z11':z11})\n# Zthev at Bus 2\nz12   = parallel(z4,z9)\nz13   = z12 + zg\nz14   = parallel(z13,ze)\nz15   = za + z14\nzthv2 = parallel(z15, z2g1)\nrdzstr = print_network_reduction_z(rdzstr,{'z12':z12, 'z13':z13, 'z14':z14, 'z15':z15})\n# Zthev at Bus 1\nz16   = z15 + z12t3t4\nz17   = z16*(400.*400.)/(120.*120.)\nzthv1 = parallel(z17, zq1)\nrdzstr = print_network_reduction_z(rdzstr,{'z16':z16, 'z17':z17})\n# Zthev at Bus 6\nzt5lv = zt5mv*(10.5*10.5)/(115.0*115.0)\nz21   = parallel(z11, zq2)\nz21lv = z21*(10.5*10.5)/(115.0*115.0)\nz22   = z21lv + zt5lv*0.5\nz24   = parallel(zm1, zm2)\nz25   = zl6 + z24\nz26   = parallel(zg3, z25)\nzthv6 = parallel(z22, z26)\nrdzstr = print_network_reduction_z(rdzstr,{'zt5lv':zt5lv, 'z21':z21, 'z21lv':z21lv, 'z22':z22, 'z24':z24, 'z25':z25, 'z26':z26})\n# Zthev at Bus 7\nz27   = parallel(z22, zg3)\nz28   = z27 + zl6\nzthv7 = parallel(z28, z24)\nrdzstr = print_network_reduction_z(rdzstr,{'z27':z27, 'z28':z28})\nzthev = [zthv1, zthv2, zthv4, zthv5, zthv6, zthv7]\nreturn zthev, rdzstr\n# =================================================================================\ndef calculate_3ph_fault_ik(zthev):\nzthv1 = zthev[0]\nzthv2 = zthev[1]\nzthv4 = zthev[2]\nzthv5 = zthev[3]\nzthv6 = zthev[4]\nzthv7 = zthev[5]\nvflt = 1.1*110.0/sqrt3\nif2   = vflt/zthv2\nif4   = vflt/zthv4\nif5   = vflt/zthv5\nvflt1 = 1.1*380.0/sqrt3\nif1   = vflt1/zthv1\nvfl67 = 1.1*10.0/sqrt3\nif6   = vfl67/zthv6\nif7   = vfl67/zthv7\nik = [if1, if2, if4, if5, if6, if7]\nreturn ik\n# =================================================================================\ndef calculate_k_factor_method_B(bus,zc):\nr = zc.real\nx = zc.imag\nrx = r/x\nrbyx = -3.0*rx\nk = 1.02 + 0.98*math.exp(rbyx)\nif bus==7: k = k*1.15   # add safety factor for bus 7 faults\nif k>2.0: k=2.0\nreturn k\ndef calculate_k_factor_method_C(zc):\nr = zc.real\nx = zc.imag\nrx = r/x\nrbyx = 0.4*rx\nrbyx = -3.0*rbyx\nk = 1.02 + 0.98*math.exp(rbyx)\n#print 'K factor for r/x=%f, is k=%f' % (rbyx,k)\nreturn k\ndef calculate_ip(buslst,iklst,zclst,method):\nklst  = []\niplst = []\nfor bus,ik,zc in zip(buslst,iklst,zclst):\nik = abs(ik)\nif method=='B':\nk  = calculate_k_factor_method_B(bus,zc)\nif method=='C':\nk  = calculate_k_factor_method_C(zc)\nip = k*math.sqrt(2.0)*ik\nklst.append(k)\niplst.append(ip)\nreturn klst, iplst\ndef back_calculate_k(iklst,iplst):\nklst = []\nfor ik,ip in zip(iklst,iplst):\n# ip=k*sprt(2)*ik\nk = ip/(math.sqrt(2)*ik)\nklst.append(k)\nreturn klst\ndef calculate_idc(iklst,zlst):\n# idc = sprt(2)*ik*e^(-2piftR/X)\nidclst = []\nfor ik,z in zip(iklst,zlst):\nr = z.real\nx = z.imag\nrx = r/x\nrx = 0.055*rx\nrbyx = -2.0*math.pi*50.0*0.1*rx\nk = math.exp(rbyx)\nidc = math.sqrt(2)*abs(ik)*k\n#print 'dc component: z, k, abs(ik), idc = ',z,k,abs(ik),idc\nidclst.append(idc)\nreturn idclst\n# =================================================================================\nfoutobj.write('IEC 60909-4:2000 Figure 16 (Page 121) 3-phase Fault Calculations with Network reduction')\nfoutobj.write(' '+time.asctime())\nfoutobj.write('\\n')\nbuses = [1,2,4,5,6,7]\n# Base frequency calculations\nxftr = 1.0\ntable11_data(xftr)\nbase_z = print_z()\nzthev_bas, rdzstr_bas = calculate_3ph_fault_zthev()\nik_bas = calculate_3ph_fault_ik(zthev_bas)\n# Method B\n# Method B peak currents are worse (compared to results in standard) when Rgf is used.\n#xftr = 1.0\n#table11_data(xftr,peak=True)\n#mthdB_z = print_z()\n#zthev_b, rdzstr_b = calculate_3ph_fault_zthev()\n#k_b, ip_b = calculate_ip(buses,ik_bas,zthev_b,method='B')\nk_b, ip_b = calculate_ip(buses,ik_bas,zthev_bas,method='B')\n# Method C\nxftr = 20.0/50.0\ntable11_data(xftr,peak=True)\nmthdC_z = print_z()\nzthev_c, rdzstr_c = calculate_3ph_fault_zthev()\nk_c, ip_c = calculate_ip(buses,ik_bas,zthev_c,method='C')\n# DC Component\n# tmin=0.1 s, f*t = 50*0.1 = 5, fc/f=0.055\nxftr = 0.055\ntable11_data(xftr,peak=False)\ndc_z = print_z()\nzthev_dc, rdzstr_dc = calculate_3ph_fault_zthev()\nidc_cal = calculate_idc(ik_bas,zthev_dc)\n# Table 12 from Standard\nik1_tbl12   = 40.6447\nip1_b_tbl12 = 100.5766\nip1_c_tbl12 = 100.5677\nib1_tbl12   = 40.645\nik2_tbl12   = 31.7831\nip2_b_tbl12 = 80.8249\nip2_c_tbl12 = 80.6079\nib2_tbl12   = 31.570\nik4_tbl12   = 16.2277\nip4_b_tbl12 = 36.8041\nip4_c_tbl12 = 36.8427\nib4_tbl12   = 16.017\nik5_tbl12   = 33.1894\nip5_b_tbl12 = 83.6266\nip5_c_tbl12 = 83.4033\nib5_tbl12   = 32.795\nik6_tbl12   = 37.5629\nip6_b_tbl12 = 99.1910\nip6_c_tbl12 = 98.1434\nib6_tbl12   = 34.028\nik7_tbl12   = 25.5895\nip7_b_tbl12 = 51.3864*1.15\nip7_c_tbl12 = 51.6899\nib7_tbl12   = 23.212\nik_tbl12   = [ik1_tbl12,   ik2_tbl12,   ik4_tbl12,   ik5_tbl12,   ik6_tbl12,   ik7_tbl12  ]\nip_b_tbl12 = [ip1_b_tbl12, ip2_b_tbl12, ip4_b_tbl12, ip5_b_tbl12, ip6_b_tbl12, ip7_b_tbl12]\nip_c_tbl12 = [ip1_c_tbl12, ip2_c_tbl12, ip4_c_tbl12, ip5_c_tbl12, ip6_c_tbl12, ip7_c_tbl12]\nib_tbl12   = [ib1_tbl12,   ib2_tbl12,   ib4_tbl12,   ib5_tbl12,   ib6_tbl12,   ib7_tbl12  ]\nk_b_tbl12  = back_calculate_k(ik_tbl12,ip_b_tbl12)\nk_c_tbl12  = back_calculate_k(ik_tbl12,ip_c_tbl12)\n# PSS(R)E Results\n# Bus Nums      1        2        4        5        6       7\nik_psse  = [ 40.6447, 31.7830, 16.2277, 33.1894, 37.5628, 25.5894]\nipb_psse = [100.5766, 80.5119, 36.8041, 83.6265, 99.1908, 59.0943]\nipc_psse = [100.5676, 80.6079, 36.8427, 83.4033, 98.1432, 51.6898]\nidc_psse = [  2.7396, 12.7917,  2.6296,  3.9796, 15.1072,  0.0671]\nibs_psse = [ 40.6426, 31.5777, 16.0211, 32.8065, 34.0131, 23.1936]\niba_psse = [ 40.7348, 34.0702, 16.2354, 33.0470, 37.2171, 23.1937]\n# Print Base frequency and Method C impedances\nbase_z_lst  = base_z.split('\\n')\nmthdC_z_lst = mthdC_z.split('\\n')\ndc_z_lst = dc_z.split('\\n')\nrdzstr_bas_lst = rdzstr_bas.split('\\n')\nrdzstr_c_lst   = rdzstr_c.split('\\n')\nrdzstr_dc_lst  = rdzstr_dc.split('\\n')\nhdr = r\"\"\"NETWORK ELEMENT IMPEDANCES in OHMS (COMPARE this to TABLE 11, PP 127)\n|---------- BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\nfor v1,v2,v3 in zip(base_z_lst, mthdC_z_lst,dc_z_lst):\nif not v1: continue\ntxt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\\n'\nfoutobj.write(txt)\nhdr = r\"\"\"\nNETWORK REDUCTION  CALCULATION IMPEDANCES in OHMS\n|---------- BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\nfor v1,v2,v3 in zip(rdzstr_bas_lst, rdzstr_c_lst, rdzstr_dc_lst):\nif not v1: continue\ntxt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\\n'\nfoutobj.write(txt)\nhdr = r\"\"\"\nThevenin Impedance in OHMS calculated with NETWORK REDUCTION (R+jX, X/R ratio)\n|BUS| |---------- BASE FREQUENCY --------|    |   |----- METHOD C FREQ (fc/f=0.4)----|    |   |---- DC COMPONENT (fc/f=0.055)----|\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\nzstrlst_bas = format_z_ratio(zthev_bas)\nzstrlst_c   = format_z_ratio(zthev_c,method='C')\nzstrlst_dc  = format_z_ratio(zthev_dc,method='DC')\nfor b,zstr, zstr_c, zstr_dc in zip(buses,zstrlst_bas,zstrlst_c,zstrlst_dc):\nfoutobj.write('  %d    %s       %s       %s' % (b, zstr, zstr_c, zstr_dc))\nfoutobj.write('\\n')\nhdr =\"\"\"\nMETHOD        BUS    I\"k       K ip(50)     ip(50)     K ip(20)     ip(20)      Ib dc\"\"\"\nfoutobj.write(hdr)\nfoutobj.write('\\n')\nfor b1,ik,kb,ipb,kc,ipc,idc,ik_t,kb_t,ipb_t,kc_t,ipc_t,ik_e,ipb_e,ipc_e,idc_e in zip(buses, ik_bas, k_b, ip_b, k_c, ip_c, idc_cal,\nik_tbl12, k_b_tbl12, ip_b_tbl12, k_c_tbl12, ip_c_tbl12,\nik_psse, ipb_psse, ipc_psse, idc_psse):\nikabs = abs(ik)\ns1    = ' '"
  },
  {
    "id": "chunk_069",
    "text": "lin1 = \" CALCULATED   %(b1)3d   %(ikabs)-10.4f   %(kb)-10.4f %(ipb)-10.4f   %(kc)-10.4f %(ipc)-10.4f   %(idc)-10.4f\" % vars()\nlin2 = \" PSS(R)E      %(s1)3s   %(ik_e)-10.4f   %(s1)10s %(ipb_e)-10.4f   %(s1)10s %(ipc_e)-10.4f   %(idc_e)-10.4f\" % vars()\nlin3 = \" STANDARD     %(s1)3s   %(ik_t)-10.4f   %(kb_t)-10.4f %(ipb_t)-10.4f   %(kc_t)-10.4f %(ipc_t)-10.4f\" % vars()\nfoutobj.write(lin1)\nfoutobj.write('\\n')\nfoutobj.write(lin2)\nfoutobj.write('\\n')\nfoutobj.write(lin3)\nfoutobj.write('\\n\\n')\nfoutobj.close()\nmsg = \" Results saved in file: %s\" % fnamout\nprint(msg)\n# =================================================================================\n#[iecs_demo.py]   Fault Calculations using IECS\n# =====================================================================================================\n'''There are three different ways to calculate faults using IECS.\n1) Using activity IECS (psspy.iecs_4)\nRuns all types of faults, creates text reports, but no access to results from Python script.\n2) Using Python module arrbox.iecs.iecs_currents\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain both phase and sequence fault currents.\nb) contain faults currents for bus faults only.\nc) does not contain faults currents for linout and linend faults.\n3) Using Python module arrbox.fault.FAULT_SUMMARY\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain only total fault currents for faults calculated.\nb) contain faults currents for bus, linout and linend faults.\nThis is an example file showing how to run IECS fault calculations using either of these methods.\n---------------------------------------------------------------------------------\nHow to use this file?\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\nimport psseXX\n[Here XX is PSSE major version number.]\nB) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.\nrun_iecs_4(..)\nrun_iecs_currents_txtrpt(..)\nrun_iecs_currents_xls(..)\nrun_fault_summary_iecs(..)\nRun either of these functions under  __main__ to see how they work.\nC) Create similar functions for the network case and faults you want to run.\n'''\n# ========================================================================================\n#\n\"\"\"\nUse any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default   Description\n# STATUS array\nflt3ph   = 0        # 1 0=>omit, 1=>include\nfltlg    = 0        # 2 0=>omit, 1=>include\nfltllg   = 0        # 3 0=>omit, 1=>include\nfltll    = 0        # 4 0=>omit, 1=>include\nrptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl   = 0        # 6  number of contribution levels\nfltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,\n#    2=>AUX.XMER (connected to power station unit) LV bus\nlinout   = 0        # 8  0=>omit, 1=>include\nlinend   = 0        # 9  0=>omit, 1=>include\ntpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,\n#    3=>N unchanged and phi=0\nlnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,\n#    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\ndcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\ncfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,\n#    2=>User specified, maximum current, 3=>User specified, minimum current\nloadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\ngenxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs\n# VALUES array\nbrktime  = 0.1      # 0.1 seconds, breaker contact parting time\nucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)\n# File args\niecfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n# ========================================================================================\nimport sys, os, time, math\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n'owners':[], 'zones':[]}\ndef fault_bsys(sid, **kwds):\nimport psspy\nif sid==0: return\nactv_kwds = {}  # activity keywords\nfor k, v in bsys_kwds.items():\nif k in kwds:\nactv_kwds[k] = kwds[k]\nelse:\nactv_kwds[k] = v\nactv_kwds['sid']      = sid\nactv_kwds['numarea']  = len(actv_kwds['areas'])\nactv_kwds['numbus']   = len(actv_kwds['buses'])\nactv_kwds['numowner'] = len(actv_kwds['owners'])\nactv_kwds['numzone']  = len(actv_kwds['zones'])\nierr = psspy.bsys(**actv_kwds)\nreturn ierr\n# ========================================================================================\ndef set_prg_rpt(prgfile='', rptfile=''):\nimport psspy\npsspy.lines_per_page_one_device(1,10000000)\nif prgfile: psspy.progress_output(2,prgfile,[0,0])\nif rptfile: psspy.report_output(2,rptfile,[0,0])\n# ========================================================================================\ndef reset_prg_rpt():\nimport psspy\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,'',[0,0])\npsspy.report_output(1,'',[0,0])\n# ========================================================================================\nclass IECS_DEMO:\n\"\"\" Run PSSE IECS Calculations\"\"\"\ndef __init__(self):\nimport psspy\nself.ierr = psspy.psseinit(buses=150000)\n# ------------------------------------------------------------------------------------\ndef _frmted_z(self, cnum):\nr=cnum.real\nx=cnum.imag\ncsign='+j'\nif x<0:\ncsign='-j'\nx=abs(x)\nif r==0:\nrstr=''\nelse:\nrstr=\"%9.6f\" % r\nif x==0:\nxstr=''\ncsign=''\nelse:\nxstr=\"%9.6f\" % x\nzstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\nreturn zstr\n# ------------------------------------------------------------------------------------\ndef _frmted_z_xbyr(self, cnum):\nzstr = self._frmted_z(cnum)\nr=cnum.real\nx=abs(cnum.imag)\nif r==0:\nxbyr=''\nelse:\nxbyr=\"%9.6f\" % (x/r)\ncstr=\"%(zstr)s, %(xbyr)s\" % vars()\nreturn cstr\n# ------------------------------------------------------------------------------------\ndef _crnt_mag(self, fmt, cval):\nif fmt=='rectangular':\nreturn abs(cval)\nelse:\nreturn cval.real\n# ------------------------------------------------------------------------------------\ndef _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\nif scfmt=='rectangular':\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\ncrnt = abs(crnt)\nelse:\ncval = cval.real\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\nmva  = math.sqrt(3.0)*basekv*crnt/1000.0\nreturn crnt, mva\n# ------------------------------------------------------------------------------------\ndef run_iecs_api(self, sid, allbus, **kwds):\nimport psspy\nierr = psspy.iecs_4(sid, allbus, **kwds)\n# ------------------------------------------------------------------------------------\ndef run_iecs_currents(self, sid, allbus, **kwds):\nimport psspy, arrbox.iecs\nrlst = arrbox.iecs.iecs_currents(sid, allbus, **kwds)\nif rlst.ierr!=0:\nraise Exception(\"arrbox.iecs.iecs_currents error= {}\\n\".format(rlst.ierr))\nreturn rlst\n# ------------------------------------------------------------------------------------\ndef run_fault_summary(self, sid, allbus, **kwds):\nimport psspy, arrbox.fault\nfltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)\nif fltobj.ierr!=0:\nraise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\nreturn fltobj\n# ------------------------------------------------------------------------------------\ndef report_iecs_currents(self, rlst, rptfile=''):\nimport psspy\nif rlst.ierr: return\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:\nx = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nnfbus=len(rlst.fltbus)\ntxtlst = []\nif not rptfile: txtlst.append('')\nttlstr=\"PSS(R)E IECS SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\nln1str,ln2str=psspy.titldt()\nmaxlen=max(len(ttlstr),len(ln1str),len(ln2str))\ntxtlst.append(ttlstr.center(maxlen))\ntxtlst.append(ln1str.center(maxlen))\ntxtlst.append(ln2str.center(maxlen))\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nscunit = rlst.scunit\nscfmt  = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nif scunit == 'pu':\nunits = 'PU'\nelse:\nunits = 'AMP'\nunitstr   = units.center(10)\nclnhdr    = \"   BUS     \" + 6*unitstr\nfor i in range(nfbus):\ntxtlst = []\ntxtlst.append('')\ntxtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\ntxtlst.append(clnhdr)"
  },
  {
    "id": "chunk_070",
    "text": "fbus   = rlst.fltbus[i]\nif flt3ph:\nttxt   = \"%6d\" % fbus\nspc    = '3PH'\nia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\nib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\nic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltlg:\nif flt3ph:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = ' LG'\nia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltllg:\nif flt3ph or fltlg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = 'LLG'\nia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltll:\nif flt3ph or fltlg or fltllg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc     = ' LL'\nia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\nif scunit_z!='pu':\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\ntmptxt=110*'-'\ntxtlst.append(tmptxt)\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\n# Maximum Fault Currents\ninam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\nunitstr   = units.center(11)\nunitstr = ''\nfor each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\nt = each+'('+units+')'\nt = ' ' + t.center(9) + ' '\nunitstr += t\ntxtlst = []\ntxtlst.append('')\nclnhdr    = \"   BUS  \" + unitstr + \"  Description\"\ntxtlst.append(\"BREAKER DUTY CURRENTS\")\ntxtlst.append(clnhdr)\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nfor i in range(nfbus):\nfbus   = rlst.fltbus[i]\nia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\nib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\nic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\ndsc    = rlst.maxfltdsc[i]\nif rptfile: report('\\n')\ntmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\nreport(tmptxt)\n# ------------------------------------------------------------------------------------------------\nif rptfile:\nrptfile_h.close()\nprint('\\n Done .... IECS FAULT Report saved to file %s' % rptfile)\n# ------------------------------------------------------------------------------------\ndef excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):\nimport psspy\nimport excelpy\nif rlst.ierr: return\n# bus data\nsid  = -1   # consider subsystem of all buses\nflag = 1    # consider only in-service buses\nierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\nierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\nierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\nierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\nbus_data = {}\nfor bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\nbus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nscunit   = rlst.scunit\nscfmt    = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nnfbus=len(rlst.fltbus)\nxlswbk = excelpy.workbook(xlsfile)\nxlswbk.show()\nsavfile, snpfile = psspy.sfiles()\nline1, line2 = psspy.titldt()\nttl      = r\"PSSE Short Circuit Calculations Using IECS\"\nttl      = ttl + 5*' ' + time.ctime()\nttl_file = savfile\nttl_line1= line1.strip()\nttl_line2= line2.strip()\ncln_mrglst = []\ncln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\ncln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\nfor fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\nif fltok:\ncln_mrglst.append(len(cln_heads_r1)+1)\ncln_heads_r1.extend([clnnam, ''])\ncln_heads_r2.extend(['MVA', 'AMP'])\ncln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\ncln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\ncolheads = [cln_heads_r1, cln_heads_r2]\nrow = 7\ncln = 1\nsbase = psspy.sysmva()\nfor i in range(nfbus):\nrowdata = []\nfbus    = rlst.fltbus[i]\nbasekv  = bus_data[fbus]['basekv']\nprefltv = bus_data[fbus]['prefltv']\nrowdata.append(fbus)\nrowdata.append(bus_data[fbus]['name'])\nrowdata.append(basekv)\nrowdata.append(basekv*abs(prefltv))\nif flt3ph:\ncval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nif fltlg:\ncval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([3*mva, 3*crnt])\nif fltllg:\ncval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([3*mva, 3*crnt])\nif fltll:\ncval = rlst.fltll[i].ib   # Ifault=Ib\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nzpos  = rlst.thevzpu[i].z1\nzneg  = rlst.thevzpu[i].z2\nzzero = rlst.thevzpu[i].z0\ns_zpos  = self._frmted_z(zpos)\ns_zneg  = self._frmted_z(zneg)\ns_zzero = self._frmted_z(zzero)\nrowdata.extend([s_zpos, s_zneg, s_zzero])\nbrow,rcln = xlswbk.set_range(row,cln,rowdata)\nrow = brow + 1\nxlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\nxlswbk.autofit_columns((6,9,brow,rcln))\nxlswbk.align((6,9,brow,rcln),'right')\n# headings and column titles\nxlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nxlswbk.merge((1,1,1,rcln))\nxlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((2,1,2,rcln))\nxlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((3,1,3,rcln))\nxlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((4,1,4,rcln))\nbrow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\nxlswbk.merge((5,1,5,2))\nfor cln in cln_mrglst:\nxlswbk.merge((5,cln,5,cln+1))\nxlswbk.merge((5,rcln-2,5,rcln))\nxlswbk.align((1,1),'h_center')\nxlswbk.align_rows((1,1,6,1),'h_center')\nif xlsfile: xlswbk.save(xlsfile)\n# ========================================================================================\ndef _get_exam_path():\nimport psspy\nvrsn_pydir = os.path.dirname(psspy.__file__)\nvrsn_rootdir, jnk = os.path.split(vrsn_pydir)\nexamdir = os.path.join(vrsn_rootdir, \"EXAMPLE\")\nreturn examdir\n# ========================================================================================\ndef _get_outpath():\nimport psspy\nnam, mjr, mnr, pch, dt, stat = psspy.psseversion()\ns_mjr = \"{}\".format(mjr)\ns_mnr = \"{}\".format(mnr)\ns_pch = \"{}\".format(pch)\nvnam = \"v{}{}{}\".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))\noutnam = \"output_iecs_demo_{}\".format(vnam)\noutpath = os.path.join(os.getcwd(), outnam)\nif not os.path.exists(outpath): os.makedirs(outpath)\nreturn outpath\n# ========================================================================================\ndef _get_iec60909_network_files():\nsavfile = 'iec60909_testnetwork_50Hz.sav'\niecfile = 'iec60909_testnetwork.iec'\nif not os.path.exists(savfile):\nexamdir = _get_exam_path()\nsavfile = os.path.join(examdir, savfile)\niecfile = os.path.join(examdir, iecfile)\nif not os.path.exists(savfile):\nmsg = \" IEC 60909 Network case not found.\\n    {}\".format(savfile)\nprint(msg)\nraise Exception(\" Case File not found\")\nreturn savfile, iecfile\n# ========================================================================================\ndef run_iecs_4(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nset_prg_rpt(rptfile=rptfile)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\niecsobj.run_iecs_api(sid, allbus, **kwds)\nreset_prg_rpt()\n# ========================================================================================\ndef run_iecs_currents_txtrpt(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iecs_currents_{}.txt\".format(nam_unt[unt])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)"
  },
  {
    "id": "chunk_071",
    "text": "# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nrlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\niecsobj.report_iecs_currents(rlst, rptfile)\n# ========================================================================================\ndef run_iecs_currents_xls(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nxlsfile = \"z_iecs_currents_{}\".format(nam_unt[unt])\noutpath = _get_outpath()\nxlsfile = os.path.join(outpath, xlsfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nrlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\niecsobj.excel_iecs_currents(rlst, xlsfile)\n# ========================================================================================\ndef run_fault_summary_iecs(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iecs_fault_summary_{}.txt\".format(nam_unt[unt])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n##    kwds = {\n##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,\n##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,\n##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,\n##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,\n##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nfltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)\nfltobj.text_report(rptfile)\n# ========================================================================================\n# IEC 60909 Test Network - Compare PSSE Results\ndef run_iec60909_test_network():\n# Results output of following run_iecs_4(..)\n# match to those in Table 12 and Table 13 of IEC 60909-4 2001.\nrun_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)\n# ========================================================================================\ndef _temp():\n# Run either of these functions under  __main__ to see how they work.\nrun_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\nrun_iec60909_test_network()\n# ========================================================================================\nif __name__=='__main__':\npass\n#[iecs_demo.py]   Fault Calculations using IECS\n# =====================================================================================================\n'''There are three different ways to calculate faults using IECS.\n1) Using activity IECS (psspy.iecs_4)\nRuns all types of faults, creates text reports, but no access to results from Python script.\n2) Using Python module arrbox.iecs.iecs_currents\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain both phase and sequence fault currents.\nb) contain faults currents for bus faults only.\nc) does not contain faults currents for linout and linend faults.\n3) Using Python module arrbox.fault.FAULT_SUMMARY\nRuns all types of faults, creates text reports and returns results in python object that can be\naccessed from Python script.\nThe returned python object\na) contain only total fault currents for faults calculated.\nb) contain faults currents for bus, linout and linend faults.\nThis is an example file showing how to run IECS fault calculations using either of these methods.\n---------------------------------------------------------------------------------\nHow to use this file?\nA) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:\nimport psseXX\n[Here XX is PSSE major version number.]\nB) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.\nrun_iecs_4(..)\nrun_iecs_currents_txtrpt(..)\nrun_iecs_currents_xls(..)\nrun_fault_summary_iecs(..)\nRun either of these functions under  __main__ to see how they work.\nC) Create similar functions for the network case and faults you want to run.\n'''\n# ========================================================================================\n#\n\"\"\"\nUse any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.\nKeyword   Default   Description\n# STATUS array\nflt3ph   = 0        # 1 0=>omit, 1=>include\nfltlg    = 0        # 2 0=>omit, 1=>include\nfltllg   = 0        # 3 0=>omit, 1=>include\nfltll    = 0        # 4 0=>omit, 1=>include\nrptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions\nrptlvl   = 0        # 6  number of contribution levels\nfltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,\n#    2=>AUX.XMER (connected to power station unit) LV bus\nlinout   = 0        # 8  0=>omit, 1=>include\nlinend   = 0        # 9  0=>omit, 1=>include\ntpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,\n#    3=>N unchanged and phi=0\nlnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)\nshntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,\n#    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)\ndcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)\nzcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)\ncfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,\n#    2=>User specified, maximum current, 3=>User specified, minimum current\nloadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)\ngenxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs\n# VALUES array\nbrktime  = 0.1      # 0.1 seconds, breaker contact parting time\nucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)\n# File args\niecfile   = ''\nfcdfile   = ''\nscfile    = 'nooutput'\n\"\"\"\n# ========================================================================================\nimport sys, os, time, math\nbsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],\n'owners':[], 'zones':[]}\ndef fault_bsys(sid, **kwds):\nimport psspy\nif sid==0: return\nactv_kwds = {}  # activity keywords\nfor k, v in bsys_kwds.items():\nif k in kwds:\nactv_kwds[k] = kwds[k]\nelse:\nactv_kwds[k] = v\nactv_kwds['sid']      = sid\nactv_kwds['numarea']  = len(actv_kwds['areas'])\nactv_kwds['numbus']   = len(actv_kwds['buses'])\nactv_kwds['numowner'] = len(actv_kwds['owners'])\nactv_kwds['numzone']  = len(actv_kwds['zones'])\nierr = psspy.bsys(**actv_kwds)\nreturn ierr\n# ========================================================================================\ndef set_prg_rpt(prgfile='', rptfile=''):\nimport psspy\npsspy.lines_per_page_one_device(1,10000000)\nif prgfile: psspy.progress_output(2,prgfile,[0,0])\nif rptfile: psspy.report_output(2,rptfile,[0,0])\n# ========================================================================================\ndef reset_prg_rpt():\nimport psspy\npsspy.lines_per_page_one_device(2,10000000)\npsspy.progress_output(1,'',[0,0])\npsspy.report_output(1,'',[0,0])\n# ========================================================================================\nclass IECS_DEMO:\n\"\"\" Run PSSE IECS Calculations\"\"\"\ndef __init__(self):\nimport psspy\nself.ierr = psspy.psseinit(buses=150000)\n# ------------------------------------------------------------------------------------\ndef _frmted_z(self, cnum):"
  },
  {
    "id": "chunk_072",
    "text": "r=cnum.real\nx=cnum.imag\ncsign='+j'\nif x<0:\ncsign='-j'\nx=abs(x)\nif r==0:\nrstr=''\nelse:\nrstr=\"%9.6f\" % r\nif x==0:\nxstr=''\ncsign=''\nelse:\nxstr=\"%9.6f\" % x\nzstr = \"%(rstr)s%(csign)s%(xstr)s\" % vars()\nreturn zstr\n# ------------------------------------------------------------------------------------\ndef _frmted_z_xbyr(self, cnum):\nzstr = self._frmted_z(cnum)\nr=cnum.real\nx=abs(cnum.imag)\nif r==0:\nxbyr=''\nelse:\nxbyr=\"%9.6f\" % (x/r)\ncstr=\"%(zstr)s, %(xbyr)s\" % vars()\nreturn cstr\n# ------------------------------------------------------------------------------------\ndef _crnt_mag(self, fmt, cval):\nif fmt=='rectangular':\nreturn abs(cval)\nelse:\nreturn cval.real\n# ------------------------------------------------------------------------------------\ndef _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):\nif scfmt=='rectangular':\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\ncrnt = abs(crnt)\nelse:\ncval = cval.real\nif scunit=='pu':\nbaseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)\ncrnt = cval*baseamp\nelse:\ncrnt = cval\nmva  = math.sqrt(3.0)*basekv*crnt/1000.0\nreturn crnt, mva\n# ------------------------------------------------------------------------------------\ndef run_iecs_api(self, sid, allbus, **kwds):\nimport psspy\nierr = psspy.iecs_4(sid, allbus, **kwds)\n# ------------------------------------------------------------------------------------\ndef run_iecs_currents(self, sid, allbus, **kwds):\nimport psspy, arrbox.iecs\nrlst = arrbox.iecs.iecs_currents(sid, allbus, **kwds)\nif rlst.ierr!=0:\nraise Exception(\"arrbox.iecs.iecs_currents error= {}\\n\".format(rlst.ierr))\nreturn rlst\n# ------------------------------------------------------------------------------------\ndef run_fault_summary(self, sid, allbus, **kwds):\nimport psspy, arrbox.fault\nfltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)\nif fltobj.ierr!=0:\nraise Exception(\"arrbox.fault.FAULT_SUMMARY error= {}\\n\".format(fltobj.ierr))\nreturn fltobj\n# ------------------------------------------------------------------------------------\ndef report_iecs_currents(self, rlst, rptfile=''):\nimport psspy\nif rlst.ierr: return\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:\nx = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nnfbus=len(rlst.fltbus)\ntxtlst = []\nif not rptfile: txtlst.append('')\nttlstr=\"PSS(R)E IECS SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\nln1str,ln2str=psspy.titldt()\nmaxlen=max(len(ttlstr),len(ln1str),len(ln2str))\ntxtlst.append(ttlstr.center(maxlen))\ntxtlst.append(ln1str.center(maxlen))\ntxtlst.append(ln2str.center(maxlen))\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nscunit = rlst.scunit\nscfmt  = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nif scunit == 'pu':\nunits = 'PU'\nelse:\nunits = 'AMP'\nunitstr   = units.center(10)\nclnhdr    = \"   BUS     \" + 6*unitstr\nfor i in range(nfbus):\ntxtlst = []\ntxtlst.append('')\ntxtlst.append(\"           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\")\ntxtlst.append(clnhdr)\nfbus   = rlst.fltbus[i]\nif flt3ph:\nttxt   = \"%6d\" % fbus\nspc    = '3PH'\nia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)\nib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)\nic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltlg:\nif flt3ph:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = ' LG'\nia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltllg:\nif flt3ph or fltlg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = 'LLG'\nia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\nif fltll:\nif flt3ph or fltlg or fltllg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc     = ' LL'\nia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)\nib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)\nic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f\" % vars()\ntxtlst.append(tmptxt)\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (pu), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\nif scunit_z!='pu':\ntxtlst.append(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\")\nz1str = self._frmted_z_xbyr(rlst.thevz[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = self._frmted_z_xbyr(rlst.thevz[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = self._frmted_z_xbyr(rlst.thevz[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\" % vars()\nelse:\ntmptxt=\"%(z1str)s\" % vars()\ntxtlst.append(tmptxt)\ntmptxt=110*'-'\ntxtlst.append(tmptxt)\ntxtlst.append('')\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\n# Maximum Fault Currents\ninam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\nunitstr   = units.center(11)\nunitstr = ''\nfor each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\nt = each+'('+units+')'\nt = ' ' + t.center(9) + ' '\nunitstr += t\ntxtlst = []\ntxtlst.append('')\nclnhdr    = \"   BUS  \" + unitstr + \"  Description\"\ntxtlst.append(\"BREAKER DUTY CURRENTS\")\ntxtlst.append(clnhdr)\ntxtall = \"\\n\".join(txtlst)\nreport(txtall)\nfor i in range(nfbus):\nfbus   = rlst.fltbus[i]\nia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)\nia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)\nia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)\nia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)\nib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)\nic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)\ndsc    = rlst.maxfltdsc[i]\nif rptfile: report('\\n')\ntmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\" % vars()\nreport(tmptxt)\n# ------------------------------------------------------------------------------------------------\nif rptfile:\nrptfile_h.close()\nprint('\\n Done .... IECS FAULT Report saved to file %s' % rptfile)\n# ------------------------------------------------------------------------------------\ndef excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):\nimport psspy\nimport excelpy\nif rlst.ierr: return\n# bus data\nsid  = -1   # consider subsystem of all buses\nflag = 1    # consider only in-service buses\nierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])\nierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')\nierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu\nierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')\nbus_data = {}\nfor bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):\nbus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}\nflt3ph = rlst.flt3ph\nfltlg  = rlst.fltlg\nfltllg = rlst.fltllg\nfltll  = rlst.fltll\nscunit   = rlst.scunit\nscfmt    = rlst.scfmt\nscunit_z = rlst.scunit_z\nscfmt_z  = rlst.scfmt_z\nnfbus=len(rlst.fltbus)\nxlswbk = excelpy.workbook(xlsfile)\nxlswbk.show()\nsavfile, snpfile = psspy.sfiles()\nline1, line2 = psspy.titldt()\nttl      = r\"PSSE Short Circuit Calculations Using IECS\"\nttl      = ttl + 5*' ' + time.ctime()\nttl_file = savfile\nttl_line1= line1.strip()\nttl_line2= line2.strip()\ncln_mrglst = []\ncln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']\ncln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']\nfor fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],\n['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):\nif fltok:\ncln_mrglst.append(len(cln_heads_r1)+1)\ncln_heads_r1.extend([clnnam, ''])\ncln_heads_r2.extend(['MVA', 'AMP'])\ncln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])\ncln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])\ncolheads = [cln_heads_r1, cln_heads_r2]\nrow = 7\ncln = 1\nsbase = psspy.sysmva()\nfor i in range(nfbus):\nrowdata = []\nfbus    = rlst.fltbus[i]\nbasekv  = bus_data[fbus]['basekv']\nprefltv = bus_data[fbus]['prefltv']\nrowdata.append(fbus)\nrowdata.append(bus_data[fbus]['name'])\nrowdata.append(basekv)\nrowdata.append(basekv*abs(prefltv))\nif flt3ph:\ncval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nif fltlg:\ncval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([3*mva, 3*crnt])\nif fltllg:\ncval = rlst.fltllg[i].ia0   # Ifault=3*Ia0\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)"
  },
  {
    "id": "chunk_073",
    "text": "rowdata.extend([3*mva, 3*crnt])\nif fltll:\ncval = rlst.fltll[i].ib   # Ifault=Ib\ncrnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)\nrowdata.extend([mva, crnt])\nzpos  = rlst.thevzpu[i].z1\nzneg  = rlst.thevzpu[i].z2\nzzero = rlst.thevzpu[i].z0\ns_zpos  = self._frmted_z(zpos)\ns_zneg  = self._frmted_z(zneg)\ns_zzero = self._frmted_z(zzero)\nrowdata.extend([s_zpos, s_zneg, s_zzero])\nbrow,rcln = xlswbk.set_range(row,cln,rowdata)\nrow = brow + 1\nxlswbk.font((6,3,brow,8),numberFormat=\"0.00\")\nxlswbk.autofit_columns((6,9,brow,rcln))\nxlswbk.align((6,9,brow,rcln),'right')\n# headings and column titles\nxlswbk.set_cell((1,1),ttl,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nxlswbk.merge((1,1,1,rcln))\nxlswbk.set_cell((2,1),ttl_file,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((2,1,2,rcln))\nxlswbk.set_cell((3,1),ttl_line1,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((3,1,3,rcln))\nxlswbk.set_cell((4,1),ttl_line2,fontStyle=\"Bold\",fontSize=10, fontColor=\"red\")\nxlswbk.merge((4,1,4,rcln))\nbrow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor=\"blue\")\nxlswbk.merge((5,1,5,2))\nfor cln in cln_mrglst:\nxlswbk.merge((5,cln,5,cln+1))\nxlswbk.merge((5,rcln-2,5,rcln))\nxlswbk.align((1,1),'h_center')\nxlswbk.align_rows((1,1,6,1),'h_center')\nif xlsfile: xlswbk.save(xlsfile)\n# ========================================================================================\ndef _get_exam_path():\nimport psspy\nvrsn_pydir = os.path.dirname(psspy.__file__)\nvrsn_rootdir, jnk = os.path.split(vrsn_pydir)\nexamdir = os.path.join(vrsn_rootdir, \"EXAMPLE\")\nreturn examdir\n# ========================================================================================\ndef _get_outpath():\nimport psspy\nnam, mjr, mnr, pch, dt, stat = psspy.psseversion()\ns_mjr = \"{}\".format(mjr)\ns_mnr = \"{}\".format(mnr)\ns_pch = \"{}\".format(pch)\nvnam = \"v{}{}{}\".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))\noutnam = \"output_iecs_demo_{}\".format(vnam)\noutpath = os.path.join(os.getcwd(), outnam)\nif not os.path.exists(outpath): os.makedirs(outpath)\nreturn outpath\n# ========================================================================================\ndef _get_iec60909_network_files():\nsavfile = 'iec60909_testnetwork_50Hz.sav'\niecfile = 'iec60909_testnetwork.iec'\nif not os.path.exists(savfile):\nexamdir = _get_exam_path()\nsavfile = os.path.join(examdir, savfile)\niecfile = os.path.join(examdir, iecfile)\nif not os.path.exists(savfile):\nmsg = \" IEC 60909 Network case not found.\\n    {}\".format(savfile)\nprint(msg)\nraise Exception(\" Case File not found\")\nreturn savfile, iecfile\n# ========================================================================================\ndef run_iecs_4(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt\".format(nam_unt[unt], kwds['rptop'])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nset_prg_rpt(rptfile=rptfile)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\niecsobj.run_iecs_api(sid, allbus, **kwds)\nreset_prg_rpt()\n# ========================================================================================\ndef run_iecs_currents_txtrpt(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iecs_currents_{}.txt\".format(nam_unt[unt])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nrlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\niecsobj.report_iecs_currents(rlst, rptfile)\n# ========================================================================================\ndef run_iecs_currents_xls(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nxlsfile = \"z_iecs_currents_{}\".format(nam_unt[unt])\noutpath = _get_outpath()\nxlsfile = os.path.join(outpath, xlsfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nrlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)\niecsobj.excel_iecs_currents(rlst, xlsfile)\n# ========================================================================================\ndef run_fault_summary_iecs(**kwds):\nimport psspy\npsspy.psseinit(buses=150000)\nsavfile, iecfile = _get_iec60909_network_files()\nbuses = [1,2,3,4,5,6,7,8]\nsid, allbus = 3, 0\nnam_unt = {0:'pu', 1:'amp'}\nunt=1\nrptfile = \"z_iecs_fault_summary_{}.txt\".format(nam_unt[unt])\noutpath = _get_outpath()\nrptfile = os.path.join(outpath, rptfile)\nierr = psspy.case(savfile)\nierr = fault_bsys(sid, buses=buses)\n# set short circuit options\npsspy.short_circuit_units(unt)          # 0=PU, 1=Physical\npsspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical\npsspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar\npsspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar\npsspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings\n##    kwds = {\n##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,\n##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,\n##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,\n##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,\n##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }\nkwds['iecfile'] = iecfile\niecsobj = IECS_DEMO()\nfltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)\nfltobj.text_report(rptfile)\n# ========================================================================================\n# IEC 60909 Test Network - Compare PSSE Results\ndef run_iec60909_test_network():\n# Results output of following run_iecs_4(..)\n# match to those in Table 12 and Table 13 of IEC 60909-4 2001.\nrun_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)\n# ========================================================================================\ndef _temp():\n# Run either of these functions under  __main__ to see how they work.\nrun_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)\nrun_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)\nrun_iec60909_test_network()\n# ========================================================================================\nif __name__=='__main__':\npass\n#[iecs_report.py]    Get IEC fault currents in arrays and create custom report\n# =====================================================================================================\n'''\nThis is an example file showing how to use \"iecs_currents\" function from pssarrays module.\nIECS_CURRENTS function returns IEC 60909 standard fault currents for each faulted bus and\neach type of fault applied. They are:\nia1   = Positive Sequence Current\nia2   = Negative Sequence Current\nia0   = Zero Sequence Current\nia    = Phase A current\nib    = Phase B current\nic    = Phase C current\nipb   = peak Current - Method B, ip(B)\nipc   = peak Current - Method C, ip(C)\nidc   = DC component of asymmetrical breaking current, idc\nibsym = symmetrical breaking current (r.m.s.), ib(sym)\nibuns = asymmetrical breaking current (r.m.s.), ib(uns)\nThe APIs used in this program are part of python \"pssarrays\" module.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call funtion\nrun_iecs_report()\nYou may want to change inputs specified in this function.\nrun_iecs_report(savfile, iecfile, fltbuses, rptfile)\nDefaults:\nsavfile  = 'iec60909_testnetwork_50Hz.sav'\niecfile  = 'iec60909_testnetwork.iec'\nfltbuses = [1,2,3,4,5,6,7,8]\nrptfile  = 'iecs_report_iec60909_testnetwork_50Hz.txt'\nWhen this script is called from PSSE's Example Folder,\nreport is created in subfolder 'Output_Pyscript'\n'''\n# =====================================================================================================\nimport os, time\n# =====================================================================================================\ndef encode_complex_number_xbyr(cnum):\nr=cnum.real\nx=cnum.imag\ncsign='+j'\nif x<0:\ncsign='-j'\nx=abs(x)\nif r==0:\nrstr=''\nxbyr=''\nelse:\nrstr=\"%9.6f\" % r\nxbyr=\"%9.6f\" % (x/r)\nif x==0:\nxstr=''\ncsign=''\nelse:\nxstr=\"%9.6f\" % x\ncstr=\"%(rstr)s%(csign)s%(xstr)s, %(xbyr)s\" % vars()\nreturn cstr\n# =====================================================================================================\ndef current_magnitude(fmt,cmplxvalue):\nif fmt == 'rectangular':\nreturn abs(cmplxvalue)\nelse:\nreturn cmplxvalue.real\n# =====================================================================================================\ndef create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,\nlnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,\nsavfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):\nimport psspy, arrbox.iecs\n# open case\nif savfile: psspy.case(savfile)\n# set sc units and format\npsspy.short_circuit_units(units)\npsspy.short_circuit_coordinates(fmt)\nsid = 3\nif fltbuses:\npsspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])\nbusall = 0\nelse:\nbusall = 1\n# call pssarrays routine\nrlst=arrbox.iecs.iecs_currents(sid=sid, all=busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,\nfltll=fltll, linout=linout, linend=linend, tpunty=tpunty, lnchrg=lnchrg,\nshntop=shntop, dcload=dcload, zcorec= zcorec, optnftrc=optnftrc, loadop=loadop,"
  },
  {
    "id": "chunk_074",
    "text": "genxop=genxop, brktime=brktime, vfactorc=vfactorc,\niecfile=iecfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)\nif rlst.ierr!=0:\nraise Exception(\"arrbox.iecs.iecs_currents error= %d\\n\" % rlst.ierr)\nif rptfile:\np, nx = os.path.split(rptfile)\nn, x = os.path.splitext(nx)\nif not x:\nx = '.txt'\nnx = n + x\nif p:\nrptfile = os.path.join(p, nx)\nelse:\nrptfile = os.path.join(os.getcwd(), nx)\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\nelse:\npsspy.beginreport()\nreport = psspy.report\nnfbus=len(rlst.fltbus)\nttlstr=\"PSS(R)E IEC 60909 SHORT CIRCUIT CURRENTS\" + 10*' ' + time.ctime()\nln1str,ln2str=psspy.titldt()\nmaxlen=max(len(ttlstr),len(ln1str),len(ln2str))\nreport(ttlstr.center(maxlen))\nreport(\"\\n\")\nreport(ln1str.center(maxlen))\nreport(\"\\n\")\nreport(ln2str.center(maxlen))\nreport(\"\\n\\n\")\nscunit = rlst.scunit\nscfmt  = rlst.scfmt\nif scunit == 'pu':\nunits = 'PU'\nelse:\nunits = 'AMP'\nunitstr   = units.center(10)\nclnhdr    = \"   BUS     \" + 6*unitstr + \"\\n\"\nfor i in range(nfbus):\nreport(\"           <-i''k--> <-ip(B)-> <-ip(C)-> <--idc--> <ib(sym)> <ib(uns)>\\n\")\nreport(clnhdr)\nfbus   = rlst.fltbus[i]\nif flt3ph:\nttxt   = \"%6d\" % fbus\nspc    = '3PH'\nia1    = current_magnitude(scfmt,rlst.flt3ph[i].ia1)\nia2    = current_magnitude(scfmt,rlst.flt3ph[i].ia2)\nia0    = current_magnitude(scfmt,rlst.flt3ph[i].ia0)\nia     = current_magnitude(scfmt,rlst.flt3ph[i].ia)\nib     = current_magnitude(scfmt,rlst.flt3ph[i].ib)\nic     = current_magnitude(scfmt,rlst.flt3ph[i].ic)\nipb    = current_magnitude(scfmt,rlst.flt3ph[i].ipb)\nipc    = current_magnitude(scfmt,rlst.flt3ph[i].ipc)\nidc    = current_magnitude(scfmt,rlst.flt3ph[i].idc)\nibsym  = current_magnitude(scfmt,rlst.flt3ph[i].ibsym)\nibuns  = current_magnitude(scfmt,rlst.flt3ph[i].ibuns)\ntmptxt = \"%(ttxt)s %(spc)s %(ia1)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltlg:\nif flt3ph:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = ' LG'\nia1    = current_magnitude(scfmt,rlst.fltlg[i].ia1)\nia2    = current_magnitude(scfmt,rlst.fltlg[i].ia2)\nia0    = current_magnitude(scfmt,3*rlst.fltlg[i].ia0)\nia     = current_magnitude(scfmt,rlst.fltlg[i].ia)\nib     = current_magnitude(scfmt,rlst.fltlg[i].ib)\nic     = current_magnitude(scfmt,rlst.fltlg[i].ic)\nipb    = current_magnitude(scfmt,rlst.fltlg[i].ipb)\nipc    = current_magnitude(scfmt,rlst.fltlg[i].ipc)\nidc    = current_magnitude(scfmt,rlst.fltlg[i].idc)\nibsym  = current_magnitude(scfmt,rlst.fltlg[i].ibsym)\nibuns  = current_magnitude(scfmt,rlst.fltlg[i].ibuns)\ntmptxt = \"%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltllg:\nif flt3ph or fltlg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc    = 'LLG'\nia1    = current_magnitude(scfmt,rlst.fltllg[i].ia1)\nia2    = current_magnitude(scfmt,rlst.fltllg[i].ia2)\nia0    = current_magnitude(scfmt,3*rlst.fltllg[i].ia0)\nia     = current_magnitude(scfmt,rlst.fltllg[i].ia)\nib     = current_magnitude(scfmt,rlst.fltllg[i].ib)\nic     = current_magnitude(scfmt,rlst.fltllg[i].ic)\nipb    = current_magnitude(scfmt,rlst.fltllg[i].ipb)\nipc    = current_magnitude(scfmt,rlst.fltllg[i].ipc)\nidc    = current_magnitude(scfmt,rlst.fltllg[i].idc)\nibsym  = current_magnitude(scfmt,rlst.fltllg[i].ibsym)\nibuns  = current_magnitude(scfmt,rlst.fltllg[i].ibuns)\ntmptxt = \"%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\nreport(tmptxt)\nif fltll:\nif flt3ph or fltlg or fltllg:\nttxt = 6*' '\nelse:\nttxt = \"%6d\" % fbus\nspc     = ' LL'\nia1    = current_magnitude(scfmt,rlst.fltll[i].ia1)\nia2    = current_magnitude(scfmt,rlst.fltll[i].ia2)\nia0    = current_magnitude(scfmt,rlst.fltll[i].ia0)\nia     = current_magnitude(scfmt,rlst.fltll[i].ia)\nib     = current_magnitude(scfmt,rlst.fltll[i].ib)\nic     = current_magnitude(scfmt,rlst.fltll[i].ic)\nipb    = current_magnitude(scfmt,rlst.fltll[i].ipb)\nipc    = current_magnitude(scfmt,rlst.fltll[i].ipc)\nidc    = current_magnitude(scfmt,rlst.fltll[i].idc)\nibsym  = current_magnitude(scfmt,rlst.fltll[i].ibsym)\nibuns  = current_magnitude(scfmt,rlst.fltll[i].ibuns)\ntmptxt = \"%(ttxt)s %(spc)s %(ib)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \\n\" % vars()\nreport(tmptxt)\nreport(\"\\nTHEVENIN IMPEDANCE (pu), X/R\\n\")\nz1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\nelse:\ntmptxt=\"%(z1str)s\\n\" % vars()\nreport(tmptxt)\nif scunit != 'pu':\nreport(\"\\nTHEVENIN IMPEDANCE (ohms), X/R\\n\")\nz1str = encode_complex_number_xbyr(rlst.thevz[i].z1)\nz1str =\"Z1: \" + z1str\nif fltlg or fltllg or fltll:\nz2str = encode_complex_number_xbyr(rlst.thevz[i].z2)\nz2str =\"Z2: \" + z2str\nz0str = encode_complex_number_xbyr(rlst.thevz[i].z0)\nz0str =\"Z0: \" + z0str\ntmptxt=\"%(z1str)s    %(z2str)s    %(z0str)s\\n\" % vars()\nelse:\ntmptxt=\"%(z1str)s\\n\" % vars()\nreport(tmptxt)\ntmptxt=110*'-'\nreport(tmptxt)\nreport(\"\\n\")\n# Maximum Fault Currents\ninam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']\nunitstr   = units.center(11)\nunitstr = ''\nfor each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:\nt = each+'('+units+')'\nt = ' ' + t.center(9) + ' '\nunitstr += t\nclnhdr    = \"   BUS  \" + unitstr + \"  Description\\n\"\nreport(\"\\nBREAKER DUTY CURRENTS\\n\")\nreport(clnhdr)\nfor i in range(nfbus):\nfbus   = rlst.fltbus[i]\nia1    = current_magnitude(scfmt,rlst.maxflt[i].ia1)\nia2    = current_magnitude(scfmt,rlst.maxflt[i].ia2)\nia0    = current_magnitude(scfmt,rlst.maxflt[i].ia0)\nia     = current_magnitude(scfmt,rlst.maxflt[i].ia)\nib     = current_magnitude(scfmt,rlst.maxflt[i].ib)\nic     = current_magnitude(scfmt,rlst.maxflt[i].ic)\ndsc    = rlst.maxfltdsc[i]\ntmptxt = \"%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\\n\" % vars()\nreport(tmptxt)\n# ------------------------------------------------------------------------------------------------\nif rptfile:\nrptfile_h.close()\nprint('\\n Done .... IECS FAULT Report saved to file %s' % rptfile)\nelse:\nprint('\\n Done .... IECS FAULT Report created in Report window.')\n# =====================================================================================================\ndef check_psse_example_folder(rptfile):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nrptpath, rptfnam = os.path.split(rptfile)\nif not rptpath:\nrptpath = os.getcwd()\ncwd = rptpath.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(os.getcwd(), 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\nrptfile  = os.path.join(outdir, rptfnam)\nreturn rptfile\n# =====================================================================================================\ndef run_iecs_report(savfile='iec60909_testnetwork_50Hz.sav', iecfile='iec60909_testnetwork.iec',\nfltbuses=[1,2,3,4,5,6,7,8], rptfile='iecs_report_iec60909_testnetwork_50Hz.txt'):\nimport psspy\npsspy.psseinit()\n# Inputs, change as required\nunits    = 1       # 0=per unit,    1=physical\nfmt      = 0       # 0=rectangular, 1=polar coordinates\nflt3ph   = 1       #\nfltlg    = 1       #\nfltllg   = 1       #\nfltll    = 1       #\nlinout   = 0       #\nlinend   = 0       #\ntpunty   = 0       #\nlnchrg   = 1       #\nshntop   = 1       #\ndcload   = 0       #\nzcorec   = 0       #\noptnftrc = 0       #\nloadop   = 1       #\ngenxop   = 0       # 0=X\", 1=X', 2=Xs (generator reactance)\nbrktime  = 0.1     # 0.1 seconds\nvfactorc = 1.0     #\nrptfile  = check_psse_example_folder(rptfile)\nfcdfile  = \"\"\nscfile   = \"\"\nrprtyp   = -1      # no report\nrprlvl   = 0       # number of contribution levels\ncreate_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,\nlnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,\nsavfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun_iecs_report()\n# ====================================================================================================\n#[nlevel_buses.py]   Get N level buses from Home Bus\n# =====================================================================================================\n'''This script returns a dictionary of N level buses from Home (starting) Bus.\nThe next level bus is found from its branch and transformer connections [and not its electrical length].\n---------------------------------------------------------------------------------\nHow to use this file?\nRefer \"test_me()\" function.\n'''\n# ========================================================================================\ndef get_nlevel_buses(homebus, nlevels):\n\"\"\"\nPython Syntax:\nlvl_busdict = get_nlevel_buses(savfile, homebus, nlevels)\nArguments:\nhomebus(integer) : Home (starting) bus number to start finding next buses\nnlevels(integer) : Number of levels of buses from Home Bus\n\"\"\"\nimport psspy\npsspy.psseinit()\nlvl_list = [n+1 for n in range(nlevels)]\nlvl_busdict = {}\nlvl_busdict[0] = [homebus]\ndo_buslist = [homebus]\ndone_busdict = {}\nfor lvl in lvl_list:\nif not do_buslist: break\ntmp_busdict = {}\n# Search for branches and two winding transformers\nfor ibus in do_buslist:\nierr = psspy.inibrn(ibus, single=2)\n#print(\"0 inibrn: ierr={}, ibus={}\".format(ierr, ibus))\nif ierr == 0:\nwhile True:\nierr,jbus,ickt = psspy.nxtbrn(ibus)\n#print(\"1 nxtbrn: ierr={}, jbus={}\".format(ierr, jbus))\nif ierr: break\ntmp_busdict[jbus] = 1\n# Search for three winding transformers\nfor ibus in do_buslist:\nierr = psspy.inibrn(ibus, single=2)\nif ierr == 0:\nwhile True:\nierr,jbus,kbus,ickt = psspy.nxtbrn3(ibus)\n#print(\"2 nxtbrn3: ierr={}, jbus={}, kbus={}\".format(ierr, jbus, kbus))\nif ierr: break"
  },
  {
    "id": "chunk_075",
    "text": "tmp_busdict[jbus] = 1\nif (kbus>0): tmp_busdict[kbus] = 1\ntmp_buslist = list(tmp_busdict.keys())\ntmp_buslist.sort()\nfor ibus in do_buslist:\ndone_busdict[ibus] = 1\ndo_buslist = []\nfor ibus in tmp_buslist:\nif ibus not in done_busdict:\ndo_buslist.append(ibus)\nlvl_busdict[lvl] = do_buslist[:]\n# all done\nreturn lvl_busdict\n# ========================================================================================\ndef test_me():\nimport psse3502\nimport psspy\npsspy.psseinit()\nsavfile = \"sample.sav\"\npsspy.case(savfile)\nlvl_busdict = get_nlevel_buses(151, 3)\n#lvl_busdict = get_nlevel_buses(206, 10)\n#lvl_busdict = get_nlevel_buses(101, 10)\nprint(\"N Level Buses\")\nfor lvl, buslist in lvl_busdict.items():\nprint(\"Level={}, Buses={}\".format(lvl, buslist))\n# ========================================================================================\nif __name__==\"__main__\":\npass\n# Generated on TUE, JUN 08 2004  11:37\npsspy.case(r\"\"\"savnw.sav\"\"\")\npsspy.opendiagfile(r\"\"\"savnw.sld\"\"\")\n#[otdffactors_excel.py]  OTDF FACTORS Exported to Excel Spreadsheet\n# ====================================================================================================\n'''\nThis is an example file showing how to use DFAX_PP object's method \"otdf_factors\" from\nPSSARRAYS module to export OTDF factors to excel spreadsheet.\nYou need to have Win32 extensions for Python installed.\n(http://sourceforge.net/projects/pywin32)\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call funtion\notdf_excel(savfile, dfxfile, outpath, show)\nor\notdf_excel()  <-- savnw.sav and savnw.dfx must exist in working folder.\n'''\n# ----------------------------------------------------------------------------------------------------\nimport sys, os\n# -----------------------------------------------------------------------------------------------------\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# -----------------------------------------------------------------------------------------------------\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ----------------------------------------------------------------------------------------------------\ndef otdf_excel(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None, show=True):\nimport psspy, arrbox.dfax_pp\nimport excelpy\nif not os.path.exists(savfile):\nprint(\"\\n SAV file '%s' not found.\" % savfile)\nreturn\nif not os.path.exists(dfxfile):\nprint(\"\\n DFAX file '%s' not found.\" % dfxfile)\nreturn\np, nx = os.path.split(dfxfile)\nn, x  = os.path.splitext(nx)\nxlfile = get_output_filename(outpath, 'otdffactors_'+n)\npsspy.psseinit()\npsspy.case(savfile)\ndfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)\notdfobj = dfxobj.otdf_factors()\nif otdfobj.ierr != 0: return\notdfxls = excelpy.workbook(xlfile, 'OTDF FACTORS', overwritesheet=True)\nif show: otdfxls.show()\notdfxls.show_alerts(0) # do not show pop-up alerts\notdfxls.page_format(orientation=\"landscape\",left=1.0,right=1.0,\ntop=0.5,bottom=0.5,header=0.25,footer=0.25)\notdfxls.page_footer(left='page number of page total', right='date, time')\notdfxls.page_header(center='file name:sheet name')\notdfxls.font_sheet()\n# Report Title\ncol = 1\nrow = 1\ntmplst = ([\"OTDF Factors Report\"],[dfxfile])\nbottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\notdfxls.font((1,1),fontColor='red',fontSize=14)\notdfxls.font_color((2,1),'blue')\nrow = bottomRow + 1\ntmplst = [\notdfobj.casetitle.line1,                                       #\notdfobj.casetitle.line2,                                       #\n''\n'Saved Case file              = %s' % otdfobj.file.sav,         #\n'DFAX file                    = %s' % otdfobj.file.dfx,         #\n'Subsystem file               = %s' % otdfobj.file.sub,         #\n'Monitored Element file       = %s' % otdfobj.file.mon,         #\n'Contingency Description file = %s' % otdfobj.file.con,         #\n]\nbottomRow,rightCol = otdfxls.set_range(row,col,tmplst,transpose=True)\nrow = bottomRow + 2 # one blank row\ntxt = \"'*** OTDF Contingency Description ***\"\notdfxls.set_cell((row,col),txt,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nrow = row + 1\ntmplst=[]\nfor i in range(otdfobj.size.ncase):\nlbl  = otdfobj.colabel[i]\ndesc = otdfobj.codesc[i]\ntmplst.append([lbl,desc])\nbottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\notdfxls.align((row,col,bottomRow,col),'right')\notdfxls.font_color((row,col,bottomRow,col),'dgreen')\nrow = bottomRow + 2 # one blank row\ntxt = \"'*** OTDF Factors ***\"\notdfxls.set_cell((row,col),txt,fontStyle=\"Bold\",fontSize=12, fontColor=\"red\")\nrow = row + 1\ntmplst=['<---------- Monitored Branch/Interface ------------->']\nfor each in otdfobj.colabel:\ntmplst.append(each.strip())\nbottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\notdfxls.align((row,col,bottomRow,rightCol),'right')\notdfxls.font_color((row,col,bottomRow,rightCol),'blue')\nrow = bottomRow + 1\ntmplst=[]\nfor i in range(otdfobj.size.nmline+otdfobj.size.ninter):\ntmplst.append([otdfobj.melement[i].strip()])\nbottomRow,rightCol = otdfxls.set_range(row,col,tmplst)\notdfxls.align((row,col,bottomRow,col),'right')\notdfxls.font_color((row,col,bottomRow,col),'dgreen')\ncol = rightCol + 1\nbottomRow,rightCol = otdfxls.set_range(row,col,otdfobj.factor,transpose=True,numberFormat='0.0000')\notdfxls.width((1,1),53)\notdfxls.width((1,2,1,rightCol),12)\n# ------------------------------------------------------------------------------------------------\n# Save the workbook and close the Excel application\nxlfile = otdfxls.save(xlfile)\nif not show:\notdfxls.close()\ntxt = '\\n OTDF Factors saved to file %s\\n' % xlfile\nsys.stdout.write(txt)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\notdf_excel()\n# OR\n#otdf_excel(savfile, dfxfile, outpath, show)\n# ====================================================================================================\n#[otdffactors_report.py]  OTDF FACTORS REPORT\n# ====================================================================================================\n'''\nThis is an example file showing how to use DFAX_PP object's method \"otdf_factors\" from\nPSSARRAYS module to generate OTDF factors report.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call funtion\notdf_report(savfile, dfxfile, outpath, show)\nor\notdf_report()  <-- savnw.sav and savnw.dfx must exist in working folder.\n'''\n# ----------------------------------------------------------------------------------------------------\nimport sys, os, time\n# -----------------------------------------------------------------------------------------------------\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# -----------------------------------------------------------------------------------------------------\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ----------------------------------------------------------------------------------------------------\ndef otdf_report(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):\nimport psspy, arrbox.dfax_pp\nif not os.path.exists(savfile):\nprint(\"\\n SAV file '%s' not found.\" % savfile)\nreturn\nif not os.path.exists(dfxfile):\nprint(\"\\n DFAX file '%s' not found.\" % dfxfile)\nreturn\np, nx = os.path.split(dfxfile)\nn, x  = os.path.splitext(nx)\nrptfile = get_output_filename(outpath, 'otdffactors_'+n+'.txt')\npsspy.psseinit()\npsspy.case(savfile)\ndfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)\notdfobj = dfxobj.otdf_factors()\nif otdfobj.ierr != 0: return\nrptfile_h = open(rptfile,'w')\nreport    = rptfile_h.write\n# (0) Report title\nttl_hline = '*' + 46* ' *' + '\\n\\n'\nttl       = 30*' ' + \"OTDF Factors Report\" + \"\\n\"\nttl_file  = 30*' ' + otdfobj.file.dfx + \"\\n\"\nttl_time  = 30*' ' + time.ctime() + \"\\n\\n\"\nreport(ttl_hline)\nreport(ttl)\nreport(ttl_file)\nreport(ttl_time)\nreport(ttl_hline)\nreport('%s\\n' % otdfobj.casetitle.line1)\nreport('%s\\n' % otdfobj.casetitle.line2)\nreport('\\n')\nreport('Saved Case file              = %s\\n' % otdfobj.file.sav)\nreport('DFAX file                    = %s\\n' % otdfobj.file.dfx)\nreport('Subsystem file               = %s\\n' % otdfobj.file.sub)\nreport('Monitored Element file       = %s\\n' % otdfobj.file.mon)\nreport('Contingency Description file = %s\\n' % otdfobj.file.con)\nreport('\\n')\nreport('*** OTDF Contingency Description ***\\n')\nfor i in range(otdfobj.size.ncase):\nlbl  = otdfobj.colabel[i]\ndesc = otdfobj.codesc[i]\nreport(\"  %(lbl)12s  %(desc)s\\n\" %vars())\nreport(\"\\n\")\nreport('*** OTDF Factors ***\\n')\nreport('  <---------- Monitored Branch/Interface ------------->  ')\nfor each in otdfobj.colabel:\nreport(\"%12s  \" %each.strip())\nreport(\"\\n\")\nfor i in range(otdfobj.size.nmline+otdfobj.size.ninter):\nreport(\"  %52s  \" % otdfobj.melement[i].strip())\nfor j in range(otdfobj.size.ncase):\nreport(\"%12.6f  \" % otdfobj.factor[j][i])\nreport(\"\\n\")\n# ------------------------------------------------------------------------------------------------\nrptfile_h.close()\ntxt = '\\n OTDF Factors saved to file %s\\n' % rptfile\nsys.stdout.write(txt)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\notdf_report()\n# OR\n#otdf_report(savfile, dfxfile, outpath)\n# ====================================================================================================\n# [preparer_transfomers_iec_data.py] 04/08/2009 Preparer Two and Three Winding Transformers IEC Data\n# ==================================================================================================\n'''"
  },
  {
    "id": "chunk_076",
    "text": "In some PSSE Saved Cases, especially some old sav files, all transformer data is provided on\nSystem MVA base (SBASE). When this network data is to be used to calculate fault currents\naccording to \"IEC 60909\" standard, in order to calculate correct IEC impedance correction factors,\nnameplate transformer winding MVA data is required.\nThis file is used to:\n(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and\nwhen winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.\nRefer function: change_winding_mva(rating='')\nIn some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),\nthen this files can be used to change transformer winding MVA with selected Rating.\n(2) Create transformers IEC data file.\nRefer function: create_iecdata(wdgmva='',rptfile='')\nCreate a text file with all transformer branches and then use this file to provide\nnameplate transformer winding MVA as part of transformer nameplate IEC data records.\n---------------------------------------------------------------------------------\nFunctions:\n(1) change_winding_mva(rating='')\nChange all Transformers Winding MVA to a MVA value derived from RATE A or B or C.\n(2) create_iecdata(wdgmva='',rptfile='')\nCreate IEC data file for all Transformers Winding MVA.\nEach IEC data record for a transformer has following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nTransformers IEC data records created here need to put in complete IEC data file.\nRefer POM Volume 1, API IECS for format of IEC data file.\nThis function creates output file depending on the wndmva input provided.\n(1) If wndmva is not provided, it creates records in the following format.\nIBUS, JBUS, KBUS, CKT\nThen users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.\n(2) If wndmva=\"SBASE\", it creates records in the following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nThen users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n(3) If wndmva=\"RATEA\" or \"RATEB\" or \"RATEC\", it creates records in the following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nwhere SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)\nSBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)\nSBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)\nIf any of the winding MVA is zero, it is ignored.\nUsers could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n---------------------------------------------------------------------------------\nHow to use this file?\n(1) Open the Saved Case using PSS(R)E GUI\n(2) Without PROMPT for inputing arguments:\nCall follwoing functions from CLI or another Python automation file:\nchange_winding_mva(rating)\nor\ncreate_iecdata(wndmva, rptfile)\n(3) With PROMPTS for inputing arguments:\nCall follwoing functions from CLI or another Python automation file:\ndochng()\nor\ndocreate()\n'''\nimport psspy, os\n# ===========================================================================================\ndef _splitstring_commaspace(tmpstr):\n'''Split string first at comma and then by space. Example:\nInput  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\nOutput strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n'''\nstrlst = []\ncommalst = tmpstr.split(',')\nfor each in commalst:\neachlst = each.split()\nif eachlst:\nstrlst.extend(eachlst)\nelse:\nstrlst.extend(' ')\nreturn strlst\n# ===========================================================================================\ndef _check_wdgmva(instr):\n'''check for valid wdgmva string.'''\nif type(instr) != str: instr = str(instr)\ninstr0 = instr\ninstr = instr.strip().lower()\nif not instr:\nretv = ''\nelif instr =='ratea':\nretv = \"RATEA\"\nelif instr =='rateb':\nretv = \"RATEB\"\nelif instr =='ratec':\nretv = \"RATEC\"\nelif instr =='sbase':\nretv = \"SBASE\"\nelse:\nprint(' Input value \"%s\" not recognized.\\n' % str(instr0))\nretv = ''\nreturn retv\n# ===========================================================================================\ndef _min_rate(r1,r2):\nif not r1:\nretv = r2\nelif not r2:\nretv = r1\nelse:\nretv = min(r1,r2)\nreturn retv\n# ===========================================================================================\ndef _get_xmer_data(wdgmva=''):\n'''\nwdgmva = 0 or ''    # return just transfomrer buses and ckt id\n= 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE\n= 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from\n= 'rateb'    # winding rating A or B or C\n= 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)\n'''\nsid   = -1       # all buses\nowner = 1        # ignored\nties  = 1        # ignored\n# Get Two Winding Transformer Specified Rating\nflag  = 2        # =1 in-service transformers, =2 all\nentry = 1        # each branch once only\nierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])\nierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])\nif wdgmva:\nif wdgmva == \"SBASE\":\nstrval = \"SBASE1\"\nelse:\nstrval = wdgmva\nierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])\ntwo_wdg_xmers = {}\nfor i in range(len(tmplist1[0])):\nbusi  = tmplist1[0][i]\nbusj  = tmplist1[1][i]\ncktid = tmplist2[0][i]\nif wdgmva:\nval = tmplist3[0][i]\nelse:\nval = ''\ntwo_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}\n# Three Winding Transformer Specified Rating\nflag  = 3        # =2 all windings of in-service transformers\n# =3 all transformers\nentry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)\n# need to be done differently when entry = 1\nierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])\nierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])\nif wdgmva:\nierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])\nthree_wdg_xmers = {}\nnwdgs = len(tmplist1[0])\nfor i in range(0,nwdgs,3):\nbusi     = tmplist1[0][i]\nbusj     = tmplist1[1][i]\nbusk     = tmplist1[2][i]\ncktid    = tmplist2[0][i]\nif wdgmva == 'SBASE':\nval1 = tmplist3[0][i]\nval2 = tmplist3[0][i+1]\nval3 = tmplist3[0][i+2]\nelif wdgmva in ['RATEA', 'RATEB', 'RATEC']:\nratea_w1 = tmplist3[0][i]\nratea_w2 = tmplist3[0][i+1]\nratea_w3 = tmplist3[0][i+2]\nval1 = _min_rate(ratea_w1,ratea_w2)\nval2 = _min_rate(ratea_w2,ratea_w3)\nval3 = _min_rate(ratea_w3,ratea_w1)\nelse:\nval1 = ''\nval2 = ''\nval3 = ''\nthree_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}\nreturn two_wdg_xmers, three_wdg_xmers\n# ===========================================================================================\ndef change_winding_mva(rating=''):\n'''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''\nwdgmva = _check_wdgmva(rating)\nif wdgmva not in ['RATEA', 'RATEB', 'RATEC']:\nprint(\" No need to update working case.\")\nreturn\ntwo_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\nlst2wdg = list(two_wdg_xmers.keys())\nlst2wdg.sort()\nlst3wdg = list(three_wdg_xmers.keys())\nlst3wdg.sort()\nfor brn in lst2wdg:\nibus = brn[0]\njbus = brn[1]\nckt  = brn[2]\nsbase12 = two_wdg_xmers[brn]['sbase12']\nierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)\nfor brn in lst3wdg:\nibus = brn[0]"
  },
  {
    "id": "chunk_077",
    "text": "jbus = brn[1]\nkbus = brn[2]\nckt  = brn[3]\nsbase12 = three_wdg_xmers[brn]['sbase12']\nsbase23 = three_wdg_xmers[brn]['sbase23']\nsbase31 = three_wdg_xmers[brn]['sbase31']\nierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,\nrealari8=sbase23, realari9=sbase31)\n# ===========================================================================================\ndef create_iecdata(wdgmva='',rptfile=''):\n'''Create IEC data file for all Transformers Winding MVA.'''\nwdgmva = _check_wdgmva(wdgmva)\ntwo_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\nif rptfile:     # open report file to write\np,nx = os.path.split(rptfile)\nif not p: p = os.getcwd()\nn,x = os.path.splitext(nx)\nif not x or x.lower() != '.txt': x = '.txt'\nnx = n + x\nrptfile = os.path.join(p,nx)\nrptfile_h = open(rptfile,'w')\nreport       = rptfile_h.write\nelse:           # send results to PSS(R)E report window\npsspy.beginreport()\nreport = psspy.report\n# printing\nreport('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\\n')\n# Two Winding Transformers\nlst2wdg = list(two_wdg_xmers.keys())\nlst2wdg.sort()\nfor brn in lst2wdg:\nibus = brn[0]\njbus = brn[1]\nkbus = 0\nckt  = brn[2].strip()\nsbase12 = two_wdg_xmers[brn]['sbase12']\nif sbase12:\nsbase12 = \"%8.2f\" % sbase12\nelse:\nsbase12 = ''\nreport('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\\n' % vars())\n# Three Winding Transformers\nlst3wdg = list(three_wdg_xmers.keys())\nlst3wdg.sort()\nfor brn in lst3wdg:\nibus = brn[0]\njbus = brn[1]\nkbus = brn[2]\nckt  = brn[3].strip()\nsbase12  = three_wdg_xmers[brn]['sbase12']\nsbase23  = three_wdg_xmers[brn]['sbase23']\nsbase31  = three_wdg_xmers[brn]['sbase31']\nif sbase12:\nsbase12 = \"%8.2f\" % sbase12\nsbase23 = \"%8.2f\" % sbase23\nsbase31 = \"%8.2f\" % sbase31\nelse:\nsbase12 = ''\nsbase23 = ''\nsbase31 = ''\nreport('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\\n' % vars())\nif rptfile:\nprint(\" Transformers IEC Data records saved in file %s.\" % rptfile)\n# ====================================================================================================\ndef dochng():\npsspy.prompt(\"PROVIDE RATING TO SELECT:\\n\\n\\\n- TYPE ratea for RATE A or\\n\\\n- TYPE rateb for RATE B or\\n\\\n- TYPE ratec for RATE C\")\nierr, rating = psspy.userin()\nchange_winding_mva(rating)\n# ====================================================================================================\ndef docreate():\npsspy.prompt(\"PROVIDE WINDING MVA selection string and IEC DATA output text file name:\\n\\n\\\n- ALLOWED WINDING MVA selection string\\n\\\nsbase, ratea, rateb, ratec or ''(empty string) \\n\")\npsspy.prompt(\"        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\\n\")\npsspy.prompt(\"TYPE inputs separated either by comma or space.\")\nierr, instr = psspy.userin()\nwndmva  = ''\nrptfile = ''\nif instr:\ninstrlst = _splitstring_commaspace(instr)\nwndmva = instrlst[0]\ntry:\nrptfile = instrlst[1]\nexcept:\npass\ncreate_iecdata(wndmva, rptfile)\n# ====================================================================================================\nif __name__ == '__main__':\n#dochng()\ndocreate()\n# ====================================================================================================\n# [preparer_transfomers_iec_data.py] 04/08/2009 Preparer Two and Three Winding Transformers IEC Data\n# ==================================================================================================\n'''\nIn some PSSE Saved Cases, especially some old sav files, all transformer data is provided on\nSystem MVA base (SBASE). When this network data is to be used to calculate fault currents\naccording to \"IEC 60909\" standard, in order to calculate correct IEC impedance correction factors,\nnameplate transformer winding MVA data is required.\nThis file is used to:\n(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and\nwhen winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.\nRefer function: change_winding_mva(rating='')\nIn some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),\nthen this files can be used to change transformer winding MVA with selected Rating.\n(2) Create transformers IEC data file.\nRefer function: create_iecdata(wdgmva='',rptfile='')\nCreate a text file with all transformer branches and then use this file to provide\nnameplate transformer winding MVA as part of transformer nameplate IEC data records.\n---------------------------------------------------------------------------------\nFunctions:\n(1) change_winding_mva(rating='')\nChange all Transformers Winding MVA to a MVA value derived from RATE A or B or C.\n(2) create_iecdata(wdgmva='',rptfile='')\nCreate IEC data file for all Transformers Winding MVA.\nEach IEC data record for a transformer has following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nTransformers IEC data records created here need to put in complete IEC data file.\nRefer POM Volume 1, API IECS for format of IEC data file.\nThis function creates output file depending on the wndmva input provided.\n(1) If wndmva is not provided, it creates records in the following format.\nIBUS, JBUS, KBUS, CKT\nThen users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.\n(2) If wndmva=\"SBASE\", it creates records in the following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nThen users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n(3) If wndmva=\"RATEA\" or \"RATEB\" or \"RATEC\", it creates records in the following format.\nIBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1\nwhere SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)\nSBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)\nSBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)\nIf any of the winding MVA is zero, it is ignored.\nUsers could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.\n---------------------------------------------------------------------------------\nHow to use this file?\n(1) Open the Saved Case using PSS(R)E GUI\n(2) Without PROMPT for inputing arguments:\nCall follwoing functions from CLI or another Python automation file:\nchange_winding_mva(rating)\nor\ncreate_iecdata(wndmva, rptfile)\n(3) With PROMPTS for inputing arguments:\nCall follwoing functions from CLI or another Python automation file:\ndochng()\nor\ndocreate()\n'''\nimport psspy, os\n# ===========================================================================================\ndef _splitstring_commaspace(tmpstr):\n'''Split string first at comma and then by space. Example:\nInput  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9\nOutput strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']\n'''\nstrlst = []\ncommalst = tmpstr.split(',')\nfor each in commalst:\neachlst = each.split()\nif eachlst:\nstrlst.extend(eachlst)\nelse:\nstrlst.extend(' ')\nreturn strlst\n# ===========================================================================================\ndef _check_wdgmva(instr):\n'''check for valid wdgmva string.'''\nif type(instr) != str: instr = str(instr)\ninstr0 = instr\ninstr = instr.strip().lower()\nif not instr:\nretv = ''\nelif instr =='ratea':\nretv = \"RATEA\"\nelif instr =='rateb':\nretv = \"RATEB\"\nelif instr =='ratec':\nretv = \"RATEC\"\nelif instr =='sbase':\nretv = \"SBASE\"\nelse:\nprint(' Input value \"%s\" not recognized.\\n' % str(instr0))\nretv = ''\nreturn retv\n# ===========================================================================================\ndef _min_rate(r1,r2):\nif not r1:\nretv = r2\nelif not r2:\nretv = r1\nelse:\nretv = min(r1,r2)\nreturn retv\n# ===========================================================================================\ndef _get_xmer_data(wdgmva=''):\n'''\nwdgmva = 0 or ''    # return just transfomrer buses and ckt id\n= 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE"
  },
  {
    "id": "chunk_078",
    "text": "= 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from\n= 'rateb'    # winding rating A or B or C\n= 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)\n'''\nsid   = -1       # all buses\nowner = 1        # ignored\nties  = 1        # ignored\n# Get Two Winding Transformer Specified Rating\nflag  = 2        # =1 in-service transformers, =2 all\nentry = 1        # each branch once only\nierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])\nierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])\nif wdgmva:\nif wdgmva == \"SBASE\":\nstrval = \"SBASE1\"\nelse:\nstrval = wdgmva\nierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])\ntwo_wdg_xmers = {}\nfor i in range(len(tmplist1[0])):\nbusi  = tmplist1[0][i]\nbusj  = tmplist1[1][i]\ncktid = tmplist2[0][i]\nif wdgmva:\nval = tmplist3[0][i]\nelse:\nval = ''\ntwo_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}\n# Three Winding Transformer Specified Rating\nflag  = 3        # =2 all windings of in-service transformers\n# =3 all transformers\nentry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)\n# need to be done differently when entry = 1\nierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])\nierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])\nif wdgmva:\nierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])\nthree_wdg_xmers = {}\nnwdgs = len(tmplist1[0])\nfor i in range(0,nwdgs,3):\nbusi     = tmplist1[0][i]\nbusj     = tmplist1[1][i]\nbusk     = tmplist1[2][i]\ncktid    = tmplist2[0][i]\nif wdgmva == 'SBASE':\nval1 = tmplist3[0][i]\nval2 = tmplist3[0][i+1]\nval3 = tmplist3[0][i+2]\nelif wdgmva in ['RATEA', 'RATEB', 'RATEC']:\nratea_w1 = tmplist3[0][i]\nratea_w2 = tmplist3[0][i+1]\nratea_w3 = tmplist3[0][i+2]\nval1 = _min_rate(ratea_w1,ratea_w2)\nval2 = _min_rate(ratea_w2,ratea_w3)\nval3 = _min_rate(ratea_w3,ratea_w1)\nelse:\nval1 = ''\nval2 = ''\nval3 = ''\nthree_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}\nreturn two_wdg_xmers, three_wdg_xmers\n# ===========================================================================================\ndef change_winding_mva(rating=''):\n'''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''\nwdgmva = _check_wdgmva(rating)\nif wdgmva not in ['RATEA', 'RATEB', 'RATEC']:\nprint(\" No need to update working case.\")\nreturn\ntwo_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\nlst2wdg = list(two_wdg_xmers.keys())\nlst2wdg.sort()\nlst3wdg = list(three_wdg_xmers.keys())\nlst3wdg.sort()\nfor brn in lst2wdg:\nibus = brn[0]\njbus = brn[1]\nckt  = brn[2]\nsbase12 = two_wdg_xmers[brn]['sbase12']\nierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)\nfor brn in lst3wdg:\nibus = brn[0]\njbus = brn[1]\nkbus = brn[2]\nckt  = brn[3]\nsbase12 = three_wdg_xmers[brn]['sbase12']\nsbase23 = three_wdg_xmers[brn]['sbase23']\nsbase31 = three_wdg_xmers[brn]['sbase31']\nierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,\nrealari8=sbase23, realari9=sbase31)\n# ===========================================================================================\ndef create_iecdata(wdgmva='',rptfile=''):\n'''Create IEC data file for all Transformers Winding MVA.'''\nwdgmva = _check_wdgmva(wdgmva)\ntwo_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)\nif rptfile:     # open report file to write\np,nx = os.path.split(rptfile)\nif not p: p = os.getcwd()\nn,x = os.path.splitext(nx)\nif not x or x.lower() != '.txt': x = '.txt'\nnx = n + x\nrptfile = os.path.join(p,nx)\nrptfile_h = open(rptfile,'w')\nreport       = rptfile_h.write\nelse:           # send results to PSS(R)E report window\npsspy.beginreport()\nreport = psspy.report\n# printing\nreport('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\\n')\n# Two Winding Transformers\nlst2wdg = list(two_wdg_xmers.keys())\nlst2wdg.sort()\nfor brn in lst2wdg:\nibus = brn[0]\njbus = brn[1]\nkbus = 0\nckt  = brn[2].strip()\nsbase12 = two_wdg_xmers[brn]['sbase12']\nif sbase12:\nsbase12 = \"%8.2f\" % sbase12\nelse:\nsbase12 = ''\nreport('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\\n' % vars())\n# Three Winding Transformers\nlst3wdg = list(three_wdg_xmers.keys())\nlst3wdg.sort()\nfor brn in lst3wdg:\nibus = brn[0]\njbus = brn[1]\nkbus = brn[2]\nckt  = brn[3].strip()\nsbase12  = three_wdg_xmers[brn]['sbase12']\nsbase23  = three_wdg_xmers[brn]['sbase23']\nsbase31  = three_wdg_xmers[brn]['sbase31']\nif sbase12:\nsbase12 = \"%8.2f\" % sbase12\nsbase23 = \"%8.2f\" % sbase23\nsbase31 = \"%8.2f\" % sbase31\nelse:\nsbase12 = ''\nsbase23 = ''\nsbase31 = ''\nreport('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\\n' % vars())\nif rptfile:\nprint(\" Transformers IEC Data records saved in file %s.\" % rptfile)\n# ====================================================================================================\ndef dochng():\npsspy.prompt(\"PROVIDE RATING TO SELECT:\\n\\n\\\n- TYPE ratea for RATE A or\\n\\\n- TYPE rateb for RATE B or\\n\\\n- TYPE ratec for RATE C\")\nierr, rating = psspy.userin()\nchange_winding_mva(rating)\n# ====================================================================================================\ndef docreate():\npsspy.prompt(\"PROVIDE WINDING MVA selection string and IEC DATA output text file name:\\n\\n\\\n- ALLOWED WINDING MVA selection string\\n\\\nsbase, ratea, rateb, ratec or ''(empty string) \\n\")\npsspy.prompt(\"        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\\n\")\npsspy.prompt(\"TYPE inputs separated either by comma or space.\")\nierr, instr = psspy.userin()\nwndmva  = ''\nrptfile = ''\nif instr:\ninstrlst = _splitstring_commaspace(instr)\nwndmva = instrlst[0]\ntry:\nrptfile = instrlst[1]\nexcept:\npass\ncreate_iecdata(wndmva, rptfile)\n# ====================================================================================================\nif __name__ == '__main__':\n#dochng()\ndocreate()\n# ====================================================================================================\n# pssexcel_demo.py  Use of pssexcel to export ACCC, PV and QV\n# ====================================================================================================\n'''\nThis is an example file showing how to use Python module \"pssexcel\"\nto export ACCC, PV and QV solution results to excel spreadsheets.\nRefer help(pssexcel) for details.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example, where XX could be 33 or 34:\nimport psseXX\n- call any of the function as below\naccc()\naccc(accfile='savnw.acc', show=True, cosep=True)\npv()\npv(pvfile='savnw.pv', show=True)\nqv()\nqv(qvfile='savnw.qv', show=True)\n---------------------------------------------------------------------------------\nAlternatively, use either of the following menu items.\n- from Start>Programs>PSSExx>Export Results to Excel OR\n- from Power Flow>Reports>Export Results to Excel\n'''\n# ====================================================================================================\nimport sys, os\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# ====================================================================================================\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ====================================================================================================\ndef accc(accfile='savnw.acc', outpath=None, show=True, cosep=True):\nimport pssexcel\nif not os.path.exists(accfile):\nprgmsg = \" Error: Input accfile '{0}' does not exist\".format(accfile)\nprint(prgmsg)\nreturn\n# Change these values as required.\nstring  = ['s','e','b','i','v','l','g','p','a']\ncolabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\np, nx = os.path.split(accfile)\nn, x  = os.path.splitext(nx)\nxlsfile = get_output_filename(outpath, 'pssexcel_demo_accc_' + n)"
  },
  {
    "id": "chunk_079",
    "text": "sheet = n + '_accc'\noverwritesheet = True\nbaseflowvio = False\nbasevoltvio = False\nflowlimit   = 0.0\nflowchange  = 0.0\nvoltchange  = 0.0\nbranchanglediff = True\nangdifmin=0.05\npssexcel.accc(accfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show,\nbaseflowvio=baseflowvio, basevoltvio=basevoltvio, flowlimit=flowlimit,\nflowchange=flowchange, voltchange=voltchange, angdifmin=angdifmin, cosep=cosep, branchanglediff=branchanglediff)\n# ====================================================================================================\ndef pv(pvfile='savnw.pv', outpath=None, show=True):\nimport pssexcel\nif not os.path.exists(pvfile):\nprgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\nprint(prgmsg)\nreturn\n# Change these values as required.\nstring  = ['s','v','m','g','l','b','i']\ncolabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\np, nx = os.path.split(pvfile)\nn, x  = os.path.splitext(nx)\nxlsfile = get_output_filename(outpath, 'pssexcel_demo_pv_' + n)\nsheet = n + '_pv'\noverwritesheet = True\npssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n# ====================================================================================================\ndef qv(qvfile='savnw.qv', outpath=None, show=True):\nimport pssexcel\nif not os.path.exists(qvfile):\nprgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\nprint(prgmsg)\nreturn\n# Change these values as required.\nstring  = ['s','v','m','g']\ncolabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']\np, nx = os.path.split(qvfile)\nn, x  = os.path.splitext(nx)\nxlsfile = get_output_filename(outpath, 'pssexcel_demo_qv_' + n)\nsheet = n + '_qv'\noverwritesheet = True\npssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\npass\n# change XX to 33, 34 or 35.\n#import psseXX\n#accc(accfile)\n#pv(pvfile)\n#qv(qvfile)\n# ====================================================================================================\n# pv_export.py  Exporting PV Solution Results to Excel Spreadsheet\n# ====================================================================================================\n'''\nThis is an example file showing how to export PV solution results to excel spreadsheets.\nRefer help(arrbox.pv_pp) for details.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call any of the function as below\nexcel_report()\nexcel_report(pvfile='savnw.pv', show=True)\ntext_report()\ntext_report(pvfile='savnw.pv')\n---------------------------------------------------------------------------------\nAlternatively, use either of the following menu items.\n- from Start>Programs>PSSExx>Export Results to Excel OR\n- from Power Flow>Reports>Export Results to Excel\n'''\n# ====================================================================================================\nimport sys, os\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# ====================================================================================================\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ====================================================================================================\ndef excel_report(pvfile='savnw.pv', outpath=None, show=True):\nimport pssexcel\nif not os.path.exists(pvfile):\nprgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\nprint(prgmsg)\nreturn\n# Change these values as required.\nstring  = ['s','v','m','g','l','b','i']\ncolabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']\np, nx = os.path.split(pvfile)\nn, x  = os.path.splitext(nx)\nxlsfile = get_output_filename(outpath, 'pv_export_' + n)\nsheet = n + '_pv'\noverwritesheet = True\npssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n# ====================================================================================================\ndef text_report(pvfile='savnw.pv', outpath=None):\nimport arrbox.pv_pp\nif not os.path.exists(pvfile):\nprgmsg = \" Error: Input pvfile '{0}' does not exist\".format(pvfile)\nprint(prgmsg)\nreturn\npvobj = arrbox.pv_pp.PV_PP(pvfile)\np, nx = os.path.split(pvfile)\nn, x  = os.path.splitext(nx)\nsmryfile = get_output_filename(outpath, 'pv_export_' + n +'_summary.txt')\nsolnfile = get_output_filename(outpath, 'pv_export_' + n +'_solution.txt')\nierr = pvobj.summary_report(smryfile)\nierr = pvobj.solution_report(colabels=None,rptfile=solnfile)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\n#excel_report()\n#text_report()\n#excel_report(pvfile='savnw.pv', show=True)\n#text_report(pvfile='savnw.pv')\n# ====================================================================================================\n# qv_export.py  Exporting QV Solution Results to Excel Spreadsheet\n# ====================================================================================================\n'''\nThis is an example file showing how to export PV solution results to excel spreadsheets.\nRefer help(arrbox.qv_pp) for details.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call any of the function as below\nexcel_report()\nexcel_report(qvfile='savnw.qv', show=True)\ntext_report()\ntext_report(qvfile='savnw.qv')\n---------------------------------------------------------------------------------\nAlternatively, use either of the following menu items.\n- from Start>Programs>PSSExx>Export Results to Excel OR\n- from Power Flow>Reports>Export Results to Excel\n'''\n# ====================================================================================================\nimport sys, os\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# ====================================================================================================\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ====================================================================================================\ndef excel_report(qvfile='savnw.qv', outpath=None, show=True):\nimport pssexcel\nif not os.path.exists(qvfile):\nprgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\nprint(prgmsg)\nreturn\n# Change these values as required.\nstring  = ['s','v','m','g']\ncolabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']\np, nx = os.path.split(qvfile)\nn, x  = os.path.splitext(nx)\nxlsfile = get_output_filename(outpath, 'qv_export_' + n)\nsheet = n + '_qv'\noverwritesheet = True\npssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)\n# ====================================================================================================\ndef text_report(qvfile='savnw.qv', outpath=None):\nimport arrbox.qv_pp\nif not os.path.exists(qvfile):\nprgmsg = \" Error: Input qvfile '{0}' does not exist\".format(qvfile)\nprint(prgmsg)\nreturn\nqvobj = arrbox.qv_pp.QV_PP(qvfile)\np, nx = os.path.split(qvfile)\nn, x  = os.path.splitext(nx)\nsmryfile = get_output_filename(outpath, 'qv_export_' + n +'_summary.txt')\nsolnfile = get_output_filename(outpath, 'qv_export_' + n +'_solution.txt')\nierr = qvobj.summary_report(smryfile)\nierr = qvobj.solution_report(colabels=None,rptfile=solnfile)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\n#excel_report()\n#text_report()\n#excel_report(qvfile='savnw.qv', show=True)\n#text_report(qvfile='savnw.qv')\n# ====================================================================================================\n'run_idle.py - This script starts up the IDLE interpreter (for Python 2.3).'\nimport sys\n# Import IDLE's PyShell and run its main()\nsys.argv=['','-n','-t','PSS/E-Python Shell'] #Arguments for IDLE\nimport idlelib.PyShell                       #Import the PyShell module\nidlelib.PyShell.main()                       #Start IDLE\n#[sample_add_substations.py]    Create sample_zils case with various Node Breaker Substation Configurations\n# =====================================================================================================\n'''This file shows example of adding one or more substation configurations.\nUses sample.raw and sample.seq files.\nThis example uses substations data [latitude, longitude, RG] from sample_fv4.gic, but applies\ndifferent Substation Configurations.\n'''\nss_config = {\n1: 'SB',        #'Single Bus',\n2: 'RB',        #'Ring Bus',\n3: 'DBDB',      #'Double Bus double breaker',\n4: 'BH',        #'Breaker and a half',\n5: 'DBSB',      #'Double Bus Single breaker',\n6: 'MBTB',      #'Main Bus Transfer Bus',\n}\nsub_dict = {\n1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211      ]},\n2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022   ]},\n3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154                    ]},\n4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202              ]},\n5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204]},"
  },
  {
    "id": "chunk_080",
    "text": "6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                ]},\n7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002      ]},\n8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005           ]},\n9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018       ]},\n10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                          ]},\n11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                          ]},\n12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212                          ]},\n13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                          ]},\n14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                          ]},\n15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                          ]},\n16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                 ]},\n17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                         ]},\n18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                         ]},\n}\nrawfnam           = r\"sample.raw\"\nseqfnam           = r\"sample.seq\"\nrawoutfnam        = r\"sample\"\nrawoutfnam_nb     = r\"sample_nb\"\nrawoutfnam_nb_sec = r\"sample_nb_sec\"\nprgfnam           = r\"sample_nb_progress.txt\"\nimport os\n# ==================================================================================================\ndef solve_pf():\nimport psspy\npf_options = [1,0,0,1,1,0,99,0]\npsspy.fdns(pf_options)\npsspy.fdns(pf_options)\nival = psspy.solved()\nreturn ival\ndef save_case(rawfile, seqfile, savfnam, outpath):\nimport psspy\npsspy.read(0, rawfile)\npsspy.resq(seqfile)\nival = solve_pf()\nif ival==0:\nsavfile = \"{}.sav\".format(savfnam)\nsavfile = os.path.join(outpath, savfile)\npsspy.save(savfile)\n# ==================================================================================================\ndef run(datapath=None, outpath=None):\nimport psspy\nif datapath is None:        # use Example folder\npsspy_dir = os.path.dirname(psspy.__file__)\npsse_dir, jnk = os.path.split(psspy_dir)\ndatapath = os.path.join(psse_dir, 'Example')\nrawfile = os.path.join(datapath, rawfnam)\nseqfile = os.path.join(datapath, seqfnam)\nif not os.path.exists(rawfile):\nmsg = \"\\n Error- RAW file not found, terminated:\\n    {}\".format(rawfile)\nprint(msg)\nreturn\nif not os.path.exists(seqfile):\nmsg = \"\\n Error- SEQ file not found, terminated:\\n    {}\".format(seqfile)\nprint(msg)\nreturn\nif outpath is None:\noutpath = os.path.dirname(__file__)\noutpath = os.path.join(outpath, 'output_sample_nb')\nif not os.path.exists(outpath): os.makedirs(outpath)\npsspy.psseinit()\nprgfile = os.path.join(outpath, prgfnam)\npsspy.progress_output(2,prgfile,[0,0])\n_i = psspy.getdefaultint()\n_f = psspy.getdefaultreal()\n_s = psspy.getdefaultchar()\npsspy.read(0, rawfile)\npsspy.resq(seqfile)\nival_raw = solve_pf()\nif ival_raw>0:\nmsg = \"\\n Error - Power flow non converged. RAW file:\\n    {}\".format(rawfile)\nprint(msg)\nreturn\nsslst = list(sub_dict.keys())\nsslst.sort()\nfor ss in sslst:\nvdict = sub_dict[ss]\nname  = sub_dict[ss]['name']\nlat   = sub_dict[ss]['lat']\nlon   = sub_dict[ss]['long']\nrg    = sub_dict[ss]['rg']\nconfig= sub_dict[ss]['config']\nbuses = sub_dict[ss]['buses']\ns_ss = \"{:{fill}2d}\".format(ss, fill='0')\ns_config = ss_config[config]\nss_name  = \"SS{}_{}_TYP_{}_{}\".format(s_ss, name, config, s_config)\nfor b in buses:\npsspy.station_build_config(b,ss,_s,config)\npsspy.station_data(ss, [lat, lon, rg], ss_name)\n# Update/Change Node and Switching Device Names\nsid = -1\nflag = 1\nierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])\nierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])\nfor ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):\nnlst = nam.strip().split('_')\nnewlst = ['SS', nlst[1], 'NODE', str(node)]\nnewnam = '_'.join(newlst)\npsspy.station_node_chng(ss,node,[_i,_i],newnam)\nierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])\nierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])\nfor ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):\nnlst = nam.strip().split('_')\nnewlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]\nnewnam = '_'.join(newlst)\npsspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)\n# --------------------------------------------------\n# Save un-solved raw file\n##    rawfileout = \"{}_pf_no.raw\".format(rawoutfnam_nb)\n##    rawfileout = os.path.join(outpath, rawfileout)\n##    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout)\n# --------------------------------------------------\n# Solve power flow and save raw file\nival_raw_nb = solve_pf()\npsspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\nr'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, NO ZILS')\nrawfileout_nb = \"{}.raw\".format(rawoutfnam_nb)\nrawfileout_nb = os.path.join(outpath, rawfileout_nb)\npsspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)\nseqfileout_nb = \"{}.seq\".format(rawoutfnam_nb)\nseqfileout_nb = os.path.join(outpath, seqfileout_nb)\npsspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)\nif ival_raw_nb>0:\nmsg = \"\\n Error - Power flow non converged after adding substations, SAV file not created.\"\nprint(msg)\n# --------------------------------------------------\n# Create substation sections\npsspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n# --------------------------------------------------\n# Solve power flow and save raw file\nival_raw_nb_sec = solve_pf()\npsspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\nr'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, NO ZILS')\nrawfileout_nb_sec = \"{}.raw\".format(rawoutfnam_nb_sec)\nrawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)\npsspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)\nseqfileout_nb_sec = \"{}.seq\".format(rawoutfnam_nb_sec)\nseqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)\npsspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)\nif ival_raw_nb_sec>0:\nmsg = \"\\n Error - Power flow non converged after adding substation sections, SAV file not created.\"\nprint(msg)\nreturn\n# --------------------------------------------------\n# Create .sav files\nif not os.path.exists(seqfile):\nmsg = \"\\n Error- SEQ sile not found:\\n    {}\".format(seqfile)\nprint(msg)\nreturn\n# base case\nsave_case(rawfile, seqfile, rawoutfnam, outpath)\n# base+NB case\nsave_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)\n# base+NB+sections case\nsave_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)\n# --------------------------------------------------\n# all done\npsspy.progress_output(1,\"\",[0,0])\nmsg = \"\\n Progress saved in file: {}\".format(prgfile)\nprint(msg)\n# ==================================================================================================\ndef test1():\n# Run from outside of PSSE GUI.\n# Use input sample RAW/SEQ files from specified folder [datapath].\n# Create output RAW/SEQ files in specified folder [outpath].\nimport psse35\ndatapath = os.getcwd()\noutpath  = os.getcwd()\nrun(datapath=datapath, outpath=outpath)\n# --------------------------------------------------\ndef test2():\n# Run from inside of PSSE GUI.\n# Use input sample RAW/SEQ files from specified folder [datapath].\n# Create output RAW/SEQ files in specified folder [outpath].\nimport psse35\ndatapath = os.getcwd()\noutpath  = os.getcwd()\nrun(datapath=datapath, outpath=outpath)\n# --------------------------------------------------\ndef test3():\n# Run from inside of PSSE GUI.\n# Use input sample RAW/SEQ files from Example folder.\n# Create output RAW/SEQ files in folder Example/output_sample_nb.\nrun()\n# ==================================================================================================\nif __name__=='__main__':\npass\n#[sample_zils_add_substations.py]    Create sample case with various Node Breaker Substation Configurations\n# =====================================================================================================\n'''This file shows example of adding one or more substation configurations.\nUses sample_zils.raw and sample_zils.seq files.\nThis example uses substations data [latitude, longitude, RG] from sample_zils_fv4.gic, but applies\ndifferent Substation Configurations.\n'''\nss_config = {\n1: 'SB',        #'Single Bus',\n2: 'RB',        #'Ring Bus',\n3: 'DBDB',      #'Double Bus double breaker',\n4: 'BH',        #'Breaker and a half',\n5: 'DBSB',      #'Double Bus Single breaker',\n6: 'MBTB',      #'Main Bus Transfer Bus',\n}\nsub_dict = {\n1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211, 80102, 80151 ]},\n2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022, 803022    ]},\n3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154, 809154                     ]},\n4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202, 80203                ]},"
  },
  {
    "id": "chunk_081",
    "text": "5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204         ]},\n6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                         ]},\n7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002, 803002       ]},\n8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005                    ]},\n9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018, 803008, 803010, 803018]},\n10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                                   ]},\n11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                                   ]},\n12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212, 80212                            ]},\n13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                                   ]},\n14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                                   ]},\n15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                                   ]},\n16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                          ]},\n17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                                  ]},\n18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                                  ]},\n19: {'name': 'DC2TERM',     'lat': 31.7104,  'long': -84.5694 ,  'rg':0.30, 'config':1, 'buses': [301, 80301                            ]},\n20: {'name': 'DCMTERM',     'lat': 33.9163,  'long': -81.9163 ,  'rg':0.31, 'config':1, 'buses': [401, 402, 80402                       ]},\n}\nrawfnam           = r\"sample_zils.raw\"\nseqfnam           = r\"sample_zils.seq\"\nrawoutfnam        = r\"sample_zils\"\nrawoutfnam_nb     = r\"sample_zils_nb\"\nrawoutfnam_nb_sec = r\"sample_zils_nb_sec\"\nprgfnam           = r\"sample_zils_nb_progress.txt\"\nimport os\n# ==================================================================================================\ndef solve_pf():\nimport psspy\npf_options = [1,0,0,1,1,0,99,0]\npsspy.fdns(pf_options)\npsspy.fdns(pf_options)\nival = psspy.solved()\nreturn ival\ndef save_case(rawfile, seqfile, savfnam, outpath):\nimport psspy\npsspy.read(0, rawfile)\npsspy.resq(seqfile)\nival = solve_pf()\nif ival==0:\nsavfile = \"{}.sav\".format(savfnam)\nsavfile = os.path.join(outpath, savfile)\npsspy.save(savfile)\n# ==================================================================================================\ndef run(datapath=None, outpath=None):\nimport psspy\nif datapath is None:        # use Example folder\npsspy_dir = os.path.dirname(psspy.__file__)\npsse_dir, jnk = os.path.split(psspy_dir)\ndatapath = os.path.join(psse_dir, 'Example')\nrawfile = os.path.join(datapath, rawfnam)\nseqfile = os.path.join(datapath, seqfnam)\nif not os.path.exists(rawfile):\nmsg = \"\\n Error- RAW file not found, terminated:\\n    {}\".format(rawfile)\nprint(msg)\nreturn\nif not os.path.exists(seqfile):\nmsg = \"\\n Error- SEQ file not found, terminated:\\n    {}\".format(seqfile)\nprint(msg)\nreturn\nif outpath is None:\noutpath = os.path.dirname(__file__)\noutpath = os.path.join(outpath, 'output_sample_nb')\nif not os.path.exists(outpath): os.makedirs(outpath)\npsspy.psseinit()\nprgfile = os.path.join(outpath, prgfnam)\npsspy.progress_output(2,prgfile,[0,0])\n_i = psspy.getdefaultint()\n_f = psspy.getdefaultreal()\n_s = psspy.getdefaultchar()\npsspy.read(0, rawfile)\npsspy.resq(seqfile)\nival_raw = solve_pf()\nif ival_raw>0:\nmsg = \"\\n Error - Power flow non converged. RAW file:\\n    {}\".format(rawfile)\nprint(msg)\nreturn\nsslst = list(sub_dict.keys())\nsslst.sort()\nfor ss in sslst:\nvdict = sub_dict[ss]\nname  = sub_dict[ss]['name']\nlat   = sub_dict[ss]['lat']\nlon   = sub_dict[ss]['long']\nrg    = sub_dict[ss]['rg']\nconfig= sub_dict[ss]['config']\nbuses = sub_dict[ss]['buses']\ns_ss = \"{:{fill}2d}\".format(ss, fill='0')\ns_config = ss_config[config]\nss_name  = \"SS{}_{}_TYP_{}_{}\".format(s_ss, name, config, s_config)\nfor b in buses:\npsspy.station_build_config(b,ss,_s,config)\npsspy.station_data(ss, [lat, lon, rg], ss_name)\n# Update/Change Node and Switching Device Names\nsid = -1\nflag = 1\nierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])\nierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])\nfor ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):\nnlst = nam.strip().split('_')\nnewlst = ['SS', nlst[1], 'NODE', str(node)]\nnewnam = '_'.join(newlst)\npsspy.station_node_chng(ss,node,[_i,_i],newnam)\nierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])\nierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])\nfor ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):\nnlst = nam.strip().split('_')\nnewlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]\nnewnam = '_'.join(newlst)\npsspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)\n# --------------------------------------------------\n# Save un-solved raw file\n##    rawfileout = \"{}_pf_no.raw\".format(rawoutfnam_nb)\n##    rawfileout = os.path.join(outpath, rawfileout)\n##    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout)\n# --------------------------------------------------\n# Solve power flow and save raw file\nival_raw_nb = solve_pf()\npsspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\nr'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, CONTAINS ZILS')\nrawfileout_nb = \"{}.raw\".format(rawoutfnam_nb)\nrawfileout_nb = os.path.join(outpath, rawfileout_nb)\npsspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)\nseqfileout_nb = \"{}.seq\".format(rawoutfnam_nb)\nseqfileout_nb = os.path.join(outpath, seqfileout_nb)\npsspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)\nif ival_raw_nb>0:\nmsg = \"\\n Error - Power flow non converged after adding substations, SAV file not created.\"\nprint(msg)\n# --------------------------------------------------\n# Create substation sections\npsspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\npsspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)\n# --------------------------------------------------\n# Solve power flow and save raw file\nival_raw_nb_sec = solve_pf()\npsspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',\nr'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, CONTAINS ZILS')\nrawfileout_nb_sec = \"{}.raw\".format(rawoutfnam_nb_sec)\nrawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)\npsspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)\nseqfileout_nb_sec = \"{}.seq\".format(rawoutfnam_nb_sec)\nseqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)\npsspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)\nif ival_raw_nb_sec>0:\nmsg = \"\\n Error - Power flow non converged after adding substation sections, SAV file not created.\"\nprint(msg)\nreturn\n# --------------------------------------------------\n# Create .sav files\nif not os.path.exists(seqfile):\nmsg = \"\\n Error- SEQ sile not found:\\n    {}\".format(seqfile)\nprint(msg)\nreturn\n# base case\nsave_case(rawfile, seqfile, rawoutfnam, outpath)\n# base+NB case\nsave_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)\n# base+NB+sections case\nsave_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)\n# --------------------------------------------------\n# all done\npsspy.progress_output(1,\"\",[0,0])\nmsg = \"\\n Progress saved in file: {}\".format(prgfile)\nprint(msg)\n# ==================================================================================================\ndef test1():\n# Run from outside of PSSE GUI.\n# Use input sample RAW/SEQ files from specified folder [datapath].\n# Create output RAW/SEQ files in specified folder [outpath].\nimport psse35\ndatapath = os.getcwd()\noutpath  = os.getcwd()\nrun(datapath=datapath, outpath=outpath)\n# --------------------------------------------------\ndef test2():\n# Run from inside of PSSE GUI.\n# Use input sample RAW/SEQ files from specified folder [datapath].\n# Create output RAW/SEQ files in specified folder [outpath].\nimport psse35\ndatapath = os.getcwd()\noutpath  = os.getcwd()\nrun(datapath=datapath, outpath=outpath)\n# --------------------------------------------------\ndef test3():\n# Run from inside of PSSE GUI.\n# Use input sample RAW/SEQ files from Example folder.\n# Create output RAW/SEQ files in folder Example/output_sample_nb.\nrun()\n# ==================================================================================================\nif __name__=='__main__':\npass\n#[sensitivity_factors.py]  Sensitivity Analysis Report and Accesing them in Python Script\n# ====================================================================================================\n'''Sensitivity Factors of a branch flow to MW power at generator and load buses:\nThis is an example file showing how to generate sensitivity factors report or\naccess those factor values in Python script.\n# ----------------------------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call any of the function as below\nrun_demo()  OR\nrun_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None)\nYou could modify various inputs in run)demo() as desired."
  },
  {
    "id": "chunk_082",
    "text": "'''\n# ====================================================================================================\nimport sys, os\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# ====================================================================================================\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ====================================================================================================\ndef create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile):\n# Create Report\nimport arrbox.sensitivity_flow_to_mw\nflow2mw = arrbox.sensitivity_flow_to_mw()\nierr = flow2mw.sensitivity_flow_to_mw_report(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',\ntransfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='',rptfile=rptfile)\n# ====================================================================================================\ndef demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys):\n# Access factor results in Python script\nimport arrbox.sensitivity_flow_to_mw\nflow2mw = arrbox.sensitivity_flow_to_mw()\nrobj = flow2mw.sensitivity_flow_to_mw(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',\ntransfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='')\nprint(\"\\n Returned dictionary object as is:\")\nprint(robj)\nprint('\\n')\nprint(\"  Getting 'ngenbuses' value by different ways:\")\nprint(\"     robj.ngenbuses    = {0:d}\".format(robj.ngenbuses))\nprint(\"     robj.ngenBuses    = {0:d}\".format(robj.ngenBuses))\nprint(\"     robj['ngenbuses'] = {0:d}\".format(robj['ngenbuses']))\nprint(\"     robj['NGENbuses'] = {0:d}\".format(robj['NGENbuses']))\nprint('\\n')\nprint(\"  Bus names for which generator factors are calculated:\")\nprint(list(robj.genvalues.keys()))\nprint('\\n')\nprint(\"  Generator factors:\")\nfor bus, vdict in list(robj.genvalues.items()):\ntdct = {'bus':bus, 'pmax':vdict.pmax, 'pmin':vdict.pmin, 'pgen':vdict.pgen, 'sftr':vdict.factor}\nprint(\"{bus:s}  {pmax:8.2f}  {pmin:8.2f} {pgen:8.2f}  {sftr:8.5f}\".format(**tdct))\n# ====================================================================================================\ndef run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):\nimport psspy\nibus        = 151\njbus        = 152\nkbus        = 0\nckt         = '1'\nmainsys     = 'STUDY'\nnetmod      = 'dc'\nbrnflowtyp  = 'mw'\ntransfertyp = 'import'\noppsystyp   = 'slack bus'\ndispmod     = 1\ntoln        = None\noppsys      = ''\nif not os.path.exists(savfile):\nprgmsg = \" Error: Input savfile '{0}' does not exist\".format(savfile)\nprint(prgmsg)\nreturn\nif not os.path.exists(dfxfile):\nprgmsg = \" Error: Input dfxfile '{0}' does not exist\".format(dfxfile)\nprint(prgmsg)\nreturn\np, nx = os.path.split(dfxfile)\nn, x = os.path.splitext(nx)\nrptfile = get_output_filename(outpath, 'sensitivity_factors_' + n +'_report.txt')\npsspy.psseinit()\npsspy.case(savfile)\ncreate_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile)\ndemo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun_demo()\n# ====================================================================================================\n# [\t]     04/23/20     Python Functions to emulate GRPG\n#\n#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n#  *                                                                     *\n#  *  THIS PROGRAM AND ITS DOCUMENTATION ARE TRADE SECRETS OF POWER      *\n#  *  TECHNOLOGIES, INC. (PTI).  THEY HAVE BEEN LEASED TO                *\n#  *                   client full name (clabr)                          *\n#  *  SUBJECT TO TERMS WHICH PROHIBIT clabr FROM DISCLOSING OR TRANS-    *\n#  *  FERRING THE PROGRAM OR ITS DOCUMENTATION, WHETHER IN ITS ORIGINAL  *\n#  *  OR MODIFIED FORM, TO A THIRD PARTY, OR FROM USING THE PROGRAM FOR  *\n#  *  ANY PURPOSE OTHER THAN COMPUTATION RELATING TO clabr'S OWN SYSTEM. *\n#  *  ANY SUCH TRANSFER OR USE BY clabr OR ITS EMPLOYEES WILL CONSTI-    *\n#  *  TUTE A BREACH OF CONFIDENCE AND OF THE CONTRACT UNDER WHICH        *\n#  *  RIGHTS OF USE HAVE BEEN GRANTED.                                   *\n#  *                                                                     *\n#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n'''The functions in this Python module return:\n- formatted text which can be used to put annotation on slider diagrams.\n- values which are used to generate formatted text above.\nExample: function 'area_summary' returns formatted text and\nfunction 'area_summary_v' returns values used by 'area_summary'\ni.e, functions with name ending with \"_v\" return values\n'''\nimport psspy\n#========================================================================================\ndef area_summary_v(arnum):\n'''Returns desired and net interchange, loads, generation and losses for\narea 'arnum'.\npdes,pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.area_summary_v(arnum)\n'''\nsid  = 3\nflag = 2\nierr = psspy.asys(sid, flag, [arnum])\nierr, rdata = psspy.aareareal(sid,flag,\n['PDES','PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])\npsspy.asysdef(sid, 0)\nif ierr==0:\n(pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata\nif len(pdes)>0:\nreturn pdes[0],pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]\nreturn None,None,None,None,None,None,None,None,None\ndef area_summary(arnum):\n'''Returns formatted text showing desired and net interchange, loads, generation\nand losses for area 'arnum'.\ntxt = pssgrpg.area_summary(arnum)\n'''\npdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = area_summary_v(arnum)\nif pdes:\ntxt = '''Area %(arnum)d Summary:\nDesired Interchange: %(pdes)9.2f MW\nNet Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR\nArea loads         : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR\nArea generation    : %(pgen)9.2f MW, %(qgen)9.2f MVAR\nArea losses        : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\nelse:\ntxt = '''Area %(arnum)d Summary:\nDesired Interchange: None\nNet Interchange    : None\nArea loads         : None\nArea generation    : None\nArea losses        : None''' % vars()\nreturn txt\ndef area_interchange_net_v(arnum):\n'''Returns desired and net interchange for area 'arnum'.\npdes,pint,qint = pssgrpg.area_interchange_net_v(arnum)\n'''\nsid  = 3\nflag = 2\nierr = psspy.asys(sid, flag, [arnum])\nierr, rdata = psspy.aareareal(sid,flag,['PDES','PINT','QINT'])\npsspy.asysdef(sid, 0)\nif ierr==0:\n(pdes,pint,qint) = rdata\nif len(pdes)>0:\nreturn pdes[0],pint[0],qint[0]\nreturn None,None,None\ndef area_interchange_net(arnum):\n'''Returns formatted text showing desired and net interchange for area 'arnum'.\ntxt = pssgrpg.area_interchange_net(arnum)\n'''\npdes,pint,qint = area_interchange_net_v(arnum)\nif pdes:\ntxt = '''Area %(arnum)d Interchange:\nDesired Interchange: %(pdes)9.2f MW\nNet Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\nelse:\ntxt = '''Area %(arnum)d Interchange:\nDesired Interchange: None\nNet Interchange    : None''' % vars()\nreturn txt\ndef area_interchange_ij_v(iar,jar):\n'''Returns interchange from area 'iar' to area 'jar'.\np,q = pssgrpg.area_interchange_ij_v(iar,jar)\n'''\nierr, cmpval = psspy.aritoj(iar,jar)\nif ierr==0:\nreturn cmpval.real, cmpval.imag\nreturn None,None\ndef area_interchange_ij(iar,jar):\n'''Returns formatted text showing interchange from area 'iar' to area 'jar'.\ntxt = pssgrpg.area_interchange_ij(iar,jar)\n'''\npint,qint = area_interchange_ij_v(iar,jar)\nif pint:\ntxt = '''Interchange from Area %(iar)d to Area %(jar)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\nelse:\ntxt = '''Interchange from Area %(iar)d to Area %(jar)d: None''' % vars()\nreturn txt\n#========================================================================================\ndef zone_summary_v(znnum):\n'''Returns net interchange, loads, generation and losses for zone 'znnum'.\npint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.zone_summary_v(znnum)\n'''\nsid  = 3\nflag = 2\nierr = psspy.zsys(sid, flag, [znnum])\nierr, rdata = psspy.azonereal(sid,flag,\n['PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])\npsspy.zsysdef(sid, 0)\nif ierr==0:\n(pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata\nif len(pint)>0:\nreturn pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]\nreturn None,None,None,None,None,None,None,None,None\ndef zone_summary(znnum):\n'''Returns formatted text showing net interchange, loads, generation and losses\nfor zone 'znnum'.\ntxt = pssgrpg.zone_summary(znnum)\n'''\npint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = zone_summary_v(znnum)\nif pint:\ntxt = '''Zone %(znnum)d Summary:\nNet Interchange : %(pint)9.2f MW, %(qint)9.2f MVAR\nZone loads      : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR\nZone generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR\nZone losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\nelse:\ntxt = '''Zone %(znnum)d Summary:\nNet Interchange : None"
  },
  {
    "id": "chunk_083",
    "text": "Zone loads      : None\nZone generation : None\nZone losses     : None''' % vars()\nreturn txt\ndef zone_interchange_ij_v(izn,jzn):\n'''Returns interchange from zone 'izn' to zone 'jzn'.\np,q = pssgrpg.zone_interchange_ij_v(izn,jzn)\n'''\nierr, cmpval = psspy.znitoj(izn,jzn)\nif ierr==0:\nreturn cmpval.real, cmpval.imag\nreturn None,None\ndef zone_interchange_ij(izn,jzn):\n'''Returns formatted text showing interchange from zone 'izn' to zone 'jzn'.\ntxt = pssgrpg.zone_interchange_ij(izn,jzn)\n'''\npint,qint = zone_interchange_ij_v(izn,jzn)\nif pint:\ntxt = '''Interchange from Zone %(izn)d to Area %(jzn)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()\nelse:\ntxt = '''Interchange from Zone %(izn)d to Zone %(jzn)d: None''' % vars()\nreturn txt\n#========================================================================================\ndef system_summary_v():\n'''Returns working case loads, generation and losses.\npload,qload,pgen,qgen,ploss,qloss = pssgrpg.system_summary_v()\n'''\nierr, syslod = psspy.systot('LOAD')\nierr, sysgen = psspy.systot('GEN')\nierr, syslos = psspy.systot('LOSS')\nreturn syslod.real, syslod.imag, sysgen.real, sysgen.imag, syslos.real, syslos.imag\ndef system_summary():\n'''Returns formatted text showing working case loads, generation and losses.\ntxt = pssgrpg.system_summary()\n'''\npload,qload,pgen,qgen,ploss,qloss = system_summary_v()\ntxt = '''Case Summary:\nTotal loads      : %(pload)9.2f MW, %(qload)9.2f MVAR\nTotal generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR\nTotal losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()\nreturn txt\n#========================================================================================\n#[wecclf_demo.py]  Demo for running WECCLF Converter from Python Scripts\n# ====================================================================================================\n'''\nWECCLF converter is used to convert PSLF Power Flow (.epc) and Sequence (.seq) Data\nto PSSE Power Flow (.raw) and Sequence (.seq) Data.\nAdditionally it also compares PSSE and PSLF Power Flow Solutions.\nWECCLF converter can be run from its own GUI:\n>>> import wecclf_gui\n>>> wecclf_gui.main()\nThis scripts shows different ways to run WECCLF Converter from Python Scripts.\n'''\nimport os, sys\n# ====================================================================================================\ndef run_wecclf(pslf_version, pslf_epcfile, psse_version, workdir=os.getcwd(), testnum=2):\nimport ndppslf\nif not os.path.exists(pslf_epcfile):\nmsgtxt = \" EPC file does not exist, WECCLF converter not run.\\n    {}\".format(pslf_epcfile)\nprint(msgtxt)\nreturn\np, nx = os.path.split(pslf_epcfile)\nnam, ext  = os.path.splitext(nx)\noutdir = 'wecclf_demo_output_v{}'.format(psse_version)\nworkdir = os.path.join(workdir, outdir)\nif not os.path.exists(workdir): os.makedirs(workdir)\nrawfnam  = \"{}_v{}.raw\".format(nam, psse_version)\nrawfile  = os.path.join(workdir, rawfnam)\nprgsplit = False\nprgfull  = True\nif testnum==1:\n#(1) Convert and compare power flow solutions using all default options\nndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\npsse_rawfile=rawfile, ratea=1, rateb=2, ratec=3,\nworkdir=workdir, prgsplit=prgsplit, prgfull=prgfull)\nelif testnum==2:\n#(2) Convert only\nndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\npsse_rawfile=rawfile, do_psse_pfsoln=False,\nworkdir=workdir, compare_pfsoln=False, prgfull=prgfull, prgsplit=prgsplit)\nelif testnum==3:\n#(3) Convert and compare power flow solutions using options from epcfile and options as specified\nndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\npsse_rawfile=rawfile,\nworkdir=workdir, prgsplit=prgsplit, prgfull=prgfull,\npfmethod='RSOL', use_epcoptns=False, itmxn=100, flat=0, varlmt=99, nondiv=0,\nrsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,\ncompare_pfsoln=True, show_ntop=-1, toler_vpu=-0.001,\ntoler_pgen=-1.0, toler_qgen=-1.0, toler_bact=-0.01, toler_pitf=-1.0, toler_qitf=-1.0)\nelif testnum==4:\n#(4) Convert and compare power flow solutions using options as specified\nndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,\npsse_rawfile=rawfile, psse_autofile='',\nworkdir=workdir, prgsplit=prgsplit, prgfull=prgfull,\npfmethod='RSOL', use_epcoptns=False, itmxn=100, toln=0.1, thrshz=0.0001, tap=0,\narea=0, phshft=0, dctap=1, swsh=1,flat=0, varlmt=99, nondiv=0,\nrsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,\ncompare_pfsoln=True, show_ntop=100, toler_vpu=0.02, toler_pgen=1.0,\ntoler_qgen=-1.0, toler_bact=0.01, toler_pitf=1.0, toler_qitf=-1.0)\n# ====================================================================================================\ndef _run_how():\npass\n##    # EPC file version=18\n##    epcfile18 = r\"sample18.epc\"\n##    run_wecclf(18, epcfile18, psse_version=34, workdir=os.getcwd(), testnum=3)\n##\n##    # EPC file version=19\n##    epcfile19 = r\"sample19.epc\"\n##    run_wecclf(19, epcfile19, psse_version=34, workdir=os.getcwd(), testnum=3)\n##\n##    # EPC file version=21\n##    epcfile21 = r\"sample21.epc\"\n##    run_wecclf(21, epcfile21, psse_version=34, workdir=os.getcwd(), testnum=3)\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nif __name__ == '__main__':\npass\n# Here \"import psse34\" or \"import psse35\" as appropriate.\n# Then run required test. See _run_how() above for reference.\n#[wordpy_demo.py]  Demo for using functions from wordpy module\n# ====================================================================================================\n'''\n'wordpy' module provides Pythonic Interface to Miscrosoft Word.\nThis module has functions to create new or update existing Microsoft Word document by:\n- adding text into Word document\n- inserting pictures/plots into Word document\nThis is an example file showing how to use various functions available in wordpy module.\n---------------------------------------------------------------------------------\nHow to use this file?\nAs showed in __main__ (end of this file)\n- Enable PSSE version specific environment, as an example:\nimport psse35\n- call any of the function as below\nrun()  OR\nrun(pssplt_eps_files, pict_files, docfile, outpath, show)\nYou could modify various inputs in run)demo() as desired.\n'''\n# ====================================================================================================\nimport sys, os\ndef get_output_dir(outpath):\n# if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'\nif outpath:\noutdir = outpath\nif not os.path.exists(outdir): os.mkdir(outdir)\nelse:\noutdir = os.getcwd()\ncwd = outdir.lower()\ni = cwd.find('pti')\nj = cwd.find('psse')\nk = cwd.find('example')\nif i>0 and j>i and k>j:     # called from Example folder\noutdir = os.path.join(outdir, 'Output_Pyscript')\nif not os.path.exists(outdir): os.mkdir(outdir)\nreturn outdir\n# ====================================================================================================\ndef get_output_filename(outpath, fnam):\np, nx = os.path.split(fnam)\nif p:\nretvfile = fnam\nelse:\noutdir = get_output_dir(outpath)\nretvfile = os.path.join(outdir, fnam)\nreturn retvfile\n# ====================================================================================================\ndef run(pssplt_eps_files=[], pict_files=[], docfile='', outpath=None, show=True):\n\"\"\"\nInputs:\npssplt_eps_files --> List of Multi-page 'eps' plot files created by PSSPLT\npict_files       --> List of any word compatible picture files (.eps, .wmf, .png, .bmp etc.)\ndocfile          --> Word file name\noutpath          --> Outpath where Word file created/saved\nShow             --> = True, Show Word\n= False, Create and Save Word file but do not show\n\"\"\"\nimport wordpy\npssplt_eps_files_lst = []\nfor fnam in pssplt_eps_files:\nif not os.path.exists(fnam): continue\npssplt_eps_files_lst.append(fnam)\npict_files_lst   = []\npict_caption_lst = []\nfor fnam in pict_files:\nif not os.path.exists(fnam): continue\np, nx = os.path.split(fnam)\ncaption, x = os.path.splitext(nx)\npict_files_lst.append(fnam)\npict_caption_lst.append(caption)\nif  docfile:\np, nx = os.path.split(docfile)\ndocfnam, x = os.path.splitext(nx)\nelse:\ndocfnam = r'wordpy_demo_created'\np = outpath\n# doc file\ndocfile = get_output_filename(p, docfnam)\ndocoverwrite = True\n# Picture Insert Options (see help(wordpy) for explaination)\nalign      = 'center'\ncaptionpos = 'below'\nheight     = None\nwidth      = None\nrotate     = None\n# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n# Put-it-together\nwdobj = wordpy.workdoc(docfile=docfile, overwrite=docoverwrite)\nif show:\nwdobj.show()\nwdobj.page_format(orientation=\"portrait\",left=0.75,right=0.75,top=0.5,bottom=0.5,\nheader=0.25,footer=0.25)\nwdobj.add_styled_para('Use of Python and Word','Title')\ntxt = \"This file is produced by Python script, by inserting picture files into word document. \\\nIt uses python module 'wordpy'.\\n\\n\\\nThis module is mainly created to add plot files (.eps, .png, .wmf etc.) \\\ncreated by PSSPLT/PSSPLOT to existing or new Word files.\\n\\n\\\nUse PSSPLT to create .eps files, and PSSPLOT to create .wmf files. Then use \\\n'wordpy' module to create Word document from those files.\\n\\n\\\nHow to use it?\\n\\n\\\nUse 'workdoc' function to create Miscrosoft Word object and use 'add_picture(...)' or \\\n'add_pictures(...)' methods to insert pictures into the doc file.\\n\\n\"\nwdobj.add_text(txt)\ntxt = \"\"\"Use either of the following to create Word object:\n(1) When file does not exist, create new file.\nwdobj = wordpy.workdoc()"
  },
  {
    "id": "chunk_084",
    "text": "(2) When file exists, do not remove the content and add data at the end.\nwdobj = wordpy.workdoc(r\"c:\\working dir\\ex1.doc\", overwrite=False)\n(3) When file exists, remove the content and create new file.\nwdobj = wordpy.workdoc(r\"c:\\working dir\\ex1.doc\", overwrite=True)\n\"\"\"\nwdobj.add_text(txt)\nif pssplt_eps_files_lst:\nwdobj.insert_page_break()\nwdobj.add_styled_para('Inserting multi-page PSSPLT EPS Files - add_pssplt_eps(...)','Heading 1')\nfor fnam in pssplt_eps_files_lst:\nwdobj.add_pssplt_eps(fnam, captionlst=True, align=align, captionpos=captionpos,\nheight=height, width=width, rotate=rotate)\nwdobj.insert_page_break()\nif pict_files_lst:\nwdobj.add_styled_para('Inserting One Picture File - add_picture(...)','Heading 1')\nwdobj.add_picture(pictfile=pict_files_lst[0], caption=pict_caption_lst[0], align=align,\ncaptionpos=captionpos, height=None, width=None, rotate=0.0)\nwdobj.insert_page_break()\nif pict_files_lst:\nwdobj.add_styled_para('Inserting Many Picture Files - add_pictures(...)','Heading 1')\nwdobj.add_pictures(pictfilelst=pict_files_lst, captionlst=pict_caption_lst, align=align,\ncaptionpos=captionpos, height=height, width=width, rotate=0.0)\nwdobj.save()\nif not show:\ntxt = \"\\n Word file created:\\n     {0}\".format(wdobj.DOCFNAM)\nwdobj.close()\nprint(txt)\n# ====================================================================================================\n# ====================================================================================================\nif __name__ == '__main__':\nimport psse35\nrun()\n# ====================================================================================================\n# Blocks of code to run (0 - Do no run ; 1 - Run)\nGUI_CASES = 1\nGUI_STUDY = 0\nGUI_REPORTS = 0\nGUI_CAPACITY = 0\nGUI_DELTA = 0\nGUI_SLIM = 0\nGUI_MATCH = 0\n# Set thresholds to eliminate redundant contingencies and consolidate reports\n# * Disable this feature by setting Threshold = 0\n# [0] Report name (do not change)\n# [1] Report number (do not change)\n# [2] Thermal threshold is in decimal percent\n#     Voltage threshold is in decimal pu\n#     Convergence threshold should be 0 (do not change)\n#     Capacity threshold is in decimal percent and assumes 50 MVA minimum element rating\nSS_REPORT = []\nSS_REPORT.append([\"THERMAL\",1,0.05])\nSS_REPORT.append([\"VOLTAGE\",2,0.01])\nSS_REPORT.append([\"CONVERGENCE\",4,0])\nSS_REPORT.append([\"CAPACITY\",6,0.05])\nSS_REPORT.append([\"DELTA\",0,0.05])\n# Clean mode (0 - Leave miscellaneous files in place ; 1 - Delete miscellaneous files)\nSS_CLEAN = 1\n# Contingencies to run (0 - Do not run contingency ; 1 - Run contingency)\nP1 = 1\nP2_1 = 1\nP2 = 0\nP3 = 1 # ERCOT2\nP4 = 0\nP5 = 0\nP6 = 0\nP7 = 1 # ERCOT1\nERCOT3 = 1\nEE = 0\nSPECIAL = 0\n# Maximum number of contingency events in a single file\nSS_CONSPLIT = 57\n# Number of CPUs to use for parallel processing\nSS_CPU = 6\n# Post-contingency thermal loading threshold, in percent\nSS_LOADING = 90\n# Post-contingency rating (1 - Rate A ; 2 - Rate B ; 3 - Rate C)\nSS_RATE = 1\n# Post-contingency voltage limit (1 - Normal limit ; 2 - Emergency limit)\nSS_LIMIT = 2\n# Exclude elements with pre-contingency (base case) voltage violations (0 - Do not exclude ; 1 - Exclude)\nSS_EXCLUDE = 0\n# Post-contingency tap adjustment (0 - Lock taps ; 1 - Stepping ; 2 - Direct)\nSS_TAP = 0\n# Post-contingency shunt control (0 - Lock all ; 1 - Enable all ; 2 - Enable continuous and disable discrete)\nSS_SHUNT = 1\n# Post-contingency adjust PSTs (0 - Do not adjust ; 1 - Adjust)\nSS_PST = 0\n# Mismatch tolerance\nSS_TOL = 1.0\n# File paths\nFPATH_SAV = \"CASES\\\\SAV\\\\\"\nFPATH_RAW = \"CASES\\\\RAW\\\\\"\nFPATH_RCSV = \"CASES\\\\CSV\\\\\"\nFPATH_RCON = \"CASES\\\\CONFILES\\\\\"\nFPATH_CON = \"CONFILES\\\\\"\nFPATH_ACC = \"PSSE\\\\ACC\\\\\"\nFPATH_PDEV = \"PSSE\\\\PDEV\\\\\"\nFPATH_DFX = \"PSSE\\\\DFX\\\\\"\nFPATH_TXT = \"REPORTS\\\\TXT\\\\\"\nFPATH_CSV = \"REPORTS\\\\CSV\\\\\"\n# Import libraries\nimport os, sys, time, re, string, shutil\nfrom datetime import datetime\nfrom glob import glob\nimport importlib\nimport multiprocessing\nimport functools\nimport tkinter as tk\nfrom tkinter import scrolledtext\n# Import PSS/E library and initialize PSS/E\nos.path.abspath(sys.argv[0])\nsys.path.append(r\"C:\\Program Files\\PTI\\PSSE35\\35.6\\PSSPY311\")\nos.environ['PATH'] += \";\" + r\"C:\\Program Files\\PTI\\PSSE35\\35.6\\PSSPY311\"\nimport psse3506 as psse35\nimport psspy\nimport pssarrays\nimport redirect\nredirect.psse2py()\nierr = psspy.psseinit(0)\n##### Main function\n# (0) Setup GUI\n# (1) Case I/O\n# (2) Run study and create .txt reports\n# (3) Create .csv reports\n# (4) Create .csv capacity reports\n# (5) Consolidate and trim .csv reports\n# (6) Add bus and branch information to .csv reports\ndef main():\nm_gui()\nif GUI_STUDY == 1:\nm_study()\nif GUI_REPORTS == 1:\nm_reports()\nif GUI_CAPACITY == 1 or GUI_DELTA == 1:\n# Run both\nif GUI_CAPACITY == 1 and GUI_DELTA == 1:\nm_capacity(0)\n# Run capacity report only\nelif GUI_CAPACITY == 1:\nm_capacity(1)\n# Run delta report only\nelif GUI_DELTA == 1:\nm_capacity(-1)\n# (0,0) condition does not exist\nif GUI_DELTA == 1:\nm_delta()\nif GUI_SLIM == 1:\nm_slim()\nif GUI_MATCH == 1:\nm_match()\n##### GUI\ndef m_gui():\nglobal GUI_CASES, GUI_STUDY, GUI_REPORTS, GUI_CAPACITY, GUI_DELTA, GUI_SLIM, GUI_MATCH\nglobal P1, P2_1, P2, P3, P4, P5, P6, P7, ERCOT3, EE, SPECIAL\nglobal SS_CPU, SS_LOADING, SS_EXCLUDE, SS_TAP, SS_SHUNT\nglobal SS_REPORT\nroot = tk.Tk()\nroot.winfo_toplevel().title(\"FastStudy\")\n# Variables to interface the GUI and code\nGUI_CASES = tk.IntVar(value=GUI_CASES)\nGUI_STUDY = tk.IntVar(value=GUI_STUDY)\nGUI_REPORTS = tk.IntVar(value=GUI_REPORTS)\nGUI_CAPACITY = tk.IntVar(value=GUI_CAPACITY)\nGUI_DELTA = tk.IntVar(value=GUI_DELTA)\nGUI_SLIM = tk.IntVar(value=GUI_SLIM)\nGUI_MATCH = tk.IntVar(value=GUI_MATCH)\n#\nP1 = tk.IntVar(value=P1)\nP2_1 = tk.IntVar(value=P2_1)\nP2 = tk.IntVar(value=P2)\nP3 = tk.IntVar(value=P3)\nP4 = tk.IntVar(value=P4)\nP5 = tk.IntVar(value=P5)\nP6 = tk.IntVar(value=P6)\nP7 = tk.IntVar(value=P7)\nERCOT3 = tk.IntVar(value=ERCOT3)\nEE = tk.IntVar(value=EE)\nSPECIAL = tk.IntVar(value=SPECIAL)\n#\nSS_CPU = tk.IntVar(value=SS_CPU)\nSS_LOADING = tk.DoubleVar(value=SS_LOADING)\nSS_EXCLUDE = tk.IntVar(value=SS_EXCLUDE)\nSS_TAP = tk.IntVar(value=SS_TAP)\nSS_SHUNT = tk.IntVar(value=SS_SHUNT)\n#\nSS_REPORT_THERMAL = tk.DoubleVar(value=SS_REPORT[0][2])\nSS_REPORT_VOLTAGE = tk.DoubleVar(value=SS_REPORT[1][2])\nSS_REPORT_CAPACITY = tk.DoubleVar(value=SS_REPORT[3][2])\nSS_REPORT_DELTA = tk.DoubleVar(value=SS_REPORT[4][2])\n# m_cases()\n# tk.Checkbutton(root,text=\"Convert .sav case files to .raw and .csv case files\",variable=GUI_CASES).grid(row=1,column=1,sticky=\"W\")\ntk.Button(root,text=\"Click this button to create case .csv and .con files\",command=m_gui_cases,height=2,width=40,bg=\"white\",fg=\"blue\").grid(row=1,column=1,pady=(20,20))\n# m_study\ntk.Checkbutton(root,text=\"Create .acc study files and .txt report files\",variable=GUI_STUDY).grid(row=2,column=1,sticky=\"W\")\ntk.Checkbutton(root,text=\"P1 / P2.1 / P7 / ERCOT 1\",variable=P1).grid(row=3,column=1,sticky=\"W\",padx=(20,0))\n# tk.Checkbutton(root,text=\"* P2.1\",variable=P2_1).grid(row=4,column=1,sticky=\"W\",padx=(20,0))\n# tk.Checkbutton(root,text=\"* P7 / ERCOT 1\",variable=P7).grid(row=5,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"P3 / ERCOT 2\",variable=P3).grid(row=6,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"ERCOT 3\",variable=ERCOT3).grid(row=7,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"\\u2217 P2 / P4 / P5 / EE\",variable=P2).grid(row=8,column=1,sticky=\"W\",padx=(20,0))\n# tk.Checkbutton(root,text=\"* P4\",variable=P4).grid(row=9,column=1,sticky=\"W\",padx=(20,0))\n# tk.Checkbutton(root,text=\"* P5\",variable=P5).grid(row=10,column=1,sticky=\"W\",padx=(20,0))\n# tk.Checkbutton(root,text=\"* EE\",variable=EE).grid(row=11,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"\\u2217 P6\",variable=P6).grid(row=12,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"\\u2217 SPECIAL\",variable=SPECIAL).grid(row=13,column=1,sticky=\"W\",padx=(20,0))\ntk.Entry(root,textvariable=SS_CPU,width=6).grid(row=14,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Number of CPUs to use for parallel processing (integer)\").grid(row=14,column=1,sticky=\"W\",padx=(69,0))\ntk.Checkbutton(root,text=\"Exclude elements with base case voltage violations\",variable=SS_EXCLUDE).grid(row=15,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"Enable transformer taps\",variable=SS_TAP).grid(row=16,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"Enable switch shunts\",variable=SS_SHUNT).grid(row=17,column=1,sticky=\"W\",padx=(20,0))\ntk.Entry(root,textvariable=SS_LOADING,width=6).grid(row=18,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Post-contingency thermal loading threshold (percent)\").grid(row=18,column=1,sticky=\"W\",padx=(69,5))\n# Report\ntk.Checkbutton(root,text=\"Convert .txt report files to .csv report files\",variable=GUI_REPORTS).grid(row=19,column=1,sticky=\"W\")\n# Capacity\ntk.Checkbutton(root,text=\"Create .csv capacity report files using .acc study files\",variable=GUI_CAPACITY).grid(row=20,column=1,sticky=\"W\",padx=(20,0))\ntk.Checkbutton(root,text=\"Create .csv delta report files using .acc study files\",variable=GUI_DELTA).grid(row=21,column=1,sticky=\"W\",padx=(20,0))\n# Slim\ntk.Checkbutton(root,text=\"Combine .csv report files and eliminate redundant violations\",variable=GUI_SLIM).grid(row=22,column=1,sticky=\"W\")\ntk.Entry(root,textvariable=SS_REPORT_THERMAL,width=6).grid(row=23,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Thermal redudancy threshold (decimal percent)\").grid(row=23,column=1,sticky=\"W\",padx=(69,0))\ntk.Entry(root,textvariable=SS_REPORT_VOLTAGE,width=6).grid(row=24,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Voltage redudancy threshold (pu)\").grid(row=24,column=1,sticky=\"W\",padx=(69,0))\ntk.Entry(root,textvariable=SS_REPORT_CAPACITY,width=6).grid(row=25,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Capacity redudancy threshold (decimal percent)\").grid(row=25,column=1,sticky=\"W\",padx=(69,0))\ntk.Entry(root,textvariable=SS_REPORT_DELTA,width=6).grid(row=26,column=1,sticky=\"W\",padx=(25,0))\ntk.Label(root,text=\"Delta redudancy threshold (decimal percent)\").grid(row=26,column=1,sticky=\"W\",padx=(69,0))\n# Match\ntk.Checkbutton(root,text=\"Add case data to combined .csv report files\",variable=GUI_MATCH).grid(row=27,column=1,sticky=\"W\")\n# I/O\ndef GUI_IO():\nglobal GUI_CASES, GUI_STUDY, GUI_REPORTS, GUI_CAPACITY, GUI_DELTA, GUI_SLIM, GUI_MATCH\nglobal P1, P2_1, P2, P3, P4, P5, P6, P7, ERCOT3, EE, SPECIAL"
  },
  {
    "id": "chunk_085",
    "text": "global SS_CPU, SS_LOADING, SS_EXCLUDE, SS_TAP, SS_SHUNT\nglobal SS_REPORT\nGUI_CASES = GUI_CASES.get()\nGUI_STUDY = GUI_STUDY.get()\nGUI_REPORTS = GUI_REPORTS.get()\nGUI_CAPACITY = GUI_CAPACITY.get()\nGUI_DELTA = GUI_DELTA.get()\nGUI_SLIM = GUI_SLIM.get()\nGUI_MATCH = GUI_MATCH.get()\n#\nP1 = P1.get()\nP2_1 = P1 # P2_1.get()\nP2 = P2.get()\nP3 = P3.get()\nP4 = P2 # P4.get()\nP5 = P2 # P5.get()\nP6 = P6.get()\nP7 = P1 # P7.get()\nERCOT3 = ERCOT3.get()\nEE = P2 # EE.get()\nSPECIAL = SPECIAL.get()\n#\nSS_CPU = int(SS_CPU.get())\nSS_LOADING = float(SS_LOADING.get())\nSS_EXCLUDE = SS_EXCLUDE.get()\nSS_TAP = SS_TAP.get()\nSS_SHUNT = SS_SHUNT.get()\n#\nSS_REPORT[0][2] = float(SS_REPORT_THERMAL.get())\nSS_REPORT[1][2] = float(SS_REPORT_VOLTAGE.get())\nSS_REPORT[3][2] = float(SS_REPORT_CAPACITY.get())\nSS_REPORT[4][2] = float(SS_REPORT_DELTA.get())\n#\nroot.destroy()\n# Button\ntk.Button(root,text=\"Click this button to run the script\",command=GUI_IO,height=2,width=30,bg=\"white\").grid(row=28,column=1,pady=(20,20))\ntk.Button(root,text=\"Click this button to delete files\",command=m_gui_kill,height=2,width=30,bg=\"white\",fg=\"red\").grid(row=29,column=1,pady=(0,20))\n# Close\nroot.mainloop()\ndef m_gui_cases():\nm_cases()\nprint(\"Created case files!\")\ndef m_gui_kill():\n# Folders\nrs = []\nrs.append([FPATH_RAW,\"raw\",\"orange\",0])\nrs.append([FPATH_RCSV,\"csv\",\"orange\",0])\nrs.append([FPATH_ACC,\"acc\",\"red\",0])\nrs.append([FPATH_PDEV,\"pdev\",\"red\",1])\nrs.append([FPATH_DFX,\"dfx\",\"red\",1])\nrs.append([FPATH_CSV,\"csv\",\"purple\",0])\nrs.append([FPATH_CSV + \"CAPACITY\\\\\",\"csv\",\"purple\",0])\nrs.append([FPATH_CSV + \"CONTINGENCY\\\\\",\"csv\",\"purple\",1])\nrs.append([FPATH_CSV + \"CONVERGENCE\\\\\",\"csv\",\"purple\",1])\nrs.append([FPATH_CSV + \"DELTA\\\\\",\"csv\",\"purple\",1])\nrs.append([FPATH_CSV + \"LOAD\\\\\",\"csv\",\"purple\",1])\nrs.append([FPATH_CSV + \"THERMAL\\\\\",\"csv\",\"purple\",1])\nrs.append([FPATH_CSV + \"VOLTAGE\\\\\",\"csv\",\"purple\",1])\n# Window 1\nroot = tk.Tk()\nroot.winfo_toplevel().title(\"Delete\")\nGUI_RS = [tk.IntVar(root,value=r[3]) for r in rs]\nfor i, r in enumerate(rs):\ntk.Checkbutton(root,text=r[0]+\"*.\"+r[1],fg=r[2],variable=GUI_RS[i],font=\"TkFixedFont\").grid(row=i+1,column=1,sticky=\"W\")\n# Kill list\ndef m_gui_kill_confirm(rs):\n# Get value from GUI\nfor i, r in enumerate(rs):\nrs[i][2] = GUI_RS[i].get()\n# Update list\n# [^\\\\\\\\]* is any character excluding \"\\\"\nrs = [r[0].replace(\"\\\\\",\"\\\\\\\\\").replace(\"*\",\"[^\\\\\\\\]*\") + \"[^\\\\\\\\]*\" + \"\\.\" + r[1] for r in rs if r[2] == 1]\n# Get list of filenames\nfnames = set()\nfor fpath, dirs, files in os.walk(\".\"):\nfor fname in files:\nfnames.add(os.path.join(fpath.replace(\".\\\\\",\"\"),fname))\nfnames = list(fnames)\nfnames.sort()\n# Workaround \"\\\\\" usage in re\nfnames = [fname.replace(\"\\\\\",\"/\") for fname in fnames]\n# Filter list of filenames\nfnames_filter = set()\nfor r in rs:\n# Workaround \"\\\\\" usage in re\nfnames_filter.update(set(filter(re.compile(r.replace(\"\\\\\\\\\",\"/\")).match,fnames)))\nfnames = list(fnames_filter)\nfnames.sort()\n# Workaround \"\\\\\" usage in re\nfnames = [fname.replace(\"/\",\"\\\\\") for fname in fnames]\n# Kill Window 1\nfor widget in root.winfo_children():\nwidget.destroy()\n# Window 2\nst = scrolledtext.ScrolledText(root,wrap=tk.WORD,width=120,height=40,font=\"TkFixedFont\")\nst.grid(row=1,column=1,pady=10,padx=10)\nst.configure(state =\"normal\")\nfor i, fname in enumerate(fnames):\nst.insert(tk.INSERT,fname + \"\\n\")\nst.configure(state =\"disabled\")\nst.focus()\ntk.Button(root,text=\"Click this button to delete these files\",command=functools.partial(m_kill,fnames),height=2,width=30,bg=\"white\").grid(row=2,column=1,pady=(0,10))\n# Kill function\ndef m_kill(fnames):\nfor fname in fnames:\nos.remove(fname)\nroot.destroy()\n# Button\ntk.Button(root,text=\"Click this button to generate delete list\",command=functools.partial(m_gui_kill_confirm,rs),height=2,width=30,bg=\"white\").grid(row=len(rs)+1,column=1,pady=(20,20))\n# Close\nroot.mainloop()\n##### Case I/O\n# (1) Export .sav files in the FPATH_SAV folder to .raw files in the FPATH_RAW folder\n# (2) Convert .raw files in the FPATH_RAW folder to a set of .csv files in FPATH_CSV subfolders\n# (3) Combine .csv files in the FPATH_RCSV folder and subfolders\ndef m_cases():\n# Export each .sav file to .raw file\nfnames_sav = [os.path.basename(x) for x in glob(FPATH_SAV + \"*.sav\")]\nfor fname_sav in fnames_sav:\nfname_raw = FPATH_RAW + fname_sav.replace(\".sav\",\".raw\")\npsspy.case(FPATH_SAV + fname_sav)\npsspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,fname_raw)\n# Clean up the FPATH_RCSV folder\nnuke(FPATH_RCSV,0)\nfpaths = [\"AREA\",\"BRANCH\",\"BUS\",\"FACTSDEVICE\",\"FIXEDSHUNT\",\"GENERATOR\",\"LINES\",\"LINES_MIRROR\",\"LOAD\",\"MULTI-SECTIONLINE\",\"OWNER\",\"SWITCHEDSHUNT\",\"SYSTEMSWITCHINGDEVICE\",\"TRANSFORMER2\",\"TRANSFORMER3\",\"ZONE\"]\nfor fpath in fpaths:\nos.mkdir(FPATH_RCSV + fpath)\n# Clean up the FPATH_RCON folder\nfpaths = [\"P1_1\",\"P1_3\",\"P1_4\",\"P2_1\"]\nfor fpath in fpaths:\nnuke(FPATH_RCON + fpath + \"\\\\\",1)\nos.mkdir(FPATH_RCON + fpath)\n# Export each .raw file to a set of .csv files\nfnames_raw = [os.path.basename(x) for x in glob(FPATH_RAW + \"*.raw\")]\nfor fname_raw in fnames_raw:\ncsv_case(FPATH_RAW + fname_raw)\n# Export .csv files to .con files\nfpaths = []\nfpaths.append([\"GENERATOR\",\"P1_1\"])\nfpaths.append([\"TRANSFORMER2\",\"P1_3\"])\nfpaths.append([\"TRANSFORMER3\",\"P1_3\"])\nfpaths.append([\"FIXEDSHUNT\",\"P1_4\"])\nfpaths.append([\"SWITCHEDSHUNT\",\"P1_4\"])\nfpaths.append([\"BRANCH\",\"P2_1\"])\nfor fpath in fpaths:\nfpath_csv = FPATH_RCSV + fpath[0] + \"\\\\\"\nfpath_con = FPATH_RCON + fpath[1] + \"\\\\\"\nfnames_csv = [os.path.basename(x) for x in glob(fpath_csv + \"*.csv\")]\nfor fname_csv in fnames_csv:\nfname_con = fpath_con + fname_csv.replace(\".csv\",\".con\")\ncsv_con(fpath_csv + fname_csv,fname_con,fpath[0])\n# Combine cases\nfpaths = glob(FPATH_RCSV + \"*\\\\\")\nfor fpath in fpaths:\nfnames_csv = [os.path.basename(x) for x in glob(fpath + \"*.csv\")]\nfnames_csv = [fpath + s for s in fnames_csv]\nfname_dest = FPATH_RCSV + fpath.replace(FPATH_RCSV,\"\").replace(\"\\\\\",\"\") + \".csv\"\ncsv_combine(fnames_csv, fname_dest)\n# Combine .con files\nfnames = set()\nfor fpath, dirs, files in os.walk(FPATH_RCON):\nfor fname in files:\nfnames.add(os.path.join(fpath.replace(FPATH_RCON,\"\"),fname))\nfnames = set(filter(re.compile(\".*\" + \"\\.con\").match,fnames))\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_P1.1\" + \".*\",\"P1_1\\\\\\\\\" + \".*\"],\"P1_1.con\",[],SS_CONSPLIT,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_P1.2\" + \".*\",\"P2_1\\\\\\\\\" + \".*\"],\"P1_2.con\",[],SS_CONSPLIT,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_P1.3\" + \".*\",\"P1_3\\\\\\\\\" + \".*\"],\"P1_3.con\",[],SS_CONSPLIT,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_P1.4\" + \".*\",\"P1_4\\\\\\\\\" + \".*\"],\"P1_4.con\",[],SS_CONSPLIT,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"P7\" + \".*\"],\"P7.con\",[],SS_CONSPLIT,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_P[2,4,5]\" + \".*\"],\"P2_P4_P5.con\",[],0,[])\ncon_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \".*\" + \"_EE\" + \".*\"],\"EE.con\",[],0,[])\n#con_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \"ERCOT3\" + \".*\"],\"ERCOT3.con\",[],SS_CONSPLIT,[])\n#con_scsfs(fnames,[\".*\" + \"\\\\\\\\\" + \"P3\" + \".*\"],\"P3.con\",[],SS_CONSPLIT,[])\nfnames = [os.path.basename(x) for x in glob(FPATH_RCON + \"*.con\")]\ncon_scsfs(fnames,[\"P1_[2-9]\" + \".*\" + \".con\"],\"P6.con\",[\"DB_ID_\"],SS_CONSPLIT,[\"EHV\",\"HV\"])\ncon_scsfs(fnames,[\"P7\" + \".*\" + \".con\"],\"P6_PGRR98.con\",[],SS_CONSPLIT,[\"EHV\",\"HV\"])\n#\ncon_scsfs(fnames,[\"P1_3\" + \".*\" + \".con\"],\"ERCOT3_EHV.con\",[\"DB_ID_\"],SS_CONSPLIT,[\"EHV\"])\ncon_scsfs(fnames,[\"P1_3\" + \".*\" + \".con\"],\"ERCOT3_HV.con\",[\"DB_ID_\"],SS_CONSPLIT,[\"HV\"])\n# Combine .csv dictionary files\nfnames = set()\nfor fpath, dirs, files in os.walk(FPATH_RCON):\nfor fname in files:\nfnames.add(os.path.join(fpath.replace(FPATH_RCON,\"\"),fname))\nfnames = set(filter(re.compile(\"P[1-2]_[1,3,4]\" + \"\\\\\\\\\" + \".*\" + \"\\.csv\").match,fnames))\nfnames = [FPATH_RCON + fname for fname in fnames]\ncsv_combine(fnames,FPATH_RCON + \"DICT_SINGLES_ONLY.csv\",True)\n# Create unified dictionary file\nfnames = [\"DICT_SINGLES_ONLY.csv\",\"DICT_SSWG_ONLY.csv\"]\nfnames = [FPATH_RCON + fname for fname in fnames]\ncsv_combine(fnames,FPATH_RCON + \"DICT_ALL.csv\",True)\n# Clean up the FPATH_RCSV folder\nfpaths = [\"AREA\",\"BRANCH\",\"BUS\",\"FACTSDEVICE\",\"FIXEDSHUNT\",\"GENERATOR\",\"LINES\",\"LINES_MIRROR\",\"LOAD\",\"MULTI-SECTIONLINE\",\"OWNER\",\"SWITCHEDSHUNT\",\"SYSTEMSWITCHINGDEVICE\",\"TRANSFORMER2\",\"TRANSFORMER3\",\"ZONE\"]\nfor fpath in fpaths:\nnuke(FPATH_RCSV + fpath + \"\\\\\",1)\n# Clean up the FPATH_RCON folder\nfpaths = [\"P1_1\",\"P1_3\",\"P1_4\",\"P2_1\"]\nfor fpath in fpaths:\nnuke(FPATH_RCON + fpath + \"\\\\\",1)\n# Heavy\nif True:\n# BUS\nfname_dest = FPATH_RCSV + \"HEAVY_BUS.csv\"\nmatch_and_add(FPATH_RCSV + \"BUS.csv\", [0,5], FPATH_RCSV + \"AREA.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,6], FPATH_RCSV + \"ZONE.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,7], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\n# LOAD\nfname_dest = FPATH_RCSV + \"HEAVY_LOAD.csv\"\nmatch_and_add(FPATH_RCSV + \"LOAD.csv\", [0,4], FPATH_RCSV + \"AREA.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,5], FPATH_RCSV + \"ZONE.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,12], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\n# GENERATOR\nfname_dest = FPATH_RCSV + \"HEAVY_GENERATOR.csv\"\nmatch_and_add(FPATH_RCSV + \"GENERATOR.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,8], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\n# FIXEDSHUNT\nfname_dest = FPATH_RCSV + \"HEAVY_FIXEDSHUNT.csv\"\nmatch_and_add(FPATH_RCSV + \"FIXEDSHUNT.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\n# SWITCHEDSHUNT\nfname_dest = FPATH_RCSV + \"HEAVY_SWITCHEDSHUNT.csv\"\nmatch_and_add(FPATH_RCSV + \"SWITCHEDSHUNT.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\n# BRANCH\nfname_dest = FPATH_RCSV + \"HEAVY_BRANCH.csv\"\nmatch_and_add(FPATH_RCSV + \"BRANCH.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,2], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,27], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,29], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,31], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)"
  },
  {
    "id": "chunk_086",
    "text": "match_and_add(fname_dest, [0,33], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\n# TRANSFORMER2\nfname_dest = FPATH_RCSV + \"HEAVY_TRANSFORMER2.csv\"\nmatch_and_add(FPATH_RCSV + \"TRANSFORMER2.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,2], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,13], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,15], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,17], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,19], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\n# TRANSFORMER3\nfname_dest = FPATH_RCSV + \"HEAVY_TRANSFORMER3.csv\"\nmatch_and_add(FPATH_RCSV + \"TRANSFORMER3.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,2], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,3], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,13], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,15], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,17], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,19], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\n# FACTSDEVICE\nfname_dest = FPATH_RCSV + \"HEAVY_FACTSDEVICE.csv\"\nmatch_and_add(FPATH_RCSV + \"FACTSDEVICE.csv\", [0,2], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,3], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,20], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,16], FPATH_RCSV + \"OWNER.csv\", [0,1], fname_dest)\n# SYSTEMSWITCHINGDEVICE\nfname_dest = FPATH_RCSV + \"HEAVY_SYSTEMSWITCHINGDEVICE.csv\"\nmatch_and_add(FPATH_RCSV + \"SYSTEMSWITCHINGDEVICE.csv\", [0,1], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\nmatch_and_add(fname_dest, [0,2], FPATH_RCSV + \"HEAVY_BUS.csv\", [0,1], fname_dest)\n# Helper function to nuke a folder\ndef nuke(fpath,delete_fpath=0):\nif os.path.isdir(fpath):\nfor root, dirs, files in os.walk(fpath, topdown=False):\nfor fname in files:\nos.remove(os.path.join(root,fname))\nfor sdir in dirs:\nos.rmdir(os.path.join(root,sdir))\nif delete_fpath == 1:\nos.rmdir(fpath)\n# Helper function to search, combine, slim, filter, and split .con files\ndef con_scsfs(fnames, rs, fname_dest, fs, n=100000, bes=[]):\nif n == 0:\nn = 100000\n# Workaround \"\\\\\" usage in re\nfnames = [fname.replace(\"\\\\\",\"/\") for fname in fnames]\n# Search\nfnames_con = set()\nfor r in rs:\n# Workaround \"\\\\\" usage in re\nfnames_con.update(set(filter(re.compile(r.replace(\"\\\\\\\\\",\"/\")).match,fnames)))\n# Workaround \"\\\\\" usage in re\nfnames_con = [fname_con.replace(\"/\",\"\\\\\") for fname_con in fnames_con]\n# Combine\nfnames_con = [FPATH_RCON + fname_con for fname_con in fnames_con]\nfnames_con.sort()\nfname_dest = FPATH_RCON + fname_dest\ncon_combine(fnames_con,fname_dest)\n# Slim\ncon_slim(fname_dest,FPATH_RCON + \"BUS_LIST.txt\",bes)\n# Filter\nfor f in fs:\ncon_filter(fname_dest,f)\n# Split\ncon_split(fname_dest,n)\n# Convert .csv file to .con file\ndef csv_con(fname_csv, fname_con, mode):\n# Set the mode\nif mode == \"GENERATOR\":\nid_slugs = [\"UNIT \",\"(\",\")\"]\nid_stops = [1,2]\ncmd_slugs = [\"REMOVE UNIT \",\" FROM BUS \",\"\"]\ncmd_stops = [2,1]\ndict_slugs = [\"\",\"\"]\ndict_stops = [1]\nstatus = 16\nnerc = \"P1.1\"\nelif mode == \"TRANSFORMER2\":\nid_slugs = [\"SINGLE \",\"-\",\"(\",\")\"]\nid_stops = [1,2,4]\ncmd_slugs = [\"OPEN BRANCH FROM BUS \",\" TO BUS \",\" CKT \",\"\"]\ncmd_stops = [1,2,4]\ndict_slugs = [\"\",\" - \",\"\"]\ndict_stops = [1,2]\nstatus = 12\nnerc = \"P1.3\"\nelif mode == \"TRANSFORMER3\":\nid_slugs = [\"SINGLE \",\"-\",\"-\",\"(\",\")\"]\nid_stops = [1,2,3,4]\ncmd_slugs = [\"OPEN BRANCH FROM BUS \",\" TO BUS \",\" TO BUS \",\" CKT \",\"\"]\ncmd_stops = [1,2,3,4]\ndict_slugs = [\"\",\" - \",\" - \",\"\"]\ndict_stops = [1,2,3]\nstatus = 12\nnerc = \"P1.3\"\nelif mode == \"FIXEDSHUNT\":\nid_slugs = [\"SHUNT \",\"(\",\")\"]\nid_stops = [1,2]\ncmd_slugs = [\"REMOVE SHUNT \",\" FROM BUS \",\"\"]\ncmd_stops = [2,1]\ndict_slugs = [\"\",\"\"]\ndict_stops = [1]\nstatus = 3\nnerc = \"P1.4\"\nelif mode == \"SWITCHEDSHUNT\":\nid_slugs = [\"SHUNT \",\"(\",\")\"]\nid_stops = [1,2]\ncmd_slugs = [\"REMOVE SWSHUNT \",\" FROM BUS \",\"\"]\ncmd_stops = [2,1]\ndict_slugs = [\"\",\"\"]\ndict_stops = [1]\nstatus = 5\nnerc = \"P1.4\"\nelif mode == \"BRANCH\":\nid_slugs = [\"SINGLE \",\"-\",\"(\",\")\"]\nid_stops = [1,2,3]\ncmd_slugs = [\"OPEN BRANCH FROM BUS \",\" TO BUS \",\" CKT \",\"\"]\ncmd_stops = [1,2,3]\ndict_slugs = [\"\",\" - \",\"\"]\ndict_stops = [1,2]\nstatus = 24\nnerc = \"P2.1\"\nelse:\nreturn\n# Read .csv file\nwith open(fname_csv,\"r\") as f:\nlines = f.readlines()\nlines.pop(0)\n# Dictionary\nd = build_dict(fname_csv.replace(mode,\"BUS\"),[1])\nfor key, value in d.items():\nd[key] = value.split(\",\")[2]\n# Write contingency file\nwith open(fname_con,\"w\") as g:\nwith open(fname_con.replace(\".con\",\".csv\"),\"w\") as h:\n# Dictionary header\nh.write(\"CONTINGENCY,TYPE,SUBMITTER,DESCRIPTION\\n\")\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\n# Contingency name\ncon_id = id_slugs[0]\nfor i, id_stop in enumerate(id_stops):\ncon_id = con_id + s[id_stop] + id_slugs[i+1]\n# Contingency action\ncon_cmd = cmd_slugs[0]\nfor i, cmd_stop in enumerate(cmd_stops):\ncon_cmd = con_cmd + s[cmd_stop] + cmd_slugs[i+1]\n# Check if the element is closed and write contingency\nif s[status] == \"1\":\ng.write(\"CONTINGENCY '\" + con_id + \"'\\n\")\ng.write(\"   \" + con_cmd + \"\\n\")\ng.write(\"END\\n\")\n# Dictionary\ncon_dict = dict_slugs[0]\nfor i, dict_stop in enumerate(dict_stops):\ncon_dict = con_dict + d[s[dict_stop]] + dict_slugs[i+1]\ncon_dict = con_dict + \" (\"\nfor i, cmd_stop in enumerate(cmd_stops):\ncon_dict = con_dict + s[cmd_stop] + \"-\"\ncon_dict = con_dict[:-1] + \")\"\n# Write dictionary\nh.write(con_id + \",\" + nerc + \",SINGLE,\" + con_dict + \"\\n\")\n# Terminate file\ng.write(\"END\")\n# Convert .raw file to .csv file\ndef csv_case(fname_raw):\nwith open(fname_raw,\"r\") as f:\nlines = f.readlines()\n# Strip file\nlines = [line_snip(line,\"'\",\",\") for line in lines] # Fix commas inside quotes\nlines = [line.replace(\"'\",\"\") for line in lines]\nlines = [line.replace(\" \",\"\") for line in lines]\nlines = [line for line in lines if line[0:2] != \"@!\"]\n# Case name\na = fname_raw.rfind(\"\\\\\") + 1\nb = fname_raw.rfind(\".\")\ncase_name = fname_raw[a:b]\n# Bug to help generate paths and names\nfname_bug = FPATH_RCSV + \"BUG\\\\\" + fname_raw.replace(FPATH_RAW,\"\").replace(\".raw\",\"_BUG.csv\")\n# Headers for each section of the .raw file\nsections = [\"AREA\",\"BRANCH\",\"BUS\",\"FACTSDEVICE\",\"FIXEDSHUNT\",\"GENERATOR\",\"LOAD\",\"MULTI-SECTIONLINE\",\"OWNER\",\"SWITCHEDSHUNT\",\"SYSTEMSWITCHINGDEVICE\",\"ZONE\"]\nheaders = [\"AREA,ISW,PDES,PTOL,NAME\\n\"]\nheaders.append(\"FR,TO,CKT,R,X,B,NAME,RATE_1,RATE_2,RATE_3,RATE_4,RATE_5,RATE_6,RATE_7,RATE_8,RATE_9,RATE_10,RATE_11,RATE_12,GI,BI,GJ,BJ,STATUS,MET,LEN,O1,F1,O2,F2,O3,F3,O4,F4\\n\")\nheaders.append(\"BUS,NAME,KV,IDE,AREA,ZONE,OWNER,VM,VA,NVHI,NVLO,EVHI,EVLO\\n\")\nheaders.append(\"NAME,FR,TO,MODE,PDES,QDES,VSET,SHMX,TRMX,VTMN,VTMX,VSMX,IMX,LINX,RMPCT,OWNER,SET1,SET2,VSREF,FCREG,NREG,MNAME\\n\")\nheaders.append(\"BUS,ID,STATUS,GL,BL\\n\")\nheaders.append(\"BUS,ID,PG,QG,QT,QB,VS,IREG,NREG,MBASE,ZR,ZX,RT,XT,GTAP,STATUS,RMPCT,PT,PB,BASLOD,O1,F1,O2,F2,O3,F3,O4,F4,WMOD,WPF\\n\")\nheaders.append(\"BUS,ID,STATUS,AREA,ZONE,PL,QL,IP,IQ,YP,YQ,OWNER,SCALE,INTRPT,DGENP,DGENQ,DGENF,TYPE\\n\")\nheaders.append(\"FR,TO,ID,MET,DUM1,DUM2,DUM3,DUM4,DUM5,DUM6,DUM7,DUM8,DUM9\\n\")\nheaders.append(\"OWNER,NAME\\n\")\nheaders.append(\"BUS,ID,MODSW,ADJM,STATUS,VSWHI,VSWLO,SWREM,NREG,RMPCT,RMIDNT,BINIT,S1,N1,B1,S2,N2,B2,S3,N3,B3,S4,N4,B4,S5,N5,B5,S6,N6,B6,S7,N7,B7,S8,N8,B8\\n\")\nheaders.append(\"FR,TO,CKT,X,RATE_1,RATE_2,RATE_3,RATE_4,RATE_5,RATE_6,RATE_7,RATE_8,RATE_9,RATE_10,RATE_11,RATE_12,STATUS,NSTATUS,MET,STYPE,NAME\\n\")\nheaders.append(\"ZONE,NAME\\n\")\n# Parse the .raw file\n# Formats for .raw files and .csv files are the same\nfor i, section in enumerate(sections):\nfname_csv = fname_bug.replace(\"BUG\",section)\ng = open(fname_csv,\"w\")\ng.write(\"CASE,\" + headers[i])\n# Each section begins and ends with a similar cardinal\nwlines = txt_trim(lines, \"BEGIN\" + section + \"DATA\", \"ENDOF\" + section + \"DATA\")\n# Append the case name to the start of each line\nwlines = [case_name + \",\" + wline for wline in wlines]\ng.writelines(wlines)\ng.close()\n# Two-winding transformers\nfname_csv = fname_bug.replace(\"BUG\",\"TRANSFORMER2\")\ng2 = open(fname_csv,\"w\")\ng2.write((\"CASE,FR,TO,TR,ID,CW,CZ,CM,MAG1,MAG2,METER,NAME,STATUS,O1,F1,O2,F2,O3,F3,O4,F4,VECGRP,R1_2,X1_2,SBASE1_2,\" +\n\"WINDV1,NOMV1,ANG1,RATE_1,RATE_2,RATE_3,RATE_4,RATE_5,RATE_6,RATE_7,RATE_8,RATE_9,RATE_10,RATE_11,RATE_12,COD1,CONT1,NOD1,RMA1,RMI1,VMA1,VMI1,NTP1,TAB1,CR1,CX1,CNX1,WINDV2,NOMV2\\n\"))\n# Three-winding transformers\nfname_csv = fname_bug.replace(\"BUG\",\"TRANSFORMER3\")\ng3 = open(fname_csv,\"w\")\ng3.write((\"CASE,FR,TO,TR,ID,CW,CZ,CM,MAG1,MAG2,METER,NAME,STATUS,O1,F1,O2,F2,O3,F3,O4,F4,VECGRP,ZCOD,\" +\n\"R1_2,X1_2,SBASE1_2,R2_3,X2_3,SBASE2_3,R3_1,X3_1,SBASE3_1,VMSTAR,ANSTAR,\" +\n\"WINDV1,NOMV1,ANG1,RATE1_1,RATE1_2,RATE1_3,RATE1_4,RATE1_5,RATE1_6,RATE1_7,RATE1_8,RATE1_9,RATE1_10,RATE1_11,RATE1_12,COD1,CONT1,NOD1,RMA1,RMI1,VMA1,VMI1,NTP1,TAB1,CR1,CX1,CNXA1,\" +\n\"WINDV2,NOMV2,ANG2,RATE2_1,RATE2_2,RATE2_3,RATE2_4,RATE2_5,RATE2_6,RATE2_7,RATE2_8,RATE2_9,RATE2_10,RATE2_11,RATE2_12,COD2,CONT2,NOD2,RMA2,RMI2,VMA2,VMI2,NTP2,TAB2,CR2,CX2,CNXA2,\" +\n\"WINDV3,NOMV3,ANG3,RATE3_1,RATE3_2,RATE3_3,RATE3_4,RATE3_5,RATE3_6,RATE3_7,RATE3_8,RATE3_9,RATE3_10,RATE3_11,RATE3_12,COD3,CONT3,NOD3,RMA3,RMI3,VMA3,VMI3,NTP3,TAB3,CR3,CX3,CNXA3\\n\"))\n# Parse the portion of the .raw file containing transformer data, which is split across multiple lines\ni = 0\nwlines = txt_trim(lines, \"BEGINTRANSFORMERDATA\", \"ENDOFTRANSFORMERDATA\")\nwlines = [wline.replace(\"\\n\",\"\") for wline in wlines]\nwhile i < len(wlines):\ns = wlines[i].split(\",\")\n# Two-winding transformers do not have a tertiary bus\nif s[2] == \"0\":\ng2.write(case_name + \",\" + wlines[i] + \",\" + wlines[i+1] + \",\" + wlines[i+2] + \",\" + wlines[i+3] + \"\\n\")"
  },
  {
    "id": "chunk_087",
    "text": "i = i + 4\n# Three-winding transformers have a tertiary bus\nelse:\ng3.write(case_name + \",\" + wlines[i] + \",\" + wlines[i+1] + \",\" + wlines[i+2] + \",\" + wlines[i+3] + \",\" + wlines[i+4] + \"\\n\")\ni = i + 5\ng2.close()\ng3.close()\n# Pad out certain sections\nsections = [\"BRANCH\",\"GENERATOR\",\"SWITCHEDSHUNT\"]\nfor section in sections:\nfname_csv = fname_bug.replace(\"BUG\",section)\nwith open(fname_csv,\"r\") as f:\nlines = f.readlines()\nwith open(fname_csv,\"w\") as g:\ng.write(lines.pop(0))\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\nif section == \"BRANCH\":\nif len(s) == 29: s = s + [\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]\nif len(s) == 31: s = s + [\"0\",\"1\",\"0\",\"1\"]\nif len(s) == 33: s = s + [\"0\",\"1\"]\nelif section == \"GENERATOR\":\nif len(s) == 23: s = s + [\"0\",\"1\",\"0\",\"1\",\"0\",\"1\",\"\",\"\"]\nif len(s) == 25: s = s + [\"0\",\"1\",\"0\",\"1\",\"\",\"\"]\nif len(s) == 27: s = s + [\"0\",\"1\",\"\",\"\"]\nif len(s) == 29: s = s + [\"\",\"\"]\nif len(s) == 30: s = s + [\"\"]\nelif section == \"SWITCHEDSHUNT\":\nif len(s) == 16: s = s + 21*[\"\"]\nif len(s) == 19: s = s + 18*[\"\"]\nif len(s) == 22: s = s + 15*[\"\"]\nif len(s) == 25: s = s + 12*[\"\"]\nif len(s) == 28: s = s + 9*[\"\"]\nif len(s) == 31: s = s + 6*[\"\"]\nif len(s) == 34: s = s + 3*[\"\"]\ng.write(\",\".join(s) + \"\\n\")\n# Bus Name dictionary\ndbusname = build_dict(fname_bug.replace(\"BUG\",\"BUS\"),[1])\nfor key, value in dbusname.items():\ndbusname[key] = value.split(\",\")[2]\n# Bus kV dictionary\ndbuskv = build_dict(fname_bug.replace(\"BUG\",\"BUS\"),[1])\nfor key, value in dbuskv.items():\ndbuskv[key] = value.split(\",\")[3]\n# Owner dictionary\ndowner = build_dict(fname_bug.replace(\"BUG\",\"OWNER\"),[1])\nfor key, value in downer.items():\ndowner[key] = value.split(\",\")[2]\n# Lines include branches, two-winding transformers, and three-winding transformers\nfname_csv = fname_bug.replace(\"BUG\",\"LINES\")\ng = open(fname_csv,\"w\")\n# Columns are hard-coded to each source csv file\ng.write(\"CASE,TYPE,FR,TO,CKT,NAME,RATE_1,RATE_2,RATE_3,RATE_4,RATE_5,RATE_6,RATE_7,RATE_8,RATE_9,RATE_10,RATE_11,RATE_12,STATUS,LEN,O1,F1,O2,F2,O3,F3,O4,F4,BRANCH,KV\\n\")\n# Branches\nwith open(fname_bug.replace(\"BUG\",\"BRANCH\"),\"r\") as f:\nlines = f.readlines()\nlines.pop(0)\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\n#\nm1 = dbusname.get(s[1]) + \" > \" + dbusname.get(s[2]) + \" (\" + s[1] + \"-\" + s[2] + \"-\" + s[3] + \")\"\nm2 = kvpretty(dbuskv.get(s[1]))\n#\nif len(s) == 29: s = s + [\"0\",\"1\",\"0\",\"1\",\"0\",\"1\"]\nif len(s) == 31: s = s + [\"0\",\"1\",\"0\",\"1\"]\nif len(s) == 33: s = s + [\"0\",\"1\"]\ns1 = [s[i] for i in [1,2,3,7,8,9,10,11,12,13,14,15,16,17,18,19,24,26,27,28,29,30,31,32,33,34]]\ng.write(s[0] + \",LINE,\" + \",\".join(s1) + \",\" + m1 + \",\" + m2 + \"\\n\")\n# Two-winding transformers\nwith open(fname_bug.replace(\"BUG\",\"TRANSFORMER2\"),\"r\") as f:\nlines = f.readlines()\nlines.pop(0)\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\n#\nm2a = kvpretty(dbuskv.get(s[1]))\nm2b = kvpretty(dbuskv.get(s[2]))\nif float(m2a) >= float(m2b):\nm1 = dbusname.get(s[1]) + \" > \" + dbusname.get(s[2]) + \" (\" + s[1] + \"-\" + s[2] + \"-\" + s[4] + \")\"\nm2 = m2a + \"/\" + m2b\nelse:\nm1 = dbusname.get(s[2]) + \" > \" + dbusname.get(s[1]) + \" (\" + s[2] + \"-\" + s[1] + \"-\" + s[4] + \")\"\nm2 = m2b + \"/\" + m2a\n#\ns1 = [s[i] for i in [1,2,4,11,28,29,30,31,32,33,34,35,36,37,38,39,12]]\ns2 = [s[i] for i in [13,14,15,16,17,18,19,20]]\ng.write(s[0] + \",XFMR2,\" + \",\".join(s1) + \",0,\" + \",\".join(s2) + \",\" + m1 + \",\" + m2 + \"\\n\")\n# Three-winding transformers\nwith open(fname_bug.replace(\"BUG\",\"TRANSFORMER3\"),\"r\") as f:\nlines = f.readlines()\nlines.pop(0)\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\n#\nm1 = [s[1],s[2],s[3]]\nm2 = [kvpretty(dbuskv.get(m)) for m in m1]\nm2float = [float(m) for m in m2]\nm1 = [dbusname.get(m) for _ , m in sorted(zip(m2float,m1))]\nm2 = [m for _ , m in sorted(zip(m2float,m2))]\n#\nm1 = m1[2] + \" > \" + m1[1] + \" (\" + s[1] + \"-\" + s[2] + \"-\" + s[3] + \"-\" + s[4]\nm2 = m2[2] + \"/\" + m2[1]\n#\nkv = [s[1],s[2],s[3]]\nkv = [kvpretty(dbuskv.get(m)) for m in kv]\n# Winding 1\ns1 = [s[i] for i in [4,11,37,38,39,40,41,42,43,44,45,46,47,48,12]]\ns2 = [s[i] for i in [13,14,15,16,17,18,19,20]]\ng.write(s[0] + \",XFMR3,\" + s[1] + \",3WNDTR \" + s[11] + \",\" + \",\".join(s1) + \",0,\" + \",\".join(s2) + \",\" + m1 + \"w1),\" + m2 + \"#\" + kv[0] + \"\\n\")\n# Winding 2\ns1 = [s[i] for i in [4,11,64,65,66,67,68,69,70,71,72,73,74,75,12]]\ns2 = [s[i] for i in [13,14,15,16,17,18,19,20]]\ng.write(s[0] + \",XFMR3,\" + s[2] + \",3WNDTR \" + s[11] + \",\" + \",\".join(s1) + \",0,\" + \",\".join(s2) + \",\" + m1 + \"w2),\" + m2 + \"#\" + kv[1] + \"\\n\")\n# Winding 3\ns1 = [s[i] for i in [4,11,91,92,93,94,95,96,97,98,99,100,101,102,12]]\ns2 = [s[i] for i in [13,14,15,16,17,18,19,20]]\ng.write(s[0] + \",XFMR3,\" + s[3] + \",3WNDTR \" + s[11] + \",\" + \",\".join(s1) + \",0,\" + \",\".join(s2) + \",\" + m1 + \"w3),\" + m2 + \"#\" + kv[2] + \"\\n\")\n## # Add owners\n## m3a = downer.get(s[27])\n## m3b = downer.get(s[29])\n## m3c = downer.get(s[31])\n## m3d = downer.get(s[33])\n## if r is None: r = d.get(k)\n# Housekeeping\ng.close()\n# Lines in forward and reverse direction\nfname_csv = fname_bug.replace(\"BUG\",\"LINES_MIRROR\")\ng = open(fname_csv,\"w\")\n# Branches\nwith open(fname_bug.replace(\"BUG\",\"LINES\"),\"r\") as f:\nlines = f.readlines()\n# Header\nline = lines.pop(0)\ns = line.replace(\"\\n\",\"\").split(\",\")\ns.insert(1,\"DIR\")\ng.write(\",\".join(s) + \"\\n\")\n# Body\nfor line in lines:\n# Forward\ns = line.replace(\"\\n\",\"\").split(\",\")\ns.insert(1,\"F\")\ng.write(\",\".join(s) + \"\\n\")\n# Reverse\ns = line.replace(\"\\n\",\"\").split(\",\")\n[s[2],s[3]] = [s[3],s[2]]\ns.insert(1,\"R\")\ng.write(\",\".join(s) + \"\\n\")\n# Housekeeping\ng.close()\n# Replace characters inside delimiters (e.g., commas inside string / quote marks)\ndef line_snip(line, delim_str, snip_str):\ndelim_str = delim_str[0]\nsnip_str = snip_str[0]\n# Index of \"'\" characters\nmn = [i for i, letter in enumerate(line) if letter == delim_str]\n# \"m\" is the start \"'\"\nm = mn[0::2]\n# \"n\" is the end \"'\"\nn = mn[1::2]\n# Catch unpaired \"'\"\nif len(m) > len(n):\nm = m[:-1]\n# List of tuples\nfor mn in list(zip(m,n)):\nline = line[:mn[0]] + line[mn[0]:mn[1]].replace(snip_str,\" \") + line[mn[1]:]\n# Return line\nreturn line\n# Parse list of strings using start (astr) and stop (bstr) flags (exclusive)\ndef txt_trim(lines, astr, bstr):\na = -1\nb = -1\nfor i, line in enumerate(lines):\n# Look for astr\nif a < 0 and astr in line:\na = i + 1\n# Look for bstr\nelif a >= 0 and bstr in line:"
  },
  {
    "id": "chunk_088",
    "text": "b = i\nbreak\n# Start and stop flag not found\nif a < 0 and b < 0:\nreturn [\"\"]\n# Stop flag not found\nelif a >= 0 and b < 0:\nreturn lines[a:]\n# Start and stop flag found\nelif a >= 0 and b >= 0:\nreturn lines[a:b]\n# Combine .csv files and export as a single .csv file\ndef csv_combine(fnames_csv, fname_dest, unique=False):\n# Destination file\ng = open(fname_dest,\"w\")\n# No files to open\nif len(fnames_csv) == 0:\ng.close()\nos.remove(fname_dest)\nreturn\n# Header\nwith open(fnames_csv[0],\"r\") as f:\ng.write(f.readline())\n# Contents\nfor fname_csv in fnames_csv:\nwith open(fname_csv,\"r\") as f:\nf.readline()\nfor line in f:\ng.write(line)\n# Housekeeping\ng.close()\n# Uniques\nif unique:\n# Read\nwith open(fname_dest,\"r\") as f:\nlines = f.readlines()\n# Write\nwith open(fname_dest,\"w\") as g:\ng.write(lines[0])\nlines = list(set(lines[1:]))\nlines.sort()\ng.writelines(lines)\n# Combine .con files and export as a single .con file with unique contingencies\ndef con_combine(fnames_con, fname_dest):\n# Dictionary with contingency definitions\nd = {}\ne = {}\n# Parse each .con file and populate dictionary\nfnames_con.sort()\nfor fname_con in fnames_con:\nfor kv in con_parse(fname_con):\n# Key is the contingency command\nkey = kv[1]\n# Value is the contingency name\nvalue = kv[0]\n# Add to dictionary\nif key not in d:\nd[key] = value\nelif d[key][0:6] == \"DB_ID_\":\nd[key] = value\n# Superset of all contingencies\nif kv[0] not in e:\ne[kv[0]] = kv[1]\n# Write output .con file\nwith open(fname_dest,\"w\") as g:\n# Header\nfor fname_con in fnames_con:\ng.write(\"/* \" + fname_con.replace(FPATH_RCON,\"\").replace(\"\\\\\",\"/\") + \"\\n\")\ng.write(\"\\n\")\n# Content\nlines = []\nfor key, value in d.items():\nlines.append(\"CONTINGENCY '\" + value + \"'\\n\" + key + \"END\\n\")\n# Uncomment next two lines to superset unique contingencies by ID\n# for key, value in e.items():\n#    lines.append(\"CONTINGENCY '\" + key + \"'\\n\" + value + \"END\\n\")\n# Write\nlines.sort()\ng.writelines(lines)\ng.write(\"END\")\n# Parse .con file into a string array\ndef con_parse(fname_con):\n# Read\nwith open(fname_con,\"r\") as f:\nlines = f.readlines()\n# Clean\nlines = [line.replace(\"\\n\",\"\") for line in lines]\nlines = [line.split(\"/*\")[0] for line in lines]\nlines = [line.strip() for line in lines]\nlines = [line for line in lines if line != \"\"]\n# Parse\nconlines = []\nconline = [\"\",\"\"]\nfor line in lines:\n# Look for contingency name\nif line[0:13] == \"CONTINGENCY '\":\nconline[0] = line.replace(\"CONTINGENCY \",\"\").replace(\"'\",\"\")\ncontinue\n# Look for contingency end\nif conline[0] != \"\" and line == \"END\":\nif conline[1] != \"\":\nconlines.append(conline)\nconline = [\"\",\"\"]\ncontinue\n# Look for contingency actions\nif conline[0] != \"\":\nconline[1] = conline[1] + \"   \" + line + \"\\n\"\n# Return\nreturn conlines\n# Slim .con file to only include buses in a certain file\ndef con_slim(fname_con, fname_bus, bes=[]):\n# Read bus list\nwith open(fname_bus,\"r\") as f:\nbus_list = set([int(bus) for bus in f.readlines()])\n# Read and parse\nconlines = con_parse(fname_con)\n# Bus kV dictionary\ndbuskvfull = build_dict(FPATH_RCSV + \"BUS.csv\",[0,1])\ndbuskvfull.pop(0)\ndbuskv = {}\nfor key, value in dbuskvfull.items():\ndbuskvfull[key] = value.split(\",\")[3]\nfor key, value in dbuskvfull.items():\nk = int(key.split(\",\")[1])\nv = float(value)\nif k not in dbuskv:\ndbuskv[k] = v\nelif v > dbuskv[k]:\ndbuskv[k] = v\n# Write\nwith open(fname_con,\"w\") as g:\nfor conline in conlines:\nif True in [int(s.replace(\"BUS \",\"\")) in bus_list for s in re.findall(\"BUS [0-9]+\",conline[1])]:\n# Include all contingencies with at least one BES element (i.e., bus number < 100000)\nif len(bes) > 0:\nkv = set()\nfor c in conline[1].split(\"\\n\")[:-1]:\nb = [int(s.replace(\"BUS \",\"\")) for s in re.findall(\"BUS [0-9]+\",c)]\nkv.add(kvclass(b, [dbuskv[i] if i in dbuskv else 0 for i in b]))\nif len(kv.intersection(set(bes))) > 0:\ng.write(\"CONTINGENCY '\" + conline[0] + \"'\\n\" + conline[1] + \"END\\n\")\n# Include all contingencies\nelse:\ng.write(\"CONTINGENCY '\" + conline[0] + \"'\\n\" + conline[1] + \"END\\n\")\ng.write(\"END\")\n# Filter .con file to exclude contingencies containing string\ndef con_filter(fname_con, filter_str):\n# Do not look for the null string\nif filter_str == \"\":\nreturn\n# Read and parse\nconlines = con_parse(fname_con)\n# Write\nwith open(fname_con,\"w\") as g:\nfor conline in conlines:\nif filter_str not in conline[0]:\ng.write(\"CONTINGENCY '\" + conline[0] + \"'\\n\" + conline[1] + \"END\\n\")\ng.write(\"END\")\n# Split .con file into smaller chunks\ndef con_split(fname_con, n):\n# Read and parse\nconlines = con_parse(fname_con)\n# Minimum 10 contingencies in each file\nn = max(n,10)\n# Do not split small files\nif len(conlines) <= 2*n:\nreturn\n# Counter\nk = 1\nwhile len(conlines) > 0:\n# Chunk\nif len(conlines) > 1.5*n:\nlines = conlines[0:n]\ndel conlines[0:n]\nelse:\nlines = conlines[0:]\ndel conlines[0:]\n# Write chunk\nwith open(fname_con.replace(\".con\",\"__\" + format(k,\"04\") + \".con\"),\"w\") as g:\nfor line in lines:\ng.write(\"CONTINGENCY '\" + line[0] + \"'\\n\" + line[1] + \"END\\n\")\ng.write(\"END\")\n# Increment counter\nk = k + 1\n# Delete original file\nos.remove(fname_con)\n# Pretty print a voltage string\ndef kvpretty(kv):\nkv = kv.rstrip(\"0\")\nif kv[-1] == \".\":\nreturn kv[:-1]\nelse:\nreturn kv\n# Determine the voltage class of a branch based on the bus numbers\ndef kvclass(b, kv):\nif len(b) != len(kv):\nreturn \"\"\n# Check for generator bus\nif any([i >= 100000 and i < 200000 for i in b]):\nreturn \"GEN\"\n# Check for SODG bus\nif any([i >= 700000 and i < 800000 for i in b]):\nreturn \"SODG\"\n#\nif len(kv) == 1:\nif kv[0] >= 300:\nreturn \"EHV\"\nelif kv[0] >= 60:\nreturn \"HV\"\nelse:\nreturn \"LV\"\n#\nelif len(kv) == 2:\nif max(kv) >= 300 and min(kv) >= 60:\nreturn \"EHV\"\nelif min(kv) >= 60:\nreturn \"HV\"\nelse:\nreturn \"LV\"\n#\nelif len(kv) == 3:\nif sorted(kv)[2] >= 300 and sorted(kv)[1] >= 100:\nreturn \"EHV\"\nelif sorted(kv)[2] >= 60 and sorted(kv)[1] >= 60:\nreturn \"HV\"\nelse:\nreturn \"LV\"\n#\nelse:\nreturn \"\"\n##### Run study and create .txt reports\n# (1) Get list of .sav files in FPATH_SAV folder\n# (2) Get list of .con files in FPATH_CON folder\n# (3) Match .sav and .con files according to contingency types\n# (4) Append each match to a list of \"ContingencyCalculation\" objects\n# (5) Create .acc file in FPATH_ACC folder for each \"ContingencyCalculation\" object in the list\n# (6) Create .txt report in FPATH_TXT folder for each \"ContingencyCalculation\" object in the list"
  },
  {
    "id": "chunk_089",
    "text": "# (7) Create .csv report in FPATH_CSV folder for each \"ContingencyCalculation\" object in the list\ndef m_study():\nfnames_sav = [os.path.basename(x) for x in glob(FPATH_SAV + \"*.sav\")]\n# fnames_con = [os.path.basename(x) for x in glob(FPATH_CON + \"*.con\")]\nfname_sub = \"PSSE\\\\SUBSYSTEM.sub\"\nfname_mon = \"PSSE\\\\MONITOR.mon\"\n# Set of all .con files in folder and subfolders\nfnames = set()\nfor fpath, dirs, files in os.walk(FPATH_CON):\nfor fname in files:\nfnames.add(os.path.join(fpath.replace(FPATH_CON,\"\"),fname))\nfnames_con = set(filter(re.compile(\".*\" + \"\\.con\").match,fnames))\n# Define combinations of .sav and .con files for N-1 and N-2 contingency calculations\n# Sets are used to prevent the inclusion of duplicates\nacc_set = set()\nfor fname_sav in fnames_sav:\n# Slug is the text before the third underscore\n# [0:5] is the 6-character build, like \"20SSWG\" or \"20TSIP\"\n# [6] is \"_\"\n# [7:10] is the 4-digit year\n# [11] is \"_\"\n# [12:14] or [12:15] is the 3- or 4-character season, like \"MIN\" or \"HWLL\" or \"SUM1\"\nslug = fname_sav\na = 0\nb = slug.find(\"_\",12)\nif b > 0 and a <= b:\nslug = slug[a:b]\n# Slugs for \"SUM1\" and \"SUM2\" match contingency files for \"SUM1\" only\nif slug[-1].isdigit():\nslug = slug[:-1] + \"1\"\n# Define contingencies by searching contingency filenames using regular expressions\ns = set()\n# N-1\nif P1 == 1:\nr1 = re.compile(slug + \".*\" + \"_P1\" + \".*\")\nr2 = re.compile(\"P1\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\nif P2_1 == 1:\nr1 = re.compile(\"P2_1\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\nif P2 == 1:\nr1 = re.compile(slug + \".*\" + \"_P2\" + \".*\")\nr2 = re.compile(\"P2\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\nif P4 == 1:\nr1 = re.compile(slug + \".*\" + \"_P4\" + \".*\")\nr2 = re.compile(\"P4\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\nif P5 == 1:\nr1 = re.compile(slug + \".*\" + \"_P5\" + \".*\")\nr2 = re.compile(\"P5\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\nif P7 == 1:\nr1 = re.compile(slug + \".*\" + \"_P7\" + \".*\")\nr2 = re.compile(\"P7\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\nif EE == 1:\nr1 = re.compile(slug + \".*\" + \"_EE\" + \".*\")\nr2 = re.compile(\"EE\" + \".*\")\ns.update(set(filter(r1.match,fnames_con)))\ns.update(set(filter(r2.match,fnames_con)))\n# Add N-0 and N-1 contingencies to list\nfor fname_con in s:\nacc_set.add(fname_sav + \">\" + fname_con + \">\" + \"\")\n# N-2\ns1 = []\ns2 = []\nif P3 == 1:\nt1_set = set()\nt2_set = set()\n# Contingency 1\nr1 = re.compile(slug + \".*\" + \"_P1\" + \".*\")\nr2 = re.compile(\"P1\" + \".*\")\nr3 = re.compile(slug + \".*\" + \"_P7\" + \".*\")\nr4 = re.compile(\"P7\" + \".*\")\nt1_set.update(set(filter(r1.match,fnames_con)))\nt1_set.update(set(filter(r2.match,fnames_con)))\nt1_set.update(set(filter(r3.match,fnames_con)))\nt1_set.update(set(filter(r4.match,fnames_con)))\n# Contingency 2\nr1 = re.compile(\"P3\" + \".*\")\nt2_set.update(set(filter(r1.match,fnames_con)))\n# Add N-2 contingencies to list\nfor t1 in t1_set:\nfor t2 in t2_set:\ns1 = s1 + [t1]\ns2 = s2 + [t2]\nif P6 == 1:\n# Contingency 1\nr1 = re.compile(\"P6\" + \".*\")\nt1_list = list(filter(r1.match,fnames_con))\n# Contingency 2\nt2_list = t1_list\n# Add N-2 contingencies to list\nfor i, t1 in enumerate(t1_list):\nfor j, t2 in enumerate(t2_list):\nif j >= i:\ns1 = s1 + [t1]\ns2 = s2 + [t2]\nif ERCOT3 == 1:\nt1_set = set()\nt2_set = set()\n# Contingency 1\nr1 = re.compile(slug + \".*\" + \"_P1\" + \".*\")\nr2 = re.compile(\"P1\" + \".*\")\nr3 = re.compile(slug + \".*\" + \"_P7\" + \".*\")\nr4 = re.compile(\"P7\" + \".*\")\nt1_set.update(set(filter(r1.match,fnames_con)))\nt1_set.update(set(filter(r2.match,fnames_con)))\nt1_set.update(set(filter(r3.match,fnames_con)))\nt1_set.update(set(filter(r4.match,fnames_con)))\n# Contingency 2\nr1 = re.compile(\".*\" + \"ERCOT3\" + \".*\")\nt2_set.update(set(filter(r1.match,fnames_con)))\n# Add N-2 contingencies to list\nfor t1 in t1_set:\nfor t2 in t2_set:\ns1 = s1 + [t1]\ns2 = s2 + [t2]\n# This section is a placeholder for custom contingency definitions\nif SPECIAL == 1:\nt1_set = set()\nt2_set = set()\n# Contingency 1\nr1 = re.compile(slug + \".*\" + \"_P1\" + \".*\")\nr2 = re.compile(\"P1\" + \".*\")\nt1_set.update(set(filter(r1.match,fnames_con)))\nt1_set.update(set(filter(r2.match,fnames_con)))\n# Contingency 2\nr1 = re.compile(\"ECODEV\" + \"*.*\")\nr2 = re.compile(slug + \".*\" + \"_P7\" + \".*\")\nt2_set.update(set(filter(r1.match,fnames_con)))\nt2_set.update(set(filter(r2.match,fnames_con)))\n# Add N-2 contingencies to list\nfor t1 in t1_set:\nfor t2 in t2_set:\ns1 = s1 + [t1]\ns2 = s2 + [t2]\n# Add N-1 contingencies to list\nfor fname_con1 in set(s1):\nacc_set.add(fname_sav + \">\" + fname_con1 + \">\" + \"\")\nfor fname_con2 in set(s2):\nacc_set.add(fname_sav + \">\" + fname_con2 + \">\" + \"\")\n# Add N-2 contingencies to list\nfor i, fname_con1 in enumerate(s1):\nfname_con2 = s2[i]\nacc_set.add(fname_sav + \">\" + fname_con1 + \">\" + fname_con2)\n# Define ContingencyCalculation list\nacc_list = []\n# Slug to make each script run unique\ntime_slug = time.strftime(\"%Y_%b_%d_%H%M\").upper()\nfor line in acc_set:\ns = line.split(\">\")\nfname_sav = s[0]\nfname_con1 = s[1]\nfname_con2 = s[2]\nfname_acc = fname_sav.replace(\".sav\", \"__\" + time_slug + \"_\" + format(len(acc_list) + 1, \"06\") + \".acc\")\nacc = ContingencyCalculation(fname_sav, fname_con1, fname_con2, fname_acc)\nacc_list.append(acc)\n# Hard code (if necessary)\n# acc_list = []\n# acc_list.append(ContingencyCalculation(\"SAV\",\"CON1\",\"CON2\",\"ACC\"))\n# Log which contingencies will be run\nlines = []\nfor acc in acc_list:\nlines.append(acc.fname_sav + \",\" + acc.fname_con1 + \",\" + acc.fname_con2 + \",\" + acc.fname_acc + \"\\n\")\nwith open(\"FastStudy_\" + time_slug + \".csv\",\"w\") as g:\ng.write(\"SAV,CON1,CON2,ACC\\n\")\nlines.sort()\ng.writelines(lines)\n# Run contingency analysis\np = multiprocessing.Pool(SS_CPU)\np.map(functools.partial(par_run_accc,fname_sub=fname_sub,fname_mon=fname_mon),iterable=acc_list)\np.close()\n# ContingencyCalculation encapsulates an AC Contingency Calculation in a single object\nclass ContingencyCalculation:\n# Initialize ACCC object, which requires 1 .sav file and 1 or 2 .con files and 1 .acc output file\ndef __init__(self, fname_sav, fname_con1, fname_con2, fname_acc):\nself.fname_sav = FPATH_SAV + fname_sav\nself.fname_con1 = \"\"\nself.fname_con2 = \"\"\nif fname_con1 != \"\": self.fname_con1 = FPATH_CON + fname_con1\nif fname_con2 != \"\": self.fname_con2 = FPATH_CON + fname_con2\nself.fname_acc = FPATH_ACC + fname_acc\nself.fname_pdev = FPATH_PDEV + fname_acc.replace(\".acc\",\".pdev\")\nself.fname_dfx = FPATH_DFX + fname_acc.replace(\".acc\",\".dfx\")\nself.fname_report = FPATH_TXT + fname_acc.replace(\".acc\",\".txt\")\n# Create .acc file\ndef run_accc(self, fname_sub, fname_mon):\n# Open .sav file\npsspy.case(self.fname_sav)\n# Progress output file\npsspy.lines_per_page_one_device(1,60)\npsspy.progress_output(2,self.fname_pdev,[0,0])\n# Construct a .dfx file (Distribution Factor Data File)\npsspy.dfax_2([1,1,0],fname_sub,fname_mon,self.fname_con1,self.fname_dfx)\n# Solution engine is Full NR (0 - Fixed-slope decoupled NR ; 1 - Full NR)\n# Post-contingency adjust DC taps is enabled (0 - Do not adjust ; 1 - Adjust)\n# Contingency calculation for N-1\nif self.fname_con2 == \"\":\npsspy.accc_with_dsp_3(SS_TOL,[SS_TAP,0,SS_PST,1,SS_SHUNT,1,0,0,0,0,0],\"\",self.fname_dfx,self.fname_acc,\"\",\"\",\"\")\n# Contingency calculation for N-2\nelse:\n#     n11_accc_2([SS_TAP,0,SS_PST,1,SS_SHUNT,0,1,0,SS_TAP,0,SS_PST,1,SS_SHUNT,0,0,0,1,1,1,1],[SS_TOL,100],\"\",self.fname_dfx,self.fname_acc,self.fname_con2,\"\",\"\")\npsspy.n11_accc_3([SS_TAP,0,SS_PST,1,SS_SHUNT,0,1,0,SS_TAP,0,SS_PST,1,SS_SHUNT,0,0,0        ],[SS_TOL    ],\"\",self.fname_dfx,self.fname_acc,self.fname_con2,\"\",\"\")\n# Create .txt report file"
  },
  {
    "id": "chunk_090",
    "text": "def run_report(self):\npsspy.lines_per_page_one_device(1,60)\npsspy.report_output(2,self.fname_report,[0,0])\n# Pre-contingency thermal rating is Rate A (1 - Rate A ; 2 - Rate B ; 3 - Rate C)\n# Pre-contingency voltage limit is normal limit (1 - Normal limit ; 2 - Emergency limit)\n# Post-contingency voltage limit is normal limit (1 - Normal limit ; 2 - Emergency limit)\n# Voltage check is enabled (0 - Do not check ; 1 - Check)\n#     accc_single_run_report_4([0,1,SS_RATE,    1,1,0,1,SS_EXCLUDE,SS_EXCLUDE,0,0,1],[0,0,0,0,6000],[0.5,5.0,SS_LOADING,0.1,0.0,0.0,99999.],self.fname_acc)\n# 0.5 = Bus mismatch converged tolerance (MW or Mvar)\n# 5.0 = System mismatch converged tolerance (MVA)\n# SS_LOADING = Percent of flow rating used in overload report (%)\n# 0.1 = Minimum contingency case flow change from base case value (MVA)\n# 0.0 = Minimum contingency case flow change from base case value (%)\n# 0.001 = Minimum contingency case voltage change from base case value (pu)\n# 99999 = Cutoff threshold for available capacity table (MVA)\npsspy.accc_single_run_report_5([0,1,SS_RATE,1,1,1,1,0,1,SS_EXCLUDE,SS_EXCLUDE,0,0,1],[0,0,0,0,6000],[0.5,5.0,SS_LOADING,0.1,0.0,0.001,99999],self.fname_acc)\npsspy.close_report()\n# Create .csv capacity report file\ndef run_capacity(self):\ncapacity_report(self.fname_acc,1)\ndef nuke(self):\ntry:\nos.remove(self.fname_acc)\nos.remove(self.fname_dfx)\nexcept:\npass\n# Run contingency calculations and output report files in parallel\ndef par_run_accc(acc, fname_sub, fname_mon):\nacc.run_accc(fname_sub, fname_mon)\nacc.run_report()\n# Special for the screening study\n#acc.run_capacity()\n#acc.nuke()\n#####  Create .csv reports\n# (1) Get list of .txt report files in FPATH_TXT folder\n# (2) Convert each .txt report file to a set of .csv report files in FPATH_CSV subfolders\ndef m_reports():\nfnames_txt = [os.path.basename(x) for x in glob(FPATH_TXT + \"*.txt\")]\nfor fname_txt in fnames_txt:\ncsv_report(FPATH_TXT + fname_txt)\n# Convert a single .txt report files to a set of .csv report files in FPATH_CSV subfolders\ndef csv_report(fname_txt):\n# Source file\nf = open(fname_txt,\"r\")\n# Case name\na = fname_txt.rfind(\"\\\\\") + 1\nb = fname_txt.rfind(\"__\")\ncase_name = fname_txt[a:b]\n# Read file line-by-line\nflag = 0\nfor line in f:\n# End of section\nif flag > 0 and line in [\"\\n\", \"\\r\\n\"]:\nflag = 0\ng.close()\n# Start of section\nif flag == 0:\nif \"-- MONITORED BRANCH --\" in line:\nflag = 1\nreport = \"THERMAL\"\nheader = \"CASE,FR,DIR_F,FR_NAME,FR_KV,TO,DIR_R,TO_NAME,TO_KV,ID,CONTINGENCY_1,CONTINGENCY_2,RATING,MW,MVAR,MVA,PERCENT\"\nif \"MONITORED VOLTAGE REPORT:\" in line:\nflag = 2\nreport = \"VOLTAGE\"\nheader = \"CASE,SYSTEM,TYPE,CONTINGENCY_1,CONTINGENCY_2,BUS,BUS_NAME,BUS_KV,V_CONT,V_INIT,V_MAX,V_MIN\"\nif \"LOSS OF LOAD REPORT:\" in line:\nflag = 3\nreport = \"LOAD\"\nheader = \"CASE,BUS,BUS_NAME,BUS_KV,CONTINGENCY_1,CONTINGENCY_2,LOAD_MW\"\nif \"-- POST-CONTINGENCY SOLUTION --\" in line:\nflag = 4\nreport = \"CONVERGENCE\"\nheader = \"CASE,CONTINGENCY_1,CONTINGENCY_2,TERMINATION_STATE,FLOW,SWD,VOLT,LOAD\"\nif \"CONTINGENCY LEGEND:\" in line:\nflag = 5\nreport = \"CONTINGENCY\"\nheader = \"CASE,CONTINGENCY,ACTION\"\nif flag > 0:\nfname_csv = fname_txt.replace(FPATH_TXT,FPATH_CSV + \"\\\\\" + report + \"\\\\\")\nfname_csv = fname_csv.replace(\".txt\",\".csv\")\ng = open(fname_csv,\"w\")\ng.write(header + \"\\n\")\n# Parse\nif flag > 0:\n# \"BASE CASE\" contingency is \"\"\nline = line.replace(\"BASE CASE\",\"         \")\n# Replace any stray commas\nline = line.replace(\",\",\" \")\n# Thermal N-1\nif flag == 1 and len(line) == 140:\nif line[30:36] == \"3WNDTR\":\nwline = case_name + \",\" + csv_split(line,[6,5,12,6,24,0,0,6,3,33,0,9,9,9,9,8])\nelse:\nwline = case_name + \",\" + csv_split(line,[6,5,12,6,7,5,12,6,3,33,0,9,9,9,9,8])\n# Thermal N-2\nelif flag == 1 and len(line) == 173:\nif line[30:36] == \"3WNDTR\":\nwline = case_name + \",\" + csv_split(line,[6,5,12,6,24,0,0,6,3,33,33,9,9,9,9,8])\nelse:\nwline = case_name + \",\" + csv_split(line,[6,5,12,6,7,5,12,6,3,33,33,9,9,9,9,8])\n# Voltage N-1\nelif flag == 2 and len(line) == 144:\nwline = case_name + \",\" + csv_split(line,[33,12,33,0,10,13,6,9,9,9,9])\nwline = wline.replace(\"'\",\"\")\nwline = wline.replace(\"RANGE\",\"R\")\nwline = wline.replace(\"DEVIATION\",\"D\")\n# Voltage N-2\nelif flag == 2 and len(line) == 156:\nwline = case_name + \",\" + csv_split(line,[20,4,33,33,10,13,6,9,9,9,9])\nwline = wline.replace(\"'\",\"\")\nwline = wline.replace(\"RANGE\",\"R\")\nwline = wline.replace(\"DEVIATION\",\"D\")\n# Load N-1\nelif flag == 3 and len(line) == 72:\nwline = case_name + \",\" + csv_split(line,[10,13,7,33,0,8])\n# Load N-2\nelif flag == 3 and len(line) == 105:\nwline = case_name + \",\" + csv_split(line,[10,13,7,33,33,8])\n# Convergence N-1\nelif flag == 4 and len(line) == 77:\nwline = case_name + \",\" + csv_split(line,[32,0,20,6,6,6,6])\nwline = wline.replace(\"--\",\"9999\")\n# Convergence N-2\nelif flag == 4 and len(line) == 110:\nwline = case_name + \",\" + csv_split(line,[33,32,20,6,6,6,6])\nwline = wline.replace(\"--\",\"9999\")\n# Contingency\nelif flag == 5 and len(line) > 34:\nwline = case_name + \",\" + csv_split(line.replace(\":\",\" \"),[33,10000])\n# Clean up bus notation\nb = wline.find(\"]\")\nwhile b > -1:\na = max(b-6,0)\nwline = wline[0:a] + wline[b:]\nb = wline.find(\"]\",a+1)\nwline = wline.replace(\"BUS\",\"\")\n# Clean up extra spaces\nwhile wline.find(\"  \") > -1:\nwline = wline.replace(\"  \",\" \")\nwline = wline.replace(\" ]\",\"]\")\nelse:\nwline = \"\"\n# Headers contain carrots\nif \"<\" not in wline and \">\" not in wline and wline != \"\":\ng.write(wline + \"\\n\")\n# Housekeeping\nf.close()\nif flag > 0: g.close()\n# Insert commas at specified stops in a string\ndef csv_split(rline,stops):\ns = stops\na = 0\nfor i, stop in enumerate(stops):\nb = a + max(0,stop)\ns[i] = rline[a:b].strip().replace(\",\",\"\")\na = min(b,len(rline))\nreturn \",\".join(s)\n##### Create .csv capacity reports\n# (1) Get list of .acc files in FPATH_ACC folder\n# (2) Create a .csv capacity & delta report file in the FPATH_CSV folder from each .acc file\ndef m_capacity(delta=0):\nfnames_acc = [FPATH_ACC + os.path.basename(x) for x in glob(FPATH_ACC + \"*.acc\")]\np = multiprocessing.Pool(SS_CPU)\np.map(functools.partial(capacity_report,delta=delta),iterable=fnames_acc)\np.close()\n# for fname_acc in fnames_acc: capacity_report(fname_acc,delta)\n# Create .csv capacity report file\ndef capacity_report(fname_acc,delta=0):\n# Hack\nfname_capacity = FPATH_CSV + \"CAPACITY\" + \"\\\\\" + fname_acc.replace(FPATH_ACC,\"\").replace(\".acc\",\".csv\")\nfname_delta = FPATH_CSV + \"DELTA\" + \"\\\\\" + fname_acc.replace(FPATH_ACC,\"\").replace(\".acc\",\".csv\")\n# Case name\na = fname_acc.rfind(\"\\\\\") + 1\nb = fname_acc.rfind(\"__\")\ncase_name = fname_acc[a:b]\n# Element and rating lists\nmelements = pssarrays.accc_summary(fname_acc).melement\nfor i, melement in enumerate(melements):\nif melement[30:36] == \"3WNDTR\":\nmelements[i] = case_name + \",\" + csv_split(melement.replace(\",\",\" \"),[11,12,6,24,0,6,3])\nelse:\nmelements[i] = case_name + \",\" + csv_split(melement.replace(\",\",\" \"),[11,12,6,12,12,6,3])\n# Ratings\nratea = pssarrays.accc_summary(fname_acc).rating.a\nrateb = pssarrays.accc_summary(fname_acc).rating.b\nratec = pssarrays.accc_summary(fname_acc).rating.c\nrates = [\"{:.1f},{:.1f},{:.1f}\".format(ratea[i],rateb[i],ratec[i]) for i, rate in enumerate(ratea)]\n# Contingency labels\ncolabels = list(pssarrays.accc_summary(fname_acc).colabel)\ns1 = [\"BASE CASE\" for s in colabels if s == \"BASE CASE\"]\ns2 = [s for s in colabels if s != \"BASE CASE\" and \":\" not in s]\ns3 = [s for s in colabels if \":\" in s]\ncolabels = s1 + s2 + s3\n# Generate report\nwith open(fname_capacity,\"w\") as g:\nwith open(fname_delta,\"w\") as h:\n# Write header\nif delta >= 0: g.write(\"CASE,FR,FR_NAME,FR_KV,TO,TO_NAME,TO_KV,ID,CONTINGENCY_1,CONTINGENCY_2,FLOW,RATE_1,RATE_2,RATE_3,CONV_STATUS\\n\")\nif delta <= 0: h.write(\"CASE,FR,FR_NAME,FR_KV,TO,TO_NAME,TO_KV,ID,CONTINGENCY_1,CONTINGENCY_2,FLOW,RATE_2,RATE_2,RATE_3,CONV_STATUS\\n\")\n# Dictionary"
  },
  {
    "id": "chunk_091",
    "text": "d = {}\nfor colabel in colabels:\n# Split contingency label\nif colabel == \"BASE CASE\":\nc = [\"\",\"\"]\nelif \":\" not in colabel:\nc = [colabel,\"\"]\nelse:\nc = colabel.split(\":\")\n# Check convergence status\nif not hasattr(pssarrays.accc_solution(fname_acc,colabel),\"cnvflag\"):\ncontinue\ncnvcond = pssarrays.accc_solution(fname_acc,colabel).cnvcond\nif not pssarrays.accc_solution(fname_acc,colabel).cnvflag and not cnvcond == \"Iteration limit exceeded\":\n# Pull line loadings in iterated solutions\nfor i, melement in enumerate(melements):\n# \"Singular Jacobian or 0.0 voltage\"\n# \"Blown up\"\nif delta >= 0: g.write(melement + \",\" + c[0] + \",\" + c[1] + \",-9999,\" + rates[i] + \",\" + cnvcond + \"\\n\")\nif delta <= 0: h.write(melement + \",\" + c[0] + \",\" + c[1] + \",-9999,\" + rates[i] + \",\" + cnvcond + \"\\n\")\ncontinue\n# Monitored element flows\nmvaflows = pssarrays.accc_solution(fname_acc,colabel).mvaflow\nmvaflows = [abs(mvaflow) for mvaflow in mvaflows]\n# Add monitored element flows to dictionary\nfor i, mvaflow in enumerate(mvaflows):\nkeys = []\nkeys = keys + [melements[i] + \",\"]\nkeys = keys + [melements[i] + \",\" + c[0]]\nkeys = keys + [melements[i] + \",\" + c[1]]\n# Flags set to False mean an equivalent contingency violation already exists\nflags = [True for key in keys]\n# Do not add key-value pair if existing value is within 2 percent or 0.5 MVA\nfor j, key in enumerate(keys):\nif key in d and all(flags):\nif mvaflow < (d[key] + 0.02*ratea[i]) or mvaflow < (d[key] + 0.5):\nflags[j] = False\n# Write element and flow to the capacity report\nif all(flags):\nif delta >= 0: g.write(melements[i] + \",\" + c[0] + \",\" + c[1] + \",\" + \"{:.2f}\".format(mvaflow) + \",\" + rates[i] + \",\" + cnvcond + \"\\n\")\n# Add N-0 or N-1 to dictionary\nif c[1] == \"\":\nd[melements[i] + \",\" + c[0]] = mvaflow\n# Write element and flow to the delta report\nif delta <= 0: h.write(melements[i] + \",\" + c[0] + \",\" + c[1] + \",\" + \"{:.2f}\".format(mvaflow) + \",\" + rates[i] + \",\" + cnvcond + \"\\n\")\n# Housekeeping\nif delta < 0: os.remove(fname_capacity)\nif delta > 0: os.remove(fname_delta)\n##### Create .csv delta reports\n# (0) Run m_capacity() with delta <= 0 before running this function to populate the DELTA folder\n# (1) Create a .csv capacity report file in the DELTA folder for each branch\n# (2) For each .csv branch capacity report file, pack with corresponding N-0 and N-1 loadings, as applicable, for each loading\n# (3) For each .csv branch capacity report file, slim the overloads report\ndef m_delta():\n# Create a .csv capacity report file in the FPATH_DELTA folder from each .acc file, using the m_capacity() function\nfnames_csv = [FPATH_CSV + \"DELTA\" + \"\\\\\" + os.path.basename(x) for x in glob(FPATH_CSV + \"DELTA\" + \"\\\\\" + \"*.csv\")]\n#\nfnames_acc = [FPATH_ACC + os.path.basename(x) for x in glob(FPATH_ACC + \"*.acc\")]\nfnames_csv = [FPATH_CSV + \"DELTA\" + \"\\\\\" + fname_acc.replace(FPATH_ACC,\"\").replace(\".acc\",\".csv\") for fname_acc in fnames_acc]\n# Get list of branch names\nd = {}\n# Create a .csv capacity report file in the FPATH_DELTA folder for each branch\nfor i, fname_csv in enumerate(fnames_csv):\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : \" + '{:5d}'.format(i+1) + \" / \" + str(len(fnames_csv)) + \" : \" + fname_csv.replace(FPATH_CSV + \"DELTA\" + \"\\\\\",\"\"))\nwith open(fname_csv,\"r\") as f:\nheader = f.readline() # Skip header\nfor line in f:\ns = line.split(\",\")\n# Key is the branch name\n# !! This feature will break if branch names are not unique\n# Value is the file pointer\nkey = \",\".join([s[c] for c in [1,2,4,5,7]])\n# File does not exist\nif key not in d:\n# print(\"+ \" + key)\nfname_dest = FPATH_CSV + \"DELTA\" + \"\\\\\" + key.replace(\",\",\"#\").replace(\" \",\"\") + \".csv\"\nd[key] = open(fname_dest,\"w\")\nd[key].write(header)\nd[key].write(line)\n# Housekeeping\nfor key, value in d.items():\nd[key].close()\n# Delete the old files\nfor fname_csv in fnames_csv:\nos.remove(fname_csv)\n# os.remove(FPATH_CSV + \"DELTA\" + \"\\\\\" + \"10076#CATCLAW1_5#10077#CATCLAW2_5#BT.csv\")\n# os.remove(FPATH_CSV + \"DELTA\" + \"\\\\\" + \"10076#CATCLAW2_5#10077#CATCLAW1_5#BT.csv\")\n# Process the new files\nfnames_csv = [FPATH_CSV + \"DELTA\" + \"\\\\\" + os.path.basename(x) for x in glob(FPATH_CSV + \"DELTA\" + \"\\\\\" + \"*.csv\")]\np = multiprocessing.Pool(4)\np.map(functools.partial(m_delta_pack),iterable=fnames_csv)\np.map(functools.partial(m_delta_slim,threshold=SS_REPORT[4][2],dv=1.5),iterable=fnames_csv)\np.close()\n# Pack .csv delta report with N-0 and N-1 loadings\ndef m_delta_pack(fname_csv):\n# Read file\nwith open(fname_csv,\"r\") as f:\nlines = f.readlines()\n# Key index\ncols = [0]\n# Contingency 1 index\nc1 = 8\n# Contingency 2 index\nc2 = 9\n# Flow index\nv = 10\n# Pack and write\nwith open(fname_csv,\"w\") as g:\n# Header\nline = lines.pop(0)\ns = line.replace(\"\\n\",\"\").split(\",\")\ns.insert(v,\"FLOW_N1B\")\ns.insert(v,\"FLOW_N1A\")\ns.insert(v,\"FLOW_N0\")\ns.insert(c1,\"GROUP\")\ng.write(\",\".join(s) + \"\\n\")\n# Convert lines to set\nlines = set(lines)\n# Initialize contingency dictionary\nd = {}\n# N-0\nfor line in lines:\nif contingency_count(line, c1, c2) == 0:\ns = line.replace(\"\\n\",\"\").split(\",\")\n# Add all N-0 key-value pairs\nkey = s[0] + \",\"\nif key not in d:\nd[key] = s[v]\n# Write line\ns.insert(v,\"\")\ns.insert(v,\"\")\ns.insert(v,\"\")\ns.insert(c1,\"N-0\")\ng.write(\",\".join(s) + \"\\n\")\n# N-1\nfor line in lines:\nif contingency_count(line, c1, c2) == 1:\ns = line.replace(\"\\n\",\"\").split(\",\")\n# Add all N-1 key-value pairs\nkey = s[0] + \",\" + s[c1]\nif key not in d:\nd[key] = s[v]\n# Write line\ns.insert(v,\"\")\ns.insert(v,\"\")\ns.insert(v,d[s[0]+\",\"])\ns.insert(c1,\"N-1\")\ng.write(\",\".join(s) + \"\\n\")\n# N-2\nfor line in lines:\nif contingency_count(line, c1, c2) == 2:\ns = line.replace(\"\\n\",\"\").split(\",\")\n# Ensure that contingencies are in alphabetical order\nif s[c1] > s[c2]:\ns[c1], s[c2] = s[c2], s[c1]\n# Special code for ERCOT 2 and ERCOT 3 contingencies\nif s[c1][0:2] == \"E2\" or s[c1][0:2] == \"E3\":\ns[c1], s[c2] = s[c2], s[c1]\n# Write line\ns.insert(v,d[s[0]+\",\"+s[c2]])\ns.insert(v,d[s[0]+\",\"+s[c1]])\ns.insert(v,d[s[0]+\",\"])\ns.insert(c1,\"N-2\")\ng.write(\",\".join(s) + \"\\n\")\n# Slim .csv delta report\ndef m_delta_slim(fname_csv,threshold=0.05,dv=1.5):\n# Read file\nwith open(fname_csv,\"r\") as f:\nlines = f.readlines()\n# Slim and write\nwith open(fname_csv,\"w\") as g:\n# Header\ng.write(lines.pop(0).replace(\"\\n\",\",SCORE\\n\"))\n# Key index\ncols = [9,10] # [0,9,10] for TSIP or single-case processing because s[0] is the case name\n# Build dictionary & count the number of cases\nd = {}\ncases = set()\nfor line in lines:\ns = line.replace(\"\\n\",\"\").split(\",\")\nkey = \",\".join([s[i] for i in cols])\n# Create empty key-value pair if it does not exist\nif key not in d:"
  },
  {
    "id": "chunk_092",
    "text": "d[key] = set()\n# Key is First Contingency + Second Contingency\n# Value is a set with all the lines with that First Contingency + Second Contingency\nd[key].add(line.replace(\"\\n\",\"\"))\n# Unique case names only\ncases.add(s[0])\n# Test 1 : At least one entry must be non-equal to the N-0 or N-1 violation\nrkeys = set(d.keys())\nfor key, value in d.items():\nfor line in value:\ns = line.split(\",\")\n# N-0\nif s[8] == \"N-0\":\nrkeys.remove(key)\nbreak\n# N-1 and N-2\nelse:\n# N-1\nif s[8] == \"N-1\":\nv0 = float(s[11])\n# N-2\nelse:\nv0 = max([float(v) for v in s[11:14]])\n# Any element with a zero rating is ignored\nif float(s[15]) <= 0:\nbreak\n# Test 1\nv0 = v0 / float(s[15])\nv = float(s[14]) / float(s[15])\nif v > (v0 + threshold) or v < 0:\nrkeys.remove(key)\nbreak\n# Delete values that did not pass Test 1\nfor rkey in rkeys:\nd.pop(rkey)\n# Test 2 : Maximum & minimum overloads to include overloads and large changes in flow\nscore = {}\nfor key, value in d.items():\nscore[key] = False\nif len(value) == 0:\ncontinue\n# Need to copy because assign (\"=\") does not make a copy of the object\nc = cases.copy()\nv = set()\nfor line in value:\ns = line.split(\",\")\n# N-0\nif s[8] == \"N-0\":\nbreak\n# N-1 and N-2\nelse:\n# Set of cases not in value\nif s[0] in c:\nc.remove(s[0])\n# Array of values\nv.add(float(s[14])/float(s[15]))\n# N-0\nif len(v) == 0:\nscore[key] = \"A\"\n# One case\nelif len(v) == 1:\nscore[key] = \"B\"\n# Negative (non-converged)\nelif min(v) < 0:\nscore[key] = \"C\"\n# Score = Max Flow + dv * (Max Flow - Min Flow)\nelse:\nf = max(v) + dv*(max(v)-min(v))\nif f > 0.99:\nscore[key] = \"F99\"\nelif f > 0.9:\nscore[key] = \"F90\"\nelif f > 0.8:\nscore[key] = \"F80\"\nelif f > 0.7:\nscore[key] = \"F70\"\nelif f > 0.6:\nscore[key] = \"F60\"\nelif f > 0.5:\nscore[key] = \"F50\"\nelse:\nscore[key] = \"F00\"\n# Missing cases gets a different designator\nif len(c) > 0:\nscore[key] = score[key].replace(\"F\",\"D\")\n# Write each key-value to the output file\nlines = []\nfor key, value in d.items():\nif len(value) > 0:\nfor line in value:\nlines.append(line + \",\" + score[key] + \"\\n\")\nlines.sort()\ng.writelines(lines)\n##### Consolidate and trim .csv reports\n# (1) Get list of unique case names in FPATH_TXT folder\n# (2) For each report type and unique case name, create a single .csv report file in the corresponding FPATH_CSV subfolder\n# (3) For each report type, create a consolidated .csv report file in FPATH_CSV folder\ndef m_slim():\nfor report in SS_REPORT:\n# Special behavior for the delta report\nif report[0] == \"DELTA\":\nfnames_csv = [FPATH_CSV + \"DELTA\" + \"\\\\\" + os.path.basename(x) for x in glob(FPATH_CSV + \"DELTA\" + \"\\\\\" + \"*.csv\")]\ncsv_combine(fnames_csv, FPATH_CSV + report[0] + \".csv\")\ncontinue\n# Get unique case names\nslugs = [os.path.basename(x) for x in glob(FPATH_CSV + report[0] + \"\\\\\" + \"*.csv\")]\nslugs = [slug[0:slug.rfind(\"__\")] for slug in slugs]\nslugs = list(set(slugs))\n# Slim reports group according to their slug\nfor slug in slugs:\nfname_dest = FPATH_CSV + report[0] + \"\\\\\" + slug + \".csv\"\nif os.path.exists(fname_dest): os.remove(fname_dest)\nfnames_csv = [os.path.basename(x) for x in glob(FPATH_CSV + report[0] + \"\\\\\" + slug + \"__*.csv\")]\nfnames_csv = [FPATH_CSV + report[0] + \"\\\\\" + s for s in fnames_csv]\nif report[2] == 0:\ncsv_combine(fnames_csv, fname_dest)\nelse:\ncsv_slim(fnames_csv, fname_dest, report[1], report[2])\n# Remove lines from the convergence report containing certain text\nif report[1] == 4:\ntxt_slim(fname_dest, \"Met convergence to\")\n# txt_slim(fname_dest, \"Iteration limit ex\")\n# Consolidate all reports into a single .csv report file\nfnames_csv = [FPATH_CSV + report[0] + \"\\\\\" + slug + \".csv\" for slug in slugs]\ncsv_combine(fnames_csv, FPATH_CSV + report[0] + \".csv\")\n# Nuke slugs\nfor fname_csv in fnames_csv:\nos.remove(fname_csv)\n# Combine and slim .csv thermal reports\ndef csv_slim(fnames_csv, fname_dest, mode, threshold):\n# Thermal report indexes\nif mode == 1:\n# Key index\ncols = [0,1,2,3,4,5,6,7,8,9]\n# Contingency 1 index\nc1 = 10\n# Contingency 2 index\nc2 = 11\n# Thermal index\nv = [15]\n# Voltage report indexes\nelif mode == 2:\n# Voltage index\ncols = [0,2,5,6,7,9,10,11]\n# Contingency 1 index\nc1 = 3\n# Contingency 2 index\nc2 = 4\n# Voltage value index\nv = [8]\n# Capacity report indexes\nelif mode == 6:\n# Key index\ncols = [0,1,2,3,4,5,6,7]\n# Contingency 1 index\nc1 = 8\n# Contingency 2 index\nc2 = 9\n# Flow and rating index\nv = [10,11]\n# Capacity report proxy indexes\n# elif mode == 6.1:\n#   # Key index\n#   cols = [0,1,2,3,4,5,6,7]\n#   # Contingency 1 index\n#   c1 = 15\n#   # Contingency 2 index\n#   c2 = 16\n#   # Flow and rating index\n#   v = [10,11]\nelse:\n# Combine reports and quit\ncsv_combine(fnames_csv, fname_dest)\nreturn\n# Open destination file\ng = open(fname_dest,\"w\")\n# No files to open\nif len(fnames_csv) == 0:\ng.close()\nreturn\n# Write header from first .csv file\nwith open(fnames_csv[0],\"r\") as f:\ng.write(f.readline())\n# Initialize contingency dictionary\nd = {}\n# N-0\nfor fname_csv in fnames_csv:\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : N-0 : \" + fname_csv)\nwith open(fname_csv,\"r\") as f:\nfor line in f:\nif contingency_count(line, c1, c2) == 0:\ns = line.replace(\"\\n\",\"\").split(\",\")\nk = \",\".join([s[i] for i in cols])\n# Add all N-0 key-value pairs\nkey = k + \",,\"\nif key not in d:\nd[key] = line.replace(\"\\n\",\"\")\n# N-1\nfor fname_csv in fnames_csv:\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : N-1 : \" + fname_csv)\nwith open(fname_csv,\"r\") as f:\nfor line in f:\nif contingency_count(line, c1, c2) == 1:\ns = line.replace(\"\\n\",\"\").split(\",\")\nk = \",\".join([s[i] for i in cols])\n# Keys to look for\nkeys = []\nkeys = keys + [k + \",,\"]\nkeys = keys + [k + \",\" + s[c1] + \",\"]\n# Flags set to False mean an equivalent contingency violation already exists\nflags = [True for key in keys]\n# Do not add key-value pair if existing value is equal\nfor i, key in enumerate(keys):"
  },
  {
    "id": "chunk_093",
    "text": "if key in d and all(flags):\nif element_equal(d[key], line, v, mode, threshold):\nflags[i] = False\nif all(flags):\nd[keys[1]] = line.replace(\"\\n\",\"\")\n# N-2\nfor fname_csv in fnames_csv:\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : N-2 : \" + fname_csv)\nwith open(fname_csv,\"r\") as f:\nf.readline() # Skip header\nfor line in f:\nif contingency_count(line, c1, c2) == 2:\ns = line.replace(\"\\n\",\"\").split(\",\")\nk = \",\".join([s[i] for i in cols])\n# Keys to look for\nkeys = []\nkeys = keys + [k + \",,\"]\nkeys = keys + [k + \",\" + s[c1] + \",\"]\nkeys = keys + [k + \",\" + s[c2] + \",\"]\nkeys = keys + [k + \",\" + s[c1] + \",\" + s[c2]]\nkeys = keys + [k + \",\" + s[c2] + \",\" + s[c1]]\n# Flags set to False mean an equivalent contingency violation already exists\nflags = [True for key in keys]\n# Do not add key-value pair if existing value is equal\nfor i, key in enumerate(keys):\nif key in d and all(flags):\nif element_equal(d[key], line, v, mode, threshold):\nflags[i] = False\nif all(flags):\nd[keys[3]] = line.replace(\"\\n\",\"\")\n# Write output\nlines = []\nfor key, value in d.items():\nlines.append(value + \"\\n\")\nlines.sort()\ng.writelines(lines)\n# Housekeeping\ng.close()\n# Count the number of contingencies in a comma-separated report string (line)\ndef contingency_count(line, c1, c2):\ns = line.split(\",\")\n# Out-of-range\nif c1 >= len(s) or c2 >= len(s) or c1 < 0 or c2 < 0:\nreturn -1\n# N-0\nelif s[c1] == \"\" and s[c2] == \"\":\nreturn 0\n# N-1\nelif s[c2] == \"\":\nreturn 1\n# N-2\nelse:\nreturn 2\n# Boolean T/F if value of Element 2 < Element 1 + Threshold\ndef element_equal(line1, line2, v, mode, threshold):\n# DEBUG\nif \"7170,L_BERGHE8_1Y,138.00,70170,P_BERGHE8_1_,138.00,1\" in line1:\nreturn True\nelif \"7170,L_BERGHE8_1Y,138.00,70170,P_BERGHE8_1_,138.00,1\" in line2:\nreturn True\n# DEBUG\ns1 = line1.split(\",\")\ns2 = line2.split(\",\")\n# Numeric values for each line\nif mode == 1 or mode == 2:\nv1 = float(s1[v[0]])\nv2 = float(s2[v[0]])\nelif int(mode) == 6:\nv1 = float(s1[v[0]]) / float(s1[v[1]])\nv2 = float(s2[v[0]]) / float(s2[v[1]])\n# Thermal threshold (overloads) is in decimal percent\nif mode == 1:\nreturn (v2 < (1+threshold)*v1)\n# Thermal threshold (capacity) is in decimal percent\nelif int(mode) == 6:\nreturn (v2 < (v1+threshold))\n# Voltage threshold is in pu\nelif mode == 2:\nif v2 > 1:\n# High voltage\nreturn (v2 < v1 + threshold)\nelse:\n# Low voltage\nreturn (v2 > v1 - threshold)\nelse:\nreturn False\n# Delete lines containing a string from file\ndef txt_slim(fname, s):\nfname_ext = fname[fname.rfind(\".\"):]\nfname_temp = fname.replace(fname_ext, \"_TEMP\" + fname_ext)\nf = open(fname,\"r\")\ng = open(fname_temp,\"w\")\nfor line in f:\nif s not in line:\ng.write(line)\nf.close()\ng.close()\n# Overwrite old file with new file\nshutil.move(fname_temp, fname)\n# Find and replace text\ndef txt_replace(fname, s):\nfname_ext = fname[fname.rfind(\".\"):]\nfname_temp = fname.replace(fname_ext, \"_TEMP\" + fname_ext)\nf = open(fname,\"r\")\ng = open(fname_temp,\"w\")\nfor line in f:\ng.write(line.replace(s,\"\"))\nf.close()\ng.close()\n# Overwrite old file with new file\nshutil.move(fname_temp, fname)\n##### Add bus and branch information to .csv reports\n# (1) Match THERMAL.csv file in FPATH_CSV with LINES.csv file in FPATH_RCSV\n# (2) Match VOLTAGE.csv file in FPATH_CSV with BUS.csv file in FPATH RCSV\ndef m_match():\n# Thermal\nfname_csv = FPATH_CSV + \"THERMAL.csv\"\nfname_dest = FPATH_CSV + \"THERMAL_MATCH.csv\"\nif os.path.exists(fname_csv):\n# Match thermal and line information\nfname_dict = FPATH_RCSV + \"LINES_MIRROR.csv\"\nmatch_and_add(fname_csv, [0,1,5,9], fname_dict, [0,3,4,5], fname_dest)\n## # Match thermal and owner information\n## fname_dict = FPATH_RCSV + \"OWNER.csv\"\n## match_and_add(fname_dest, [0,38], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,40], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,42], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,44], fname_dict, [0,1], fname_dest)\n# Match thermal and contingency information\nfname_dict = FPATH_CON + \"DICT_ALL.csv\"\nmatch_and_add(fname_dest, [10], fname_dict, [0], fname_dest)\nmatch_and_add(fname_dest, [11], fname_dict, [0], fname_dest)\n# Voltage\nfname_csv = FPATH_CSV + \"VOLTAGE.csv\"\nfname_dest = FPATH_CSV + \"VOLTAGE_MATCH.csv\"\nif os.path.exists(fname_csv):\n# Match voltage and bus information\nfname_dict = FPATH_RCSV + \"BUS.csv\"\nmatch_and_add(fname_csv, [0,5], fname_dict, [0,1], fname_dest)\n# Match voltage and area information\nfname_dict = FPATH_RCSV + \"AREA.csv\"\nmatch_and_add(fname_dest, [0,17], fname_dict, [0,1], fname_dest)\n# Match voltage and zone information\nfname_dict = FPATH_RCSV + \"ZONE.csv\"\nmatch_and_add(fname_dest, [0,18], fname_dict, [0,1], fname_dest)\n# Match voltage and owner information\nfname_dict = FPATH_RCSV + \"OWNER.csv\"\nmatch_and_add(fname_dest, [0,19], fname_dict, [0,1], fname_dest)\n# Match voltage and contingency information\nfname_dict = FPATH_CON + \"DICT_ALL.csv\"\nmatch_and_add(fname_dest, [3], fname_dict, [0], fname_dest)\nmatch_and_add(fname_dest, [4], fname_dict, [0], fname_dest)\n# Convergence\nfname_csv = FPATH_CSV + \"CONVERGENCE.csv\"\nfname_dest = FPATH_CSV + \"CONVERGENCE_MATCH.csv\"\nif os.path.exists(fname_csv):\n# Match convergence and contingency information\nfname_dict = FPATH_CON + \"DICT_ALL.csv\"\nmatch_and_add(fname_csv, [1], fname_dict, [0], fname_dest)\nmatch_and_add(fname_dest, [2], fname_dict, [0], fname_dest)\n# Capacity Proxy\nfname_csv = FPATH_CSV + \"CAPACITY.csv\"\nif os.path.exists(fname_csv):\n# Proxy Capacity Report\nif os.stat(fname_csv).st_size > 1000000:\n# Add proxy contingency types\nfname_dest = FPATH_CSV + \"CAPACITY_PROXY.csv\"\ncapacity_proxy(fname_csv, fname_dest)\n# Match capacity and line information\nfname_csv = fname_dest\n# Match capacity and line information\nfname_dest = FPATH_CSV + \"CAPACITY_MATCH.csv\"\nfname_dict = FPATH_RCSV + \"LINES_MIRROR.csv\"\nmatch_and_add(fname_csv, [0,1,4,7], fname_dict, [0,3,4,5], fname_dest)\n## # Match thermal and owner information\n## fname_dict = FPATH_RCSV + \"OWNER.csv\"\n## match_and_add(fname_dest, [0,35], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,37], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,39], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,41], fname_dict, [0,1], fname_dest)\n# Match thermal and contingency information\nfname_dict = FPATH_CON + \"DICT_ALL.csv\"\nmatch_and_add(fname_dest, [8], fname_dict, [0], fname_dest)\nmatch_and_add(fname_dest, [9], fname_dict, [0], fname_dest)\n# Delta\nfname_csv = FPATH_CSV + \"DELTA.csv\"\nfname_dest = FPATH_CSV + \"DELTA_MATCH.csv\"\nif os.path.exists(fname_csv):\n# Match thermal and line information\nfname_dict = FPATH_RCSV + \"LINES_MIRROR.csv\"\nmatch_and_add(fname_csv, [0,1,4,7], fname_dict, [0,3,4,5], fname_dest)\n## # Match thermal and owner information\n## fname_dict = FPATH_RCSV + \"OWNER.csv\"\n## match_and_add(fname_dest, [0,40], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,42], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,44], fname_dict, [0,1], fname_dest)\n## match_and_add(fname_dest, [0,46], fname_dict, [0,1], fname_dest)\n# Match thermal and contingency information\nfname_dict = FPATH_CON + \"DICT_ALL.csv\"\nmatch_and_add(fname_dest, [9], fname_dict, [0], fname_dest)\nmatch_and_add(fname_dest, [10], fname_dict, [0], fname_dest)\n# Add case information to report files\ndef match_and_add(fname_csv, k1, fname_dict, k2, fname_dest):\n# Read report file\nwith open(fname_csv,\"r\") as f:\nlines = [line.replace(\"\\n\",\"\") for line in f.readlines()]\n# Create dictionary\nd = build_dict(fname_dict, k2)\n# Open output file\ng = open(fname_dest,\"w\")"
  },
  {
    "id": "chunk_094",
    "text": "# Write header\ng.write(lines.pop(0) + \",\" + d.get(0) + \"\\n\")\n# Search dictionary\nfor line in lines:\ns = line.split(\",\")\nk = \",\".join([s[c] for c in k1])\nr = d.get(k)\n# Search for key without spaces\n# Special consideration for 3-winding transformers\nif r is None: r = d.get(k.replace(\" \",\"\").replace(\"3WNDTR\",\"3WNDTR \"))\n# Special consideration for bus number sections (e.g., \"7150- 12\")\nif r is None: r = d.get(k[:k.rfind(\"-\")])\n# Blank if key is not found\nif r is None: r = \",\".join([\"-\" for dummy in d.get(0).split(\",\")])\ng.write(line + \",\" + r + \"\\n\")\ng.close()\n# Build dictionary with key-value pairs defined by input columns\ndef build_dict(fname_csv, col):\n# Open input file and strip newline characters\nwith open(fname_csv,\"r\") as f:\nlines = [line.replace(\"\\n\",\"\") for line in f.readlines()]\n# Empty dictionary\nlines_dict = {}\n# Header\nlines_dict[0] = lines.pop(0)\n# Construct dictionary\nfor line in lines:\nkey = line.split(\",\")\nkey = [key[c] for c in col]\nkey = \",\".join(key)\nlines_dict[key] = line\n# Return\nreturn lines_dict\n# Define contingency classes for capacity reports\ndef capacity_proxy(fname_csv, fname_dest):\nf = open(fname_csv,\"r\")\ng = open(fname_dest,\"w\")\n# Header\ng.write(f.readline())\n# Dictionary\nd = {}\ncols = [0,1,2,3,4,5,6,7]\nfor line in f:\ns = line.replace(\"\\n\",\"\").split(\",\")\n# Special consideration for bus number sections (e.g., \"7150- 12\")\nif \"-\" in s[1]: s[1] = s[1][:s[1].rfind(\"-\")]\nif \"-\" in s[4]: s[4] = s[4][:s[4].rfind(\"-\")]\nkey = \",\".join([s[i] for i in cols])\n# Add that branch to the dictionary\nif key not in d:\nd[key] = []\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : Capacity Report : Added \" + key)\nd[key].append(\",\".join(s) + \"\\n\")\n# Housekeeping\nf.close()\n# Sort each value in the dictionary by flow\nfor key, value in d.items():\n# Sort the value list in descending order\nv = 10\nv = [float(line.replace(\"\\n\",\"\").split(\",\")[v]) for line in value]\nd[key] = [m for _ , m in sorted(zip(v,value),reverse=True)]\n# Only include a specified number of each contingency type\nfor key, value in d.items():\n# Create a new dictionary\n# - Key is the contingency type\n# - Value is the count & the maximum count\na = {}\na[\"BASE\"]   = [0,9999999999]\na[\"SINGLE\"] = [0,9999999999]\na[\"ERCOT3\"] = [0,20]\na[\"P3\"]     = [0,10]\na[\"P6\"]     = [0,5]\nfor line in value:\nk = capacity_proxy_helper(line, 8, 9)\na[k][0] = a[k][0] + 1\nif a[k][0] <= a[k][1]:\ng.write(line)\n# Reporting\nprint(time.strftime(\"%Y-%m-%d %H:%M:%S\") + \" : Capacity Report : Processed \" + key)\n# Housekeeping\ng.close()\n# Helper function\ndef capacity_proxy_helper(line, c1, c2):\n# N-0\nif contingency_count(line, c1, c2) == 0: return \"BASE\"\n# N-1\nif contingency_count(line, c1, c2) == 1: return \"SINGLE\"\n# N-2\ns = line.replace(\"\\n\",\"\").split(\",\")\ns1 = s[c1]\ns2 = s[c2]\np3set = {\n\"P3_BAT_10908\",\"P3_BAT_11158\",\"P3_BAT_11163\",\"P3_BAT_11287\",\"P3_BAT_11359\",\"P3_BAT_11362\",\"P3_BAT_11387\",\"P3_BAT_11407\",\n\"P3_BAT_13185\",\"P3_BAT_13278\",\"P3_BAT_13293\",\"P3_BAT_13294\",\"P3_BAT_13495\",\"P3_BAT_13526\",\"P3_BAT_13546\",\"P3_BAT_13548\",\n\"P3_BAT_13549\",\"P3_BAT_13555\",\"P3_BAT_13556\",\"P3_BAT_13557\",\"P3_BAT_13558\",\"P3_BAT_13559\",\"P3_BAT_13560\",\"P3_BAT_13578\",\n\"P3_BAT_13615\",\"P3_BAT_13621\",\"P3_BAT_13622\",\"P3_BAT_13628\",\"P3_BAT_13633\",\"P3_BAT_13639\",\"P3_BAT_13640\",\"P3_BAT_13643\",\n\"P3_BAT_15175\",\"P3_BAT_15213\",\"P3_BAT_15313\",\"P3_BAT_15319\",\"P3_BAT_15329\",\"P3_BAT_15338\",\"P3_BAT_15449\",\"P3_BAT_16098\",\n\"P3_BAT_16296\",\"P3_BAT_16337\",\"P3_BAT_16338\",\"P3_BAT_16339\",\"P3_BAT_16340\",\"P3_BAT_16374\",\"P3_BAT_16380\",\"P3_BAT_16386\",\n\"P3_BAT_16387\",\"P3_BAT_16404\",\"P3_BAT_16405\",\"P3_BAT_16406\",\"P3_BAT_16419\",\"P3_BAT_16420\",\"P3_BAT_16423\",\"P3_BAT_16428\",\n\"P3_BAT_16433\",\"P3_BAT_17057\",\"P3_BAT_17058\",\"P3_BAT_17065\",\"P3_BAT_17066\",\"P3_BAT_17072\",\"P3_BAT_17087\",\"P3_BAT_17088\",\n\"P3_BAT_17089\",\"P3_BAT_17107\",\"P3_BAT_17108\",\"P3_BAT_17137\",\"P3_BAT_17138\",\"P3_BAT_18095\",\"P3_BAT_18096\",\"P3_BAT_18103\",\n\"P3_BAT_18327\",\"P3_BAT_18340\",\"P3_BAT_18351\",\"P3_BAT_18352\",\"P3_BAT_18362\",\"P3_BAT_18367\",\"P3_BAT_18378\",\"P3_BAT_18390\",\n\"P3_COAL_COLETO\",\"P3_COAL_FPP_1\",\"P3_COAL_FPP_2\",\"P3_COAL_FPP_3\",\"P3_COAL_SANMIG\",\"P3_COAL_SCES\",\n\"P3_COAL_SPRUCE_1\",\"P3_COAL_SPRUCE_2\",\"P3_COAL_STP_1\",\"P3_COAL_STP_2\",\"P3_COAL_TNP_1\",\"P3_COAL_TNP_2\",\n\"P3_EXDS_ADEL\",\"P3_EXDS_ALIL\",\"P3_EXDS_ANSO\",\"P3_EXDS_ARGE\",\"P3_EXDS_AVIL\",\"P3_EXDS_BIRD\",\"P3_EXDS_BRAC\",\"P3_EXDS_BRDR\",\n\"P3_EXDS_BRIG\",\"P3_EXDS_BSAM\",\"P3_EXDS_CACT\",\"P3_EXDS_CHIL\",\"P3_EXDS_CITF\",\"P3_EXDS_CSTA\",\"P3_EXDS_CUCH\",\"P3_EXDS_DOVE\",\n\"P3_EXDS_GBRY\",\"P3_EXDS_GHOL\",\"P3_EXDS_GOLD\",\"P3_EXDS_GRYH\",\"P3_EXDS_GSLA\",\"P3_EXDS_HERM\",\"P3_EXDS_HFWF\",\"P3_EXDS_HNYC\",\n\"P3_EXDS_HOYT\",\"P3_EXDS_INGO\",\"P3_EXDS_IRON\",\"P3_EXDS_LARK\",\"P3_EXDS_LAVA\",\"P3_EXDS_LIME\",\"P3_EXDS_LOMA\",\"P3_EXDS_LYNX\",\n\"P3_EXDS_MATA\",\"P3_EXDS_MONT\",\"P3_EXDS_MRAN\",\"P3_EXDS_NFLL\",\"P3_EXDS_NORI\",\"P3_EXDS_PATR\",\"P3_EXDS_PICA\",\"P3_EXDS_PINT\",\n\"P3_EXDS_RGDW\",\"P3_EXDS_RHOL\",\"P3_EXDS_ROCI\",\"P3_EXDS_SCHS\",\"P3_EXDS_SEVN\",\"P3_EXDS_SODA\",\"P3_EXDS_STLH\",\"P3_EXDS_STLI\",\n\"P3_EXDS_STRG\",\"P3_EXDS_THRD\",\"P3_EXDS_TSEC\",\"P3_EXDS_YAUP\",\n\"P3_GAS_ATKINS\",\"P3_GAS_AVR\",\"P3_GAS_BARNEY\",\"P3_GAS_BARNEY_1\",\"P3_GAS_BASTEN\",\"P3_GAS_BRAUNIG_1\",\"P3_GAS_BRAUNIG_2\",\"P3_GAS_BRAUNIG_3\",\n\"P3_GAS_BRAUNIG_6\",\"P3_GAS_CALHOUN\",\"P3_GAS_DANSBY\",\"P3_GAS_DECKER\",\"P3_GAS_DUKE\",\"P3_GAS_ECEC\",\"P3_GAS_FERGUSON\",\"P3_GAS_FLCNS\",\n\"P3_GAS_FRONTERA\",\"P3_GAS_GIDEON_1\",\"P3_GAS_GIDEON_2\",\"P3_GAS_GIDEON_3\",\"P3_GAS_GUADALUPE_1\",\"P3_GAS_GUADALUPE_2\",\n\"P3_GAS_HAYSEN\",\"P3_GAS_LAREDO\",\"P3_GAS_LEON\",\"P3_GAS_LOSTPINES\",\"P3_GAS_MGSES\",\"P3_GAS_NEDIN\",\"P3_GAS_NUECES\",\"P3_GAS_OECCS_1\",\n\"P3_GAS_OECCS_2\",\"P3_GAS_PB2SES\",\"P3_GAS_PEARSAL\",\"P3_GAS_QUAIL_1\",\"P3_GAS_QUAIL_2\",\"P3_GAS_RAYBURN\",\"P3_GAS_REDGATE\",\"P3_GAS_RIONOG\",\n\"P3_GAS_SANDHILL\",\"P3_GAS_SANDHILL_5\",\"P3_GAS_SILAS\",\"P3_GAS_SKY\",\"P3_GAS_SOMMERS_1\",\"P3_GAS_SOMMERS_2\",\"P3_GAS_TAMU\",\"P3_GAS_TEMPLE_1\",\n\"P3_GAS_TEMPLE_2\",\"P3_GAS_TIMMERMAN\",\"P3_GAS_VICTCITY\",\"P3_GAS_VICTORIA\",\"P3_GAS_VICTPORT_1\",\"P3_GAS_VICTPORT_2\",\"P3_GAS_WINCHESTER\",\n\"P3_SOL_11158\",\"P3_SOL_11163\",\"P3_SOL_11204\",\"P3_SOL_11209\",\"P3_SOL_11214\",\"P3_SOL_11226\",\"P3_SOL_11235\",\"P3_SOL_11277\",\n\"P3_SOL_11287\",\"P3_SOL_11305\",\"P3_SOL_11311\",\"P3_SOL_11325\",\"P3_SOL_11365\",\"P3_SOL_11387\",\"P3_SOL_11392\",\"P3_SOL_11414\",\n\"P3_SOL_12026\",\"P3_SOL_12039\",\"P3_SOL_13233\",\"P3_SOL_13243\",\"P3_SOL_13248\",\"P3_SOL_13273\",\"P3_SOL_13278\",\"P3_SOL_13283\",\n\"P3_SOL_13288\",\"P3_SOL_13294\",\"P3_SOL_13334\",\"P3_SOL_13384\",\"P3_SOL_13409\",\"P3_SOL_13414\",\"P3_SOL_13424\",\"P3_SOL_13429\",\n\"P3_SOL_13434\",\"P3_SOL_13444\",\"P3_SOL_13459\",\"P3_SOL_13470\",\"P3_SOL_13475\",\"P3_SOL_13480\",\"P3_SOL_13490\",\"P3_SOL_13495\",\n\"P3_SOL_13501\",\"P3_SOL_13511\",\"P3_SOL_13518\",\"P3_SOL_13532\",\"P3_SOL_13550\",\"P3_SOL_13598\",\"P3_SOL_13610\",\"P3_SOL_13616\",\n\"P3_SOL_13634\",\"P3_SOL_13644\",\"P3_SOL_15170\",\"P3_SOL_15175\",\"P3_SOL_15203\",\"P3_SOL_15213\",\"P3_SOL_15319\",\"P3_SOL_15329\",\n\"P3_SOL_15338\",\"P3_SOL_15368\",\"P3_SOL_15373\",\"P3_SOL_15428\",\"P3_SOL_15449\",\"P3_SOL_16254\",\"P3_SOL_16279\",\"P3_SOL_16284\",\n\"P3_SOL_16286\",\"P3_SOL_16302\",\"P3_SOL_16312\",\"P3_SOL_16317\",\"P3_SOL_16322\",\"P3_SOL_16332\",\"P3_SOL_16352\",\"P3_SOL_16357\",\n\"P3_SOL_16364\",\"P3_SOL_16369\",\"P3_SOL_16388\",\"P3_SOL_16393\",\"P3_SOL_16428\",\"P3_SOL_17020\",\"P3_SOL_17034\",\"P3_SOL_17038\",\n\"P3_SOL_17052\",\"P3_SOL_17060\",\"P3_SOL_17067\",\"P3_SOL_17077\",\"P3_SOL_17082\",\"P3_SOL_17090\",\"P3_SOL_17095\",\"P3_SOL_17102\",\n\"P3_SOL_17111\",\"P3_SOL_17116\",\"P3_SOL_17122\",\"P3_SOL_17127\",\"P3_SOL_17132\",\"P3_SOL_18075\",\"P3_SOL_18165\",\"P3_SOL_18168\",\n\"P3_SOL_18173\",\"P3_SOL_18215\",\"P3_SOL_18225\",\"P3_SOL_18230\",\"P3_SOL_18250\",\"P3_SOL_18260\",\"P3_SOL_18282\",\"P3_SOL_18307\",\n\"P3_SOL_18317\",\"P3_SOL_18322\",\"P3_SOL_18335\",\"P3_SOL_18340\",\"P3_SOL_18345\",\"P3_SOL_18352\",\"P3_SOL_18357\",\"P3_SOL_18362\",\n\"P3_SOL_18368\",\"P3_SOL_18378\",\"P3_SOL_18385\",\"P3_SOL_78570\",\n\"P3_WAT_AUSTIN\",\"P3_WAT_BUCHANAN\",\"P3_WAT_CANYON\",\"P3_WAT_INKS\",\"P3_WAT_MARBFA\",\"P3_WAT_MARSFO\",\"P3_WAT_WIRTZ\",\n\"P3_WND_11138\",\"P3_WND_11298\",\"P3_WND_11409\",\"P3_WND_11421\",\"P3_WND_13012\",\"P3_WND_13033\",\"P3_WND_13043\",\"P3_WND_13053\",\n\"P3_WND_13063\",\"P3_WND_13073\",\"P3_WND_13083\",\"P3_WND_13093\",\"P3_WND_13114\",\"P3_WND_13125\",\"P3_WND_13135\",\"P3_WND_13145\",\n\"P3_WND_13155\",\"P3_WND_13165\",\"P3_WND_13175\",\"P3_WND_13185\",\"P3_WND_13195\",\"P3_WND_13211\",\"P3_WND_13216\",\"P3_WND_13221\",\n\"P3_WND_13238\",\"P3_WND_13263\",\"P3_WND_13268\",\"P3_WND_13299\",\"P3_WND_13304\",\"P3_WND_13344\",\"P3_WND_13349\",\"P3_WND_13364\",\n\"P3_WND_13379\",\"P3_WND_13399\",\"P3_WND_13404\",\"P3_WND_13449\",\"P3_WND_13454\",\"P3_WND_13465\",\"P3_WND_13485\",\"P3_WND_13561\",\n\"P3_WND_13566\",\"P3_WND_13573\",\"P3_WND_13623\",\"P3_WND_13628\",\"P3_WND_15096\",\"P3_WND_15185\",\"P3_WND_15303\",\"P3_WND_16029\",\n\"P3_WND_16039\",\"P3_WND_16049\",\"P3_WND_16059\",\"P3_WND_16069\",\"P3_WND_16074\",\"P3_WND_16083\",\"P3_WND_16088\",\"P3_WND_16098\",\n\"P3_WND_16105\",\"P3_WND_16110\",\"P3_WND_16120\",\"P3_WND_16125\",\"P3_WND_16145\",\"P3_WND_16150\",\"P3_WND_16155\",\"P3_WND_16160\",\n\"P3_WND_16165\",\"P3_WND_16170\",\"P3_WND_16175\",\"P3_WND_16185\",\"P3_WND_16195\",\"P3_WND_16200\",\"P3_WND_16205\",\"P3_WND_16210\",\n\"P3_WND_16215\",\"P3_WND_16220\",\"P3_WND_16225\",\"P3_WND_16230\",\"P3_WND_16245\",\"P3_WND_16249\",\"P3_WND_16269\",\"P3_WND_16274\",\n\"P3_WND_16291\",\"P3_WND_16307\",\"P3_WND_16341\",\"P3_WND_16347\",\"P3_WND_16381\",\"P3_WND_16407\",\"P3_WND_17023\",\"P3_WND_17044\",\n\"P3_WND_18005\",\"P3_WND_18015\",\"P3_WND_18025\",\"P3_WND_18035\",\"P3_WND_18045\",\"P3_WND_18055\",\"P3_WND_18065\",\"P3_WND_18075\",\n\"P3_WND_18095\",\"P3_WND_18096\",\"P3_WND_18098\",\"P3_WND_18101\",\"P3_WND_18103\",\"P3_WND_18105\",\"P3_WND_18115\",\"P3_WND_18125\",\n\"P3_WND_18135\",\"P3_WND_18145\",\"P3_WND_18155\",\"P3_WND_18175\",\"P3_WND_18185\",\"P3_WND_18190\",\"P3_WND_18195\",\"P3_WND_18200\",\n\"P3_WND_18205\",\"P3_WND_18210\",\"P3_WND_18220\",\"P3_WND_18235\",\"P3_WND_18240\",\"P3_WND_18245\",\"P3_WND_18265\",\"P3_WND_18272\",\n\"P3_WND_18277\",\"P3_WND_18278\",\"P3_WND_18297\",\"P3_WND_18302\",\"P3_WND_18312\"}\ne3set = {\n\"SINGLE 10049-10050-10051(1)\",\"SINGLE 10049-10050-10052(2)\",\"SINGLE 10053-10054-10055(1)\",\"SINGLE 10053-10054-10056(2)\",\n\"SINGLE 10062-10063-10064(1)\",\"SINGLE 10062-10063-10065(2)\",\"SINGLE 1016-1027-18530(3H)\",\"SINGLE 1018-1019-18527(1)\",\n\"SINGLE 1018-1019-24996(2)\",\"SINGLE 1021-1023-24989(1)\",\"SINGLE 1022-1023-1014(1)\",\"SINGLE 1028-1027-18528(2)\",\n\"SINGLE 1029-1027-18529(1)\",\"SINGLE 11010-1013-11007(2)\",\"SINGLE 11010-1013-11008(1)\",\"SINGLE 11084-11083-11075(2)\",\n\"SINGLE 11084-11083-11085(1)\",\"SINGLE 11098-11097-11099(1)\",\"SINGLE 11098-11097-11109(2)\",\"SINGLE 11188-11189-11194(1)\",\n\"SINGLE 11188-11189-11216(2)\",\"SINGLE 1125-1124-4000(1)\",\"SINGLE 11387-11388-11386(2)\",\"SINGLE 11387-11388-11389(1)\",\n\"SINGLE 11406-11407-18531(1)\",\"SINGLE 1185-1183-1186(3)\",\"SINGLE 1198-1196(1)\",\"SINGLE 126-33126(1)\",\n\"SINGLE 131-130(1)\",\"SINGLE 1330-1329(1)\",\"SINGLE 133-132(1)\",\"SINGLE 1340-1339(1)\",\n\"SINGLE 1340-1339(2)\",\"SINGLE 13429-13441-13440(2)\",\"SINGLE 13429-13442-13439(3)\",\"SINGLE 1626-1624(1)\",\n\"SINGLE 1626-1624(2)\",\"SINGLE 1662-1661(1)\",\"SINGLE 18540-18541-24983(1)\",\"SINGLE 18540-18541-24984(2)\",\n\"SINGLE 18544-18545-18546(1)\",\"SINGLE 18544-18545-18547(2)\",\"SINGLE 18548-18549-18550(1)\",\"SINGLE 18548-18549-18551(2)\",\n\"SINGLE 23852-23875(1)\",\"SINGLE 23862-23873(1)\",\"SINGLE 32855-32856(1)\",\"SINGLE 32857-32865(1)\",\n\"SINGLE 32864-32862(1)\",\"SINGLE 32870-32882(1)\",\"SINGLE 32874-32896(1)\",\"SINGLE 32875-32897(1)\",\n\"SINGLE 32875-32897(2)\",\"SINGLE 3363-3362-13364(1)\",\"SINGLE 3363-3362-3364(1)\",\"SINGLE 3402-3410-13410(1)\",\n\"SINGLE 3406-3407-13406(1)\",\"SINGLE 3409-3410-13402(1)\",\"SINGLE 3412-3420-13412(1)\",\"SINGLE 3412-3420-13420(1)\",\n\"SINGLE 3414-13415-13414(1)\",\"SINGLE 3414-3415-3718(1)\",\"SINGLE 3422-3423-13423(1)\",\"SINGLE 3422-3423-13424(2)\",\n\"SINGLE 3496-3493(1)\",\"SINGLE 3649-3658(1)\",\"SINGLE 3684-3683(1)\",\"SINGLE 3696-3666-24992(2)\",\n\"SINGLE 3696-3666-3660(1)\",\"SINGLE 3699-3640-3745(1)\",\"SINGLE 3699-3640-3746(1)\",\"SINGLE 3717-3713-3715(1)\",\n\"SINGLE 3717-3714-3716(1)\",\"SINGLE 3751-3750-3752(1)\",\"SINGLE 38150-38143-38147(1)\",\"SINGLE 38150-38143-38148(2)\",\n\"SINGLE 38150-38143-38149(3)\",\"SINGLE 38320-38310(1)\",\"SINGLE 38420-38430(1)\",\"SINGLE 40000-40010-49005(A1)\",\n\"SINGLE 40000-40015-49008(A3)\",\"SINGLE 40005-40020-49006(2A)\",\"SINGLE 40005-40020-49007(2B)\",\"SINGLE 40450-40460-49054(A1)\",\n\"SINGLE 40700-40710-49018(A1)\",\"SINGLE 40700-40716-49019(A2)\",\"SINGLE 40850-40855-49077(A1)\",\"SINGLE 40850-40855-49078(A2)\",\n\"SINGLE 40850-40855-49079(A3)\",\"SINGLE 42530-42540-49036(A1)\",\"SINGLE 42530-42540-49037(A2)\",\"SINGLE 42530-42540-49038(A3)\",\n\"SINGLE 44500-44510-49031(A1)\",\"SINGLE 44500-44510-49063(A3)\",\"SINGLE 44500-44510-49064(A2)\",\"SINGLE 45500-45510-49039(A1)\",\n\"SINGLE 45500-45515-49071(A3)\",\"SINGLE 45600-45610-49061(A1)\",\"SINGLE 45600-45610-49083(A2)\",\"SINGLE 46020-46025-49060(A2)\",\n\"SINGLE 46020-46025-49068(A1)\",\"SINGLE 5056-5053-5060(4)\",\"SINGLE 5056-5054-5059(3)\",\"SINGLE 5056-5055(2)\",\n\"SINGLE 5056-5055-5057(1)\",\"SINGLE 5211-5208-5215(4)\",\"SINGLE 5211-5209-5214(3)\",\"SINGLE 5211-5210-5212(1)\",\n\"SINGLE 5211-5210-5213(2)\",\"SINGLE 5231-5230(1)\",\"SINGLE 5231-5230(2)\",\"SINGLE 5231-5230(3)\",\n\"SINGLE 5295-5294(1)\",\"SINGLE 5295-5294(2)\",\"SINGLE 5371-5368(1)\",\"SINGLE 5371-5368-5373(2)\",\n\"SINGLE 5371-5369-5374(3)\",\"SINGLE 5371-5370-5375(4)\",\"SINGLE 5500-5502(1)\",\"SINGLE 5535-78104(1)\",\n\"SINGLE 5536-78103(1)\",\"SINGLE 5544-5546(1)\",\"SINGLE 5582-5584(1)\",\"SINGLE 5709-5705-5706(1)\",\n\"SINGLE 5715-5717(1)\",\"SINGLE 5725-5727(1)\",\"SINGLE 5729-5728(1)\",\"SINGLE 57668-57666(1)\",\n\"SINGLE 5784-5780(1)\",\"SINGLE 5811-5813(1)\",\"SINGLE 5821-5819(1)\",\"SINGLE 5849-5851(1)\",\n\"SINGLE 5871-78280(1)\",\"SINGLE 5883-5885(1)\",\"SINGLE 5901-5902-5908(2)\",\"SINGLE 5901-5902-5909(1)\",\n\"SINGLE 60040-6216-60041(2)\",\"SINGLE 60040-6216-60043(1)\",\"SINGLE 60040-66216-60043(1)\",\"SINGLE 60359-60360(1)\",\n\"SINGLE 60385-60384(P1)\",\"SINGLE 60404-60385(T1)\",\"SINGLE 60404-60385(T2)\",\"SINGLE 60410-6393(1)\",\n\"SINGLE 60431-60432(1)\",\"SINGLE 60433-60412(1)\",\"SINGLE 60447-60448(1)\",\"SINGLE 61011-61010(1)\",\n\"SINGLE 6201-6224(1)\",\"SINGLE 6225-6228(1)\",\"SINGLE 6235-6231(1)\",\"SINGLE 6235-6231(2)\",\n\"SINGLE 6235-6232(1)\",\"SINGLE 6253-6255(1)\",\"SINGLE 6258-6260(1)\",\"SINGLE 6310-6309(1)\",\n\"SINGLE 6353-6355(1)\",\"SINGLE 6359-6390(1)\",\"SINGLE 6363-6364(1)\",\"SINGLE 6363-6364(2)\",\n\"SINGLE 6364-6365(1)\",\"SINGLE 6444-6442-60769(2)\",\"SINGLE 6444-6442-6295(1)\",\"SINGLE 6462-6464(1)\",\n\"SINGLE 6468-6470(1)\",\"SINGLE 6478-6480(1)\",\"SINGLE 6550-6562(1)\",\"SINGLE 6556-76013(1)\",\n\"SINGLE 6565-6564(1)\",\"SINGLE 6578-76579(1)\",\"SINGLE 6601-6598(1)\",\"SINGLE 6601-6598(2)\",\n\"SINGLE 6613-6615(1)\",\"SINGLE 6628-6630(1)\",\"SINGLE 6636-6260(2)\",\"SINGLE 6653-6655(1)\",\n\"SINGLE 6672-6680(1)\",\"SINGLE 6678-6680(2)\",\"SINGLE 70197-70198(1)\",\"SINGLE 7040-9328-9329(1)\",\n\"SINGLE 7040-9328-9330(2)\",\"SINGLE 7042-7180-77180(3)\",\"SINGLE 7042-7180-7832(1)\",\"SINGLE 7042-7180-7834(2)\",\n\"SINGLE 7044-7178-77044(T3)\",\"SINGLE 7044-7178-7822(2)\",\"SINGLE 7046-7150-77154(5)\",\"SINGLE 7046-7152-77152(4)\",\n\"SINGLE 70480-7148(1)\",\"SINGLE 70484-70493(1)\",\"SINGLE 70499-70498(1)\",\"SINGLE 7050-7680-77680(2)\",\n\"SINGLE 7050-7680-77683(1)\",\"SINGLE 7057-7286-7853(2)\",\"SINGLE 7058-7289-77289(4)\",\"SINGLE 7058-7289-7838(3)\",\n\"SINGLE 7074-77074(1)\",\"SINGLE 7093-7087(1)\",\"SINGLE 7119-7120(1)\",\"SINGLE 7121-7127(1)\",\n\"SINGLE 7130-7132(1)\",\"SINGLE 7191-7192(1)\",\"SINGLE 7216-7215-7217(3)\",\"SINGLE 7223-7224(1)\",\n\"SINGLE 7248-7247(3)\",\"SINGLE 7257-7258(1)\",\"SINGLE 7269-7270(1)\",\"SINGLE 7315-7314(1)\",\n\"SINGLE 7340-7336-77340(1)\",\"SINGLE 7340-7336-77341(2)\",\"SINGLE 7345-7346(1)\",\"SINGLE 7410-7751(1)\",\n\"SINGLE 7415-7149(1)\",\"SINGLE 7439-7438(1)\",\"SINGLE 7439-7438(2)\",\"SINGLE 7587-7237(1)\",\n\"SINGLE 7597-7595(1)\",\"SINGLE 76000-76595-76998(1)\",\"SINGLE 76000-76595-76999(2)\",\"SINGLE 76009-76011-77280(2)\",\n\"SINGLE 76009-76011-77281(1)\",\"SINGLE 7617-7621(2)\",\"SINGLE 7619-7613(1)\",\"SINGLE 7626-7245(1)\",\n\"SINGLE 76389-7394(3)\",\"SINGLE 76389-7395(2)\",\"SINGLE 77306-7306-77308(1)\",\"SINGLE 77306-7306-77309(2)\",\n\"SINGLE 7770-7170-7771(1)\",\"SINGLE 7770-7170-7772(2)\",\"SINGLE 78118-78106(1)\",\"SINGLE 78118-78106(2)\",\n\"SINGLE 78190-7244(1)\",\"SINGLE 79500-79600-79598(1)\",\"SINGLE 79500-79600-79599(2)\",\"SINGLE 80119-8992(1)\",\n\"SINGLE 80119-8992(2)\",\"SINGLE 80137-8966-80139(2)\",\"SINGLE 80137-8974-80140(3)\",\"SINGLE 80219-80221(1)\",\n\"SINGLE 80219-80221(2)\",\"SINGLE 8044-8666(1)\",\"SINGLE 8100-8102(1)\",\"SINGLE 8119-8121(1)\",\n\"SINGLE 8121-8123(1)\",\"SINGLE 8164-8162-8160(1)\",\"SINGLE 8164-8162-8181(2)\",\"SINGLE 8183-89450(1)\",\n\"SINGLE 8184-8186(1)\",\"SINGLE 8231-8234(1)\",\"SINGLE 8238-80081(1)\",\"SINGLE 8255-8257(2)\",\n\"SINGLE 8280-8283(1)\",\"SINGLE 8289-8314(2)\",\"SINGLE 8310-8314(2)\",\"SINGLE 8317-8314-8328(1)\",\n\"SINGLE 8318-8319-80148(2)\",\"SINGLE 8318-8319-8336(1)\",\"SINGLE 8327-8325(1)\",\"SINGLE 8377-8380(1)\",\n\"SINGLE 8383-88381-8341(1)\",\"SINGLE 8383-88382(2)\",\"SINGLE 8397-8399(1)\",\"SINGLE 8416-8418(1)\",\n\"SINGLE 8427-8430(1)\",\"SINGLE 8432-8434(1)\",\"SINGLE 8432-8434(2)\",\"SINGLE 8439-8441(1)\",\n\"SINGLE 8448-8452(1)\",\"SINGLE 8448-8452(2)\",\"SINGLE 8455-84521-8499(1)\",\"SINGLE 8455-84522-8502(2)\",\n\"SINGLE 8468-8470(1)\",\"SINGLE 8469-8467(1)\",\"SINGLE 85000-85001(1)\",\"SINGLE 85007-85001(1)\",\n\"SINGLE 8512-8514(1)\",\"SINGLE 8528-8859-89413(T1)\",\"SINGLE 8532-8380(2)\",\"SINGLE 8622-8962(1)\",\n\"SINGLE 8659-8660(1)\",\"SINGLE 8659-8674(2)\",\"SINGLE 8797-8793(1)\",\"SINGLE 88337-8735(1)\",\n\"SINGLE 88337-8735(2)\",\"SINGLE 8949-8951(1)\",\"SINGLE 8956-8961-89612(1)\",\"SINGLE 8956-8961-89616(1)\",\n\"SINGLE 8960-8961(1)\",\"SINGLE 8997-8495(1)\",\"SINGLE 9044-9045-90001(1)\",\"SINGLE 9044-9045-90007(2)\",\n\"SINGLE 9048-9071-90002(1)\",\"SINGLE 9048-9071-90003(2)\",\"SINGLE 9074-9075-77075(3)\",\"SINGLE 9074-9075-9078(1)\",\n\"SINGLE 9074-9075-9081(2)\",\"SINGLE 9077-9080-90004(1)\",\"SINGLE 9118-9119-90005(1)\",\"SINGLE 9122-9125-90006(1)\",\n\"SINGLE 9128-9129-9130(1)\",\"SINGLE 975-32859-978(1)\"}\nif s1 in e3set or s2 in e3set: return \"ERCOT3\"\nif s1 in p3set or s2 in p3set: return \"P3\"\nreturn \"P6\"\n# Delete columns from csv file\ndef csv_keep(fname, cols):\nfname_ext = fname[fname.rfind(\".\"):]\nfname_temp = fname.replace(fname_ext, \"_TEMP\" + fname_ext)\nf = open(fname,\"r\")\ng = open(fname_temp,\"w\")\nfor line in f:\ns = line.replace(\"\\n\",\"\").split(\",\")\ns = \",\".join([s[i] for i in cols])\ng.write(s + \"\\n\")\nf.close()\ng.close()\n# Delete old (read) file\nos.remove(fname)\n# Rename new (write) file\nos.rename(fname_temp, fname)\n# Main loop\nif __name__ == '__main__':\ntry:\nmain()\nexcept KeyboardInterrupt:\npool.terminate()\ncleanup()\n=========================================================\nimport sys\nimport os\nimport datetime\nimport csv\nimport math\n\"\"\"\nThis block of code is used for initializing PSSE and running it from Python\n\"\"\"\n\"\"\"\nsys_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSPY39']\nenv_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSBIN',"
  },
  {
    "id": "chunk_095",
    "text": "r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSLIB',\n]\nfor path in sys_paths:\nsys.path.append(path)\nfor path in env_paths:\nos.environ['PATH'] = os.environ['PATH'] + ';' +  path\nimport psse35\nimport psspy\nierr = psspy.psseinit()\n\"\"\"\ndef text2csv(mytextfile, myaccfiles):\nimport os\nimport csv\n#++++++ Consider condensing triggers into one variable\nnPTrigger = \"PTI INTERACTIVE POWER SYSTEM SIMULATOR\"\ntTrigger = \"CONTINGENCY CASE MONITORED BRANCHES AND INTERFACES LOADED ABOVE\"\nvHTrigger = \"CONTINGENCY CASE BUSES WITH VOLTAGE GREATER THAN\"\nvLTrigger = \"CONTINGENCY CASE BUSES WITH VOLTAGE LESS THAN\"\nvDTrigger1 = \"CONTINGENCY CASE BUSES WITH VOLTAGE RISE BEYOND\"\nvDTrigger2 = \"CONTINGENCY CASE BUSES WITH VOLTAGE DROP BEYOND\"\nNCTrigger = \"NON-CONVERGED CONTINGENCIES REPORT\"\nAFTrigger = \"OUTPUT FILE:\"\nemptydata1 = \"..............................................\"\nemptydata2 = \"---------------\"\n#Text file results\nAF = []\ntResults = []\nvResults = []\nvDResults = []\nncResults = []\n#Final Results for writing to csv\nfinalT = []\nfinalV = []\nfinalVD = []\nfinalNC = []\n#Read the whole text file\nwith open(mytextfile, 'r') as myfile:\nwfile = myfile.readlines()\n#Create output files\nfdir = os.path.dirname(myaccfiles[0])\ntcsv = fdir + \"\\\\Thermal.csv\"\nfex = True\ncount = 1\nwhile fex:\nif os.path.isfile(tcsv):\ntcsv = fdir + \"\\\\Thermal_\" + str(count) + \".csv\"\nelse:\nfex = False\ncount = count + 1\nvdcsv = fdir + \"\\\\VoltageDev.csv\"\nfex = True\ncount = 1\nwhile fex:\nif os.path.isfile(vdcsv):\nvdcsv = fdir + \"\\\\VoltageDev_\" + str(count) + \".csv\"\nelse:\nfex = False\ncount = count + 1\nvcsv = fdir + \"\\\\Voltage.csv\"\nfex = True\ncount = 1\nwhile fex:\nif os.path.isfile(vcsv):\nvcsv = fdir + \"\\\\Voltage_\" + str(count) + \".csv\"\nelse:\nfex = False\ncount = count + 1\nncsv = fdir + \"\\\\NonConv.csv\"\nfex = True\ncount = 1\nwhile fex:\nif os.path.isfile(ncsv):\nncsv = fdir + \"\\\\NonConv_\" + str(count) + \".csv\"\nelse:\nfex = False\ncount = count + 1\n#Read all accfiles for names and write title to final results\nTTitle = [\"Contingency\", \"Branch\"]\nVTitle = [\"Contingency\", \"Bus\"]\nNCTitle = [\"Contingency\",]\nfor a in myaccfiles:\nTTitle.append(os.path.basename(a))\nVTitle.append(os.path.basename(a))\nNCTitle.append(os.path.basename(a))\nfinalT.append(TTitle)\nfinalV.append(VTitle)\nfinalVD.append(VTitle)\nfinalNC.append(NCTitle)\ndataFound = 0\ncount = 0\nfor l in wfile:\nif nPTrigger in l:\ndataFound = 0\nelse:\nif dataFound:\nif dataFound == 1 and count == 9:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\ntResults.append(l)\nelif dataFound == 2 and count == 8:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nvResults.append(l)\nelif dataFound == 3 and count == 7:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nvDResults.append(l)\nelif dataFound == 4 and count == 9:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nncResults.append(l)\nelse:\ncount = count + 1\nelse:\nif AFTrigger in l:\ndud, filename = l.split(\": \")\nAF.append(filename)\nelif tTrigger in l:\ndataFound = 1\ncount = 1\nelif vHTrigger in l or vLTrigger in l:\ndataFound = 2\ncount = 1\nelif vDTrigger1 in l or vDTrigger2 in l:\ndataFound = 3\ncount = 1\nelif NCTrigger in l:\ndataFound = 4\ncount = 1\nfor r in range(0, len(tResults), 2):\nnewr1 = tResults[r].split(\"|\")\nnewr2 = tResults[r+1].split(\"|\")\nline = newr1[0][0:26]+newr2[0][:-2]\ncont = newr1[1].strip()+newr2[1].strip()\nflows = newr1[2:]\nresult = [cont, line]\nflows = map(str.strip,flows)\nflows = map(lambda each:each.replace(\"%\", \"\"), flows)\nflows = list(flows)\nresult.extend(flows[:-1])\nfinalT.append(result)\nfor r in range(0, len(vResults)):\nnewr1 = vResults[r].split(\"|\")\nbus = newr1[0][:-1]\ncont = newr1[1].strip()\npus = newr1[2:]\nresult = [cont, bus]\npus = map(str.strip,pus)\npus = list(pus)\nresult.extend(pus[:-1])\nfinalV.append(result)\nfor r in range(0, len(vDResults)):\nnewr1 = vDResults[r].split(\"|\")\nbus = newr1[0][:-1]\ncont = newr1[1].strip()\npus = newr1[2:]\nresult = [cont, bus]\npus = map(str.strip,pus)\npus = list(pus)\nresult.extend(pus[:-1])\nfinalVD.append(result)\nfor n in range(0, len(ncResults)):\nnewn = ncResults[n].split(\"|\")\ncont = newn[0].strip()\nncds = newn[1:]\nresult = [cont, ]\nncds = map(str.strip, ncds)\nncds = list(ncds)\nresult.extend(ncds[:-1])\nfinalNC.append(result)\nmyfile = open(tcsv, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalT)\nmyfile = open(vdcsv, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalVD)\nmyfile = open(vcsv, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalV)\nmyfile = open(ncsv, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalNC)\n#Run this line if the program is being run\nif __name__ == \"__main__\":\nmyaccfiles = [\nr\"GINR_Steady_State\\20SSWG_2022_WIN2_U4_FINAL_10222021_P5.acc\",\nr\"GINR_Steady_State\\21SSWG_2022_FAL2_U1_FINAL_10222021_P5.acc\",\nr\"GINR_Steady_State\\21SSWG_2022_SUM1_U1_FINAL_10222021_P5.acc\"\n]\nmytextfile = r\"GINR_Steady_State\\Results_6.txt\"\ntext2csv(mytextfile, myaccfiles)\n# -*- coding: utf-8 -*-\n\"\"\"\nThis code combines two contingency files into one.  Most useful for making P3\nand P6 contingency files for steady state analysis\n\"\"\"\nfrom collections import OrderedDict\nimport ctgx\nimport os\ndef makecon(file1, file2):\n\"\"\"\nThis module combines two contingency files into one\nIt uses the ctgx program to extract information from the contingency file\n\"\"\"\n#Create variable to store new contingencies\nNm2 = OrderedDict()\n#Read files and extract contingency data\ncontsf1 = ctgx.conextract(file1)\ncontsf2 = ctgx.conextract(file2)\n#Create keys to loop through\nkey1 = contsf1.keys()\nkey2 = contsf2.keys()\n#Loop through combining contingencies into one\nfor k1 in key1:\nfor k2 in key2:\nnewname = k1 + \"+\" + k2\nnewname.replace(\"DB_ID\", \"\")\nNm2Conts = list(contsf2[k2])\nNm2Conts.extend(contsf1[k1])\nNm2[newname] = Nm2Conts\n#Create output file\nf1name = os.path.basename(file1)\nf2name = os.path.basename(file2)\nfdir = os.path.dirname(file1)\nnewfile = fdir +\"\\\\\" + f1name.strip(\".con\") + \"_\" + f2name\nwith open(newfile, 'w') as newcon:\nfor cont, events in Nm2.items():\nnewcon.write(\"CONTINGENCY '\" + cont + \"'\\n\")\nfor e in events:\nnewcon.write(\"  \" + e +\"\\n\")\nnewcon.write(\"END\\n\")\nnewcon.write(\"END\\n\")\nreturn newfile\nif __name__ == \"__main__\":\nmyfile1 = r\"C:\\Users\\NOBERSKI\\Documents\\Code_Development\\ContingencyWork\\test.con\"\nmyfile2 = r\"C:\\Users\\NOBERSKI\\Documents\\Code_Development\\ContingencyWork\\SUM_P1.con\"\nnewfile = makecon(myfile1, myfile2)\n#These commented lines are for code testing\n\"\"\"\nfor key, data in newfile.iteritems():\nprint key\nfor d in data:\nprint d\n\"\"\"\n\"\"\"\nThis file is for running consecutive ACCC with one contingency file input\n\"\"\"\n\"\"\"\nImport the necessary modules to be used in the code\n\"\"\"\nimport sys\nimport os\nimport time\n\"\"\"\nThis block of code is used for initializing PSSE and running it from Python\n\"\"\"\nsys_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSPY39']\nenv_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSBIN',\nr'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSLIB',\n]\nfor path in sys_paths:\nsys.path.append(path)\nfor path in env_paths:\nos.environ['PATH'] = os.environ['PATH'] + ';' +  path\nimport psse35\nimport psspy\nimport wx\nierr = psspy.psseinit()\ndef grandperformance(cases, confile, monfile, subfile):\n\"\"\"\nThis module performs creates necessary files, performs the dfax, performs the"
  },
  {
    "id": "chunk_096",
    "text": "ACCC run, and creats a report of the results\n\"\"\"\nimport psspy\nimport CSV_Results_Rev1\nconname = os.path.basename(confile).strip(\".con\")\ndfxfiles = []\nfor case in cases:\ncase = case.strip(\".sav\")\ncase = case + \"_\" + conname + \".dfx\"\ndfxfiles.append(case)\naccfiles = []\nfor case in cases:\ncase = case.strip(\".sav\")\ncase = case + \"_\" + conname + \".acc\"\naccfiles.append(case)\nrfile = os.path.dirname(case)\nr1file = rfile + \"\\\\Results.txt\"\nfex = True\ncount = 1\nwhile fex:\nif os.path.isfile(r1file):\nr1file = rfile + \"\\\\Results_\" + str(count) + \".txt\"\nelse:\nfex = False\ncount = count + 1\n#+++ Make these options available in the GUI\n#Option functions for ACCC\noptacc = [\n0, #Tap adjustments 0=disable 1=enable stepping 2=enable direct\n0, #Interchange 0=disable 1=enable tie flow only 2=enable tie and loads\n0, #Phase shift 0=disable 1=enable\n1, #dc tap 0=disable 1=enable\n1, #switched shunt 0=disable 1=enable 2=enable continuous\n1, #solution flag 0=FDNS 1=FNSL 2=optimized FDNS\n0, #Non-divergent 0=disable 1=enable\n0, #induction motor 0=stall 1=trip\n0, #induction failure 0=treat contingency as non-converage 1=treak contingency as solved if it converges\n0, #dispatch mode 0=disable\n0, #zip archive 0=do not write ZIP 1=write a ZIP\n]\n#Option functions for DFAX\noptdfax = [\n1, #distribution factor flag\n0, #calculate distribution factors\n0, #out-of-service branch flag\n]\n#Empty variable for use in functions where no input is needed\nempty = \"\"\nfor case, dfxfile, accfile in zip(cases, dfxfiles, accfiles):\n\"\"\"\nRedirect outputs to a log file for later analysis\n\"\"\"\n#Create log file from case name\nlogfile = case.strip(\".sav\")\nlogfile = logfile + \"_\" + conname + \".log\"\npsspy.alert_output(2, logfile, [0, 0])\npsspy.progress_output(2, logfile, [0, 0])\n\"\"\"\nPerform DFAX and ACCC\n\"\"\"\npsspy.case(case)\n#Change max interations - Has to be called after a case is loaded\n#+++ Give the user the ability to change this\npsspy.solution_parameters_4(intgar2=40)\npsspy.dfax_2(optdfax, subfile, monfile, confile, dfxfile)\npsspy.accc_with_dsp_3(0.5, optacc, empty, dfxfile, accfile, empty, empty, empty)\n\"\"\"\nCreate report from ACCC runs using these options\n\"\"\"\nreport_opt = [\n1,  #Column headings 1=accfile name 0=casefile name\n1,  #Base Case Rating set 1=RateA 2=RateB 3=RateC\n2,  #Contingency Case Rating 1=RateA 2=RateB 3=RateC\n1,  #Base Case Voltage Limit 1=Normal 2=Emergency\n2,  #Contingency case voltage limit 1=Normal 2=Emergency\n0,  #Print Monitored Elements Summary 0=No 1=Yes\n0,  #Print Missing Monioted Elements Report 0=No 1=Yes\n0,  #Print missing monitored voltages 0 = No 1=Yes\n0,  #Print Contingency Legend 0=No 1=Master 2=reduced 3=both master and reduced\n0,  #Print missing contingencies 0=No 1=Yes\n1,  #Print non-converged report 0=No 1=Yes\n2,  #Print loading violation 0=no 1=base case and worst 2=base case and all violations 3=All\n2,  #Print voltage vilation 0=no 1=basecase and worst 2=base case and all violations 3=All\n1,  #Interface loading violations 0=exclude 1=check and report\n1,  #Exclude monitored branches violations in base case from contingency report 0=no 1=yes\n1   #Exclude monitored buses violations in base case from contingency report 0=no 1=yes\n]\nreport_vals = [\n0.5,    #Bus mismatch converge tolerance\n5.0,    #System mismatch converge tolerance\n100,     #Percent flow for report violations\n100,     #Percent flor for reporting violatinos for worst\n0,      #Min contingency flow change from basecase for reporting\n0,      #Min contingency case percentloading increase from basecase for reporting\n0       #Min contingency case voltage change for reporting\n]\npsspy.lines_per_page_one_device(1,100000)\npsspy.report_output(2, r1file, [0, 0])\npsspy.accc_multiple_run_report_2(report_opt, report_vals , len(accfiles), accfiles)\n#Output results to .csv files\nCSV_Results_Rev1.text2csv(r1file, accfiles)\nclass EasyPanel(wx.Panel):\n\"\"\"\nThis panel is placed on the window and contains all the GUI items\n\"\"\"\ndef __init__(self, parent):\nwx.Panel.__init__(self, parent)\n#Setup panel items\ncaseboxsize = (300,325)\npboxsize = (400, 150)\niboxsize = (200, 35)\nboxlabel = wx.StaticBox(self, label=\"Cases:\")\ninputlabel = wx.StaticBox(self, label=\"Input Files:\")\nprogresslabel = wx.StaticBox(self, label=\"Progress:\")\nsubst = wx.StaticText(self, label='  sub file:')\nmonst = wx.StaticText(self, label='  mon file:')\nconst = wx.StaticText(self, label='  N-1 file:')\nconn1st = wx.StaticText(self, label='  1st N-1 file:')\nconn2st = wx.StaticText(self, label='  2nd N-1 file:')\nself.casetxt = wx.TextCtrl(self, style=wx.TE_MULTILINE, size=caseboxsize)\nself.subtxt = wx.TextCtrl(self, size=iboxsize)\nself.montxt = wx.TextCtrl(self, size=iboxsize)\nself.contxt = wx.TextCtrl(self, size=iboxsize)\nself.conn1txt = wx.TextCtrl(self, size=iboxsize)\nself.conn2txt = wx.TextCtrl(self, size=iboxsize)\nself.progresstext = wx.TextCtrl(self, value='Select Cases and input files', size=pboxsize)\nself.casebtn = wx.Button(self, label='Select Cases')\nself.subbtn = wx.Button(self, label='...')\nself.monbtn = wx.Button(self, label='...')\nself.conbtn = wx.Button(self, label='...')\nself.conn1btn = wx.Button(self, label='...')\nself.conn2btn = wx.Button(self, label='...')\nself.runbtn = wx.Button(self, label='Run')\nself.cancelbtn = wx.Button(self, -1, label='Cancel')\nself.optbtn = wx.Button(self, -1, label='Options')\nself.helpbtn = wx.Button(self, -1, label=\"Help\")\n#Setup Fonts and Color\nboxFont = wx.Font(14, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL, False)\nself.SetBackgroundColour((0, 39, 76))\nself.casebtn.SetFont(boxFont)\nself.subbtn.SetFont(boxFont)\nself.monbtn.SetFont(boxFont)\nself.conbtn.SetFont(boxFont)\nself.conn1btn.SetFont(boxFont)\nself.conn2btn.SetFont(boxFont)\nself.runbtn.SetFont(boxFont)\nself.cancelbtn.SetFont(boxFont)\nself.optbtn.SetFont(boxFont)\nself.helpbtn.SetFont(boxFont)\nsubst.SetFont(boxFont)\nmonst.SetFont(boxFont)\nconst.SetFont(boxFont)\nconn1st.SetFont(boxFont)\nconn2st.SetFont(boxFont)\nboxlabel.SetFont(boxFont)\nboxlabel.SetForegroundColour((255, 255, 255))\ninputlabel.SetFont(boxFont)\ninputlabel.SetForegroundColour((255, 255, 255))\nprogresslabel.SetFont(boxFont)\nprogresslabel.SetForegroundColour((255, 255, 255))\nsubst.SetForegroundColour((255, 255, 255))\nmonst.SetForegroundColour((255, 255, 255))\nconst.SetForegroundColour((255, 255, 255))\nconn1st.SetForegroundColour((255, 255, 255))\nconn2st.SetForegroundColour((255, 255, 255))\n#SetupSizer to make everything fit on the panel and to create\n#a panel that is the minimum size capable\nself.caseboxsizer = wx.StaticBoxSizer(boxlabel, wx.VERTICAL)\nself.casesizer = wx.BoxSizer(wx.VERTICAL)\nself.casesizer.Add(self.casetxt, 0, wx.ALL|wx.CENTER, 2)\nself.casesizer.Add(self.casebtn, 0, wx.ALL|wx.CENTER, 2)\nself.caseboxsizer.Add(self.casesizer, 0, wx.ALL|wx.CENTER, 5)\nself.inputfilesizer = wx.StaticBoxSizer(inputlabel, wx.VERTICAL)\nself.filesizer = wx.FlexGridSizer(5, 3, 5, 5)\nself.filesizer.Add(subst, 0, border=5)\nself.filesizer.Add(self.subtxt, 0, border=5)\nself.filesizer.Add(self.subbtn, 0, border=5)\nself.filesizer.Add(monst, 0, border=5)\nself.filesizer.Add(self.montxt, border=5)\nself.filesizer.Add(self.monbtn, border=5)\nself.filesizer.Add(const, border=5)\nself.filesizer.Add(self.contxt, border=5)\nself.filesizer.Add(self.conbtn, border=5)\nself.filesizer.Add(conn1st, border=5)\nself.filesizer.Add(self.conn1txt, border=5)\nself.filesizer.Add(self.conn1btn, border=5)\nself.filesizer.Add(conn2st, border=5)\nself.filesizer.Add(self.conn2txt, border=5)\nself.filesizer.Add(self.conn2btn, border=5)\nself.inputfilesizer.Add(self.filesizer, 0, wx.ALL|wx.CENTER, 5)\nself.progresssizer = wx.StaticBoxSizer(progresslabel, wx.VERTICAL)\nself.progresssizer.Add(self.progresstext, 0, wx.ALL|wx.CENTER, 5)\nself.analysissizer = wx.BoxSizer(wx.HORIZONTAL)\nself.analysissizer.Add(self.runbtn, 0, wx.ALL, 5)\nself.analysissizer.Add(self.optbtn, 0, wx.ALL, 5)\nself.analysissizer.Add(self.cancelbtn, 0, wx.ALL, 5)\nself.analysissizer.Add(self.helpbtn, 0, wx.ALL, 5)\nself.rightsizer = wx.BoxSizer(wx.VERTICAL)\nself.rightsizer.Add(self.inputfilesizer, 0, wx.ALIGN_CENTER)\nself.rightsizer.Add(self.progresssizer, 0, wx.ALIGN_CENTER)\nself.rightsizer.Add(self.analysissizer, 0, wx.ALL|wx.ALIGN_CENTER, 10)\nself.myboxsizer = wx.BoxSizer(wx.HORIZONTAL)\nself.myboxsizer.Add(self.caseboxsizer)\nself.myboxsizer.Add(self.rightsizer)\nself.SetSizer(self.myboxsizer)\nclass EasyGuy(wx.Frame):\n\"\"\"\nThis class creates the window frame and creates all the events based on\nuser button presses to allow inputs\n\"\"\"\ndef __init__(self):\nwx.Frame.__init__(self, None, title='GINR Steady State')\nself.panel = EasyPanel(self)\nwindowsizer = wx.BoxSizer(wx.VERTICAL)\nwindowsizer.Add(self.panel)\nself.Fit()\nself.SetSizer(windowsizer)\nself.Fit()\nself.Show()\n#Create all the binding events to the GUI buttons\nself.panel.Bind(wx.EVT_BUTTON, self.CaseSelect, self.panel.casebtn)\nself.panel.Bind(wx.EVT_BUTTON, self.MonSelect, self.panel.monbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.ConSelect, self.panel.conbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.Conn1Select, self.panel.conn1btn)\nself.panel.Bind(wx.EVT_BUTTON, self.Conn2Select, self.panel.conn2btn)\nself.panel.Bind(wx.EVT_BUTTON, self.SubSelect, self.panel.subbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.Run, self.panel.runbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.Cancel, self.panel.cancelbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.Options, self.panel.optbtn)\nself.panel.Bind(wx.EVT_BUTTON, self.Help, self.panel.helpbtn)\ndef CaseSelect(self, event):\n\"\"\"\nThis module allows the user to select the cases that they would like\nto perform a contingency analysis on\n\"\"\"\nwith wx.FileDialog(self, \"Open SAV file\", wildcard=\"SAV files (*.sav)|*.sav\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST | wx.FD_MULTIPLE) as fileDialog:"
  },
  {
    "id": "chunk_097",
    "text": "if fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.cases = fileDialog.GetPaths()\ncaseout = \"\"\nnewcases = []\n#The two for statements are needed for printing the selected cases\n#to the GUI and for maintaining order for reporting purposes\nfor case in self.cases:\nnewcases.append(str(case))\nfor case in newcases:\ncaseout = caseout + str(os.path.basename(case)) + \"\\n\"\nself.panel.casetxt.SetValue(caseout)\nself.cases = newcases\ndef MonSelect(self, event):\n\"\"\"\nThis module allows the user to select the .mon file\n\"\"\"\nwith wx.FileDialog(self, \"Open MON file\", wildcard=\"MON files (*.mon)|*.mon\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:\nif fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.monfile = str(fileDialog.GetPath())\nself.panel.montxt.SetValue(os.path.basename(self.monfile))\ndef SubSelect(self, event):\n\"\"\"\nThis module allows the user to select the .sub file\n\"\"\"\nwith wx.FileDialog(self, \"Open SUB file\", wildcard=\"SUB files (*.sub)|*.sub\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:\nif fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.subfile = str(fileDialog.GetPath())\nself.panel.subtxt.SetValue(os.path.basename(self.subfile))\ndef ConSelect(self, event):\n\"\"\"\nThis module allows the user to select the N-1 .con file\n\"\"\"\nwith wx.FileDialog(self, \"Open CON file\", wildcard=\"CON files (*.con)|*.con\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:\nif fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.confile = str(fileDialog.GetPath())\nself.panel.contxt.SetValue(os.path.basename(self.confile))\ndef Conn1Select(self, event):\n\"\"\"\nThis module allows the user to select the first N-2 .con file\n\"\"\"\nwith wx.FileDialog(self, \"Open CON file\", wildcard=\"CON files (*.con)|*.con\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:\nif fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.conn1file = str(fileDialog.GetPath())\nself.panel.conn1txt.SetValue(os.path.basename(self.conn1file))\ndef Conn2Select(self, event):\n\"\"\"\nThis module allows the user to select the second N-2 .con file\n\"\"\"\nwith wx.FileDialog(self, \"Open CON file\", wildcard=\"CON files (*.con)|*.con\", style=wx.FD_OPEN | wx.FD_FILE_MUST_EXIST) as fileDialog:\nif fileDialog.ShowModal() == wx.ID_CANCEL:\nreturn\nself.conn2file = str(fileDialog.GetPath())\nself.panel.conn2txt.SetValue(os.path.basename(self.conn2file))\ndef Run(self, event):\n\"\"\"\nThis module allows the user to select the .mon file\n\"\"\"\nself.panel.progresstext.SetValue(\"Performing N-1 Analysis. See .log files.\")\ntime.sleep(5)\ngrandperformance(self.cases, self.confile, self.monfile, self.subfile)\nif hasattr(self, 'conn1file') & hasattr(self, 'conn2file'):\nimport CombineConts\nNm2Con = CombineConts.makecon(self.conn1file, self.conn2file)\ngrandperformance(self.cases, Nm2Con, self.monfile, self.subfile)\nself.panel.progresstext.SetValue(\"Analysis Complete :) See CSV Files\")\ndef Cancel(self, event):\n\"\"\"\nThis module closes the program\n\"\"\"\nsys.exit()\ndef Options(self, event):\n\"\"\"\nThis module is a place holder for future revisions\n\"\"\"\nself.panel.progresstext.SetValue(\"This Option is not available yet.\")\ndef Help(self, event):\n\"\"\"\nThis module opens the help button\n\"\"\"\nos.startfile(r\"\\\\wins.XXX.org\\data\\BTC\\Shared\\data\\SA\\DVAR_Planning\\PYTHON_SCRIPTS\\GINR_Steady_State\\GINR Steady State Help Document.pdf\")\napp = wx.App(False)\nframe = EasyGuy()\napp.MainLoop()\nmyaccfiles = [\nr\"GINR_Steady_State\\20SSWG_2022_WIN2_U4_FINAL_10222021_P5.acc\",\nr\"GINR_Steady_State\\21SSWG_2022_FAL2_U1_FINAL_10222021_P5.acc\",\nr\"GINR_Steady_State\\21SSWG_2022_SUM1_U1_FINAL_10222021_P5.acc\"\n]\nmytextfile = r\"GINR_Steady_State\\Results_6.txt\"\nfullresults = False\n#++++++ Consider condensing triggers into one variable\nnPTrigger = \"PTI INTERACTIVE POWER SYSTEM SIMULATOR\"\ntTrigger = \"CONTINGENCY CASE MONITORED BRANCHES AND INTERFACES LOADED ABOVE\"\nvHTrigger = \"CONTINGENCY CASE BUSES WITH VOLTAGE GREATER THAN\"\nvLTrigger = \"CONTINGENCY CASE BUSES WITH VOLTAGE LESS THAN\"\nvDTrigger1 = \"CONTINGENCY CASE BUSES WITH VOLTAGE RISE BEYOND\"\nvDTrigger2 = \"CONTINGENCY CASE BUSES WITH VOLTAGE DROP BEYOND\"\nNCTrigger = \"NON-CONVERGED CONTINGENCIES REPORT\"\nAFTrigger = \"OUTPUT FILE:\"\nemptydata1 = \"..............................................\"\nemptydata2 = \"---------------\"\n#Text file results\nAF = []\ntResults = []\nvResults = []\nvDResults = []\nncResults = []\n#Final Results for .acc search\nfinalT = []\nfinalV = []\nfinalVD = []\nfinalNC = []\n#Variable to store and get data from ACCC files\nTacc = []\nVacc = []\nVDacc = []\nNCacc = []\nimport sys\nimport os\nimport datetime\nimport csv\nimport math\nprint(datetime.datetime.now().time())\n\"\"\"\nThis block of code is used for initializing PSSE and running it from Python\n\"\"\"\nsys_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSPY39']\nenv_paths = [r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSBIN',\nr'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSLIB',\n]\nfor path in sys_paths:\nsys.path.append(path)\nfor path in env_paths:\nos.environ['PATH'] = os.environ['PATH'] + ';' +  path\nimport psse35\nimport psspy\nierr = psspy.psseinit()\nimport pssarrays\ndef istransformer(branch):\nv1 = branch[19:25]\nv2 = branch[45:51]\nif v1 == v2:\nxfmr = False\nelse:\nxfmr = True\nreturn xfmr, float(v1)\ndef checkflows(flows):\nfor f in flows:\nif f == \"\":\nreturn False\nreturn True\ndef checkvolt(volts):\nfor v in volts:\nif v == \"\":\nreturn False\nreturn True\ndef checknc(descs):\nfor d in descs:\nif d == \"\":\nreturn False\nreturn True\ndef findconv(afiles, adfiles, contingency):\nfullres = [contingency, ]\nfor afile, adfile in zip(afiles, adfiles):\ncouts = pssarrays.accc_solution(afile, contingency, \"contingency\", 0.5, 5.0)\nif couts:\nfullres.append(couts.cnvcond)\nelse:\nfullres.append(\"N/A\")\nreturn fullres\ndef findallbranches(afiles, adfiles, contingency, branch):\nxfmr, v = istransformer(branch)\nfullres = [contingency, branch]\nfor a, ad in zip(afiles, adfiles):\ncouts = pssarrays.accc_solution(a, contingency, \"contingency\", 0.5, 5.0)\nif couts:\nif couts.cnvflag:\nif xfmr:\ntry:\nbindex = ad.melement.index(branch)\nexcept:\nfullres.append(\"N/A\")\nbindex = -1\nif bindex >= 0:\nbflow = couts.mvaflow[bindex]\nbrating = ad.rating.b[bindex]\nbperct = round((abs(bflow/brating))*100, 1)\nbperct = str(bperct)\nfullres.append(bperct)\nelse:\ntry:\nbindex = ad.melement.index(branch)\nexcept:\nfullres.append(\"N/A\")\nbindex = -1\nif bindex >= 0:\nbflow = (couts.ampflow[bindex])/(math.sqrt(3)*(v/1000))\nbrating = (ad.rating.b[bindex])/(math.sqrt(3)*(v/1000))\nbperct = round((abs(bflow/brating))*100, 1)\nbperct = str(bperct)\nfullres.append(bperct)\nelse:\nfullres.append(\"NONCNV\")\nelse:\nfullres.append(\"N/A\")\nreturn fullres\ndef findallbuses(afiles, adfiles, contingency, bus):\nfullres = [contingency, bus]\nfor a, ad in zip(afiles, adfiles):\ncouts = pssarrays.accc_solution(a, contingency, \"contingency\", 0.5, 5.0)\nif couts:\nif couts.cnvflag:\ntry:\nbindex = ad.mvbuslabel.index(bus)\nexcept:\nfullres.append(\"N/A\")\nbindex = -1\nif bindex >= 0:\nbvpu = couts.volts[bindex]\nfullres.append(bvpu)\nelse:\nfullres.append(\"NONCNV\")\nelse:\nfullres.append(\"N/A\")\nreturn fullres\nwith open(mytextfile, 'r') as myfile:\nwfile = myfile.readlines()\n#Read all accfiles once\nadfiles = []\nTTitle = [\"Contingency\", \"Branch\"]\nVTitle = [\"Contingency\", \"Bus\"]\nNCTitle = [\"Contingency\",]\nfor a in myaccfiles:\naouts = pssarrays.accc_summary(a)\nadfiles.append(aouts)\nTTitle.append(os.path.basename(a))\nVTitle.append(os.path.basename(a))\nNCTitle.append(os.path.basename(a))\nfinalT.append(TTitle)\nfinalV.append(VTitle)\nfinalVD.append(VTitle)\nfinalNC.append(NCTitle)\ndataFound = 0\ncount = 0\nfor l in wfile:\nif nPTrigger in l:\ndataFound = 0\nelse:\nif dataFound:\nif dataFound == 1 and count == 9:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\ntResults.append(l)\nelif dataFound == 2 and count == 8:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nvResults.append(l)\nelif dataFound == 3 and count == 7:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nvDResults.append(l)\nelif dataFound == 4 and count == 9:\nif emptydata1 in l or emptydata2 in l:\npass\nelse:\nncResults.append(l)\nelse:\ncount = count + 1\nelse:\nif AFTrigger in l:\ndud, filename = l.split(\": \")\nAF.append(filename)\nelif tTrigger in l:\ndataFound = 1\ncount = 1\nelif vHTrigger in l or vLTrigger in l:\ndataFound = 2\ncount = 1\nelif vDTrigger1 in l or vDTrigger2 in l:\ndataFound = 3\ncount = 1\nelif NCTrigger in l:\ndataFound = 4\ncount = 1\nfor r in range(0, len(tResults), 2):\nnewr1 = tResults[r].split(\"|\")\nnewr2 = tResults[r+1].split(\"|\")"
  },
  {
    "id": "chunk_098",
    "text": "line = newr1[0][0:26]+newr2[0][:-2]\ncont = newr1[1].strip()+newr2[1].strip()\nflows = newr1[2:]\nresult = [cont, line]\nflows = map(str.strip,flows)\nflows = map(lambda each:each.replace(\"%\", \"\"), flows)\nflows = list(flows)\nresult.extend(flows[:-1])\nadd = checkflows(flows[:-1])\nif fullresults:\nif add:\nfinalT.append(result)\nelse:\nTacc.append(result)\nelse:\nfinalT.append(result)\nfor r in range(0, len(vResults)):\nnewr1 = vResults[r].split(\"|\")\nbus = newr1[0][:-1]\ncont = newr1[1].strip()\npus = newr1[2:]\nresult = [cont, bus]\npus = map(str.strip,pus)\npus = list(pus)\nresult.extend(pus[:-1])\nadd = checkvolt(pus[:-1])\nif fullresults:\nif add:\nfinalV.append(result)\nelse:\nVacc.append(result)\nelse:\nfinalV.append(result)\nfor r in range(0, len(vDResults)):\nnewr1 = vDResults[r].split(\"|\")\nbus = newr1[0][:-1]\ncont = newr1[1].strip()\npus = newr1[2:]\nresult = [cont, bus]\npus = map(str.strip,pus)\npus = list(pus)\nresult.extend(pus[:-1])\nadd = checkvolt(pus[:-1])\nif fullresults:\nif add:\nfinalVD.append(result)\nelse:\nVDacc.append(result)\nelse:\nfinalVD.append(result)\nfor n in range(0, len(ncResults)):\nnewn = ncResults[n].split(\"|\")\ncont = newn[0].strip()\nncds = newn[1:]\nresult = [cont, ]\nncds = map(str.strip, ncds)\nncds = list(ncds)\nresult.extend(ncds[:-1])\nadd = checknc(ncds[:-1])\nif fullresults:\nif add:\nfinalNC.append(result)\nelse:\nNCacc.append(result)\nelse:\nfinalNC.append(result)\nfor i in Tacc:\nresult = findallbranches(myaccfiles, adfiles, i[0], i[1])\nif result:\nfinalT.append(result)\nelse:\nfinalT.apend(i)\nfor i in Vacc:\nif \":\" in i[0]:\nfinalV.append(i)\nelse:\nresult = findallbuses(myaccfiles, adfiles, i[0], i[1])\nfinalV.append(result)\nfor i in VDacc:\nif \":\" in i[0]:\nfinalVD.append(i)\nelse:\nresult = findallbuses(myaccfiles, adfiles, i[0], i[1])\nfinalVD.append(result)\nfor i in NCacc:\nif \":\" in i[0]:\nfinalNC.append(i)\nelse:\nresults = findconv(myaccfiles, adfiles, i[0])\nfinalNC.append(results)\ncsvfile = r\"GINR_Steady_State\\Thermal.csv\"\nmyfile = open(csvfile, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalT)\ncsvfile = r\"GINR_Steady_State\\VoltageDev.csv\"\nmyfile = open(csvfile, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalVD)\ncsvfile = r\"GINR_Steady_State\\Voltage.csv\"\nmyfile = open(csvfile, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalV)\ncsvfile = r\"GINR_Steady_State\\NonConv.csv\"\nmyfile = open(csvfile, 'w')\nwith myfile:\nwriter = csv.writer(myfile, lineterminator = '\\n')\nwriter.writerows(finalNC)\nprint(datetime.datetime.now().time())\n\"\"\"\nThis code extracts details from a contingency file.  It does only data\nextraction and does not do anything but return the information in a list.\nOther code needs to be developed to do additional actions with the returned\nlist\nCreated by: Nicholas Oberski\n\"\"\"\nfrom collections import OrderedDict\ndef conextract(cfile):\n\"\"\"\nThe module reads the contingency file line by line and extracts the\ndata to make an ordered list of contingencies\n\"\"\"\nwith open(cfile, 'r') as myfile:\nclist = myfile.readlines()\n#Create an ordered dictionary to store contingencies\nmyconts = OrderedDict()\n\"\"\"\nfstate is used to determine where in teh contingecy search the program is\nlocated\nfstate = 0 No contingency start definition found yet\nfstate = 1 Found a contingency start definiton\n\"\"\"\nfstate = 0 #No contingency found yet\nfor l in clist:\nl = l.strip()\nif fstate == 0:\nif l.startswith(\"CONTINGENCY\") | l.startswith(\"Contingency\") | l.startswith(\"Contingency\"):\nfstate = 1 #Contingency found\nconName = l.split(\"'\")[1] #Find just contingency name\nmyconts[conName] = [] #Create contingency definistion in dictionary\nelse:\npass #Line is just a comment line, go to the next line\nelif fstate == 1:\nif l.startswith(\"END\") | l.startswith(\"End\") | l.startswith(\"end\"):\nfstate = 0 #End of contingency statement, start looking for the next one\nelse:\nmyconts[conName].append(l) #Add event to contingency definition\nreturn myconts\n#Run this line if the program is being run\nif __name__ == \"__main__\":\nmyfile = r\"C:\\Users\\NOBERSKI\\Documents\\Code_Development\\ContingencyWork\\SUM_P1.con\"\ncondict = conextract(myfile)\n#These commented lines are for code testing\n\"\"\"\nfor key, data in condict.iteritems():\nprint key\nfor d in data:\nprint d\n\"\"\"\n'''\nUncomment the line \"input()\" if you want to keep python window open after the tests are complete\n'''\ndef main(INIfn):\nimport os,sys\npy_ver = sys.version\nif py_ver.startswith('3.7'):\ntools_path = 'TOOLs(py3.7)'\nelif py_ver.startswith('3.8'):\ntools_path = 'TOOLs(py3.8)'\nelif py_ver.startswith('3.9'):\ntools_path = 'TOOLs(py3.9)'\nelse:\nprint ('Python 3.7, or 3.8, or 3.9 is needed for DMView')\nquit()\nsys.path.append(os.path.abspath(tools_path))\nfrom DMView_main import DMView_main\nDMView_main(INIfn,tools_path)\n#input(\"\\nPress any key to end the program\")\nif __name__ == '__main__':\nimport os, sys\nif len(sys.argv)>1:\ntemp = sys.argv[1]\ntemp = temp.strip()\nif len(temp)>1:\nrootfn, ext = os.path.splitext(temp)\nif len(ext)<1:\nINIfn = rootfn+'.ini'\nelse:\nINIfn = temp\nmain(INIfn)\n/for DMView\n/used with DMView.py\n[Build FS]\nBuild_SS_flag = 1        / 1: Build flat start (FS) using the tool; 0: Don't use the tool to build FS, users must build FS by themselves and provide a converted case and a snap file\n[Input files]\ninput_path = CASEs\\WIRTZ\nunconv_casefile = wirtz.sav        / unconverted case (if Build_SS_flag=1, must provide it, otherwise optional)\nconv_casefile = wirtz_cnv.sav      / converted case (if Build_SS_flag=0, must provide it, otherwise optional)\nsnapfile = wirtz.snp               / snap file (if Build_SS_flag=0, must provide it, otherwise optional)\nmodel_file_lst = ['WIRTZ.dyr']     / The list contains dyr and dll files (always provide a dll file if the model has it; dyr files are only needed if Build_SS_flag=1; obj/lib files are unaccepted with PSS/e 35), each file needs to have single quotation, use comma (no speicific order needed) for multpile files\n[Tests]\n/\n/A TEST list is comprised of two items: Test type and Test data.\n/Both items need to have single quotation.\n/\n/The first item is the test type. It can be any of the following:\n/ 1.  FS (flat start)\n/ 2.  VOLT (voltage response test, including ERUN, HVRT, LVRT and any other voltage response test)\n/ 3.  FREQ (frequency response test, including GRUN and any other frequency response test)\n/ 4.  VOLTFREQ (voltage and frequency response test)\n/ 5.  SCR (fixed SCR test), including SCR, SCR_SMALL, SCR_LARGE\n/ 6.  SCMVA (fixed SCMVA test), including SCMVA, SCMVA_SMALL, SCMVA_LARGE\n/ 7.  SCR2 (Variable SCR test)\n/ 8.  SCMVA2 (Variable SCMVA test)\n/ 9.  FAULT (fault test, intened to be applied to synchronous generators)\n/10.  CCT(Critical Clearing time test)\n/\n/The second item is the test data. Depending on the test type, the test data could be one of the following:\n/ 1. Simulation time (sec) for FS test; or\n/ 2. EXEL file for VOLT, FREQ, and VOLTFREQ test; or\n/ 3. SCR numbers (Use comma for multiple numbers) for SCR test; or\n/ 4. SCMVA numbers (Use comma for multiple numbers) for SCMVA test; or\n/ 5: A sequentail SCR numbers (Use -> for multiple numbers), time interval for each change in seconds, fault option (1: 3P fault; 0: no fault) at each change time, for SCR2 test; or"
  },
  {
    "id": "chunk_099",
    "text": "/ 6: A sequentail SCMVA numbers (Use -> for multiple numbers), time interval for each change in seconds, fault option (1: 3P fault; 0: no fault) at each change time, for SMVA2 test; or\n/ 7: Fault admittance for FAULT test; or\n/ 8: CCT test parameters for CCT test.\n/The tests can be added as many as users want.\n/The test name must start from 'Test' and each test name needs to be unique\n/Add '/' to comment out any specific test.\n/\n/Test 1 to Test 9 are ERCOT dynamic model quality tests\nTest01_FS = ['FS', '10']\n/Test02_VOLTDOWN = ['VOLT','DATAs\\\\ERCOT_VOLT-STEP-DOWN.xlsx']\n/Test03_VOLTUP = ['VOLT','DATAs\\\\ERCOT_VOLT-STEP-UP.xlsx']\nTest04_FRQDOWN = ['FREQ','DATAs\\\\ERCOT_FRQ-STEP-DOWN.xlsx']\n/Test05_FRQUP = ['FREQ','DATAs\\\\ERCOT_FRQ-STEP-UP.xlsx']\n/Test06_HVRT = ['VOLT','DATAs\\\\ERCOT_HVRT.xlsx']\n/Test07_LVRT = ['VOLT','DATAs\\\\ERCOT_LVRT.xlsx']\n/Test08_SCR2 = ['SCR2', '5->3->1.5->1.2, 5, 1'] /Variable SCR test: SCR is changed from 5 to 3 to 1.5 to 1.2, the time interval of the change is 5 seconds, 3P fault is applied at each change time.\nTest09_FAULT =['FAULT', '-2e10'] / Fault test: -2e10 is the fault admittance, it is inteneded to be applied to synchronous generators\n/\n/Test 10 to 16 are other model tests\n/Test10_MVRT = ['VOLT','DATAs\\\\ERCOT_Multi-LVRT.xlsx'] /multiple LVRT test\n/Test11_SCR = ['SCR', '5, 3, 1.5'] /Fixed SCR tests (including SCR_Large and SCR_Small) for SCR of 5, 3, and 1.5, each test is run seperatly\n/Test12_SCR = ['SCR_LARGE', '5, 3, 1.5'] /Fixed SCR_Large tests for SCR of 5, 3, and 1.5, each test is run seperatly\n/Test13_SCR = ['SCR_SMALL', '5, 3, 1.5'] /Fixed SCR_Small tests for SCR of 5, 3, and 1.5, each test is run seperatly\n/Test14_SCMVA = ['SCMVA', '5000, 3000, 1500'] /Fixed SCMVA test for SCMVA of 5000, 3000, and 1500, each test is run seperatly\n/Test15_SCMVA2 = ['SCMVA2', '5000->3000->1500->1200, 5, 1'] /Varialbe SCMVA test: SCMVA is changed from 5000 to 3000 to 1500 to 1200, the time interval of the change is 5 seconds, 3P fault is applied at each change time.\n/Test16_CCT = ['CCT','9:54:6,999'] /CCT test: a 3P fault applied to bus 999, the fault clear time range is between 9 to 54 cycles and the interval is 6 cycles.\n[Settings]\nPlot_Flag = 1 /1: plot the output file into PDF files; 0: Do not plot (default value)\nPlot_SCR_scale = [1, 6]\n/Plot_POWR_scale = [-3,3]\n/Plot_FREQ_scale = [-0.1, 0.1]\n/Plot_VARS_scale = [-1, 2]\n/Plot_VOLT_scale = [-0.1, 1.5]\n/Plot_TIELINE_scale =[-150,300]\n/Time_Step = 0.004166667 /time step(delta), in sec, 0.004166667 (default value)\n/Frq_filter_ratio = 4 /frequency filter constant, in ratio of time step, 4 (default value = 4*delta)\n/Accel_Factor =0.8 /acceleration factors, 0.8 by default\n/Max_Iter= 99 /maximum iteration, 99 by default\n/Fault_duration = 0.1 /fault duration (sec), it is only applied to SCR/SCR2/SCMVA/SCMVA2 tests\n/PSS_VER = 35.3 /PSSE version\n[info]\n/comments start from /\n/run as:\n/open _dos33 window, key in:\n/python dmview.py wind\n'''\nPRC.py (PreRequisites Check)\n'''\ndef versiontuple(v):\nreturn tuple(map(int, (v.split(\".\"))))\nimport os,sys\nimport glob\npython_path, _ = os.path.split(sys.executable)\npy_ver = sys.version.split('(')[0]\nmsg = ''\nflag = 1\ntry:\nmsg = 'Avaible PSS/e minor versions under Python '+py_ver+ ': \\n'\npsse35_lst = glob.glob(python_path + r\"\\\\Lib\\\\site-packages\\\\psse35*.py\", recursive = True) + glob.glob(python_path + r\"\\\\Lib\\\\site-packages\\\\psse35*.pyc\", recursive = True)\npsse_ver_lst = []\nfor psse35_i in psse35_lst:\npsse_ver = os.path.splitext(os.path.basename(psse35_i))[0]\nif len(psse_ver)>6:\nif psse_ver not in psse_ver_lst:\npsse_ver_lst.append(psse_ver)\nmsg = msg + '     ' + psse_ver +'\\n'\nmsg = msg + 'Please only use available PSS/e versions under Python '+ py_ver\nimport psse35\nimport psspy\npsspy.psseinit()\nexcept:\nmsg = 'PSSE 35 NOT available\\n'\nflag = 0\ntry:\nimport openpyxl\nexcept:\nmsg = msg + 'Please install openpyxl using python pip: pip install openpyxl\\n'\nflag = 0\ntry:\nimport matplotlib\nif versiontuple(matplotlib.__version__)>versiontuple(\"3.4.3\"):\nmsg = msg + 'Your matplotlib may not work with psse plot\\n'\nmsg = msg + 'Please install matplotlib (3.4.3) using python pip: pip install matplotlib==3.4.3\\n'\nflag = 0\nexcept:\nmsg = msg + 'Please install matplotlib (3.4.3) using python pip: pip install matplotlib==3.4.3\\n'\nflag = 0\nimport tkinter\nfrom tkinter import messagebox\ntop =  tkinter.Tk()\ntop.withdraw()\nif flag:\nmsg = msg + '\\n\\nDMView ready to use\\n\\n'\nmessagebox.showinfo(\"SUCCESS\",msg)\nelse:\nmessagebox.showinfo(\"ERROR!!!\",msg)\n/an example of thermal generation project (synchronous generators) for ERCOT dynamic model quality test\n[Build FS]\nBuild_SS_flag = 1\nIB_check_flag = 0\n[Input files]\ninput_path = CASEs\\Thermal\nunconv_casefile = Thermal.sav\nmodel_file_lst = ['Thermal.dyr']\n[Tests]\nTest1_FS = ['FS','10']\nTest2_VOLTDOWN = ['VOLT','DATAs\\\\ERCOT_VOLT-STEP-DOWN.xlsx']\nTest3_VOLTUP = ['VOLT','DATAs\\\\ERCOT_VOLT-STEP-UP.xlsx']\nTest4_FRQDOWN = ['FREQ','DATAs\\\\ERCOT_FRQ-STEP-DOWN.xlsx']\nTest5_FRQUP = ['FREQ','DATAs\\\\ERCOT_FRQ-STEP-UP.xlsx']\nTest6_FAULT = ['FAULT', '-2e10'] /-2e10 is the fault admittance, this test is intended to be applied to synchronous generators\n[Settings]\nPlot_Flag = 1\n@rem run3x.bat\n@echo OFF\necho %date% %time%\nSet PYTHONROOT=C:\\Users\\%username%\\AppData\\Local\\Programs\\Python\nSet PYVER=NONE\nif EXIST \"%PYTHONROOT%\\Python37\" set PYVER=37\nif EXIST \"%PYTHONROOT%\\Python38\" set PYVER=38\nif EXIST \"%PYTHONROOT%\\Python39\" set PYVER=39\nSet PYTHONHOME=%PYTHONROOT%\\Python%PYVER%\\\nSET PATH=%PYTHONHOME%;%PYTHONHOME%SCRIPTs;%PATH%\nIF %PYVER%==NONE (echo ERROR!!! Please install python 3.9 or 3.8 or 3.7) ELSE (echo PATHs set: python %PYVER%)\nif NOT EXIST \"C:\\Program Files\\PTI\\PSSE35\" echo ERROR!!! Please install PSS/e 35 at C:\\Program Files\\PTI\\PSSE35\npython dmview.py %*\n# Get Load stats with GUI\nimport wx\nimport pandas as pd\nimport pyodbc\nimport datetime\nfrom dateutil.relativedelta import relativedelta\nimport Etude\nimport copy\nimport shutil\nimport os\nimport numpy as np\nimport sys\nimport tempfile\nimport xlsxwriter\nimport pathlib\nimport glob\n#### psspy import ####\n# I'm not sure if this belongs here in this package or if this belongs in main()\nPSSE_PATH = r'C:\\Program Files\\PTI\\PSSE35\\35.3\\PSSBIN_39'\nsys.path.append(PSSE_PATH)\nos.environ['PATH'] += ';' + PSSE_PATH\nimport psspy\n########### Etude import ###########\nETUDE_PATH = os.path.dirname(__file__) # Based on this, Etude.py must be in the same directory as this script in order to import Etude\nsys.path.append(ETUDE_PATH)\nos.environ['PATH'] += ';' + ETUDE_PATH\nimport Etude\n### Create temp directory for file management ###\ntemporary_directory = tempfile.TemporaryDirectory()\ntmp_dir = temporary_directory.name\n#### Supress all the PSSE outputs for now\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #suppress progress output from PSS/E\npsspy.t_alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write t alerts from PSS/E to temp file\npsspy.alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write alerts from PSS/E to temp file\npsspy.report_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write report from PSS/E to temp file\n# list of cases to evaluate CNTB\ntarget_directory = r'E:\\NicoleL\\Planning\\SSWG\\23SSWG_U1_Cases_Logs_Reports_Pass9_09282023\\cases_and_logs'\ntarget_output_directory = r'E:\\NicoleL\\Planning\\SSWG\\23SSWG_U1_Cases_Logs_Reports_Pass9_09282023\\cases_and_logs\\CNTB_reports'\ncase_list = glob.glob(target_directory+r'\\*.raw')\n#print(case_list)\nfor case in case_list:\npsspy.read(0,case) # open case\npsspy.bsys(0,0,[0.48,345.],2,[7,907],0,[],0,[],0,[]) #set bsys to areas 7 and 907\ntemp_PSSE_output = tmp_dir+r'\\PSSE_capture.txt' #capture report output from PSS/E"
  },
  {
    "id": "chunk_100",
    "text": "psspy.report_output(2,temp_PSSE_output,0) #capture report output from PSS/E\npsspy.cntb(0,0,1,[0,0,0],[0.0,0.0]) #run CNTB\nEtude.silenceAllPSSE() #silence the output so PSSE lets go of the tempfile\n#write the report to a text document\nrawfilename = os.path.splitext(os.path.basename(case))[0]\nreportName = target_output_directory+r'\\{}_CNTB_output.txt'.format(rawfilename)\nf = open(reportName,'w')\nf.write(Etude.getFileByteData(temp_PSSE_output).decode('UTF-8'))\nf.close()\n# Get Load stats with GUI\nimport wx\nimport pandas as pd\nimport pyodbc\nimport datetime\nfrom dateutil.relativedelta import relativedelta\nimport copy\nimport shutil\nimport os\nimport numpy as np\nimport sys\nimport tempfile\nimport xlsxwriter\nimport pathlib\nimport glob\nimport json\nimport requests\nimport logging\nimport struct\nimport time\nimport tkinter\nfrom tkinter import Tk\nfrom tkinter import Button\nfrom tkinter import filedialog\nimport warnings\n### Get psspy bin\nprint('Select the bin location for the PSSE psspy.pyc and redirect.pyc files. Please use PSSE 35.6.')\nroot = Tk()\nPSSE_PATH = filedialog.askdirectory(initialdir = r'C:\\Program Files\\PTI\\PSSE35')\nroot.mainloop\nif (pathlib.Path(r'{0}\\psspy.pyc'.format(PSSE_PATH)).exists() == False) | (pathlib.Path(r'{0}\\redirect.pyc'.format(PSSE_PATH)).exists() == False):\nprint('No psspy.pyc and/or redirect.pyc package found at bin directory supplied {0}'.format(PSSE_PATH))\nexit()\nroot.destroy()\n#### PSS/E session initialization ####\nsys.path.append(PSSE_PATH)\nos.environ['PATH'] += ';' + PSSE_PATH\nimport psspy\nimport redirect\nredirect.psse2py()                                  ## Set output to Python Shell\nierr = psspy.psseinit(0)                            ## Initialize PSSE\n# ignore warnings to avoid terminal message clutter.\nwarnings.filterwarnings('ignore')\n########### FUNCTION DEFINITIONS ###########\ndef getAccReportViolations(Report): # pass location of PSSE text acc report\nFile1 = open(Report,'br')\nDict1 = File1.readlines()\niter_Dict1 = iter(Dict1) # iterating over the iter, see https://stackoverflow.com/questions/21594302/is-there-a-way-to-remember-the-position-in-a-python-iterator\nBrOL1 = None\nSwdOL1 = None\nVoltOL1 = None\nLdLoss1 = None\nConvRes1 = None\nCon_File_Name1 = None\nCA_Violations = None # adding this Nonetype assignment on 6/14/2021, not sure why but this appears to be a problem now with recent updates.\nBrOL1 = pd.DataFrame(columns=['Monitored_Branch','Contingency_Label','Rating','MW','Mvar','MVA','%'])\nSwdOL1 = pd.DataFrame(columns=['Monitored_SWD','Contingency_Label','Rating','MW','Mvar','MVA','%','SWD_Loop'])\nVoltOL1 = pd.DataFrame(columns=['System','Contingency_Label','Bus','V-Cont','V-Init','V-Max','V-Min'])\nLdLoss1 = pd.DataFrame(columns=['Bus','Contingency_Label','Load(MW)'])\nConvRes1 = pd.DataFrame(columns=['Contingency_Label','Termination_State','Flow#','Volt#','Load'])\nCon_File_Name1 = \"\"\n#read report data into pandas dataframes\nBrOL_fields = []\nSwdOL_fields = []\nVoltOL_fields = []\nLdLoss_fields = []\nConvRes_fields = []\nfor line in iter_Dict1:\nif \"CONTINGENCY DESCRIPTION FILE:\" in line.decode(\"utf-8\"):\nCon_File_Name1 = line[30:]\nbreak\nfor line in iter_Dict1:\n#print line\nif \"<--------------------- MONITORED BRANCH ---------------------> <----- CONTINGENCY LABEL ------>   RATING       MW     Mvar      MVA      %\" in line.decode(\"utf-8\"):\n#print \"Found Branch OL section of report\"\nfieldwidths = (62,-1,32,-1,8,-1,8,-1,8,-1,8,-1,6) # field widths of ACCC report Branch OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Branch OL section of report (newline found)\"\nBrOL1 = pd.DataFrame(data = BrOL_fields, columns=['Monitored_Branch','Contingency_Label','Rating','MW','Mvar','MVA','%'])\nbreak\n#print parse(line)\nBrOL_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<-------- MONITORED  SWD --------> <----- CONTINGENCY LABEL ------>   RATING       MW     Mvar      MVA      %   SWD LOOP\" in line.decode(\"utf-8\"):\n#print \"Found SWD OL section of report\"\nfieldwidths = (34,-1,32,-1,8,-1,8,-1,8,-1,8,-1,6,-1,10) # field widths of ACCC report SWD OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of SWD OL section of report (newline found)\"\nSwdOL1 = pd.DataFrame(data = SwdOL_fields, columns=['Monitored_SWD','Contingency_Label','Rating','MW','Mvar','MVA','%','SWD_Loop'])\nbreak\n#print parse(line)\nSwdOL_fields.append(parse(line))\nfor line in iter_Dict1:\nif \"SYSTEM                                       <----- CONTINGENCY LABEL ------> <---------- B U S ---------->   V-CONT   V-INIT   V-MAX    V-MIN\" in line.decode(\"utf-8\"):\n#print \"Found Voltage violation section of report\"\nfieldwidths = (44,-1,32,-1,29,-1,8,-1,8,-1,7,-1,8) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Voltage Violation section of report (newline found)\"\nVoltOL1 = pd.DataFrame(data = VoltOL_fields, columns=['System','Contingency_Label','Bus','V-Cont','V-Init','V-Max','V-Min'])\nbreak\n#print parse(line)\nVoltOL_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<---------- B U S ----------> <----- CONTINGENCY LABEL ------> LOAD(MW)\" in line.decode(\"utf-8\"):\n#print \"Found Load Loss section of report\"\nfieldwidths = (29,-1,32,-1,8) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Load Loss section of report (newline found)\"\nLdLoss1 = pd.DataFrame(data = LdLoss_fields, columns=['Bus','Contingency_Label','Load(MW)'])\nbreak\n#print parse(line)\nLdLoss_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<TERMINATION  STATE> FLOW#  SWD# VOLT#  LOAD\" in line.decode(\"utf-8\"):\n#print \"Found Convergence section of report\"\nfieldwidths = (32,20,-1,5,-1,5,-1,5,-1,5) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Convergence section of report (newline found)\"\nConvRes1 = pd.DataFrame(data = ConvRes_fields, columns=['Contingency_Label','Termination_State','Flow#','SWD#','Volt#','Load'])\nbreak\n#print parse(line)\nConvRes_fields.append(parse(line))\nBrOL1['ViolationType']=b'Br Thermal'\nSwdOL1['ViolationType']=b'SWD Thermal'\nVoltOL1['ViolationType']=b'Voltage'\nVoltOL1['Rating']=b'1'\nLdLoss1['ViolationType']=b'LdLoss'\nLdLoss1['Rating']=b'0'\nConvRes1['VioValue']=b'1'\nConvRes1['Rating']=b'0'\nConvRes1['Location']=ConvRes1['Contingency_Label']\nCA_Violations = pd.DataFrame(columns=['ViolationType','Contingency','Location','VioValue','Rating'])\nCA_Violations = CA_Violations.append([BrOL1[['ViolationType','Contingency_Label','Monitored_Branch','%','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Monitored_Branch':'Location','%':'VioValue'}),SwdOL1[['ViolationType','Contingency_Label','Monitored_SWD','%','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Monitored_SWD':'Location','%':'VioValue'}),VoltOL1[['ViolationType','Contingency_Label','Bus','V-Cont','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Bus':'Location', 'V-Cont':'VioValue'}),LdLoss1[['ViolationType','Contingency_Label','Bus','Load(MW)','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Bus':'Location','Load(MW)':'VioValue'}),ConvRes1[['Contingency_Label','Termination_State','VioValue','Rating','Location']].rename \\\n(columns={'Contingency_Label':'Contingency','Termination_State':'ViolationType'})],ignore_index=True,sort=False)\n#decode for human consumption\nCA_Violations['ViolationType'] = CA_Violations['ViolationType'].str.decode(encoding = 'UTF-8')\nCA_Violations['ViolationType'] = CA_Violations['ViolationType'].str.strip() #remove leading and trailing spaces\nCA_Violations['Contingency'] = CA_Violations['Contingency'].str.decode(encoding = 'UTF-8')\nCA_Violations['Contingency'] = CA_Violations['Contingency'].str.strip() #remove leading and trailing spaces\nCA_Violations['Location'] = CA_Violations['Location'].str.decode(encoding = 'UTF-8')\nCA_Violations['Location'] = CA_Violations['Location'].str.strip() #remove leading and trailing spaces\nCA_Violations['VioValue'] = CA_Violations['VioValue'].str.decode(encoding = 'UTF-8')\nCA_Violations['VioValue'] = CA_Violations['VioValue'].str.strip() #remove leading and trailing spaces\nCA_Violations['VioValue'] = pd.to_numeric(CA_Violations['VioValue']) #convert strings to numbers\nCA_Violations['Rating'] = CA_Violations['Rating'].str.decode(encoding = 'UTF-8')\nCA_Violations['Rating'] = CA_Violations['Rating'].str.strip() #remove leading and trailing spaces\nCA_Violations['Rating'] = pd.to_numeric(CA_Violations['Rating']) #convert strings to numbers\nreturn CA_Violations\ndef getAllXFRData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired_2W = ['ID','XFRNAME','VECTORGROUP']\nint_data_desired_2W = ['FROMNUMBER','TONUMBER','STATUS']\nchar_ierr_2W, carray_2W = psspy.atrnchar(SID, 1,3,2,1,char_data_desired_2W) #get all transformers, single entry\nint_ierr_2W, iarray_2W = psspy.atrnint(SID, 1,3,2,1,int_data_desired_2W)"
  },
  {
    "id": "chunk_101",
    "text": "char_data_desired_3W = ['ID','XFRNAME','VECTORGROUP']\nint_data_desired_3W = ['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER','STATUS']\nchar_ierr_3W, carray_3W = psspy.atr3char(SID, 1,3,2,1, char_data_desired_3W) #get all transformers\nint_ierr_3W, iarray_3W = psspy.atr3int(SID, 1,3,2,1,int_data_desired_3W)\nif char_ierr_2W!=0 or int_ierr_2W!=0 or char_ierr_3W!=0 or int_ierr_3W!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get transformer data.'])\nelse:\n# compile 2-winding XFR data into a dataframe\nallColumns_2W = char_data_desired_2W+int_data_desired_2W\nallData_2W = carray_2W+iarray_2W\nDF_dict_2W = dict(zip(allColumns_2W,allData_2W))\nDF_2W = pd.DataFrame(DF_dict_2W)\nDF_2W = DF_2W.rename(columns={'FROMNUMBER':'WIND1NUMBER','TONUMBER':'WIND2NUMBER'}) #rename the columns for easier appending\n# compile 3-winding XFR data into a dataframe\nallColumns_3W = char_data_desired_3W+int_data_desired_3W\nallData_3W = carray_3W+iarray_3W\nDF_dict_3W = dict(zip(allColumns_3W,allData_3W))\nDF_3W = pd.DataFrame(DF_dict_3W)\n# append the 2W and 3W data together\nDF_all = DF_2W.append(DF_3W, ignore_index=True)\nreturn DF_all\ndef getAllLineData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID']\nint_data_desired = ['FROMNUMBER','TONUMBER','STATUS']\nchar_ierr, carray = psspy.abrnchar(SID, 1,3,2,1,char_data_desired) #get all branches, single entry\nint_ierr, iarray = psspy.abrnint(SID, 1,3,2,1,int_data_desired) #get all branches, single entry\nif SID != -1:\nPSSE_SID_manager.decoupleDynamicSID(SID_manager,PSSESUBSYS)\nif char_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get line data.'])\nelse:\nallColumns = char_data_desired+int_data_desired\nallData = carray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllFixedShuntData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME']\ncomplex_data_desired = ['O_SHUNTACT']\nint_data_desired = ['NUMBER','STATION','STATUS']\nchar_ierr, carray = psspy.afxshuntchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.afxshuntcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.afxshuntint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case fixed shunt data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllSwShuntData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME']\ncomplex_data_desired = ['O_YSWACT']\nint_data_desired = ['NUMBER','STATION', 'AREA', 'ZONE', 'STATUS','OWNER']\nchar_ierr, carray = psspy.aswshchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.aswshcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.aswshint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case switched shunt data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllLoadData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME','LODTYPE']\ncomplex_data_desired = ['TOTALACT']\nint_data_desired = ['NUMBER','STATION', 'AREA', 'ZONE', 'STATUS','OWNER','SCALE','INTRPT']\nchar_ierr, carray = psspy.aloadchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.aloadcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.aloadint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case load data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllBusData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['NAME','EXNAME']\nreal_data_desired = ['BASE','NVLMLO','NVLMHI','EVLMLO','EVLMHI']\nint_data_desired = ['NUMBER','AREA','OWNER','ZONE']\nchar_ierr, carray = psspy.abuschar(SID, 2, char_data_desired)\ncomp_ierr, xarray = psspy.abusreal(SID, 2, real_data_desired)\nint_ierr, iarray = psspy.abusint(SID, 2, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get bus data. char_ierr = {0}, comp_ierr = {1}, int_ierr = {2}. SID = {3}'.format(char_ierr,comp_ierr,int_ierr,SID)])\nelse:\nallColumns = char_data_desired+real_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef PSSESetSubSystem(SID,USEKV,BASEKV,NUMAREA,AREAS,NUMBUS,BUSES,NUMOWNER,OWNERS,NUMZONE,ZONES):\nierr = psspy.bsys(SID,USEKV,BASEKV,NUMAREA,AREAS,NUMBUS,BUSES,NUMOWNER,OWNERS,NUMZONE,ZONES)\nif ierr != 0:\nraise RuntimeError('PSSESetSubSystem did not work. the psspy.bsys ierr returned is: {}'.format(ierr))\nreturn ierr\ndef PSSESaveCase(PSSESAVECASE):\nierr = psspy.save(PSSESAVECASE) #save case\nif ierr != 0:\nraise RuntimeError('PSSPY error code {} when calling psspy.save(). See PSSE API documentation for details.'.format(ierr))\nsys.exit()\nreturn ierr\ndef getBusInconsistencies():\nin_service_branches = psspy.abrnint(-1,1,3,1,1,['FROMNUMBER','TONUMBER','STATUS','FROMSECTION','TOSECTION'])[1] #in_service_branches[0] is list of FROMBUS's, n_service_branches[1] is list of TOBUS's\n# make df for in_service_br_busses\nfrom_buses = pd.DataFrame({'Bus Number':in_service_branches[0],'Bus Section':in_service_branches[3]})\nto_buses = pd.DataFrame({'Bus Number':in_service_branches[1],'Bus Section':in_service_branches[4]})\nin_service_br_busses = pd.concat([from_buses,to_buses],ignore_index=True)\nin_service_br_busses = in_service_br_busses.drop_duplicates() #drop duplicates to avoid duplicating work\nall_busses = psspy.abusint(-1,2,['NUMBER','TYPE','SECTION','AREA'])[1] #all_busses[0] is list of busses, all_busses[1] is list of statuses, all_busses[2] is list of sections\n#make df for all buses\nbuses = pd.DataFrame({'Bus Number':all_busses[0],'Bus Section':all_busses[2],'Bus Type':all_busses[1],'Bus Area':all_busses[3]})\nin_service_2w_xfr = psspy.atrnint(-1,1,3,1,1,['FROMNUMBER','TONUMBER','STATUS','FROMSECTION','TOSECTION'])[1] #this only returns in-service transformers\nfrom_bus_2w_xfr = pd.DataFrame({'Bus Number':in_service_2w_xfr[0],'Bus Section':in_service_2w_xfr[3]})\nto_bus_2w_xfr = pd.DataFrame({'Bus Number':in_service_2w_xfr[1],'Bus Section':in_service_2w_xfr[4]})\nin_service_2w_xfr_buses = pd.concat([from_bus_2w_xfr,to_bus_2w_xfr],ignore_index=True)\nin_service_2w_xfr_buses = in_service_2w_xfr_buses.drop_duplicates()\nin_service_3w_xfr = psspy.atr3int(-1,1,3,1,1,['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER','STATUS','WIND1SECTION','WIND2SECTION','WIND3SECTION'])[1]\n# make in_service_3w_xfr_buses a dataframe\nin_service_3w_xfr_buses = pd.DataFrame()\n#make dataframe for more sophisticated data comparison\nin_service_3w_xfr_df = pd.DataFrame({'WIND1NUMBER':in_service_3w_xfr[0],'WIND2NUMBER':in_service_3w_xfr[1],'WIND3NUMBER':in_service_3w_xfr[2],'STATUS':in_service_3w_xfr[3],'WIND1SECTION':in_service_3w_xfr[4],'WIND2SECTION':in_service_3w_xfr[5],'WIND3SECTION':in_service_3w_xfr[6]})\n# get in service buses for status = 1\nstat1_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==1]\nfor entry in stat1_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat1_df.at[entry,'WIND1NUMBER'],stat1_df.at[entry,'WIND2NUMBER'],stat1_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat1_df.at[entry,'WIND1SECTION'],stat1_df.at[entry,'WIND2SECTION'],stat1_df.at[entry,'WIND3SECTION']]}) #all windings in-service when status = 1\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 2\nstat2_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==2]\nfor entry in stat2_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat2_df.at[entry,'WIND1NUMBER'],stat2_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat2_df.at[entry,'WIND1SECTION'],stat2_df.at[entry,'WIND3SECTION']]}) #windings 1 and 3 in-service when status = 2\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 3\nstat3_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==3]\nfor entry in stat3_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat3_df.at[entry,'WIND1NUMBER'],stat3_df.at[entry,'WIND2NUMBER']], \\\n'Bus Section':[stat3_df.at[entry,'WIND1SECTION'],stat3_df.at[entry,'WIND2SECTION']]}) #windings 1 and 2 in-service when status = 3\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 4\nstat4_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==4]\nfor entry in stat4_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat4_df.at[entry,'WIND2NUMBER'],stat4_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat4_df.at[entry,'WIND2SECTION'],stat4_df.at[entry,'WIND3SECTION']]}) #windings 2 and 3 in-service when status = 4\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\nall_in_service_element_buses = pd.concat([in_service_br_busses,in_service_2w_xfr_buses,in_service_3w_xfr_buses],ignore_index=True)\nall_in_service_element_buses = all_in_service_element_buses.drop_duplicates()\nall_in_service_element_buses['Has in-service branches'] = 'True'\nbus_summary = pd.merge(buses,all_in_service_element_buses,on=['Bus Number','Bus Section'],how='left')\nresults_to_return = bus_summary.loc[(((bus_summary['Bus Type'] == 1)|(bus_summary['Bus Type'] == 2))&(bus_summary['Has in-service branches'] != 'True'))\\\n|((bus_summary['Bus Type'] == 4)&(bus_summary['Has in-service branches'] == 'True'))]\nreturn results_to_return\ndef getFileByteData(GETBYTEDATAFILE):\ntry:\nif type(GETBYTEDATAFILE) == tempfile._TemporaryFileWrapper:\nFileByteData = GETBYTEDATAFILE.read()\nGETBYTEDATAFILE.seek(0)\nelse:\nf = open(GETBYTEDATAFILE,'r+b')\nFileByteData = f.read()\nf.close()\nreturn FileByteData\nexcept:\nraise RuntimeError('There was a problem reading the data from {}. Check the file.'.format(GETBYTEDATAFILE))\nsys.exit()\ndef silenceAllPSSE():\npsspy.set_progress_verbose(0) #set to limit messages\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence progress output from PSS/E\npsspy.report_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence report output from PSS/E to temp file\npsspy.t_alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence alert output\npsspy.alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silece alert outputs\ndef PSSEOpenCase(PSSEOPENCASE):\nif pathlib.Path(PSSEOPENCASE).suffix == '.sav':\nierr = psspy.case(PSSEOPENCASE) #open case\nif ierr != 0:\nraise RuntimeError('PSSPY error code {0} when calling psspy.case({1}). See PSSE API documentation for details.'.format(ierr,PSSEOPENCASE))\nsys.exit()\nif pathlib.Path(PSSEOPENCASE).suffix == '.raw':\nierr = psspy.read(0,PSSEOPENCASE)\nif ierr != 0:\nraise RuntimeError('PSSPY error code {0} when calling psspy.read(0,{1}). See PSSE API documentation for details.'.format(ierr,PSSEOPENCASE))\nsys.exit()\nreturn ierr\ndef make_clickable(url, name):\nreturn '<a href=\"{}\" rel=\"noopener noreferrer\" target=\"_blank\">{}</a>'.format(url,name)\ndef makeTempDirectory():\n### Create temp directory for file management ###\ntemporary_directory = tempfile.TemporaryDirectory()\ntmp_dir = temporary_directory.name\nprint('Created temp directory {0}.'.format(tmp_dir))\nreturn temporary_directory\ndef suppressAllPSSEOutputs():\n#### Supress all the PSSE outputs for now"
  },
  {
    "id": "chunk_102",
    "text": "psspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #suppress progress output from PSS/E\npsspy.t_alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write t alerts from PSS/E to temp file\npsspy.alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write alerts from PSS/E to temp file\npsspy.report_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write report from PSS/E to temp file\ndef getCNTBCheckData(tmp_dir,SAVLOCATION,target_output_directory,rawfilename,CNTB_messages,areaList):\n#tmp_dir_CNTB = makeTempDirectory().name\nPSSEOpenCase(SAVLOCATION) #open the save case\npsspy.bsys(0,0,[0.48,345.],len(areaList),areaList,0,[],0,[],0,[]) #set bsys to areas provided by the user\ntemp_PSSE_output = tmp_dir+r'\\PSSE_capture.txt' #capture report output from PSS/E\nierr = psspy.report_output(2,temp_PSSE_output,0) #capture report output from PSS/E\nif ierr != 0:\nraise RuntimeError('Problem calling psspy.report_output. Directory location: {0}. ierr = {1}'.format(temp_PSSE_output,ierr))\npsspy.cntb(0,0,1,[0,0,0],[0.0,0.0]) #run CNTB\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile\n# PSSESaveCase(target_output_directory+r'\\{0}.sav'.format(rawfilename))\n# PSSECloseCase()\n#write the report to a text document\ndata_to_write = getFileByteData(temp_PSSE_output).decode('UTF-8')\n# reportName = target_output_directory+r'\\text_reports\\{}_CNTB_output.txt'.format(rawfilename)\n# f = open(reportName,'w')\n# f.write(data_to_write)\n# f.close()\n#partition the data to put in a csv for easier reading\nmessage_delimiter = '\\nBus '\nall_messages = data_to_write.split(message_delimiter)\nCNTB_messages_tmp = pd.DataFrame({'{0}'.format(rawfilename):all_messages})\nCNTB_messages_tmp['{0}'.format(rawfilename)] = 'Bus '+CNTB_messages_tmp['{0}'.format(rawfilename)]\nCNTB_messages_tmp['Bus'] = CNTB_messages_tmp['{0}'.format(rawfilename)]\nCNTB_messages_tmp['Area'] =CNTB_messages_tmp['Bus'].str.extract(r'area ([0-9]+)')\nCNTB_messages_tmp['Bus'] = CNTB_messages_tmp['Bus'].str.extract(r'Bus ([0-9]+)') #CNTB_messages_tmp['Bus'].str.slice(stop=10).str.rstrip().str.rstrip('[')\nCNTB_messages_tmp.loc[CNTB_messages_tmp['{0}'.format(rawfilename)].str.contains('Warning'),'Type'] = 'Warning'\nCNTB_messages_tmp.loc[CNTB_messages_tmp['{0}'.format(rawfilename)].str.contains('ERROR'),'Type'] = 'ERROR'\nCNTB_messages_tmp.loc[CNTB_messages_tmp['Type'].isnull(),'Type'] = 'Other'\nCNTB_messages_tmp = CNTB_messages_tmp[['Bus','Area','Type','{0}'.format(rawfilename)]]\nCNTB_messages_tmp = CNTB_messages_tmp.loc[(CNTB_messages_tmp['Type']=='ERROR')|(CNTB_messages_tmp['Type']=='Warning')]\n#CNTB_messages_tmp.to_csv(target_output_directory+'\\CNTB_messages_tmp.csv')\nif CNTB_messages.empty == True:\nCNTB_messages = CNTB_messages_tmp #pd.concat([CNTB_messages,CNTB_messages_tmp],ignore_index=True)\nCNTB_messages = CNTB_messages.drop_duplicates() #drop duplicate values to keep the dataset smaller\nelse:\nCNTB_messages = pd.merge(CNTB_messages,CNTB_messages_tmp,how='outer',on=['Bus','Area','Type'])\nCNTB_messages = CNTB_messages.drop_duplicates() #drop duplicate values to keep the dataset smaller\nreturn CNTB_messages\ndef getBusData(savLocation,target_output_directory,rawfilename,BusData,areaList):\nbusData_tmp = getAllBusData(savLocation)\n#busData_tmp.to_csv(target_output_directory+r'\\busData_tmp.csv')\nallBusesInSelectedAreas = busData_tmp.loc[(busData_tmp['AREA'].isin(areaList))]\nallBusesInSelectedAreas = allBusesInSelectedAreas[['NUMBER','NAME','AREA','OWNER','NVLMLO','NVLMHI','EVLMLO','EVLMHI']]\nallBusesInSelectedAreas = allBusesInSelectedAreas.round({'NVLMLO':2,'NVLMHI':2,'EVLMLO':2,'EVLMHI':2})\nallBusesInSelectedAreas['{0}'.format(rawfilename)]='TRUE'\nif BusData.empty == True:\nBusData = allBusesInSelectedAreas #pd.concat([CNTB_messages,CNTB_messages_tmp],ignore_index=True)\nBusData = BusData.drop_duplicates() #drop duplicate values to keep the dataset smaller\nelse:\nBusData = pd.merge(BusData,allBusesInSelectedAreas,how='outer',on=['NUMBER','NAME','AREA','OWNER','NVLMLO','NVLMHI','EVLMLO','EVLMHI'])\nBusData = BusData.drop_duplicates() #drop duplicate values to keep the dataset smaller\n#BusData = BusData.round({'NVLMLO':2,'NVLMHI':2,'EVLMLO':2,'EVLMHI':2})\nreturn BusData\ndef get900kBuses(BusData):\nall900k_buses = BusData.loc[BusData['NUMBER']>=900000]\nreturn all900k_buses\ndef getLdData(savLocation,allLoads,rawfilename,areaList):\n# Get load data to report on any 0-MVA or disconnected loads in selected areas\nloadData_tmp = getAllLoadData(savLocation)\nloadData_tmp = loadData_tmp.loc[(loadData_tmp['AREA'].isin(areaList))] # only keep the selected areas\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER']]\nloadData_tmp['{0}'.format(rawfilename)]='TRUE'\nif allLoads.empty == True:\nallLoads = loadData_tmp\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(loadData_tmp,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nreturn loadData_tmp\ndef getLdDataTotalsReportedInCaseColumn(savLocation,allLoads,rawfilename,areaList):\n# Get load data to report on any 0-MVA or disconnected loads in selected areas\nloadData_tmp = getAllLoadData(savLocation)\nloadData_tmp = loadData_tmp.loc[(loadData_tmp['AREA'].isin(areaList))] # only keep the selected areas\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER']]\nloadData_tmp['{0}'.format(rawfilename)]=loadData_tmp['TOTALACT']\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER','{0}'.format(rawfilename)]]\nif allLoads.empty == True:\nallLoads = loadData_tmp\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(loadData_tmp,how='outer',on=['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nreturn loadData_tmp\ndef getDisconnectedLoads(loadData_tmp,allDisconnectedLds):\ndisconnectedLds = loadData_tmp.loc[loadData_tmp['STATUS']==0]\nif allDisconnectedLds.empty == True:\nallDisconnectedLds = disconnectedLds\nallDisconnectedLds = allDisconnectedLds.drop_duplicates()\nelse:\nallDisconnectedLds = allDisconnectedLds.merge(disconnectedLds,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallDisconnectedLds = allDisconnectedLds.drop_duplicates()\nreturn allDisconnectedLds\ndef getZeroLoads(loadData_tmp,allZeroLds):\nzeroLds = loadData_tmp.loc[loadData_tmp['TOTALACT']==complex(0,0)]\nif allZeroLds.empty == True:\nallZeroLds = zeroLds\nallZeroLds = allZeroLds.drop_duplicates()\nelse:\nallZeroLds = allZeroLds.merge(zeroLds,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallZeroLds = allZeroLds.drop_duplicates()\nreturn allZeroLds\ndef getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,areaList):\n# find shunt devices that are in a status of disconnected\nSwShunts = getAllSwShuntData(savLocation)\nSwShunts = SwShunts.loc[SwShunts['AREA'].isin(areaList)] # filter down to the specific requested areas\ndisconnected_SwShunts = SwShunts.loc[SwShunts['STATUS']==0]\ndisconnected_SwShunts = disconnected_SwShunts[['ID','NAME','NUMBER','AREA','STATUS']]\nFixedShunts = getAllFixedShuntData(savLocation)\nBusAreaMap = getAllBusData(savLocation)[['NUMBER','AREA']]\nFixedShunts = FixedShunts.merge(BusAreaMap,how='left',on='NUMBER')\nFixedShunts = FixedShunts.loc[FixedShunts['AREA'].isin(areaList)] # filter down to the specific requested areas\ndisconnected_FixedShunts = FixedShunts.loc[FixedShunts['STATUS']==0]\ndisconnected_FixedShunts = disconnected_FixedShunts[['ID','NAME','NUMBER','AREA','STATUS']]\ndisconnected_shunts = pd.concat([disconnected_SwShunts,disconnected_FixedShunts],ignore_index=True)\ndisconnected_shunts['{0}'.format(rawfilename)] = 'TRUE'\nif alldisconnected_shunts.empty == True:\nalldisconnected_shunts = disconnected_shunts\nalldisconnected_shunts = alldisconnected_shunts.drop_duplicates()\nelse:\nalldisconnected_shunts = alldisconnected_shunts.merge(disconnected_shunts,how='outer',on=['ID','NAME','NUMBER','AREA','STATUS'])\nalldisconnected_shunts = alldisconnected_shunts.drop_duplicates()\nreturn alldisconnected_shunts\ndef getAllBusInconsistencies(rawfilename,allBusInconsistencies):\n# Get bus inconsistencies\ncaseBusInconsistencies = getBusInconsistencies()\ncaseBusInconsistencies['{0}'.format(rawfilename)] = 'TRUE'\nif allBusInconsistencies.empty == True:\nallBusInconsistencies = caseBusInconsistencies\nallBusInconsistencies=allBusInconsistencies.drop_duplicates()\nelse:\nallBusInconsistencies = pd.merge(allBusInconsistencies,caseBusInconsistencies,how='outer',on=['Bus Number','Bus Section','Bus Type','Bus Area','Has in-service branches'])\nallBusInconsistencies=allBusInconsistencies.drop_duplicates()\nreturn allBusInconsistencies\ndef getTREEIslands(tmp_dir,rawfilename,allIslands):\n# Run TREE to get island information\n# prepare a report to capture TREE outputs\ncaseTreeData = []\ntemp_TREE_output = tmp_dir+r'\\TREE_capture.txt' #capture report output from PSS/E\npsspy.progress_output(2,temp_TREE_output,0) #capture report output from PSS/E\nierr, num_island_buses = psspy.tree(1,0) #initialize TREE\nwhile num_island_buses > 0:\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile\ntree_data = getFileByteData(temp_TREE_output).decode('UTF-8')\nos.remove(temp_TREE_output) #get rid of the temp file\nsave_data = tree_data.split('ISLAND:\\r\\n')[1] #get data to save\ncaseTreeData.append(save_data)\npsspy.progress_output(2,temp_TREE_output,0) #capture report output from PSS/E\nierr, num_island_buses = psspy.tree(2,0) # leave the current island alone and run TREE again check for another island\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #suppress progress output from PSS/E\nCaseTreeIslands = pd.DataFrame({'Island':caseTreeData})\nCaseTreeIslands['{0}'.format(rawfilename)] = 'TRUE'\nif allIslands.empty == True:\nallIslands = CaseTreeIslands\nallIslands = allIslands.drop_duplicates()\nelse:\nallIslands = pd.merge(allIslands,CaseTreeIslands,how='outer',on='Island')\nallIslands = allIslands.drop_duplicates()\nreturn allIslands\ndef getPSSEpfChecks(tmp_dir,rawfilename,allPFCheckResults,allPFCheckTypes,areaList):\n# run the PSSE powerflow checks for the case\nSID_for_checks = 1\nPSSESetSubSystem(SID=SID_for_checks,USEKV=1,BASEKV=1,NUMAREA=len(areaList),AREAS=areaList,NUMBUS=0,BUSES=[],NUMOWNER=0,OWNERS=[],NUMZONE=0,ZONES=[])\n#psspy.bsys(0,0,[0.48,345.],1,[],0,[],0,[],0,[]) # set SID 0\nfor checkType in allPFCheckTypes.keys():\n#print('Doing PSSE PF check for {0}'.format(checkType))\nsilenceAllPSSE() #silence the output\ntemp_pfcheck_output = tmp_dir+r'\\pfcheck_capture.txt' #capture report output from PSS/E\npsspy.report_output(2,temp_pfcheck_output,0) #capture report output from PSS/E\nierr = psspy.check_powerflow_data(SID_for_checks,0,allPFCheckTypes[checkType])\nif ierr != 0:\nprint('Problem with running check_powerflow_data. ierr={0}'.format(ierr))\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile\npfcheck_data = str(getFileByteData(temp_pfcheck_output).decode('UTF-8'))\npfcheck_data = \"\"\"{0}\"\"\".format(pfcheck_data)\nsave_data = pd.DataFrame({'PF Check Message':pfcheck_data.split('\\r\\n\\r\\n')}) #get data to save\nsave_data = save_data.loc[(save_data['PF Check Message'].str.strip()!='')&\\\n(save_data['PF Check Message'].str.strip()!='Powerflow data checks')&\\\n(save_data['PF Check Message'].str.strip().str.contains(' messages:')==False)]\n#save_data = save_data['PF Check Message']\nsave_data['{0}'.format(rawfilename)] = 'TRUE'\nsave_data = save_data[['PF Check Message','{0}'.format(rawfilename)]]\nif len(allPFCheckResults[checkType].columns)<1:\nallPFCheckResults[checkType] = save_data\n#allPFCheckResults[checkType] = allPFCheckResults[checkType].drop_duplicates()\nelse:\nallPFCheckResults[checkType] = pd.merge(allPFCheckResults[checkType],save_data,how='outer',on='PF Check Message')\nallPFCheckResults[checkType] = allPFCheckResults[checkType].drop_duplicates()\nreturn allPFCheckResults\ndef getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,areaList):\n# Check for line branch elements that connect buses with different base voltages\nbusData_tmp = getAllBusData(savLocation)\nbranchData = getAllLineData(savLocation)\nbrTerminalBaseCheck = pd.merge(branchData,busData_tmp[['NUMBER','NAME','BASE','AREA','OWNER']],how='left',left_on='FROMNUMBER',right_on='NUMBER')\nbrTerminalBaseCheck = pd.merge(brTerminalBaseCheck,busData_tmp[['NUMBER','NAME','BASE','AREA','OWNER']],how='left',left_on='TONUMBER',right_on='NUMBER',suffixes=('_FromBus','_ToBus'))\n#branchData.to_csv(target_output_directory+r'\\branchData.csv')\n#brTerminalBaseCheck.to_csv(target_output_directory+r'\\brTerminalBaseCheck.csv')\ninconsistent_line_terminal_base_voltages = brTerminalBaseCheck.loc[(brTerminalBaseCheck['BASE_FromBus']!=brTerminalBaseCheck['BASE_ToBus'])\\\n&((brTerminalBaseCheck['AREA_FromBus'].isin(areaList))|(brTerminalBaseCheck['AREA_ToBus'].isin(areaList)))]\n#inconsistent_line_terminal_base_voltages.to_csv(target_output_directory+r'\\inconsistent_line_terminal_base_voltages.csv')\ninconsistent_line_terminal_base_voltages['{0}'.format(rawfilename)] = 'TRUE'\nif allBrTerminalVoltageInconsistencies.empty == True:\nallBrTerminalVoltageInconsistencies = inconsistent_line_terminal_base_voltages\nallBrTerminalVoltageInconsistencies = allBrTerminalVoltageInconsistencies.drop_duplicates()\nelse:\nallBrTerminalVoltageInconsistencies = pd.merge(allBrTerminalVoltageInconsistencies,inconsistent_line_terminal_base_voltages,how='outer',\\\non=['ID','FROMNUMBER','TONUMBER','STATUS','NUMBER_FromBus','NAME_FromBus','BASE_FromBus','AREA_FromBus','OWNER_FromBus','NUMBER_ToBus','NAME_ToBus','BASE_ToBus','AREA_ToBus','OWNER_ToBus'])\nallBrTerminalVoltageInconsistencies = allBrTerminalVoltageInconsistencies.drop_duplicates()\nreturn allBrTerminalVoltageInconsistencies\ndef getRawxJSON(tmp_dir,rawfilename):\ntemp_rawx_location = tmp_dir+r'\\{0}.rawx'.format(rawfilename)\npsspy.writerawxsubsys(0,1,[1,1,1,0,0],r\"\"\"{0}\"\"\".format(temp_rawx_location),\"\")\nwith open(temp_rawx_location,'r') as file:\ndata = file.read()\nraw_data_json = json.loads(data)\nreturn raw_data_json\ndef getNodeBreakerData(raw_data_json):\ndesired_elements = ['sub', 'subnode', 'subswd', 'subterm','load', 'fixshunt', 'generator', 'acline', 'sysswd', 'transformer','swshunt','facts','twotermdc','bus']\ndataframe_dict = {}\nfor element in desired_elements:\ndataframe_dict[element] = pd.DataFrame(raw_data_json['network'][element]['data'],columns=raw_data_json['network'][element]['fields'])\n# get all terminate-able equipment into a single dataset\nfixShunts = dataframe_dict['fixshunt'][['ibus','shntid']].rename(columns={'shntid':'eqid'})\nfixShunts['equipmentType'] = 'fixshunt'\nfixShunts['name'] = ''\nfixShunts['type'] = 'F'\nswShunts = dataframe_dict['swshunt'][['ibus','shntid']].rename(columns={'shntid':'eqid'})\nswShunts['equipmentType'] = 'swshunt'\nswShunts['name'] = ''\nswShunts['type'] = 'S'\nfacts = dataframe_dict['facts'][['ibus','jbus','name']].rename(columns={'name':'eqid'})\nfacts['equipmentType'] = 'facts'\nfacts['name'] = ''\nfacts['type'] = 'A'\nacLines = dataframe_dict['acline'][['ibus','jbus','ckt','name']].rename(columns={'ckt':'eqid'})\nacLines['equipmentType'] = 'acline'\nacLines['type'] = 'B'\ntwotermdc = dataframe_dict['twotermdc'][['ipi','name']].rename(columns={'ipi':'ibus','name':'eqid'})\ntwotermdc['equipmentType'] = 'twotermdc'\ntwotermdc['type'] = 'D'\ngenerators = dataframe_dict['generator'][['ibus','machid']].rename(columns={'machid':'eqid'})\ngenerators['equipmentType'] = 'generator'\ngenerators['name'] = ''\ngenerators['type'] = 'M'\nloads = dataframe_dict['load'][['ibus','loadid']].rename(columns={'loadid':'eqid'})\nloads['equipmentType'] = 'load'\nloads['name'] = ''\nloads['type'] = 'L'\ntransformers = dataframe_dict['transformer'][['ibus','jbus','kbus','ckt','name']].rename(columns={'ckt':'eqid'})\ntransformers['equipmentType'] = 'transformer'\ntransformers.loc[transformers['kbus']==0,'type'] = '2'\ntransformers.loc[transformers['kbus']!=0,'type'] = '3'\nsysSwds = dataframe_dict['sysswd'][['ibus','jbus','ckt','name','stat','nstat']].rename(columns={'ckt':'eqid'})"
  },
  {
    "id": "chunk_103",
    "text": "sysSwds['equipmentType'] = 'system switching device'\nsysSwds['type'] = 'B'\nall_termable_equip = pd.concat([fixShunts,acLines,generators,loads,transformers,sysSwds,swShunts,facts,twotermdc],ignore_index=True)\nall_termable_equip['kbus'] = all_termable_equip['kbus'].replace(0,np.nan)\nall_termable_equip['jbus'] = all_termable_equip['jbus'].replace(0,np.nan)\nall_termable_equip['EquipmentID'] = all_termable_equip.index # we'll need this later\n# join the terminable equipment to their corresponding substation and node, if available\n# first, format the subterm df for greater clarity: because ibus/jbus/and kbus are not consistently assigned\nsubterm_formatted = dataframe_dict['subterm'].rename(columns={'isub':'sub','inode':'node','ibus':'bus','jbus':'IDbusA','kbus':'IDbusB','eqid':'IDequip'})\n# second, join all_termable_equip to subterm_formatted on the ID fields -- this will be giant\nibus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['ibus','eqid','type'], right_on = ['bus','IDequip','type'])\nibus_node_table = ibus_node_table.loc[\\\n((ibus_node_table['jbus'].isna()==True)|((ibus_node_table['jbus']==ibus_node_table['IDbusA'])|(ibus_node_table['jbus']==ibus_node_table['IDbusB'])))\\\n&((ibus_node_table['kbus'].isna()==True)|(ibus_node_table['kbus']==ibus_node_table['IDbusA'])|(ibus_node_table['kbus']==ibus_node_table['IDbusB']))] # this is the data set for which the node bus is ibus of the equipment\nibus_node_table = ibus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\nibus_node_table = ibus_node_table.rename(columns={'sub':'isub','node':'inode'})\nibus_node_table = ibus_node_table.drop_duplicates()\njbus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['jbus','eqid','type'], right_on = ['bus','IDequip','type'])\njbus_node_table = jbus_node_table.loc[\\\n((jbus_node_table['ibus'].isna()==True)|((jbus_node_table['ibus']==jbus_node_table['IDbusA'])|(jbus_node_table['ibus']==jbus_node_table['IDbusB'])))\\\n&((jbus_node_table['kbus'].isna()==True)|((jbus_node_table['kbus']==jbus_node_table['IDbusA'])|(jbus_node_table['kbus']==jbus_node_table['IDbusB'])))] # this is the data set for which the node bus is jbus of the equipment\njbus_node_table = jbus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\njbus_node_table = jbus_node_table.rename(columns={'sub':'jsub','node':'jnode'})\njbus_node_table = jbus_node_table.drop_duplicates()\nkbus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['kbus','eqid','type'], right_on = ['bus','IDequip','type'])\nkbus_node_table = kbus_node_table.loc[\\\n((kbus_node_table['ibus'].isna()==True)|((kbus_node_table['ibus']==kbus_node_table['IDbusA'])|(kbus_node_table['ibus']==kbus_node_table['IDbusB'])))\\\n&((kbus_node_table['jbus'].isna()==True)|((kbus_node_table['jbus']==kbus_node_table['IDbusA'])|(kbus_node_table['jbus']==kbus_node_table['IDbusB'])))] # this is the data set for which the node bus is kbus of the equipment\nkbus_node_table = kbus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\nkbus_node_table = kbus_node_table.rename(columns={'sub':'ksub','node':'knode'})\nkbus_node_table = kbus_node_table.drop_duplicates()\nall_termable_equip_with_nodes = pd.merge(all_termable_equip,ibus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\nall_termable_equip_with_nodes = pd.merge(all_termable_equip_with_nodes,jbus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\nall_termable_equip_with_nodes = pd.merge(all_termable_equip_with_nodes,kbus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\n# add the substation switching devices to the all_termable_equip_with_nodes df\n# get sub switching device data\nsubSwds = dataframe_dict['subswd']\nsubSwds['jsub'] = subSwds['isub'] # adding jsub column for easier concatenation with all_termable_equip_with_nodes\nsubSwds['equipmentType'] = subSwds['type'].map({1:'Subswd - GEN',2:'Subswd - CB',3:'Subswd - DSC'}) #.astype(str)\nsubSwds=subSwds.rename(columns={'swdid':'eqid'})\nsubSwds = subSwds[['isub','inode','jsub','jnode','eqid','name','equipmentType','type','stat','nstat']]\n# the sub node data and join to sub switching deivce data\nsubNodes = dataframe_dict['subnode']\nsubNodes = subNodes.rename(columns={'isub':'sub','inode':'node','ibus':'bus'})\nsubNodes = subNodes[['sub','node','bus','name']]\nsubNodes=subNodes.drop_duplicates()\nisubNodes=subNodes.rename(columns={'sub':'isub','node':'inode','bus':'ibus','name':'inode_name'})\njsubNodes=subNodes.rename(columns={'sub':'jsub','node':'jnode','bus':'jbus','name':'jnode_name'})\nsubSwds = pd.merge(subSwds,isubNodes,how='left',on=['isub','inode'])\nsubSwds = pd.merge(subSwds,jsubNodes,how='left',on=['jsub','jnode'])\nsubSwds.index += len(all_termable_equip_with_nodes.index)\nsubSwds['EquipmentID']=subSwds.index\n# add the sys swd stype back into the dataset (it has to show as 'B' to join to the sub terminations, since 2 and 3 refer only to transformers in the subterm data)\nsysSwdWType = sysSwds = dataframe_dict['sysswd'][['ibus','jbus','ckt','name','stat','nstat','stype']].rename(columns={'ckt':'eqid'}) # the field stype refers to the switch type, where 2 is a breaker and 3 is a disconnect\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes.merge(sysSwdWType,how='left',on=['ibus','jbus','eqid','name','stat','nstat'])\nall_termable_equip_with_nodes_incl_subswds.loc[all_termable_equip_with_nodes_incl_subswds['equipmentType']=='system switching device','type']=\\\nall_termable_equip_with_nodes_incl_subswds['stype'] #replace type with stype for system switching devices\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes_incl_subswds.drop('stype',axis=1) #drop the stype column\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes_incl_subswds.drop_duplicates() #drop any duplicates introduced\n# add substation switching devices to all_termable_equip_with_nodes\nall_termable_equip_with_nodes_incl_subswds = pd.concat([all_termable_equip_with_nodes_incl_subswds,subSwds],ignore_index=False)\nreturn (ibus_node_table, jbus_node_table, kbus_node_table, all_termable_equip_with_nodes,dataframe_dict,all_termable_equip_with_nodes_incl_subswds)\ndef getInvalidSetpointsContinuousShunts(allSwShunts,rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,areaList):\n# check Binit values for switched shunt\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nSwShunts = SwShunts.loc[SwShunts['modsw']==2] #only get continuous-control-type shunts\n#print(SwShunts)\nSwShuntsWithInvalidSetpoints = SwShunts.loc[(SwShunts['vswhi']!=SwShunts['vswlo'])]\nSwShuntsWithInvalidSetpoints = SwShuntsWithInvalidSetpoints[['ibus','AREA','shntid','modsw','swreg','vswhi','vswlo']]\nSwShuntsWithInvalidSetpoints['{0}'.format(rawfilename)] = 'TRUE'\nif allSwShuntsWithInvalidSetpoints.empty==True:\nallSwShuntsWithInvalidSetpoints = SwShuntsWithInvalidSetpoints\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.drop_duplicates()\nelse:\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.merge(SwShuntsWithInvalidSetpoints,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg','vswhi','vswlo'])\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.drop_duplicates()\nreturn allSwShuntsWithInvalidSetpoints\ndef getInvalidBinitShunts(allSwShunts,rawfilename,allSwShuntsWithInvalidBinit,savLocation,areaList):\n# check Binit values for switched shunt\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nSwShunts = SwShunts.loc[SwShunts['modsw']==1] #only get discreet-control-type shunts\nSwShuntsWithInvalidBinit = SwShunts.loc[(SwShunts['binit']!=0)\\\n&(SwShunts['binit']!=SwShunts['b1'])\\\n&(SwShunts['binit']!=SwShunts['b2'])\\\n&(SwShunts['binit']!=SwShunts['b3'])\\\n&(SwShunts['binit']!=SwShunts['b4'])\\\n&(SwShunts['binit']!=SwShunts['b5'])\\\n&(SwShunts['binit']!=SwShunts['b6'])\\\n&(SwShunts['binit']!=SwShunts['b7'])\\\n&(SwShunts['binit']!=SwShunts['b8'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6']+SwShunts['b7'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6']+SwShunts['b7']+SwShunts['b8'])]\nSwShuntsWithInvalidBinit = SwShuntsWithInvalidBinit[['ibus','AREA','shntid','modsw','swreg','binit']]\nSwShuntsWithInvalidBinit['{0}'.format(rawfilename)] = 'TRUE'\nif allSwShuntsWithInvalidBinit.empty==True:\nallSwShuntsWithInvalidBinit = SwShuntsWithInvalidBinit\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.drop_duplicates()\nelse:\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.merge(SwShuntsWithInvalidBinit,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg','binit'])\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.drop_duplicates()\nreturn allSwShuntsWithInvalidBinit\ndef getSolutionData(rawfilename,allCaseSolveData):\nerror_map = {0:'no error occurred',1:'invalid OPTIONS value',2:'generators are converted',\n3:'buses in island(s) without a swing bus; use activity TREE',\n4:'bus type code and series element status inconsistencies',\n5:'prerequisite requirements for API are not met'}\nflag_map = {0:'tap adj',1:'area interchange adj',2:'phase shift adj',\n3:'dc tap adj',4:'sw shunt adj',5:'flat start',6:'var limit',7:'non-divergent sol'}\nfdns_configuration_step1 = [1,1,1,1,1,1,0,0]\nfdns_configuration_step1_labels = dict(zip(flag_map.values(),fdns_configuration_step1))\nfdns_configuration_step2 = [1,1,1,1,1,0,0,0]\nfdns_configuration_step2_labels = dict(zip(flag_map.values(),fdns_configuration_step2))\nfnsl_configuration_step3 = [1,1,1,1,1,0,0,0]\nfnsl_configuration_step3_labels = dict(zip(flag_map.values(),fnsl_configuration_step3))\nstep1_solution_dict = fdns_configuration_step1_labels.copy()\nstep2_solution_dict = fdns_configuration_step2_labels.copy()\nstep3_solution_dict = fnsl_configuration_step3_labels.copy()\n# do step 1 solve\nierr_fdns_1 = psspy.fdns(fdns_configuration_step1)\n#print('ierr_fdns is {0}'.format(ierr_fdns))\nif ierr_fdns_1 == 0:\nsolveIterat_fdns_1 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fdns_1 = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fdns_1 = psspy.solstr()\nstep1_solution_dict.update({'Step':1,'Solution Method':'fdns',\n'Iterations':solveIterat_fdns_1,'Mismatch':solveSysmsm_fdns_1,'Solution Str':solutionString_fdns_1,\n'ierr':error_map[ierr_fdns_1]})\n# do step 2 solve\nierr_fdns_2 = psspy.fdns(fdns_configuration_step2)\nif ierr_fdns_2 == 0:\nsolveIterat_fdns_2 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fdns_2 = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fdns_2 = psspy.solstr()\nstep2_solution_dict.update({'Step':2,'Solution Method':'fdns',\n'Iterations':solveIterat_fdns_2,'Mismatch':solveSysmsm_fdns_2,\n'Solution Str':solutionString_fdns_2,'ierr':error_map[ierr_fdns_2]})\n# do step 3 solve\nierr_fnsl_3 = psspy.fdns(fnsl_configuration_step3)\nif ierr_fnsl_3 == 0:\nsolveIterat_fnsl_3 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fnsl_3  = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fnsl_3  = psspy.solstr()\nstep3_solution_dict.update({'Step':3,'Solution Method':'fnsl',\n'Iterations':solveIterat_fnsl_3 ,'Mismatch':solveSysmsm_fnsl_3 ,\n'Solution Str':solutionString_fnsl_3 ,'ierr':error_map[ierr_fnsl_3 ]})\nelse:\nstep3_solution_dict.update({'Step':3,'Solution Method':'fnsl',\n'Iterations':'NA' ,'Mismatch':'NA' ,\n'Solution Str':'NA' ,'ierr':error_map[ierr_fnsl_3 ]})\nelse:\nstep2_solution_dict.update({'Step':2,'Solution Method':'fdns',\n'Iterations':'NA','Mismatch':'NA',\n'Solution Str':'NA','ierr':error_map[ierr_fdns_2]})\nelse:\nstep1_solution_dict.update({'Step':1,'Solution Method':'fdns',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':error_map[ierr_fdns_1]})\nstep2_solution_dict.update({'Step':2,'Solution Method':'NA',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':'NA (not attempted)'})\nstep3_solution_dict.update({'Step':3,'Solution Method':'NA',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':'NA (not attempted)'})\nthree_step_solution_dict = dict(zip(step1_solution_dict,zip(step1_solution_dict.values(),step2_solution_dict.values(),step3_solution_dict.values())))\nthree_step_solution_data = pd.DataFrame.from_dict(three_step_solution_dict)\nthree_step_solution_data['Case'] = '{0}'.format(rawfilename)\nif allCaseSolveData.empty == True:\nallCaseSolveData = three_step_solution_data\nallCaseSolveData = allCaseSolveData.drop_duplicates()\nelse:\n# allCaseSolveData = allCaseSolveData.merge(two_step_solution_data,how='outer',\\\n#     on=['Step','Solution Method','Iterations','Mismatch','Solution Str','ierr',\\\n#     'tap adj','area interchange adj','phase shift adj','dc tap adj',\\\n#     'sw shunt adj','flat start','var limit','non-divergent sol'])\nallCaseSolveData = pd.concat([allCaseSolveData,three_step_solution_data],ignore_index=True)\nallCaseSolveData = allCaseSolveData.drop_duplicates()\nreturn allCaseSolveData\ndef getCAConvergenceData(CASELOCATION,rawfilename,allCAData,areaList,temp_dir):\n# generate confile for all single branch elements in the selected areas\ntempConFileLoc = r'{0}\\temp.con'.format(temp_dir)\ngenerateAllSingleBranchAndXFRContingencies(CASELOCATION,areaList,tempConFileLoc)\n# generate sub and mon files\ntempSubFileLoc = r'{0}\\temp.sub'.format(temp_dir)\nf = open(tempSubFileLoc,\"w\")\nf.write(\"SUBSYSTEM 'temp'\\n\")\nfor AR in areaList:\nf.write(\"AREA {0}\\n\".format(AR))\nf.write(\"END\\nEND\")\nf.close()\ntempMonFileLoc = r'{0}\\temp.mon'.format(temp_dir)\nf = open(tempMonFileLoc,\"w\")\nf.write(\"\"\"MONITOR VOLTAGE RANGE SUBSYSTEM 'temp' 0.920 1.050\nMONITOR VOLTAGE DEVIATION SUBSYSTEM 'temp' 0.070 0.070\nMONITOR BRANCHES IN SUBSYSTEM 'temp'\nMONITOR TIES FROM SUBSYSTEM 'temp'\nEND\"\"\")\nf.close()\n# open the case and perform three-step solve from flat start\npsspy.case(CASELOCATION) #re-open case in psse\nfdns_configuration_step1 = [1,1,1,1,1,1,0,0]\nfdns_configuration_step2 = [1,1,1,1,1,0,0,0]\nfnsl_configuration_step3 = [1,1,1,1,1,0,0,0]\nierr_fdns_1 = psspy.fdns(fdns_configuration_step1)\nierr_fdns_2 = psspy.fdns(fdns_configuration_step2)\nierr_fnsl_3 = psspy.fdns(fnsl_configuration_step3)\n# set solution parameters\nCA_TOL = 0.01\nCA_TAPADJ = 1\nCA_AREAINT = 1\nCA_PHADJ = 1\nCA_DCTAP = 1\nCA_SWSH = 1\nCA_SOL = 1 # 'FDNS':0,'FNSL':1,'NSOL':0\nCA_NONDIV = 0\nCA_INDMOT = 0\nCA_INDMACH = 0\nCA_DISP = 0\nCA_ZIP = 0\n# generate dfax\ntempDfaxFileLoc = r'{0}\\temp.dfax'.format(temp_dir)\nierr = psspy.dfax([1,1],tempSubFileLoc,tempMonFileLoc,tempConFileLoc,tempDfaxFileLoc)\n# run accc\ntempAccFileLoc = r'{0}\\temp.acc'.format(temp_dir)\naccc_ierr = psspy.accc_with_dsp_3(CA_TOL,[CA_TAPADJ,CA_AREAINT,CA_PHADJ,CA_DCTAP,CA_SWSH,CA_SOL,CA_NONDIV,CA_INDMOT,CA_INDMACH,CA_DISP,CA_ZIP],\"\",tempDfaxFileLoc,tempAccFileLoc,\"\",\"\",\"\")\n# parse accc results\naccc_output_temp = r'{0}\\accc_output_temp.txt'.format(temp_dir)\n# report configs\nstat1 = 0 #spreadsheet report\nstat2 = 1 #rate 1 for base case violations\nstat3 = 2 #rate 2 for CA violations\nstat4 = 1 #bc SWD ratings set"
  },
  {
    "id": "chunk_104",
    "text": "stat5 = 2 #ca SWD ratings set\nstat6 = 1 #voltage bc normal limit\nstat7 = 1 #voltage ca normal limit\nstat8 = 0 #exclude interfaces from report?\nstat9 = 1 #run voltage limit check\nstat10 = 1 #exclude elements with bc violations in ca violations\nstat11 = 1 #exclude elements with bc violations in ca violations\nstat12 = 0 #exclude cases with no ol's\nstat13 = 0 #do not report post-tripping action solutions\nstat14 = 1 #report loss of loads\nACCC_STATUSES = [stat1,stat2,stat3,stat4,stat5,stat6,stat7,stat8,stat9,stat10,stat11,stat12,stat13,stat14]\nintv1 = 0 #lv range violations filter\nintv2 = 0 #hv range violations filter\nintv3 = 0 #voltage deviation violations filter\nintv4 = 0 #largest num of busses in disconnected island\nintv5 = 6000 #max number of element in avail capacity table\nACCC_INTVALS = [intv1,intv2,intv3,intv4,intv5]\nrlvl1 = 0.5 #bus mismatch convergence\nrlvl2 = 5.0 #system mismatch convergence tolerance in MVA\nrlvl3 = 98 #percent of flow rating I MADE THIS LOW FOR DEV, SHOULD BE CLOSE TO 100\nrlvl4 = 0 #min contingency case flow change from base case value\nrlvl5 = 0 #min contingency case percent loading increase from base case\nrlvl6 = 0 #min contingency case voltage change from base case value\nrlvl7 = 99999 #cutoff threshold for available capacity table\nACCC_REALVALS = [rlvl1,rlvl2,rlvl3,rlvl4,rlvl5,rlvl6,rlvl7]\npsspy.report_output(2,accc_output_temp,[0,0])\naccc_report_ierr = psspy.accc_single_run_report_5(ACCC_STATUSES,ACCC_INTVALS,ACCC_REALVALS,tempAccFileLoc)\nCAresults = getAccReportViolations(accc_output_temp) # parse the acc output report and return a dataframe of results\nif type(CAresults) != type(None):\nConvergedContingencies = CAresults.loc[CAresults['ViolationType']=='Met convergence to']\nAllContingencies = CAresults.loc[CAresults['ViolationType'].isin(['Met convergence to','Iteration limit ex','Blown up'])]\nnumConvergedContingencies = ConvergedContingencies.shape[0]\nnumAllContingencies = AllContingencies.shape[0]\nCAdata = pd.DataFrame({'ConvergedContingencies':[numConvergedContingencies],'TotalContingencies':[numAllContingencies]})\nCAdata['Case'] = '{0}'.format(rawfilename)\nelse:\nCAdata = pd.DataFrame({'ConvergedContingencies':['NA'],'TotalContingencies':['NA'],'UnableToObtainBaseCase':['True']})\nCAdata['Case'] = '{0}'.format(rawfilename)\nif allCAData.empty == True:\nallCAData = CAdata\nallCAData = allCAData.drop_duplicates()\nelse:\nallCAData = pd.concat([allCAData,CAdata],ignore_index=True)\nallCAData = allCAData.drop_duplicates()\nreturn allCAData\ndef getIncorrectShuntRemoteBuses(allSwShunts,rawfilename,allIncorrectShuntRemoteBuses,savLocation,areaList):\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nincorrectShuntRemoteBus = SwShunts.loc[((SwShunts['swreg']>=9700)&(SwShunts['swreg']<=9999))|\\\n((SwShunts['swreg']>=94000)&(SwShunts['swreg']<=99999))|\\\n((SwShunts['swreg']>=100000)&(SwShunts['swreg']<=199999))]\nincorrectShuntRemoteBus = incorrectShuntRemoteBus[['ibus','AREA','shntid','modsw','swreg']]\nincorrectShuntRemoteBus['{0}'.format(rawfilename)] = 'TRUE'\nif allIncorrectShuntRemoteBuses.empty==True:\nallIncorrectShuntRemoteBuses = incorrectShuntRemoteBus\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.drop_duplicates()\nelse:\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.merge(incorrectShuntRemoteBus,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg'])\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.drop_duplicates()\nreturn allIncorrectShuntRemoteBuses\ndef getIncorrectGenRemoteBuses(allGenerators,rawfilename,allIncorrectGenRemoteBuses,savLocation,areaList):\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallGeneratorsWithArea = allGenerators.merge(busData_tmp,how='left',on='ibus')\nGenerators = allGeneratorsWithArea.loc[allGeneratorsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nincorrectGeneratorRemoteBus = Generators.loc[((Generators['ireg']>=9700)&(Generators['ireg']<=9999))|\\\n((Generators['ireg']>=94000)&(Generators['ireg']<=99999))|\\\n((Generators['ireg']>=100000)&(Generators['ireg']<=199999))]\nincorrectGeneratorRemoteBus = incorrectGeneratorRemoteBus[['ibus','AREA','machid','ireg','nreg']]\nincorrectGeneratorRemoteBus['{0}'.format(rawfilename)] = 'TRUE'\nif allIncorrectGenRemoteBuses.empty == True:\nallIncorrectGenRemoteBuses = incorrectGeneratorRemoteBus\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.drop_duplicates()\nelse:\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.merge(incorrectGeneratorRemoteBus,how='outer',\\\non=['ibus','AREA','machid','ireg','nreg'])\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.drop_duplicates()\nreturn allIncorrectGenRemoteBuses\ndef generateAllSingleBranchAndXFRContingencies(CASELOCATION,areaList,tempConFileLoc):\nallBranches = getAllLineData(CASELOCATION)\nallXFRs = getAllXFRData(CASELOCATION)\nall2WXFRs = allXFRs.loc[allXFRs['WIND3NUMBER'].isnull()==True]\nall3WXFRs = allXFRs.loc[allXFRs['WIND3NUMBER'].isnull()==False]\nconfileLocation = tempConFileLoc\nf = open(confileLocation,\"w\")\ncontCounter = 1\nfor br in allBranches.index:\nbusI = allBranches.at[br,'FROMNUMBER']\nbusJ = allBranches.at[br,'TONUMBER']\ncktID = allBranches.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} CKT {2}\".format(busI,busJ,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nfor br in all2WXFRs.index:\nbusI = all2WXFRs.at[br,'WIND1NUMBER']\nbusJ = all2WXFRs.at[br,'WIND2NUMBER']\ncktID = all2WXFRs.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} CKT {2}\".format(busI,busJ,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nfor br in all3WXFRs.index:\nbusI = all3WXFRs.at[br,'WIND1NUMBER']\nbusJ = all3WXFRs.at[br,'WIND2NUMBER']\nbusK = int(all3WXFRs.at[br,'WIND3NUMBER'])\ncktID = all3WXFRs.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} TO BUS {2} CKT {3}\".format(busI,busJ,busK,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nf.write(\"END\")\nf.close()\nreturn\ndef getQAReports(CASEDIRECTORY,OUTPUTDIRECTORY,DESIRED_QA_LIST,AREALIST):\n### DESIRED_QA_LIST is a list of requested reports to be created, it may include the following entries:\n### '900k_buses','CNTB_check','out_of_range_buses','disconnected_shunts','disconnected_loads',\n### 'zero_loads', 'multiple_branches_terminating_on_node', 'invalid_Binit_switched_shunts',\n### 'TREE_islands', 'unterminated_elements', 'br_remote_end_voltage_inconsistencies',\n### 'bus_type_inconsistencies', 'incorrect_voltage_bus_limits', 'TLD_bus_updates',\n### 'check_solvability','check_CA_performance', 'PSSE_pf_checks'\n### create a dictionary of the request reports\navailable_reports = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads'\n]\nreport_dict = {}\nfor report in available_reports:\nif report in DESIRED_QA_LIST:\nreport_dict[report] = 1\nelse:\nreport_dict[report] = 0\n### Create temp directory for file management ###\n#TMP_DIR = makeTempDirectory()\ntemporary_directory = tempfile.TemporaryDirectory()\nTMP_DIR = temporary_directory.name\nprint('Created temp directory {0}.'.format(TMP_DIR))\n#### Supress all the PSSE outputs for now\nsuppressAllPSSEOutputs()\n### Get the list of raw cases to process and define\ntarget_directory = CASEDIRECTORY.GetPath()\ncase_list = glob.glob(target_directory+r'\\*.raw')\n### Prepare the output directory\ntarget_output_directory = OUTPUTDIRECTORY.GetPath()+r'\\QA_results_{}'.format(str(datetime.datetime.now().date()))\nos.makedirs(target_output_directory) #create auto QA check output file\n### set up logger\ntoday_date = str(datetime.date.today())\nlogging.basicConfig(filename='{0}\\log_file'.format(target_output_directory),filemode='a',level=logging.DEBUG,format='%(name)s - %(levelname)s - %(message)s')\nlogging.debug('{0} execute start at {1}'.format(sys.argv[0],datetime.datetime.now()))\nlogging.debug('All required files and directories selected. Now running the following QA reports for the areas {0}:'.format(','.join(map(str,AREALIST))))\nlogging.debug(DESIRED_QA_LIST)\n### Prepare blank dataframes for results\nCNTB_messages = pd.DataFrame()\nBusData = pd.DataFrame()\nallBusInconsistencies = pd.DataFrame()\nallIslands = pd.DataFrame()\nallBrTerminalVoltageInconsistencies = pd.DataFrame()\nallDisconnectedLds = pd.DataFrame()\nallZeroLds = pd.DataFrame()\nallLoads = pd.DataFrame()\nallLoadsWithTotalsColumn = pd.DataFrame()\nallSwShuntsWithInvalidBinit = pd.DataFrame()\nalldisconnected_shunts = pd.DataFrame()\nall900k_buses = pd.DataFrame()\nallCaseSolveData = pd.DataFrame()\nallIncorrectShuntRemoteBuses = pd.DataFrame()\nallIncorrectGenRemoteBuses = pd.DataFrame()\nallCAData = pd.DataFrame()\nallSwShuntsWithInvalidSetpoints = pd.DataFrame()\n# PSSE check powerflow data dataframes\nallPFCheckTypes = {'bus data':1,'load data':2,'plant data':3,'generator unit data':4,\n'induction machine data':5,'fixed bus shunt data':6,'switched shunt data':7,\n'non-transformer branch data':8,'two-winding transformer data':9,\n'three-winding transformer data':10,'transformer impedance table correciton data':11,\n'two-terminal dc line data':13,'multi-terminal dc line data':14,\n'VSC dc line data':15,'FACTS device data':16,'GNE device data':17,\n'area interchange data':18,'owner data':19,'zone data':20}\nallPFCheckResults = {}\nfor checkType in allPFCheckTypes:\nallPFCheckResults[checkType] = pd.DataFrame()\n### Process all raw files according to which reports were requested\ncounter = 1\nfor case in case_list:\n### read in the raw file\nprint('processesing case {0} out of {1}'.format(counter,len(case_list)))\nrawfilename = os.path.splitext(os.path.basename(case))[0]\nlogging.debug('processesing raw {0} -- case {1} out of {2}'.format(rawfilename,counter,len(case_list)))\ncounter = counter+1\npsspy.read(0,case) # open case\n### save the open case as a sav\nsavLocation = target_output_directory+r'\\{0}.sav'.format(rawfilename)\nPSSESaveCase(savLocation)\n### if no areas were chosen by the user, get a list of all areas in the open case\nif AREALIST == []:\nint_data_desired = ['NUMBER']\nint_ierr, iarray = psspy.aareaint(-1, 2, int_data_desired)\nallAreas = iarray[0]\nAREALIST = allAreas\n### if requested, do the solvability check. If the solvability check indicates that the case did not solve, then do not attempt CA check\nif (report_dict['check_solvability'] == 1)|(report_dict['check_CA_performance'] == 1):\n#allCaseSolveData = getSolutionData(rawfilename,allCaseSolveData)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallCaseSolveData = getSolutionData(rawfilename,allCaseSolveData)\nexcept:\nprint('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData().')\nlogging.debug('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData(): ', exc_info=True)\n### if requested, do the CA check. If the solvability check indicates that the case did not solve, then this will not be attempted.\nif report_dict['check_CA_performance'] == 1:"
  },
  {
    "id": "chunk_105",
    "text": "# check last powerflow solution\nlatestSolution = allCaseSolveData.loc[(allCaseSolveData['Case']==rawfilename)&(allCaseSolveData['Step']==3)]\nlatestSolution = latestSolution.reset_index()\nif (latestSolution.at[0,'Solution Str'] != 'Met convergence tolerances                      '):\nnoData = pd.DataFrame({'Case':[rawfilename],'CANotAttemptedDuetoNon-SolvedRAW':['True']})\nallCAData = pd.concat([allCAData,noData],ignore_index=True)\nelse:\n#allCAData = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallCAData = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR)\nexcept:\nprint('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData().')\nlogging.debug('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData(): ', exc_info=True)\n### if requested, do the CNTB check\nif report_dict['CNTB_check'] == 1:\n#CNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nCNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages,AREALIST)\nexcept:\nprint('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData().')\nlogging.debug('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData(): ', exc_info=True)\n### if any bus-related reports requested, get the bus data and extract the relevant data\nif (report_dict['900k_buses'] == 1): # for ERCOT-only distribution\n#BusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nBusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData(): ', exc_info=True)\nif (report_dict['900k_buses'] == 1) & (BusData.empty == False):\n#all900k_buses = get900kBuses(BusData) #to troubleshoot, uncomment this line and comment out the following try/except block\ntry:\nall900k_buses = get900kBuses(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().', exc_info=True)\n### if requested, get all the load data\nif (report_dict['all_lds'] == 1)|(report_dict['disconnected_loads'] == 1)|(report_dict['zero_loads'] == 1):\n#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseAllLoadData = getLdDataTotalsReportedInCaseColumn(savLocation,allLoads,rawfilename,AREALIST)\nif allLoads.empty == True:\nallLoads = thisCaseAllLoadData\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(thisCaseAllLoadData,how='outer',on=['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn(): ', exc_info=True)\n#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseLoadData = getLdData(savLocation,allLoadsWithTotalsColumn,rawfilename,AREALIST)\nif allLoadsWithTotalsColumn.empty == True:\nallLoadsWithTotalsColumn = thisCaseLoadData\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nelse:\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.merge(thisCaseLoadData,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData(): ', exc_info=True)\nif report_dict['disconnected_loads'] == 1:\n#allDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nallDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads()')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads(): ', exc_info=True)\nif report_dict['zero_loads'] == 1:\n#allZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds) #TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads(): ', exc_info=True)\n### if requested, get the disconnected shunts\nif report_dict['disconnected_shunts'] == 1:\n#alldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nalldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts(): ', exc_info=True)\n### if requested, get the bus inconsistencies\nif report_dict['bus_type_inconsistencies'] == 1:\n#allBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies(): ', exc_info=True)\n### if requested, get the islands from TREE\nif report_dict['TREE_islands'] == 1:\n#allIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands(): ', exc_info=True)\n### if requested, get the PSSE pf check reports\nif report_dict['PSSE_pf_checks'] == 1:\n#allPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks(): ', exc_info=True)\n### if requested, get the branch remote end voltage inconsistencies\nif report_dict['br_remote_end_voltage_inconsistencies'] == 1:\n#allBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies(): ', exc_info=True)\n### if any node-breaker checks are required, get the raw model in JSON format and extract the node breaker data\n# this is the if statement for the ERCOT-distributed version\nif ((report_dict['invalid_Binit_switched_shunts'] == 1)\\\n| (report_dict['incorrect_shunt_remote_buses'] == 1) | (report_dict['incorrect_gen_remote_buses'] == 1) \\\n| (report_dict['invalid_setpts_continuous_shunts'] == 1)):\n#RAW_JSON = getRawxJSON(TMP_DIR,rawfilename) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nRAW_JSON = getRawxJSON(TMP_DIR,rawfilename)\nexcept:\nprint('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON()')\nlogging.debug('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON(): ', exc_info=True)\n#IBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, ALL_ELEMENT_DATA_DICT = getNodeBreakerData(RAW_JSON)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nIBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, \\\nALL_ELEMENT_DATA_DICT, ALL_TERMABLE_EQUIP_W_NODE_DATA_INCL_SUBSWDS = getNodeBreakerData(RAW_JSON)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData(): ', exc_info=True)\nif report_dict['invalid_Binit_switched_shunts'] == 1:\n#allSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts(): ', exc_info=True)\nif report_dict['invalid_setpts_continuous_shunts'] == 1:\n#allSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts(): ', exc_info=True)"
  },
  {
    "id": "chunk_106",
    "text": "### if requested, get the incorrect switched shun remote bus report\nif report_dict['incorrect_shunt_remote_buses'] == 1:\n#allIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses(): ', exc_info=True)\n### if requested, get the incorrect generator remote bus report\nif report_dict['incorrect_gen_remote_buses'] == 1:\n#allIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses(): ', exc_info=True)\n### Save the reports\nlogging.debug('Processing cases is complete. Now creating reports')\nsummaryReport = pd.DataFrame(columns=['Report','Number of Results','Location'])\n# make excel for CNTB messages\nif report_dict['CNTB_check']==1:\nlogging.debug('Creating CNTB Report')\n#CNTB_messages.to_csv(target_output_directory+r'\\all_CNTB_messages.csv')\nCNTB_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_CNTB_messages.xlsx')\nCNTB_errors = CNTB_messages.loc[CNTB_messages['Type']=='ERROR']\nCNTB_warnings = CNTB_messages.loc[CNTB_messages['Type']=='Warning']\n#CNTB_other = CNTB_messages.loc[CNTB_messages_tmp['Type']=='Other']\nCNTB_errors.to_excel(CNTB_excelWriter,sheet_name='Errors')\nCNTB_warnings.to_excel(CNTB_excelWriter,sheet_name='Warnings')\n#CNTB_other.to_excel(CNTB_excelWriter,sheet_name='Other')\nCNTB_excelWriter.save()\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['CNTB_errors','CNTB_warnings'],\n'Number of Results':[CNTB_errors.index.size,CNTB_warnings.index.size],\n'Location':[target_output_directory+r'\\all_CNTB_messages.xlsx',target_output_directory+r'\\all_CNTB_messages.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# make excel for PSSE_pf_check_results\nif report_dict['PSSE_pf_checks'] == 1:\nlogging.debug('Creating PSSE_pf_checks report')\nPSSEpfCheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_PSSE_pf_checks.xlsx')\nfor checkType in allPFCheckResults.keys():\nsheet_name_max = checkType[0:30]\nallPFCheckResults[checkType].to_excel(PSSEpfCheck_excelWriter,sheet_name='{0}'.format(sheet_name_max))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['PSSE PF Check - {0}'.format(checkType)],\n'Number of Results':[allPFCheckResults[checkType].index.size],\n'Location':[target_output_directory+r'\\all_PSSE_pf_checks.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\nPSSEpfCheck_excelWriter.save()\n# make csv reports for all the other reports\nreport_to_data_dictionary = {'900k_buses':all900k_buses,\\\n'disconnected_shunts':alldisconnected_shunts,\\\n'disconnected_loads':allDisconnectedLds,\\\n'zero_loads':allZeroLds,\\\n'invalid_Binit_switched_shunts':allSwShuntsWithInvalidBinit,\\\n'TREE_islands':allIslands,\\\n'br_remote_end_voltage_inconsistencies':allBrTerminalVoltageInconsistencies,\\\n'bus_type_inconsistencies':allBusInconsistencies,\\\n'all_lds':allLoads,\\\n'check_solvability':allCaseSolveData,\\\n'incorrect_shunt_remote_buses':allIncorrectShuntRemoteBuses,\\\n'incorrect_gen_remote_buses':allIncorrectGenRemoteBuses,\\\n'check_CA_performance':allCAData,\\\n'invalid_setpts_continuous_shunts':allSwShuntsWithInvalidSetpoints}\nfor report in report_to_data_dictionary.keys():\nif report_dict[report]==1:\nlogging.debug('Creating {0} report'.format(report))\nreport_to_data_dictionary[report].to_csv(target_output_directory+r'\\{0}.csv'.format(report))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':[report],\n'Number of Results':[report_to_data_dictionary[report].index.size],\n'Location':[target_output_directory+r'\\{0}.csv'.format(report)]})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# create summary report\nlogging.debug('Creating summary report.')\nsummaryReport['Location'] = summaryReport['Location'].apply(lambda x: make_clickable(x, x))\nsummaryReport = summaryReport.sort_values(by=['Number of Results'],ascending=False)\nsummary_html = summaryReport.to_html(render_links=True,escape=False)\ntext_file = open(target_output_directory+r'\\SummaryReport.html','w')\ntext_file.write(summary_html)\ntext_file.close()\nlogging.debug('Reports completed.')\nlogging.debug('Done.')\nlogging.shutdown()\n########### CLASS DEFINITIONS ##############\nclass SSWGCaseQA(wx.Frame):\ndef __init__(self):\nself.SelectedAreas = []\nself.SelectedBuses = []\nself.AllAreas = [] # replace with real data from case when the corresponding button is selected\nself.AllBuses = [] # replace with real data from case when the corresponding button is selected\nself.chosenAreas = []\nself.chosenBuses = []\nwx.Frame.__init__(self,None,wx.ID_ANY,\"Perform quality assurance checks on raw file(s).\",size =(1000,600))\nself.panel = wx.Panel(self, wx.ID_ANY)\n# make wrapper\nself.wrapper = wx.FlexGridSizer(4,1,20,20) # wx.FlexGridSizer(2,1,20,20)\nself.wrapper.AddGrowableCol(0)\n#select an SSWG cases directory\nself.label1 = wx.StaticText(self.panel)\nself.caseDirectory = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow1 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the SSWG raw case directory (all .raw files in the selected directory will be analyzed):'), orient=wx.HORIZONTAL)\nrow1.Add(self.label1,0,wx.TOP | wx.RIGHT,10)\nrow1.Add(self.caseDirectory)\nself.wrapper.Add(row1,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n#select model areas for report generation\nself.label3 = wx.StaticText(self.panel)\n#self.conFile = wx.FilePickerCtrl(self.panel, size=(800,25),wildcard=\"*.con\")\nself.reportAreas = wx.TextCtrl(self.panel, size=(800,25),value=\"\")\nrow3 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please provide a comma-separated list of areas for reporting (leave blank to get results for entire model):'), orient=wx.HORIZONTAL)\nrow3.Add(self.label3,0,wx.TOP | wx.RIGHT,10)\nrow3.Add(self.reportAreas)\nself.wrapper.Add(row3,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n# self.panel.SetSizerAndFit(wrapper)\n# self.Centre()\n#select an output directory\nself.label2 = wx.StaticText(self.panel)\nself.dirCtrl = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow2 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the output location for reports:'), orient=wx.HORIZONTAL)\nrow2.Add(self.label2,0,wx.TOP | wx.RIGHT,10)\nrow2.Add(self.dirCtrl)\nself.wrapper.Add(row2,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\nself.panel.SetSizerAndFit(self.wrapper)\nself.Centre()\n# report selection radio buttons\nself.RB_900k_buses = wx.CheckBox(self.panel,11,label='900k+ buses',pos =(100,275))\nself.RB_900k_buses.SetValue(True)\nself.RB_TREE_islands = wx.CheckBox(self.panel,22,label='TREE_islands',pos =(300,275))\nself.RB_TREE_islands.SetValue(True)\nself.RB_bus_type_inconsistencies = wx.CheckBox(self.panel,33,label='Bus type inconsistencies',pos =(500,275))\nself.RB_bus_type_inconsistencies.SetValue(True)\nself.RB_CNTB_check = wx.CheckBox(self.panel,33,label='CNTB check',pos =(700,275))\nself.RB_CNTB_check.SetValue(True)\nself.RB_disconnected_shunts = wx.CheckBox(self.panel,44,label='Disconnected shunts',pos =(100,300))\nself.RB_disconnected_shunts.SetValue(True)\nself.RB_invalid_Binit_switched_shunts = wx.CheckBox(self.panel,55,label='Invalid Binit sw. shunts',pos =(300,300))\nself.RB_invalid_Binit_switched_shunts.SetValue(True)\nself.RB_invalid_setpts_continuous_shunts = wx.CheckBox(self.panel,66,label='Invalid VHi-VLo cont. ctrl. shunts',pos =(500,300))\nself.RB_invalid_setpts_continuous_shunts.SetValue(True)\nself.RB_incorrect_shunt_remote_buses = wx.CheckBox(self.panel,77,label='Non-POI Shunt Remote Bus',pos =(700,300))\nself.RB_incorrect_shunt_remote_buses.SetValue(True)\nself.RB_incorrect_gen_remote_buses = wx.CheckBox(self.panel,88,label='Non-POI Gen Remote Bus',pos =(100,325))\nself.RB_incorrect_gen_remote_buses.SetValue(True)\nself.RB_br_remote_end_voltage_inconsistencies = wx.CheckBox(self.panel,99,label='Inconsistent line end voltages',pos =(300,325))\nself.RB_br_remote_end_voltage_inconsistencies.SetValue(True)\nself.RB_check_solvability = wx.CheckBox(self.panel,111,label='Check solvability',pos =(500,325))\nself.RB_check_solvability.SetValue(True)\nself.RB_check_CA_performance = wx.CheckBox(self.panel,222,label='Check CA performance (sng. br. elem)',pos =(700,325))\nself.RB_check_CA_performance.SetValue(True)\nself.RB_PSSE_pf_checks = wx.CheckBox(self.panel,333,label='PSSE pf checks',pos =(100,350))\nself.RB_PSSE_pf_checks.SetValue(True)\nself.RB_all_lds = wx.CheckBox(self.panel,444,label='All loads report',pos =(300,350))\nself.RB_all_lds.SetValue(True)\nself.RB_disconnected_loads = wx.CheckBox(self.panel,555,label='Disconnected loads',pos =(500,350))\nself.RB_disconnected_loads.SetValue(True)\nself.RB_zero_loads = wx.CheckBox(self.panel,666,label='0 MVA loads',pos =(700,350))\nself.RB_zero_loads.SetValue(True)\n# button push\nself.generateQAReports = wx.Button(self.panel,-1, \"Generate Selected QA Reports\", pos=(400, 450))\nself.generateQAReports.Bind(wx.EVT_BUTTON, self.generateQAReportsBtnEvent, self.generateQAReports)\ndef generateQAReportsBtnEvent(self, event):\nif self.caseDirectory.GetPath() == '':\nself.nocaseDirectoryChosenMessage = wx.MessageBox('Choose a valid SSWG case directory to read the unprocessed raw files from.')\nreturn\nif self.dirCtrl.GetPath() == '':\nself.nooutputDirectoryChosenMessage = wx.MessageBox('Choose an output directory for the output reports.')\nreturn\nif self.reportAreas.GetLineText(0) == '':\nareaList = []\nelse:\ntry:\nareaList = self.reportAreas.GetLineText(0).split(\",\")\nareaList = [int(x) for x in areaList]\nexcept:\nareaList = None\nif areaList == None:\nself.areaErrorMessage = wx.MessageBox('Type a comma-separated list of areas for which to run the QA checks. (For example: \"1, 2, 3\"). Do not enter any newline characters. Leave this blank if you want to run the reports for the entire model, regardless of area.')\nrunAllReportsList = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads']\nreportSelections = [self.RB_900k_buses.GetValue(),\nself.RB_TREE_islands.GetValue(),\nself.RB_bus_type_inconsistencies.GetValue(),\nself.RB_CNTB_check.GetValue(),\nself.RB_disconnected_shunts.GetValue(),\nself.RB_invalid_Binit_switched_shunts.GetValue(),\nself.RB_invalid_setpts_continuous_shunts.GetValue(),\nself.RB_incorrect_shunt_remote_buses.GetValue(),\nself.RB_incorrect_gen_remote_buses.GetValue(),\nself.RB_br_remote_end_voltage_inconsistencies.GetValue(),\nself.RB_check_solvability.GetValue(),\nself.RB_check_CA_performance.GetValue(),\nself.RB_PSSE_pf_checks.GetValue(),\nself.RB_all_lds.GetValue(),\nself.RB_disconnected_loads.GetValue(),\nself.RB_zero_loads.GetValue()]\nAllReportsDict = dict(zip(runAllReportsList,reportSelections))\nRequestedReportsDict = {key: value for key, value in AllReportsDict.items() if value == True}\n#trigger the report creation\nprint('All required files and directories selected. Now running the following QA reports:')\nprint(list(RequestedReportsDict.keys()))\ngetQAReports(CASEDIRECTORY=self.caseDirectory,OUTPUTDIRECTORY=self.dirCtrl,DESIRED_QA_LIST=list(RequestedReportsDict.keys()),AREALIST=areaList)\nprint('Done!')\nself.QAReportsComplete = wx.MessageBox('SSWG QA reports complete. Go to {} to see results.'.format(self.dirCtrl.GetPath()))\n############ MAIN ###############\nif __name__ == \"__main__\":\napp = wx.App(False)\nframe = SSWGCaseQA() # for general SSWG distribution\nframe.Show()\napp.MainLoop()\n# Get Load stats with GUI\nimport wx\nimport pandas as pd\nimport pyodbc\nimport datetime\nfrom dateutil.relativedelta import relativedelta\nimport copy\nimport shutil\nimport os\nimport numpy as np\nimport sys\nimport tempfile\nimport xlsxwriter\nimport pathlib\nimport glob\nimport json\nimport requests\nimport logging\nimport struct\nimport time\nimport tkinter\nfrom tkinter import Tk\nfrom tkinter import Button\nfrom tkinter import filedialog\nimport warnings\nimport io\n### Get psspy bin\nprint('Select the bin location for the PSSE psspy.pyc and redirect.pyc files. Please use PSSE 35.6.')\nroot = Tk()\nPSSE_PATH = filedialog.askdirectory(initialdir = r'C:\\Program Files\\PTI\\PSSE35')\nroot.mainloop\nif (pathlib.Path(r'{0}\\psspy.pyc'.format(PSSE_PATH)).exists() == False) | (pathlib.Path(r'{0}\\redirect.pyc'.format(PSSE_PATH)).exists() == False):\nprint('No psspy.pyc and/or redirect.pyc package found at bin directory supplied {0}'.format(PSSE_PATH))\nexit()\nroot.destroy()\n#### PSS/E session initialization ####\nsys.path.append(PSSE_PATH)\nos.environ['PATH'] += ';' + PSSE_PATH\nimport psspy\nimport redirect\nredirect.psse2py()                                  ## Set output to Python Shell\nierr = psspy.psseinit(0)                            ## Initialize PSSE\n# ignore warnings to avoid terminal message clutter."
  },
  {
    "id": "chunk_107",
    "text": "warnings.filterwarnings('ignore')\n########### FUNCTION DEFINITIONS ###########\ndef parseBrViolationReport(BR_REPORTDATA):\n#define column names and specs:\nBR_col_names = ['From Bus Number','From Bus Name','From Bus kV','From Bus Area','To Bus Number','To Bus Name',\\\n'To Bus kV','To Bus Area','Circuit ID','Loading','Rating A',r'Rating A % Loading','Rating B',r'Rating B % Loading','Rating C',r'Rating C % Loading']\nBR_col_specs = [(0,11),(11,23),(23,31),(31,35),(35,47),(47,59),(59,67),(67,72),(72,76),(76,85),(85,91),(91,101),(101,108),(108,115),(115,123),(123,131)]\n#define relevant header limits\nlookup_limit1 = 'PTI INTERACTIVE POWER SYSTEM SIMULATOR'\nlookup_limit2 = 'BUS#-SCT'\nlookup_none = '* NONE *'\nheaderFlag = False\n#read in report data and determine which lines contain header limits\nBR_data = io.StringIO(getFileByteData(BR_REPORTDATA).decode('utf-8'))\nBR_data_formatted = io.StringIO()\nfor num, line in enumerate(BR_data,1):\nif lookup_limit1 in line:\nheaderFlag = True\ncontinue\nif lookup_limit2 in line:\nheaderFlag = False\ncontinue\nif lookup_none in line:\ncontinue\nif headerFlag == False:\nBR_data_formatted.write(line)\n#remove the header data from the report\nBR_data_formatted.seek(0) #go to top of the file\nBR_DF = pd.read_fwf(BR_data_formatted,names=BR_col_names,colspecs=BR_col_specs)\n# set dtypes of each column to ensure consistency, added 12/27/22 because sometimes nullvalues come back as object dtype\n# updated 1/17/2023 to fix the datatype of To Bus Number to str, because 3-winding xfr's actually don't have a To bus number and have a string in this column\nconvert_dict = {'From Bus Number':int,\\\n'From Bus Name':str,\\\n'From Bus kV':str,\\\n'From Bus Area':int,\\\n'To Bus Number':str,\\\n'To Bus Name':str,\\\n'To Bus kV':str,\\\n'To Bus Area':int,\\\n'Circuit ID':str,\\\n'Loading':float,\\\n'Rating A':float,\\\nr'Rating A % Loading':float,\\\n'Rating B':float,\\\nr'Rating B % Loading':float,\\\n'Rating C':float,\\\nr'Rating C % Loading':float}\nBR_DF = BR_DF.astype(convert_dict,errors='ignore') # updating 2/6/24 to avoid pandas throwing errors for PSSE reporting '*******' for unreasonably large numbers\nreturn BR_DF\ndef parseVoltViolationReport(VOLT_REPORTDATA):\n#define column names and specs:\nVT_col_names = ['Bus Number','Bus Name','Bus kV','V(pu)','V Limit']\nVT_col_specs_left = [(0,11),(11,23),(23,30),(30,37),(37,43)]\nVT_col_specs_right = [(49,58),(58,70),(70,77),(77,84),(84,90)]\n#define relevant header limits\nlookup_limit1 = 'PTI INTERACTIVE POWER SYSTEM SIMULATOR'\nlookup_limit2 = 'BUS#-SCT'\nlookup_low_voltage = 'BUSES WITH VOLTAGE LESS THAN'\nlookup_high_voltage = 'BUSES WITH VOLTAGE GREATER THAN'\nlookup_none = '* NONE *'\nheaderFlag = False\nvoltageFlag = None\n#read in report data and remove header data\nVT_data = io.StringIO(getFileByteData(VOLT_REPORTDATA).decode('utf-8'))\nLow_VT_data_formatted = io.StringIO()\nHi_VT_data_formatted = io.StringIO()\nfor num, line in enumerate(VT_data,1):\nif lookup_limit1 in line:\nheaderFlag = True\ncontinue\nif lookup_limit2 in line:\nheaderFlag = False\ncontinue\nif lookup_high_voltage in line:\nvoltageFlag = 'HIGH'\ncontinue\nif lookup_low_voltage in line:\nvoltageFlag = 'LOW'\ncontinue\nif lookup_none in line:\ncontinue\nif headerFlag == False:\nif voltageFlag == 'HIGH':\nHi_VT_data_formatted.write(line)\nif voltageFlag == 'LOW':\nLow_VT_data_formatted.write(line)\nLow_VT_data_formatted.seek(0) #go to top of the file\nHi_VT_data_formatted.seek(0) #go to top of the file\nLow_VT_DF_left = pd.read_fwf(Low_VT_data_formatted,names=VT_col_names,colspecs=VT_col_specs_left)\nLow_VT_DF_right = pd.read_fwf(Low_VT_data_formatted,names=VT_col_names,colspecs=VT_col_specs_left)\nLow_VT_DF = Low_VT_DF_left.append(Low_VT_DF_right,ignore_index=True)\nLow_VT_DF['Voltage Violation Type'] = 'LOW'\nHi_VT_DF_left = pd.read_fwf(Hi_VT_data_formatted,names=VT_col_names,colspecs=VT_col_specs_left)\nHi_VT_DF_right = pd.read_fwf(Hi_VT_data_formatted,names=VT_col_names,colspecs=VT_col_specs_left)\nHi_VT_DF = Hi_VT_DF_left.append(Hi_VT_DF_right,ignore_index=True)\nHi_VT_DF['Voltage Violation Type'] = 'HIGH'\nVT_DF = pd.concat([Low_VT_DF,Hi_VT_DF],ignore_index=True)\nVT_DF = VT_DF.loc[VT_DF['Bus Number'].notnull()==True]\nVT_DF['Bus Number'] = VT_DF['Bus Number'].astype(str)\nreturn VT_DF\ndef getAccReportViolations(Report): # pass location of PSSE text acc report\nFile1 = open(Report,'br')\nDict1 = File1.readlines()\niter_Dict1 = iter(Dict1) # iterating over the iter, see https://stackoverflow.com/questions/21594302/is-there-a-way-to-remember-the-position-in-a-python-iterator\nBrOL1 = None\nSwdOL1 = None\nVoltOL1 = None\nLdLoss1 = None\nConvRes1 = None\nCon_File_Name1 = None\nCA_Violations = None # adding this Nonetype assignment on 6/14/2021, not sure why but this appears to be a problem now with recent updates.\nBrOL1 = pd.DataFrame(columns=['Monitored_Branch','Contingency_Label','Rating','MW','Mvar','MVA','%'])\nSwdOL1 = pd.DataFrame(columns=['Monitored_SWD','Contingency_Label','Rating','MW','Mvar','MVA','%','SWD_Loop'])\nVoltOL1 = pd.DataFrame(columns=['System','Contingency_Label','Bus','V-Cont','V-Init','V-Max','V-Min'])\nLdLoss1 = pd.DataFrame(columns=['Bus','Contingency_Label','Load(MW)'])\nConvRes1 = pd.DataFrame(columns=['Contingency_Label','Termination_State','Flow#','Volt#','Load'])\nCon_File_Name1 = \"\"\n#read report data into pandas dataframes\nBrOL_fields = []\nSwdOL_fields = []\nVoltOL_fields = []\nLdLoss_fields = []\nConvRes_fields = []\nfor line in iter_Dict1:\nif \"CONTINGENCY DESCRIPTION FILE:\" in line.decode(\"utf-8\"):\nCon_File_Name1 = line[30:]\nbreak\nfor line in iter_Dict1:\n#print line\nif \"<--------------------- MONITORED BRANCH ---------------------> <----- CONTINGENCY LABEL ------>   RATING       MW     Mvar      MVA      %\" in line.decode(\"utf-8\"):\n#print \"Found Branch OL section of report\"\nfieldwidths = (62,-1,32,-1,8,-1,8,-1,8,-1,8,-1,6) # field widths of ACCC report Branch OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Branch OL section of report (newline found)\"\nBrOL1 = pd.DataFrame(data = BrOL_fields, columns=['Monitored_Branch','Contingency_Label','Rating','MW','Mvar','MVA','%'])\nbreak\n#print parse(line)\nBrOL_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<-------- MONITORED  SWD --------> <----- CONTINGENCY LABEL ------>   RATING       MW     Mvar      MVA      %   SWD LOOP\" in line.decode(\"utf-8\"):\n#print \"Found SWD OL section of report\"\nfieldwidths = (34,-1,32,-1,8,-1,8,-1,8,-1,8,-1,6,-1,10) # field widths of ACCC report SWD OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of SWD OL section of report (newline found)\"\nSwdOL1 = pd.DataFrame(data = SwdOL_fields, columns=['Monitored_SWD','Contingency_Label','Rating','MW','Mvar','MVA','%','SWD_Loop'])\nbreak\n#print parse(line)\nSwdOL_fields.append(parse(line))\nfor line in iter_Dict1:\nif \"SYSTEM                                       <----- CONTINGENCY LABEL ------> <---------- B U S ---------->   V-CONT   V-INIT   V-MAX    V-MIN\" in line.decode(\"utf-8\"):\n#print \"Found Voltage violation section of report\"\nfieldwidths = (44,-1,32,-1,29,-1,8,-1,8,-1,7,-1,8) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Voltage Violation section of report (newline found)\"\nVoltOL1 = pd.DataFrame(data = VoltOL_fields, columns=['System','Contingency_Label','Bus','V-Cont','V-Init','V-Max','V-Min'])\nbreak\n#print parse(line)\nVoltOL_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<---------- B U S ----------> <----- CONTINGENCY LABEL ------> LOAD(MW)\" in line.decode(\"utf-8\"):\n#print \"Found Load Loss section of report\"\nfieldwidths = (29,-1,32,-1,8) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Load Loss section of report (newline found)\"\nLdLoss1 = pd.DataFrame(data = LdLoss_fields, columns=['Bus','Contingency_Label','Load(MW)'])\nbreak"
  },
  {
    "id": "chunk_108",
    "text": "#print parse(line)\nLdLoss_fields.append(parse(line))\nfor line in iter_Dict1:\n#print line\nif \"<TERMINATION  STATE> FLOW#  SWD# VOLT#  LOAD\" in line.decode(\"utf-8\"):\n#print \"Found Convergence section of report\"\nfieldwidths = (32,20,-1,5,-1,5,-1,5,-1,5) # field widths of ACCC report Thermal OL section, negative width represent ignored padding fields\nfmtstring = ' '.join('{}{}'.format(abs(fw), 'x' if fw < 0 else 's')\nfor fw in fieldwidths)\nfieldstruct = struct.Struct(fmtstring)\nparse = fieldstruct.unpack_from\nbreak\nfor line in iter_Dict1:\nif len(line.decode(\"utf-8\")) == 2: #= '\\n': #to find encoded newline, look for a line of length 2\n#print \"Found end of Convergence section of report (newline found)\"\nConvRes1 = pd.DataFrame(data = ConvRes_fields, columns=['Contingency_Label','Termination_State','Flow#','SWD#','Volt#','Load'])\nbreak\n#print parse(line)\nConvRes_fields.append(parse(line))\nBrOL1['ViolationType']=b'Br Thermal'\nSwdOL1['ViolationType']=b'SWD Thermal'\nVoltOL1['ViolationType']=b'Voltage'\nVoltOL1['Rating']=b'1'\nLdLoss1['ViolationType']=b'LdLoss'\nLdLoss1['Rating']=b'0'\nConvRes1['VioValue']=b'1'\nConvRes1['Rating']=b'0'\nConvRes1['Location']=ConvRes1['Contingency_Label']\nCA_Violations = pd.DataFrame(columns=['ViolationType','Contingency','Location','VioValue','Rating'])\nCA_Violations = CA_Violations.append([BrOL1[['ViolationType','Contingency_Label','Monitored_Branch','%','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Monitored_Branch':'Location','%':'VioValue'}),SwdOL1[['ViolationType','Contingency_Label','Monitored_SWD','%','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Monitored_SWD':'Location','%':'VioValue'}),VoltOL1[['ViolationType','Contingency_Label','Bus','V-Cont','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Bus':'Location', 'V-Cont':'VioValue'}),LdLoss1[['ViolationType','Contingency_Label','Bus','Load(MW)','Rating']].rename(columns={'Contingency_Label':'Contingency', \\\n'Bus':'Location','Load(MW)':'VioValue'}),ConvRes1[['Contingency_Label','Termination_State','VioValue','Rating','Location']].rename \\\n(columns={'Contingency_Label':'Contingency','Termination_State':'ViolationType'})],ignore_index=True,sort=False)\n#decode for human consumption\nCA_Violations['ViolationType'] = CA_Violations['ViolationType'].str.decode(encoding = 'UTF-8')\nCA_Violations['ViolationType'] = CA_Violations['ViolationType'].str.strip() #remove leading and trailing spaces\nCA_Violations['Contingency'] = CA_Violations['Contingency'].str.decode(encoding = 'UTF-8')\nCA_Violations['Contingency'] = CA_Violations['Contingency'].str.strip() #remove leading and trailing spaces\nCA_Violations['Location'] = CA_Violations['Location'].str.decode(encoding = 'UTF-8')\nCA_Violations['Location'] = CA_Violations['Location'].str.strip() #remove leading and trailing spaces\nCA_Violations['VioValue'] = CA_Violations['VioValue'].str.decode(encoding = 'UTF-8')\nCA_Violations['VioValue'] = CA_Violations['VioValue'].str.strip() #remove leading and trailing spaces\nCA_Violations['VioValue'] = pd.to_numeric(CA_Violations['VioValue']) #convert strings to numbers\nCA_Violations['Rating'] = CA_Violations['Rating'].str.decode(encoding = 'UTF-8')\nCA_Violations['Rating'] = CA_Violations['Rating'].str.strip() #remove leading and trailing spaces\nCA_Violations['Rating'] = pd.to_numeric(CA_Violations['Rating']) #convert strings to numbers\nreturn CA_Violations\ndef getAllXFRData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired_2W = ['ID','XFRNAME','VECTORGROUP']\nint_data_desired_2W = ['FROMNUMBER','TONUMBER','STATUS']\nchar_ierr_2W, carray_2W = psspy.atrnchar(SID, 1,3,2,1,char_data_desired_2W) #get all transformers, single entry\nint_ierr_2W, iarray_2W = psspy.atrnint(SID, 1,3,2,1,int_data_desired_2W)\nchar_data_desired_3W = ['ID','XFRNAME','VECTORGROUP']\nint_data_desired_3W = ['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER','STATUS']\nchar_ierr_3W, carray_3W = psspy.atr3char(SID, 1,3,2,1, char_data_desired_3W) #get all transformers\nint_ierr_3W, iarray_3W = psspy.atr3int(SID, 1,3,2,1,int_data_desired_3W)\nif char_ierr_2W!=0 or int_ierr_2W!=0 or char_ierr_3W!=0 or int_ierr_3W!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get transformer data.'])\nelse:\n# compile 2-winding XFR data into a dataframe\nallColumns_2W = char_data_desired_2W+int_data_desired_2W\nallData_2W = carray_2W+iarray_2W\nDF_dict_2W = dict(zip(allColumns_2W,allData_2W))\nDF_2W = pd.DataFrame(DF_dict_2W)\nDF_2W = DF_2W.rename(columns={'FROMNUMBER':'WIND1NUMBER','TONUMBER':'WIND2NUMBER'}) #rename the columns for easier appending\n# compile 3-winding XFR data into a dataframe\nallColumns_3W = char_data_desired_3W+int_data_desired_3W\nallData_3W = carray_3W+iarray_3W\nDF_dict_3W = dict(zip(allColumns_3W,allData_3W))\nDF_3W = pd.DataFrame(DF_dict_3W)\n# append the 2W and 3W data together\nDF_all = DF_2W.append(DF_3W, ignore_index=True)\nreturn DF_all\ndef getAllLineData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID']\nint_data_desired = ['FROMNUMBER','TONUMBER','STATUS']\nchar_ierr, carray = psspy.abrnchar(SID, 1,3,2,1,char_data_desired) #get all branches, single entry\nint_ierr, iarray = psspy.abrnint(SID, 1,3,2,1,int_data_desired) #get all branches, single entry\nif SID != -1:\nPSSE_SID_manager.decoupleDynamicSID(SID_manager,PSSESUBSYS)\nif char_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get line data.'])\nelse:\nallColumns = char_data_desired+int_data_desired\nallData = carray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllFixedShuntData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME']\ncomplex_data_desired = ['O_SHUNTACT']\nint_data_desired = ['NUMBER','STATION','STATUS']\nchar_ierr, carray = psspy.afxshuntchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.afxshuntcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.afxshuntint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case fixed shunt data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllSwShuntData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME']\ncomplex_data_desired = ['O_YSWACT']\nint_data_desired = ['NUMBER','STATION', 'AREA', 'ZONE', 'STATUS','OWNER']\nchar_ierr, carray = psspy.aswshchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.aswshcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.aswshint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case switched shunt data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllLoadData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['ID','NAME','LODTYPE']\ncomplex_data_desired = ['TOTALACT']\nint_data_desired = ['NUMBER','STATION', 'AREA', 'ZONE', 'STATUS','OWNER','SCALE','INTRPT']\nchar_ierr, carray = psspy.aloadchar(SID, 4, char_data_desired) #get for all machines and all buses\ncomp_ierr, xarray = psspy.aloadcplx(SID, 4, complex_data_desired)\nint_ierr, iarray = psspy.aloadint(SID, 4, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get case load data.'])\nelse:\nallColumns = char_data_desired+complex_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef getAllBusData(CASELOCATION):\nPSSEOpenCase(CASELOCATION)\nSID = -1\nchar_data_desired = ['NAME','EXNAME']\nreal_data_desired = ['BASE','NVLMLO','NVLMHI','EVLMLO','EVLMHI']\nint_data_desired = ['NUMBER','AREA','OWNER','ZONE','SECTION','TYPE']\nchar_ierr, carray = psspy.abuschar(SID, 2, char_data_desired)\ncomp_ierr, xarray = psspy.abusreal(SID, 2, real_data_desired)\nint_ierr, iarray = psspy.abusint(SID, 2, int_data_desired)\nif char_ierr!=0 or comp_ierr!=0 or int_ierr!=0 : #check for errors and if any encountered, return empty dataframe\nreturn pd.DataFrame(['Unable to get bus data. char_ierr = {0}, comp_ierr = {1}, int_ierr = {2}. SID = {3}'.format(char_ierr,comp_ierr,int_ierr,SID)])\nelse:\nallColumns = char_data_desired+real_data_desired+int_data_desired\nallData = carray+xarray+iarray\nDF_dict = dict(zip(allColumns,allData))\nreturn pd.DataFrame(DF_dict)\ndef PSSESetSubSystem(SID,USEKV,BASEKV,NUMAREA,AREAS,NUMBUS,BUSES,NUMOWNER,OWNERS,NUMZONE,ZONES):\nierr = psspy.bsys(SID,USEKV,BASEKV,NUMAREA,AREAS,NUMBUS,BUSES,NUMOWNER,OWNERS,NUMZONE,ZONES)\nif ierr != 0:\nraise RuntimeError('PSSESetSubSystem did not work. the psspy.bsys ierr returned is: {}'.format(ierr))\nreturn ierr\ndef PSSESaveCase(PSSESAVECASE):\nierr = psspy.save(PSSESAVECASE) #save case\nif ierr != 0:\nraise RuntimeError('PSSPY error code {} when calling psspy.save(). See PSSE API documentation for details.'.format(ierr))\nsys.exit()\nreturn ierr\ndef getBusInconsistencies():\nin_service_branches = psspy.abrnint(-1,1,3,1,1,['FROMNUMBER','TONUMBER','STATUS','FROMSECTION','TOSECTION'])[1] #in_service_branches[0] is list of FROMBUS's, n_service_branches[1] is list of TOBUS's\n# make df for in_service_br_busses\nfrom_buses = pd.DataFrame({'Bus Number':in_service_branches[0],'Bus Section':in_service_branches[3]})\nto_buses = pd.DataFrame({'Bus Number':in_service_branches[1],'Bus Section':in_service_branches[4]})\nin_service_br_busses = pd.concat([from_buses,to_buses],ignore_index=True)\nin_service_br_busses = in_service_br_busses.drop_duplicates() #drop duplicates to avoid duplicating work\nall_busses = psspy.abusint(-1,2,['NUMBER','TYPE','SECTION','AREA'])[1] #all_busses[0] is list of busses, all_busses[1] is list of statuses, all_busses[2] is list of sections\n#make df for all buses\nbuses = pd.DataFrame({'Bus Number':all_busses[0],'Bus Section':all_busses[2],'Bus Type':all_busses[1],'Bus Area':all_busses[3]})\nin_service_2w_xfr = psspy.atrnint(-1,1,3,1,1,['FROMNUMBER','TONUMBER','STATUS','FROMSECTION','TOSECTION'])[1] #this only returns in-service transformers\nfrom_bus_2w_xfr = pd.DataFrame({'Bus Number':in_service_2w_xfr[0],'Bus Section':in_service_2w_xfr[3]})\nto_bus_2w_xfr = pd.DataFrame({'Bus Number':in_service_2w_xfr[1],'Bus Section':in_service_2w_xfr[4]})\nin_service_2w_xfr_buses = pd.concat([from_bus_2w_xfr,to_bus_2w_xfr],ignore_index=True)\nin_service_2w_xfr_buses = in_service_2w_xfr_buses.drop_duplicates()\nin_service_3w_xfr = psspy.atr3int(-1,1,3,1,1,['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER','STATUS','WIND1SECTION','WIND2SECTION','WIND3SECTION'])[1]\n# make in_service_3w_xfr_buses a dataframe\nin_service_3w_xfr_buses = pd.DataFrame()\n#make dataframe for more sophisticated data comparison\nin_service_3w_xfr_df = pd.DataFrame({'WIND1NUMBER':in_service_3w_xfr[0],'WIND2NUMBER':in_service_3w_xfr[1],'WIND3NUMBER':in_service_3w_xfr[2],'STATUS':in_service_3w_xfr[3],'WIND1SECTION':in_service_3w_xfr[4],'WIND2SECTION':in_service_3w_xfr[5],'WIND3SECTION':in_service_3w_xfr[6]})\n# get in service buses for status = 1\nstat1_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==1]\nfor entry in stat1_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat1_df.at[entry,'WIND1NUMBER'],stat1_df.at[entry,'WIND2NUMBER'],stat1_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat1_df.at[entry,'WIND1SECTION'],stat1_df.at[entry,'WIND2SECTION'],stat1_df.at[entry,'WIND3SECTION']]}) #all windings in-service when status = 1\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 2\nstat2_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==2]\nfor entry in stat2_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat2_df.at[entry,'WIND1NUMBER'],stat2_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat2_df.at[entry,'WIND1SECTION'],stat2_df.at[entry,'WIND3SECTION']]}) #windings 1 and 3 in-service when status = 2\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 3\nstat3_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==3]\nfor entry in stat3_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat3_df.at[entry,'WIND1NUMBER'],stat3_df.at[entry,'WIND2NUMBER']], \\\n'Bus Section':[stat3_df.at[entry,'WIND1SECTION'],stat3_df.at[entry,'WIND2SECTION']]}) #windings 1 and 2 in-service when status = 3"
  },
  {
    "id": "chunk_109",
    "text": "in_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\n# get in service buses for status = 4\nstat4_df = in_service_3w_xfr_df.loc[in_service_3w_xfr_df['STATUS']==4]\nfor entry in stat4_df.index:\nin_service = pd.DataFrame({'Bus Number':[stat4_df.at[entry,'WIND2NUMBER'],stat4_df.at[entry,'WIND3NUMBER']], \\\n'Bus Section':[stat4_df.at[entry,'WIND2SECTION'],stat4_df.at[entry,'WIND3SECTION']]}) #windings 2 and 3 in-service when status = 4\nin_service_3w_xfr_buses = pd.concat([in_service_3w_xfr_buses,in_service],ignore_index=True)\nall_in_service_element_buses = pd.concat([in_service_br_busses,in_service_2w_xfr_buses,in_service_3w_xfr_buses],ignore_index=True)\nall_in_service_element_buses = all_in_service_element_buses.drop_duplicates()\nall_in_service_element_buses['Has in-service branches'] = 'True'\nbus_summary = pd.merge(buses,all_in_service_element_buses,on=['Bus Number','Bus Section'],how='left')\nresults_to_return = bus_summary.loc[(((bus_summary['Bus Type'] == 1)|(bus_summary['Bus Type'] == 2))&(bus_summary['Has in-service branches'] != 'True'))\\\n|((bus_summary['Bus Type'] == 4)&(bus_summary['Has in-service branches'] == 'True'))]\nreturn results_to_return\ndef getFileByteData(GETBYTEDATAFILE):\ntry:\nif type(GETBYTEDATAFILE) == tempfile._TemporaryFileWrapper:\nFileByteData = GETBYTEDATAFILE.read()\nGETBYTEDATAFILE.seek(0)\nelse:\nf = open(GETBYTEDATAFILE,'r+b')\nFileByteData = f.read()\nf.close()\nreturn FileByteData\nexcept:\nraise RuntimeError('There was a problem reading the data from {}. Check the file.'.format(GETBYTEDATAFILE))\nsys.exit()\ndef silenceAllPSSE():\npsspy.set_progress_verbose(0) #set to limit messages\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence progress output from PSS/E\npsspy.report_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence report output from PSS/E to temp file\npsspy.t_alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silence alert output\npsspy.alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #silece alert outputs\ndef PSSEOpenCase(PSSEOPENCASE):\nif pathlib.Path(PSSEOPENCASE).suffix == '.sav':\nierr = psspy.case(PSSEOPENCASE) #open case\nif ierr != 0:\nraise RuntimeError('PSSPY error code {0} when calling psspy.case({1}). See PSSE API documentation for details.'.format(ierr,PSSEOPENCASE))\nsys.exit()\nif pathlib.Path(PSSEOPENCASE).suffix == '.raw':\nierr = psspy.read(0,PSSEOPENCASE)\nif ierr != 0:\nraise RuntimeError('PSSPY error code {0} when calling psspy.read(0,{1}). See PSSE API documentation for details.'.format(ierr,PSSEOPENCASE))\nsys.exit()\nreturn ierr\ndef make_clickable(url, name):\nreturn '<a href=\"{}\" rel=\"noopener noreferrer\" target=\"_blank\">{}</a>'.format(url,name)\ndef makeTempDirectory():\n### Create temp directory for file management ###\ntemporary_directory = tempfile.TemporaryDirectory()\ntmp_dir = temporary_directory.name\nprint('Created temp directory {0}.'.format(tmp_dir))\nreturn temporary_directory\ndef suppressAllPSSEOutputs():\n#### Supress all the PSSE outputs for now\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #suppress progress output from PSS/E\npsspy.t_alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write t alerts from PSS/E to temp file\npsspy.alert_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write alerts from PSS/E to temp file\npsspy.report_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #write report from PSS/E to temp file\ndef getCNTBCheckData(tmp_dir,SAVLOCATION,target_output_directory,rawfilename,CNTB_messages,areaList):\n#tmp_dir_CNTB = makeTempDirectory().name\nPSSEOpenCase(SAVLOCATION) #open the save case\npsspy.bsys(0,0,[0.48,345.],len(areaList),areaList,0,[],0,[],0,[]) #set bsys to areas provided by the user\ntemp_PSSE_output = tmp_dir+r'\\PSSE_capture.txt' #capture report output from PSS/E\nierr = psspy.report_output(2,temp_PSSE_output,0) #capture report output from PSS/E\nif ierr != 0:\nraise RuntimeError('Problem calling psspy.report_output. Directory location: {0}. ierr = {1}'.format(temp_PSSE_output,ierr))\npsspy.cntb(0,0,1,[0,0,0],[0.0,0.0]) #run CNTB\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile\n# PSSESaveCase(target_output_directory+r'\\{0}.sav'.format(rawfilename))\n# PSSECloseCase()\n#write the report to a text document\ndata_to_write = getFileByteData(temp_PSSE_output).decode('UTF-8')\n# reportName = target_output_directory+r'\\text_reports\\{}_CNTB_output.txt'.format(rawfilename)\n# f = open(reportName,'w')\n# f.write(data_to_write)\n# f.close()\n#partition the data to put in a csv for easier reading\nmessage_delimiter = '\\nBus '\nall_messages = data_to_write.split(message_delimiter)\nCNTB_messages_tmp = pd.DataFrame({'{0}'.format(rawfilename):all_messages})\nCNTB_messages_tmp['{0}'.format(rawfilename)] = 'Bus '+CNTB_messages_tmp['{0}'.format(rawfilename)]\nCNTB_messages_tmp['Bus'] = CNTB_messages_tmp['{0}'.format(rawfilename)]\nCNTB_messages_tmp['Area'] =CNTB_messages_tmp['Bus'].str.extract(r'area ([0-9]+)')\nCNTB_messages_tmp['Bus'] = CNTB_messages_tmp['Bus'].str.extract(r'Bus ([0-9]+)') #CNTB_messages_tmp['Bus'].str.slice(stop=10).str.rstrip().str.rstrip('[')\nCNTB_messages_tmp.loc[CNTB_messages_tmp['{0}'.format(rawfilename)].str.contains('Warning'),'Type'] = 'Warning'\nCNTB_messages_tmp.loc[CNTB_messages_tmp['{0}'.format(rawfilename)].str.contains('ERROR'),'Type'] = 'ERROR'\nCNTB_messages_tmp.loc[CNTB_messages_tmp['Type'].isnull(),'Type'] = 'Other'\nCNTB_messages_tmp = CNTB_messages_tmp[['Bus','Area','Type','{0}'.format(rawfilename)]]\nCNTB_messages_tmp = CNTB_messages_tmp.loc[(CNTB_messages_tmp['Type']=='ERROR')|(CNTB_messages_tmp['Type']=='Warning')]\n#CNTB_messages_tmp.to_csv(target_output_directory+'\\CNTB_messages_tmp.csv')\nif CNTB_messages.empty == True:\nCNTB_messages = CNTB_messages_tmp #pd.concat([CNTB_messages,CNTB_messages_tmp],ignore_index=True)\nCNTB_messages = CNTB_messages.drop_duplicates() #drop duplicate values to keep the dataset smaller\nelse:\nCNTB_messages = pd.merge(CNTB_messages,CNTB_messages_tmp,how='outer',on=['Bus','Area','Type'])\nCNTB_messages = CNTB_messages.drop_duplicates() #drop duplicate values to keep the dataset smaller\nreturn CNTB_messages\ndef getBusData(savLocation,target_output_directory,rawfilename,BusData,areaList):\nbusData_tmp = getAllBusData(savLocation)\n#busData_tmp.to_csv(target_output_directory+r'\\busData_tmp.csv')\nallBusesInSelectedAreas = busData_tmp.loc[(busData_tmp['AREA'].isin(areaList))]\nallBusesInSelectedAreas = allBusesInSelectedAreas[['NUMBER','NAME','SECTION','TYPE','AREA','OWNER','NVLMLO','NVLMHI','EVLMLO','EVLMHI']] # added section and type\nallBusesInSelectedAreas = allBusesInSelectedAreas.round({'NVLMLO':2,'NVLMHI':2,'EVLMLO':2,'EVLMHI':2})\nallBusesInSelectedAreas['{0}'.format(rawfilename)]='TRUE'\nif BusData.empty == True:\nBusData = allBusesInSelectedAreas #pd.concat([CNTB_messages,CNTB_messages_tmp],ignore_index=True)\nBusData = BusData.drop_duplicates() #drop duplicate values to keep the dataset smaller\nelse:\nBusData = pd.merge(BusData,allBusesInSelectedAreas,how='outer',on=['NUMBER','NAME','SECTION','TYPE','AREA','OWNER','NVLMLO','NVLMHI','EVLMLO','EVLMHI']) # added section and type\nBusData = BusData.drop_duplicates() #drop duplicate values to keep the dataset smaller\n#BusData = BusData.round({'NVLMLO':2,'NVLMHI':2,'EVLMLO':2,'EVLMHI':2})\nreturn BusData\ndef get900kBuses(BusData):\nall900k_buses = BusData.loc[BusData['NUMBER']>=900000]\nreturn all900k_buses\ndef getDisconnectedBuses(BusData):\nalldisconnected_buses = BusData.loc[BusData['TYPE']==4]\nreturn alldisconnected_buses\ndef getLdData(savLocation,allLoads,rawfilename,areaList):\n# Get load data to report on any 0-MVA or disconnected loads in selected areas\nloadData_tmp = getAllLoadData(savLocation)\nloadData_tmp = loadData_tmp.loc[(loadData_tmp['AREA'].isin(areaList))] # only keep the selected areas\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER']]\nloadData_tmp['{0}'.format(rawfilename)]='TRUE'\nif allLoads.empty == True:\nallLoads = loadData_tmp\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(loadData_tmp,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nreturn loadData_tmp\ndef getLdDataTotalsReportedInCaseColumn(savLocation,allLoads,rawfilename,areaList):\n# Get load data to report on any 0-MVA or disconnected loads in selected areas\nloadData_tmp = getAllLoadData(savLocation)\nloadData_tmp = loadData_tmp.loc[(loadData_tmp['AREA'].isin(areaList))] # only keep the selected areas\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER']]\nloadData_tmp['{0}'.format(rawfilename)]=loadData_tmp['TOTALACT']\nloadData_tmp = loadData_tmp[['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER','{0}'.format(rawfilename)]]\nif allLoads.empty == True:\nallLoads = loadData_tmp\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(loadData_tmp,how='outer',on=['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nreturn loadData_tmp\ndef getDisconnectedLoads(loadData_tmp,allDisconnectedLds):\ndisconnectedLds = loadData_tmp.loc[loadData_tmp['STATUS']==0]\nif allDisconnectedLds.empty == True:\nallDisconnectedLds = disconnectedLds\nallDisconnectedLds = allDisconnectedLds.drop_duplicates()\nelse:\nallDisconnectedLds = allDisconnectedLds.merge(disconnectedLds,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallDisconnectedLds = allDisconnectedLds.drop_duplicates()\nreturn allDisconnectedLds\ndef getZeroLoads(loadData_tmp,allZeroLds):\nzeroLds = loadData_tmp.loc[loadData_tmp['TOTALACT']==complex(0,0)]\nif allZeroLds.empty == True:\nallZeroLds = zeroLds\nallZeroLds = allZeroLds.drop_duplicates()\nelse:\nallZeroLds = allZeroLds.merge(zeroLds,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallZeroLds = allZeroLds.drop_duplicates()\nreturn allZeroLds\ndef getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,areaList):\n# find shunt devices that are in a status of disconnected\nSwShunts = getAllSwShuntData(savLocation)\nSwShunts = SwShunts.loc[SwShunts['AREA'].isin(areaList)] # filter down to the specific requested areas\ndisconnected_SwShunts = SwShunts.loc[SwShunts['STATUS']==0]\ndisconnected_SwShunts = disconnected_SwShunts[['ID','NAME','NUMBER','AREA','STATUS']]\nFixedShunts = getAllFixedShuntData(savLocation)\nBusAreaMap = getAllBusData(savLocation)[['NUMBER','AREA']]\nFixedShunts = FixedShunts.merge(BusAreaMap,how='left',on='NUMBER')\nFixedShunts = FixedShunts.loc[FixedShunts['AREA'].isin(areaList)] # filter down to the specific requested areas\ndisconnected_FixedShunts = FixedShunts.loc[FixedShunts['STATUS']==0]\ndisconnected_FixedShunts = disconnected_FixedShunts[['ID','NAME','NUMBER','AREA','STATUS']]\ndisconnected_shunts = pd.concat([disconnected_SwShunts,disconnected_FixedShunts],ignore_index=True)\ndisconnected_shunts['{0}'.format(rawfilename)] = 'TRUE'\nif alldisconnected_shunts.empty == True:\nalldisconnected_shunts = disconnected_shunts\nalldisconnected_shunts = alldisconnected_shunts.drop_duplicates()\nelse:\nalldisconnected_shunts = alldisconnected_shunts.merge(disconnected_shunts,how='outer',on=['ID','NAME','NUMBER','AREA','STATUS'])\nalldisconnected_shunts = alldisconnected_shunts.drop_duplicates()\nreturn alldisconnected_shunts\ndef getAllBusInconsistencies(rawfilename,allBusInconsistencies):\n# Get bus inconsistencies\ncaseBusInconsistencies = getBusInconsistencies()\ncaseBusInconsistencies['{0}'.format(rawfilename)] = 'TRUE'\nif allBusInconsistencies.empty == True:\nallBusInconsistencies = caseBusInconsistencies\nallBusInconsistencies=allBusInconsistencies.drop_duplicates()\nelse:\nallBusInconsistencies = pd.merge(allBusInconsistencies,caseBusInconsistencies,how='outer',on=['Bus Number','Bus Section','Bus Type','Bus Area','Has in-service branches'])\nallBusInconsistencies=allBusInconsistencies.drop_duplicates()\nreturn allBusInconsistencies\ndef getTREEIslands(tmp_dir,rawfilename,allIslands):\n# Run TREE to get island information\n# prepare a report to capture TREE outputs\ncaseTreeData = []\ntemp_TREE_output = tmp_dir+r'\\TREE_capture.txt' #capture report output from PSS/E\npsspy.progress_output(2,temp_TREE_output,0) #capture report output from PSS/E\nierr, num_island_buses = psspy.tree(1,0) #initialize TREE\nwhile num_island_buses > 0:\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile\ntree_data = getFileByteData(temp_TREE_output).decode('UTF-8')\nos.remove(temp_TREE_output) #get rid of the temp file\nsave_data = tree_data.split('ISLAND:\\r\\n')[1] #get data to save\ncaseTreeData.append(save_data)\npsspy.progress_output(2,temp_TREE_output,0) #capture report output from PSS/E\nierr, num_island_buses = psspy.tree(2,0) # leave the current island alone and run TREE again check for another island\npsspy.progress_output(2,tempfile.NamedTemporaryFile().name,[0,0]) #suppress progress output from PSS/E\nCaseTreeIslands = pd.DataFrame({'Island':caseTreeData})\nCaseTreeIslands['{0}'.format(rawfilename)] = 'TRUE'\nif allIslands.empty == True:\nallIslands = CaseTreeIslands\nallIslands = allIslands.drop_duplicates()\nelse:\nallIslands = pd.merge(allIslands,CaseTreeIslands,how='outer',on='Island')\nallIslands = allIslands.drop_duplicates()\nreturn allIslands\ndef getPSSEpfChecks(tmp_dir,rawfilename,allPFCheckResults,allPFCheckTypes,areaList):\n# run the PSSE powerflow checks for the case\nSID_for_checks = 1\nPSSESetSubSystem(SID=SID_for_checks,USEKV=1,BASEKV=1,NUMAREA=len(areaList),AREAS=areaList,NUMBUS=0,BUSES=[],NUMOWNER=0,OWNERS=[],NUMZONE=0,ZONES=[])\n#psspy.bsys(0,0,[0.48,345.],1,[],0,[],0,[],0,[]) # set SID 0\nfor checkType in allPFCheckTypes.keys():\n#print('Doing PSSE PF check for {0}'.format(checkType))\nsilenceAllPSSE() #silence the output\ntemp_pfcheck_output = tmp_dir+r'\\pfcheck_capture.txt' #capture report output from PSS/E\npsspy.report_output(2,temp_pfcheck_output,0) #capture report output from PSS/E\nierr = psspy.check_powerflow_data(SID_for_checks,0,allPFCheckTypes[checkType])\nif ierr != 0:\nprint('Problem with running check_powerflow_data. ierr={0}'.format(ierr))\nsilenceAllPSSE() #silence the output so PSSE lets go of the tempfile"
  },
  {
    "id": "chunk_110",
    "text": "pfcheck_data = str(getFileByteData(temp_pfcheck_output).decode('UTF-8'))\npfcheck_data = \"\"\"{0}\"\"\".format(pfcheck_data)\nsave_data = pd.DataFrame({'PF Check Message':pfcheck_data.split('\\r\\n\\r\\n')}) #get data to save\nsave_data = save_data.loc[(save_data['PF Check Message'].str.strip()!='')&\\\n(save_data['PF Check Message'].str.strip()!='Powerflow data checks')&\\\n(save_data['PF Check Message'].str.strip().str.contains(' messages:')==False)]\n#save_data = save_data['PF Check Message']\nsave_data['{0}'.format(rawfilename)] = 'TRUE'\nsave_data = save_data[['PF Check Message','{0}'.format(rawfilename)]]\nif len(allPFCheckResults[checkType].columns)<1:\nallPFCheckResults[checkType] = save_data\n#allPFCheckResults[checkType] = allPFCheckResults[checkType].drop_duplicates()\nelse:\nallPFCheckResults[checkType] = pd.merge(allPFCheckResults[checkType],save_data,how='outer',on='PF Check Message')\nallPFCheckResults[checkType] = allPFCheckResults[checkType].drop_duplicates()\nreturn allPFCheckResults\ndef getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,areaList):\n# Check for line branch elements that connect buses with different base voltages\nbusData_tmp = getAllBusData(savLocation)\nbranchData = getAllLineData(savLocation)\nbrTerminalBaseCheck = pd.merge(branchData,busData_tmp[['NUMBER','NAME','BASE','AREA','OWNER']],how='left',left_on='FROMNUMBER',right_on='NUMBER')\nbrTerminalBaseCheck = pd.merge(brTerminalBaseCheck,busData_tmp[['NUMBER','NAME','BASE','AREA','OWNER']],how='left',left_on='TONUMBER',right_on='NUMBER',suffixes=('_FromBus','_ToBus'))\n#branchData.to_csv(target_output_directory+r'\\branchData.csv')\n#brTerminalBaseCheck.to_csv(target_output_directory+r'\\brTerminalBaseCheck.csv')\ninconsistent_line_terminal_base_voltages = brTerminalBaseCheck.loc[(brTerminalBaseCheck['BASE_FromBus']!=brTerminalBaseCheck['BASE_ToBus'])\\\n&((brTerminalBaseCheck['AREA_FromBus'].isin(areaList))|(brTerminalBaseCheck['AREA_ToBus'].isin(areaList)))]\n#inconsistent_line_terminal_base_voltages.to_csv(target_output_directory+r'\\inconsistent_line_terminal_base_voltages.csv')\ninconsistent_line_terminal_base_voltages['{0}'.format(rawfilename)] = 'TRUE'\nif allBrTerminalVoltageInconsistencies.empty == True:\nallBrTerminalVoltageInconsistencies = inconsistent_line_terminal_base_voltages\nallBrTerminalVoltageInconsistencies = allBrTerminalVoltageInconsistencies.drop_duplicates()\nelse:\nallBrTerminalVoltageInconsistencies = pd.merge(allBrTerminalVoltageInconsistencies,inconsistent_line_terminal_base_voltages,how='outer',\\\non=['ID','FROMNUMBER','TONUMBER','STATUS','NUMBER_FromBus','NAME_FromBus','BASE_FromBus','AREA_FromBus','OWNER_FromBus','NUMBER_ToBus','NAME_ToBus','BASE_ToBus','AREA_ToBus','OWNER_ToBus'])\nallBrTerminalVoltageInconsistencies = allBrTerminalVoltageInconsistencies.drop_duplicates()\nreturn allBrTerminalVoltageInconsistencies\ndef getRawxJSON(tmp_dir,rawfilename):\ntemp_rawx_location = tmp_dir+r'\\{0}.rawx'.format(rawfilename)\npsspy.writerawxsubsys(0,1,[1,1,1,0,0],r\"\"\"{0}\"\"\".format(temp_rawx_location),\"\")\nwith open(temp_rawx_location,'r') as file:\ndata = file.read()\nraw_data_json = json.loads(data)\nreturn raw_data_json\ndef getNodeBreakerData(raw_data_json):\ndesired_elements = ['sub', 'subnode', 'subswd', 'subterm','load', 'fixshunt', 'generator', 'acline', 'sysswd', 'transformer','swshunt','facts','twotermdc','bus']\ndataframe_dict = {}\nfor element in desired_elements:\ndataframe_dict[element] = pd.DataFrame(raw_data_json['network'][element]['data'],columns=raw_data_json['network'][element]['fields'])\n# get all terminate-able equipment into a single dataset\nfixShunts = dataframe_dict['fixshunt'][['ibus','shntid']].rename(columns={'shntid':'eqid'})\nfixShunts['equipmentType'] = 'fixshunt'\nfixShunts['name'] = ''\nfixShunts['type'] = 'F'\nswShunts = dataframe_dict['swshunt'][['ibus','shntid']].rename(columns={'shntid':'eqid'})\nswShunts['equipmentType'] = 'swshunt'\nswShunts['name'] = ''\nswShunts['type'] = 'S'\nfacts = dataframe_dict['facts'][['ibus','jbus','name']].rename(columns={'name':'eqid'})\nfacts['equipmentType'] = 'facts'\nfacts['name'] = ''\nfacts['type'] = 'A'\nacLines = dataframe_dict['acline'][['ibus','jbus','ckt','name']].rename(columns={'ckt':'eqid'})\nacLines['equipmentType'] = 'acline'\nacLines['type'] = 'B'\ntwotermdc = dataframe_dict['twotermdc'][['ipi','name']].rename(columns={'ipi':'ibus','name':'eqid'})\ntwotermdc['equipmentType'] = 'twotermdc'\ntwotermdc['type'] = 'D'\ngenerators = dataframe_dict['generator'][['ibus','machid']].rename(columns={'machid':'eqid'})\ngenerators['equipmentType'] = 'generator'\ngenerators['name'] = ''\ngenerators['type'] = 'M'\nloads = dataframe_dict['load'][['ibus','loadid']].rename(columns={'loadid':'eqid'})\nloads['equipmentType'] = 'load'\nloads['name'] = ''\nloads['type'] = 'L'\ntransformers = dataframe_dict['transformer'][['ibus','jbus','kbus','ckt','name']].rename(columns={'ckt':'eqid'})\ntransformers['equipmentType'] = 'transformer'\ntransformers.loc[transformers['kbus']==0,'type'] = '2'\ntransformers.loc[transformers['kbus']!=0,'type'] = '3'\nsysSwds = dataframe_dict['sysswd'][['ibus','jbus','ckt','name','stat','nstat']].rename(columns={'ckt':'eqid'})\nsysSwds['equipmentType'] = 'system switching device'\nsysSwds['type'] = 'B'\nall_termable_equip = pd.concat([fixShunts,acLines,generators,loads,transformers,sysSwds,swShunts,facts,twotermdc],ignore_index=True)\nall_termable_equip['kbus'] = all_termable_equip['kbus'].replace(0,np.nan)\nall_termable_equip['jbus'] = all_termable_equip['jbus'].replace(0,np.nan)\nall_termable_equip['EquipmentID'] = all_termable_equip.index # we'll need this later\n# join the terminable equipment to their corresponding substation and node, if available\n# first, format the subterm df for greater clarity: because ibus/jbus/and kbus are not consistently assigned\nsubterm_formatted = dataframe_dict['subterm'].rename(columns={'isub':'sub','inode':'node','ibus':'bus','jbus':'IDbusA','kbus':'IDbusB','eqid':'IDequip'})\n# second, join all_termable_equip to subterm_formatted on the ID fields -- this will be giant\nibus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['ibus','eqid','type'], right_on = ['bus','IDequip','type'])\nibus_node_table = ibus_node_table.loc[\\\n((ibus_node_table['jbus'].isna()==True)|((ibus_node_table['jbus']==ibus_node_table['IDbusA'])|(ibus_node_table['jbus']==ibus_node_table['IDbusB'])))\\\n&((ibus_node_table['kbus'].isna()==True)|(ibus_node_table['kbus']==ibus_node_table['IDbusA'])|(ibus_node_table['kbus']==ibus_node_table['IDbusB']))] # this is the data set for which the node bus is ibus of the equipment\nibus_node_table = ibus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\nibus_node_table = ibus_node_table.rename(columns={'sub':'isub','node':'inode'})\nibus_node_table = ibus_node_table.drop_duplicates()\njbus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['jbus','eqid','type'], right_on = ['bus','IDequip','type'])\njbus_node_table = jbus_node_table.loc[\\\n((jbus_node_table['ibus'].isna()==True)|((jbus_node_table['ibus']==jbus_node_table['IDbusA'])|(jbus_node_table['ibus']==jbus_node_table['IDbusB'])))\\\n&((jbus_node_table['kbus'].isna()==True)|((jbus_node_table['kbus']==jbus_node_table['IDbusA'])|(jbus_node_table['kbus']==jbus_node_table['IDbusB'])))] # this is the data set for which the node bus is jbus of the equipment\njbus_node_table = jbus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\njbus_node_table = jbus_node_table.rename(columns={'sub':'jsub','node':'jnode'})\njbus_node_table = jbus_node_table.drop_duplicates()\nkbus_node_table = pd.merge(all_termable_equip,subterm_formatted, how = 'left', left_on = ['kbus','eqid','type'], right_on = ['bus','IDequip','type'])\nkbus_node_table = kbus_node_table.loc[\\\n((kbus_node_table['ibus'].isna()==True)|((kbus_node_table['ibus']==kbus_node_table['IDbusA'])|(kbus_node_table['ibus']==kbus_node_table['IDbusB'])))\\\n&((kbus_node_table['jbus'].isna()==True)|((kbus_node_table['jbus']==kbus_node_table['IDbusA'])|(kbus_node_table['jbus']==kbus_node_table['IDbusB'])))] # this is the data set for which the node bus is kbus of the equipment\nkbus_node_table = kbus_node_table[['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','sub','node','type']]\nkbus_node_table = kbus_node_table.rename(columns={'sub':'ksub','node':'knode'})\nkbus_node_table = kbus_node_table.drop_duplicates()\nall_termable_equip_with_nodes = pd.merge(all_termable_equip,ibus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\nall_termable_equip_with_nodes = pd.merge(all_termable_equip_with_nodes,jbus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\nall_termable_equip_with_nodes = pd.merge(all_termable_equip_with_nodes,kbus_node_table,how='left',on=['EquipmentID','ibus','jbus','kbus','eqid','equipmentType','stat','nstat','name','type'])\n# add the substation switching devices to the all_termable_equip_with_nodes df\n# get sub switching device data\nsubSwds = dataframe_dict['subswd']\nsubSwds['jsub'] = subSwds['isub'] # adding jsub column for easier concatenation with all_termable_equip_with_nodes\nsubSwds['equipmentType'] = subSwds['type'].map({1:'Subswd - GEN',2:'Subswd - CB',3:'Subswd - DSC'}) #.astype(str)\nsubSwds=subSwds.rename(columns={'swdid':'eqid'})\nsubSwds = subSwds[['isub','inode','jsub','jnode','eqid','name','equipmentType','type','stat','nstat']]\n# the sub node data and join to sub switching deivce data\nsubNodes = dataframe_dict['subnode']\nsubNodes = subNodes.rename(columns={'isub':'sub','inode':'node','ibus':'bus'})\nsubNodes = subNodes[['sub','node','bus','name']]\nsubNodes=subNodes.drop_duplicates()\nisubNodes=subNodes.rename(columns={'sub':'isub','node':'inode','bus':'ibus','name':'inode_name'})\njsubNodes=subNodes.rename(columns={'sub':'jsub','node':'jnode','bus':'jbus','name':'jnode_name'})\nsubSwds = pd.merge(subSwds,isubNodes,how='left',on=['isub','inode'])\nsubSwds = pd.merge(subSwds,jsubNodes,how='left',on=['jsub','jnode'])\nsubSwds.index += len(all_termable_equip_with_nodes.index)\nsubSwds['EquipmentID']=subSwds.index\n# add the sys swd stype back into the dataset (it has to show as 'B' to join to the sub terminations, since 2 and 3 refer only to transformers in the subterm data)\nsysSwdWType = sysSwds = dataframe_dict['sysswd'][['ibus','jbus','ckt','name','stat','nstat','stype']].rename(columns={'ckt':'eqid'}) # the field stype refers to the switch type, where 2 is a breaker and 3 is a disconnect\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes.merge(sysSwdWType,how='left',on=['ibus','jbus','eqid','name','stat','nstat'])\nall_termable_equip_with_nodes_incl_subswds.loc[all_termable_equip_with_nodes_incl_subswds['equipmentType']=='system switching device','type']=\\\nall_termable_equip_with_nodes_incl_subswds['stype'] #replace type with stype for system switching devices\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes_incl_subswds.drop('stype',axis=1) #drop the stype column\nall_termable_equip_with_nodes_incl_subswds = all_termable_equip_with_nodes_incl_subswds.drop_duplicates() #drop any duplicates introduced\n# add substation switching devices to all_termable_equip_with_nodes\nall_termable_equip_with_nodes_incl_subswds = pd.concat([all_termable_equip_with_nodes_incl_subswds,subSwds],ignore_index=False)\nreturn (ibus_node_table, jbus_node_table, kbus_node_table, all_termable_equip_with_nodes,dataframe_dict,all_termable_equip_with_nodes_incl_subswds)\ndef getInvalidSetpointsContinuousShunts(allSwShunts,rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,areaList):\n# check Binit values for switched shunt\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nSwShunts = SwShunts.loc[SwShunts['modsw']==2] #only get continuous-control-type shunts\n#print(SwShunts)\nSwShuntsWithInvalidSetpoints = SwShunts.loc[(SwShunts['vswhi']!=SwShunts['vswlo'])]\nSwShuntsWithInvalidSetpoints = SwShuntsWithInvalidSetpoints[['ibus','AREA','shntid','modsw','swreg','vswhi','vswlo']]\nSwShuntsWithInvalidSetpoints['{0}'.format(rawfilename)] = 'TRUE'\nif allSwShuntsWithInvalidSetpoints.empty==True:\nallSwShuntsWithInvalidSetpoints = SwShuntsWithInvalidSetpoints\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.drop_duplicates()\nelse:\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.merge(SwShuntsWithInvalidSetpoints,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg','vswhi','vswlo'])\nallSwShuntsWithInvalidSetpoints = allSwShuntsWithInvalidSetpoints.drop_duplicates()\nreturn allSwShuntsWithInvalidSetpoints\ndef getInvalidBinitShunts(allSwShunts,rawfilename,allSwShuntsWithInvalidBinit,savLocation,areaList):\n# check Binit values for switched shunt\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nSwShunts = SwShunts.loc[SwShunts['modsw']==1] #only get discreet-control-type shunts\nSwShuntsWithInvalidBinit = SwShunts.loc[(SwShunts['binit']!=0)\\\n&(SwShunts['binit']!=SwShunts['b1'])\\\n&(SwShunts['binit']!=SwShunts['b2'])\\\n&(SwShunts['binit']!=SwShunts['b3'])\\\n&(SwShunts['binit']!=SwShunts['b4'])\\\n&(SwShunts['binit']!=SwShunts['b5'])\\\n&(SwShunts['binit']!=SwShunts['b6'])\\\n&(SwShunts['binit']!=SwShunts['b7'])\\\n&(SwShunts['binit']!=SwShunts['b8'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6']+SwShunts['b7'])\\\n&(SwShunts['binit']!=SwShunts['b1']+SwShunts['b2']+SwShunts['b3']+SwShunts['b4']+SwShunts['b5']+SwShunts['b6']+SwShunts['b7']+SwShunts['b8'])]\nSwShuntsWithInvalidBinit = SwShuntsWithInvalidBinit[['ibus','AREA','shntid','modsw','swreg','binit']]\nSwShuntsWithInvalidBinit['{0}'.format(rawfilename)] = 'TRUE'\nif allSwShuntsWithInvalidBinit.empty==True:\nallSwShuntsWithInvalidBinit = SwShuntsWithInvalidBinit\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.drop_duplicates()\nelse:\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.merge(SwShuntsWithInvalidBinit,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg','binit'])\nallSwShuntsWithInvalidBinit = allSwShuntsWithInvalidBinit.drop_duplicates()\nreturn allSwShuntsWithInvalidBinit\ndef getSolutionData(rawfilename,allCaseSolveData,areaList,allVoltageViolations,allThermalViolations,temp_dir,AllBusArea):\nerror_map = {0:'no error occurred',1:'invalid OPTIONS value',2:'generators are converted',\n3:'buses in island(s) without a swing bus; use activity TREE',\n4:'bus type code and series element status inconsistencies',\n5:'prerequisite requirements for API are not met'}\nflag_map = {0:'tap adj',1:'area interchange adj',2:'phase shift adj',\n3:'dc tap adj',4:'sw shunt adj',5:'flat start',6:'var limit',7:'non-divergent sol'}\nfdns_configuration_step1 = [1,1,1,1,1,1,0,0]\nfdns_configuration_step1_labels = dict(zip(flag_map.values(),fdns_configuration_step1))\nfdns_configuration_step2 = [1,1,1,1,1,0,0,0]\nfdns_configuration_step2_labels = dict(zip(flag_map.values(),fdns_configuration_step2))\nfnsl_configuration_step3 = [1,1,1,1,1,0,0,0]\nfnsl_configuration_step3_labels = dict(zip(flag_map.values(),fnsl_configuration_step3))\nstep1_solution_dict = fdns_configuration_step1_labels.copy()\nstep2_solution_dict = fdns_configuration_step2_labels.copy()\nstep3_solution_dict = fnsl_configuration_step3_labels.copy()\n# do step 1 solve\nierr_fdns_1 = psspy.fdns(fdns_configuration_step1)\n#print('ierr_fdns is {0}'.format(ierr_fdns))\nif ierr_fdns_1 == 0:\nsolveIterat_fdns_1 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fdns_1 = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fdns_1 = psspy.solstr()\nstep1_solution_dict.update({'Step':1,'Solution Method':'fdns',\n'Iterations':solveIterat_fdns_1,'Mismatch':solveSysmsm_fdns_1,'Solution Str':solutionString_fdns_1,\n'ierr':error_map[ierr_fdns_1]})\n# do step 2 solve\nierr_fdns_2 = psspy.fdns(fdns_configuration_step2)\nif ierr_fdns_2 == 0:\nsolveIterat_fdns_2 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fdns_2 = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fdns_2 = psspy.solstr()\nstep2_solution_dict.update({'Step':2,'Solution Method':'fdns',\n'Iterations':solveIterat_fdns_2,'Mismatch':solveSysmsm_fdns_2,\n'Solution Str':solutionString_fdns_2,'ierr':error_map[ierr_fdns_2]})\n# do step 3 solve\nierr_fnsl_3 = psspy.fdns(fnsl_configuration_step3)\nif ierr_fnsl_3 == 0:\nsolveIterat_fnsl_3 = psspy.iterat() #number of iterations of solution\nsolveSysmsm_fnsl_3  = psspy.sysmsm() #total MVA mismatch of solution\nsolutionString_fnsl_3  = psspy.solstr()\nstep3_solution_dict.update({'Step':3,'Solution Method':'fnsl',\n'Iterations':solveIterat_fnsl_3 ,'Mismatch':solveSysmsm_fnsl_3 ,\n'Solution Str':solutionString_fnsl_3 ,'ierr':error_map[ierr_fnsl_3 ]})\n# if solution converged, get voltage and branch violations\nif solutionString_fnsl_3 == 'Met convergence tolerances                      ':\n# get BC Violations\ntemp_PSSE_report_output1 = temp_dir+r'\\PSSE_capture1.txt' #capture progress output from PSS/E"
  },
  {
    "id": "chunk_111",
    "text": "temp_PSSE_report_output2 = temp_dir+r'\\PSSE_capture2.txt' #capture progress output from PSS/E\npsspy.report_output(2,temp_PSSE_report_output1,0) #capture progress output from PSS/E\npsspy.set_progress_verbose(-1) #set to output all messages\nBC_violations_SID = 1\nPSSESetSubSystem(SID=BC_violations_SID,USEKV=1,BASEKV=1,NUMAREA=len(areaList),AREAS=areaList,NUMBUS=0,BUSES=[],NUMOWNER=0,OWNERS=[],NUMZONE=0,ZONES=[])\n# get Branch and voltage violations and read report\npsspy.rate_2(BC_violations_SID,0,1,1,1,0, 98.0) #get branch violations report\nsilenceAllPSSE() #reset the outputs\npsspy.report_output(2,temp_PSSE_report_output2,0) #capture progress output from PSS/E\npsspy.checkvoltagelimits(BC_violations_SID,0,1,0) #get voltage violation report\nsilenceAllPSSE() #reset the outputs\n# process Branch violations\nBCbranchViolations = parseBrViolationReport(temp_PSSE_report_output1)\nBCbranchViolations['{0}'.format(rawfilename)] = BCbranchViolations['Loading']\nBCbranchViolations = BCbranchViolations[['From Bus Number','From Bus Name','To Bus Number','To Bus Name','Circuit ID','Rating A','{0}'.format(rawfilename)]]\nBCbranchViolations['From Bus Number'] = BCbranchViolations['From Bus Number'].astype(str)\nBCbranchViolations['To Bus Number'] = BCbranchViolations['To Bus Number'].astype(str)\n# extract Bus and section numbers from the bus columns\nBCbranchViolations['FromBusNum'] = BCbranchViolations['From Bus Number'].str.extract(r'([0-9]+)',expand=True)[0].astype(int,errors='raise')\nBCbranchViolations['FromBusSection'] = BCbranchViolations['From Bus Number'].str.extract(r'-\\s+([0-9]+)').astype(int,errors='ignore')\nBCbranchViolations['ToBusNum'] = BCbranchViolations['To Bus Number'].str.extract(r'([0-9]+)',expand=True)[0].astype(int,errors='raise') #r'([0-9]+)-'\nBCbranchViolations['ToBusSection'] = BCbranchViolations['To Bus Number'].str.extract(r'-\\s+([0-9]+)').astype(int,errors='ignore')\n# join Areas to To and From buses\nAllBusArea['NUMBER'] = AllBusArea['NUMBER'].astype(int)\nFromBusAreas = AllBusArea.rename(columns={'NUMBER':'FromBusNum','AREA':'FromBusArea'})\nBCbranchViolations = BCbranchViolations.merge(FromBusAreas,how='left',on='FromBusNum')\nToBusAreas = AllBusArea.rename(columns={'NUMBER':'ToBusNum','AREA':'ToBusArea'})\nBCbranchViolations = BCbranchViolations.merge(ToBusAreas,how='left',on='ToBusNum')\nBCbranchViolations = BCbranchViolations[['From Bus Number','FromBusNum','FromBusSection','FromBusArea',\\\n'From Bus Name','To Bus Number','ToBusNum','ToBusSection','ToBusArea','To Bus Name','Circuit ID','Rating A','{0}'.format(rawfilename)]]\n# process voltage violations\nBCvoltViolations = parseVoltViolationReport(temp_PSSE_report_output2)\nBCvoltViolations['{0}'.format(rawfilename)] = BCvoltViolations['V(pu)']\nBCvoltViolations=BCvoltViolations[['Bus Number','Bus Name','Bus kV','V Limit','Voltage Violation Type','{0}'.format(rawfilename)]]\n# # extract Bus and section numbers from the bus columns\nBCvoltViolations['BusNum'] = BCvoltViolations['Bus Number'].str.extract(r'([0-9]+)',expand=True)[0].astype(int,errors='raise')\nBCvoltViolations['BusSection'] = BCvoltViolations['Bus Number'].str.extract(r'-\\s+([0-9]+)').astype(int,errors='ignore')\n# join Areas to buses\nVBusAreas = AllBusArea.rename(columns={'NUMBER':'BusNum'})\nBCvoltViolations = BCvoltViolations.merge(VBusAreas,how='left',on='BusNum')\nBCvoltViolations = BCvoltViolations[['Bus Number','BusNum','BusSection','Bus Name','Bus kV','V Limit','Voltage Violation Type','AREA','{0}'.format(rawfilename)]]\nif allVoltageViolations.empty == True:\nallVoltageViolations = BCvoltViolations\nallVoltageViolations = allVoltageViolations.drop_duplicates()\nelse:\nallVoltageViolations = allVoltageViolations.merge(BCvoltViolations,how='outer',on=['Bus Number','BusNum','BusSection','AREA',\\\n'Bus Name','Bus kV','V Limit','Voltage Violation Type'])\nallVoltageViolations = allVoltageViolations.drop_duplicates()\nif allThermalViolations.empty == True:\nallThermalViolations = BCbranchViolations\nallThermalViolations = allThermalViolations.drop_duplicates()\nelse:\nallThermalViolations = allThermalViolations.merge(BCbranchViolations,how='outer',on=['From Bus Number','From Bus Name',\\\n'FromBusNum','FromBusSection','FromBusArea','To Bus Number','ToBusNum','ToBusSection','ToBusArea','To Bus Name',\\\n'Circuit ID','Rating A'])\nallThermalViolations = allThermalViolations.drop_duplicates()\nelse:\nstep3_solution_dict.update({'Step':3,'Solution Method':'fnsl',\n'Iterations':'NA' ,'Mismatch':'NA' ,\n'Solution Str':'NA' ,'ierr':error_map[ierr_fnsl_3 ]})\nelse:\nstep2_solution_dict.update({'Step':2,'Solution Method':'fdns',\n'Iterations':'NA','Mismatch':'NA',\n'Solution Str':'NA','ierr':error_map[ierr_fdns_2]})\nelse:\nstep1_solution_dict.update({'Step':1,'Solution Method':'fdns',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':error_map[ierr_fdns_1]})\nstep2_solution_dict.update({'Step':2,'Solution Method':'NA',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':'NA (not attempted)'})\nstep3_solution_dict.update({'Step':3,'Solution Method':'NA',\n'Iterations':'NA','Mismatch':'NA','Solution Str':'NA',\n'ierr':'NA (not attempted)'})\nthree_step_solution_dict = dict(zip(step1_solution_dict,zip(step1_solution_dict.values(),step2_solution_dict.values(),step3_solution_dict.values())))\nthree_step_solution_data = pd.DataFrame.from_dict(three_step_solution_dict)\nthree_step_solution_data['Case'] = '{0}'.format(rawfilename)\nif allCaseSolveData.empty == True:\nallCaseSolveData = three_step_solution_data\nallCaseSolveData = allCaseSolveData.drop_duplicates()\nelse:\n# allCaseSolveData = allCaseSolveData.merge(two_step_solution_data,how='outer',\\\n#     on=['Step','Solution Method','Iterations','Mismatch','Solution Str','ierr',\\\n#     'tap adj','area interchange adj','phase shift adj','dc tap adj',\\\n#     'sw shunt adj','flat start','var limit','non-divergent sol'])\nallCaseSolveData = pd.concat([allCaseSolveData,three_step_solution_data],ignore_index=True)\nallCaseSolveData = allCaseSolveData.drop_duplicates()\nreturn allCaseSolveData, allVoltageViolations, allThermalViolations\ndef getCAConvergenceData(CASELOCATION,rawfilename,allCAData,areaList,temp_dir, allUnsolvedContingencies):\n# generate confile for all single branch elements in the selected areas\ntempConFileLoc = r'{0}\\temp.con'.format(temp_dir)\ngenerateAllSingleBranchAndXFRContingencies(CASELOCATION,areaList,tempConFileLoc)\n# generate sub and mon files\ntempSubFileLoc = r'{0}\\temp.sub'.format(temp_dir)\nf = open(tempSubFileLoc,\"w\")\nf.write(\"SUBSYSTEM 'temp'\\n\")\nfor AR in areaList:\nf.write(\"AREA {0}\\n\".format(AR))\nf.write(\"END\\nEND\")\nf.close()\ntempMonFileLoc = r'{0}\\temp.mon'.format(temp_dir)\nf = open(tempMonFileLoc,\"w\")\nf.write(\"\"\"MONITOR VOLTAGE RANGE SUBSYSTEM 'temp' 0.920 1.050\nMONITOR VOLTAGE DEVIATION SUBSYSTEM 'temp' 0.070 0.070\nMONITOR BRANCHES IN SUBSYSTEM 'temp'\nMONITOR TIES FROM SUBSYSTEM 'temp'\nEND\"\"\")\nf.close()\n# open the case and perform three-step solve from flat start\npsspy.case(CASELOCATION) #re-open case in psse\nfdns_configuration_step1 = [1,1,1,1,1,1,0,0]\nfdns_configuration_step2 = [1,1,1,1,1,0,0,0]\nfnsl_configuration_step3 = [1,1,1,1,1,0,0,0]\nierr_fdns_1 = psspy.fdns(fdns_configuration_step1)\nierr_fdns_2 = psspy.fdns(fdns_configuration_step2)\nierr_fnsl_3 = psspy.fdns(fnsl_configuration_step3)\n# set solution parameters\nCA_TOL = 0.01\nCA_TAPADJ = 1\nCA_AREAINT = 1\nCA_PHADJ = 1\nCA_DCTAP = 1\nCA_SWSH = 1\nCA_SOL = 1 # 'FDNS':0,'FNSL':1,'NSOL':0\nCA_NONDIV = 0\nCA_INDMOT = 0\nCA_INDMACH = 0\nCA_DISP = 0\nCA_ZIP = 0\n# generate dfax\ntempDfaxFileLoc = r'{0}\\temp.dfax'.format(temp_dir)\nierr = psspy.dfax([1,1],tempSubFileLoc,tempMonFileLoc,tempConFileLoc,tempDfaxFileLoc)\n# run accc\ntempAccFileLoc = r'{0}\\temp.acc'.format(temp_dir)\naccc_ierr = psspy.accc_with_dsp_3(CA_TOL,[CA_TAPADJ,CA_AREAINT,CA_PHADJ,CA_DCTAP,CA_SWSH,CA_SOL,CA_NONDIV,CA_INDMOT,CA_INDMACH,CA_DISP,CA_ZIP],\"\",tempDfaxFileLoc,tempAccFileLoc,\"\",\"\",\"\")\n# parse accc results\naccc_output_temp = r'{0}\\accc_output_temp.txt'.format(temp_dir)\n# report configs\nstat1 = 0 #spreadsheet report\nstat2 = 1 #rate 1 for base case violations\nstat3 = 2 #rate 2 for CA violations\nstat4 = 1 #bc SWD ratings set\nstat5 = 2 #ca SWD ratings set\nstat6 = 1 #voltage bc normal limit\nstat7 = 1 #voltage ca normal limit\nstat8 = 0 #exclude interfaces from report?\nstat9 = 1 #run voltage limit check\nstat10 = 1 #exclude elements with bc violations in ca violations\nstat11 = 1 #exclude elements with bc violations in ca violations\nstat12 = 0 #exclude cases with no ol's\nstat13 = 0 #do not report post-tripping action solutions\nstat14 = 1 #report loss of loads\nACCC_STATUSES = [stat1,stat2,stat3,stat4,stat5,stat6,stat7,stat8,stat9,stat10,stat11,stat12,stat13,stat14]\nintv1 = 0 #lv range violations filter\nintv2 = 0 #hv range violations filter\nintv3 = 0 #voltage deviation violations filter\nintv4 = 0 #largest num of busses in disconnected island\nintv5 = 6000 #max number of element in avail capacity table\nACCC_INTVALS = [intv1,intv2,intv3,intv4,intv5]\nrlvl1 = 0.5 #bus mismatch convergence\nrlvl2 = 5.0 #system mismatch convergence tolerance in MVA\nrlvl3 = 98 #percent of flow rating I MADE THIS LOW FOR DEV, SHOULD BE CLOSE TO 100\nrlvl4 = 0 #min contingency case flow change from base case value\nrlvl5 = 0 #min contingency case percent loading increase from base case\nrlvl6 = 0 #min contingency case voltage change from base case value\nrlvl7 = 99999 #cutoff threshold for available capacity table\nACCC_REALVALS = [rlvl1,rlvl2,rlvl3,rlvl4,rlvl5,rlvl6,rlvl7]\npsspy.report_output(2,accc_output_temp,[0,0])\naccc_report_ierr = psspy.accc_single_run_report_5(ACCC_STATUSES,ACCC_INTVALS,ACCC_REALVALS,tempAccFileLoc)\nCAresults = getAccReportViolations(accc_output_temp) # parse the acc output report and return a dataframe of results\nif type(CAresults) != type(None):\nConvergedContingencies = CAresults.loc[CAresults['ViolationType']=='Met convergence to']\nAllContingencies = CAresults.loc[CAresults['ViolationType'].isin(['Met convergence to','Iteration limit ex','Blown up'])]\nAllNonConvergedContingencies = CAresults.loc[CAresults['ViolationType'].isin(['Iteration limit ex','Blown up'])][['ViolationType','Location']]\nAllNonConvergedContingencies['{0}'.format(rawfilename)] = 'TRUE'\nnumConvergedContingencies = ConvergedContingencies.shape[0]\nnumAllContingencies = AllContingencies.shape[0]\nnumNonConvergedContingencies = AllNonConvergedContingencies.shape[0]\nCAdata = pd.DataFrame({'TotalContingencies':[numAllContingencies],'ConvergedContingencies':[numConvergedContingencies],\\\n'NonconvergedContingencies':[numNonConvergedContingencies]})\nCAdata['PercentConverged'] = CAdata['ConvergedContingencies'] /CAdata['TotalContingencies']\nCAdata['Case'] = '{0}'.format(rawfilename)\nelse:\nCAdata = pd.DataFrame({'TotalContingencies':['NA'],'ConvergedContingencies':['NA'],'NonconvergedContingencies':['NA'],\\\n'PercentConverged':['NA'],'UnableToObtainBaseCase':['True']})\nCAdata['Case'] = '{0}'.format(rawfilename)\nif allCAData.empty == True:\nallCAData = CAdata\nallCAData = allCAData.drop_duplicates()\nelse:\nallCAData = pd.concat([allCAData,CAdata],ignore_index=True)\nallCAData = allCAData.drop_duplicates()\nif allUnsolvedContingencies.empty == True:\nallUnsolvedContingencies = AllNonConvergedContingencies\nelse:\nallUnsolvedContingencies = allUnsolvedContingencies.merge(AllNonConvergedContingencies,how='outer',on=['ViolationType','Location'])\nreturn allCAData, allUnsolvedContingencies\ndef getIncorrectShuntRemoteBuses(allSwShunts,rawfilename,allIncorrectShuntRemoteBuses,savLocation,areaList):\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallSwShuntsWithArea = allSwShunts.merge(busData_tmp,how='left',on='ibus')\nSwShunts = allSwShuntsWithArea.loc[allSwShuntsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nincorrectShuntRemoteBus = SwShunts.loc[((SwShunts['swreg']>=9700)&(SwShunts['swreg']<=9999))|\\\n((SwShunts['swreg']>=94000)&(SwShunts['swreg']<=99999))|\\\n((SwShunts['swreg']>=100000)&(SwShunts['swreg']<=199999))]\nincorrectShuntRemoteBus = incorrectShuntRemoteBus[['ibus','AREA','shntid','modsw','swreg']]\nincorrectShuntRemoteBus['{0}'.format(rawfilename)] = 'TRUE'\nif allIncorrectShuntRemoteBuses.empty==True:\nallIncorrectShuntRemoteBuses = incorrectShuntRemoteBus\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.drop_duplicates()\nelse:\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.merge(incorrectShuntRemoteBus,how='outer',\\\non=['ibus','AREA','shntid','modsw','swreg'])\nallIncorrectShuntRemoteBuses = allIncorrectShuntRemoteBuses.drop_duplicates()\nreturn allIncorrectShuntRemoteBuses\ndef getIncorrectGenRemoteBuses(allGenerators,rawfilename,allIncorrectGenRemoteBuses,savLocation,areaList):\nbusData_tmp = getAllBusData(savLocation)[['NUMBER','AREA']].rename(columns={'NUMBER':'ibus'})\nallGeneratorsWithArea = allGenerators.merge(busData_tmp,how='left',on='ibus')\nGenerators = allGeneratorsWithArea.loc[allGeneratorsWithArea['AREA'].isin(areaList)] #get requested area shunts only\nincorrectGeneratorRemoteBus = Generators.loc[((Generators['ireg']>=9700)&(Generators['ireg']<=9999))|\\\n((Generators['ireg']>=94000)&(Generators['ireg']<=99999))|\\\n((Generators['ireg']>=100000)&(Generators['ireg']<=199999))]\nincorrectGeneratorRemoteBus = incorrectGeneratorRemoteBus[['ibus','AREA','machid','ireg','nreg']]\nincorrectGeneratorRemoteBus['{0}'.format(rawfilename)] = 'TRUE'\nif allIncorrectGenRemoteBuses.empty == True:\nallIncorrectGenRemoteBuses = incorrectGeneratorRemoteBus\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.drop_duplicates()\nelse:\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.merge(incorrectGeneratorRemoteBus,how='outer',\\\non=['ibus','AREA','machid','ireg','nreg'])\nallIncorrectGenRemoteBuses = allIncorrectGenRemoteBuses.drop_duplicates()\nreturn allIncorrectGenRemoteBuses\ndef generateAllSingleBranchAndXFRContingencies(CASELOCATION,areaList,tempConFileLoc):\nallBranches = getAllLineData(CASELOCATION)\nallXFRs = getAllXFRData(CASELOCATION)\nall2WXFRs = allXFRs.loc[allXFRs['WIND3NUMBER'].isnull()==True]\nall3WXFRs = allXFRs.loc[allXFRs['WIND3NUMBER'].isnull()==False]\nconfileLocation = tempConFileLoc\nf = open(confileLocation,\"w\")\ncontCounter = 1\nfor br in allBranches.index:"
  },
  {
    "id": "chunk_112",
    "text": "busI = allBranches.at[br,'FROMNUMBER']\nbusJ = allBranches.at[br,'TONUMBER']\ncktID = allBranches.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} CKT {2}\".format(busI,busJ,cktID)\nstrToID = 'LN_{0}-{1}_ID:{2}'.format(busI,busJ,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(strToID))) #f.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nfor br in all2WXFRs.index:\nbusI = all2WXFRs.at[br,'WIND1NUMBER']\nbusJ = all2WXFRs.at[br,'WIND2NUMBER']\ncktID = all2WXFRs.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} CKT {2}\".format(busI,busJ,cktID)\nstrToID = '2WXFR_{0}-{1}_ID:{2}'.format(busI,busJ,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(strToID))) #f.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nfor br in all3WXFRs.index:\nbusI = all3WXFRs.at[br,'WIND1NUMBER']\nbusJ = all3WXFRs.at[br,'WIND2NUMBER']\nbusK = int(all3WXFRs.at[br,'WIND3NUMBER'])\ncktID = all3WXFRs.at[br,'ID']\nstrToWrite = r\"OPEN BRANCH FROM BUS {0} TO BUS {1} TO BUS {2} CKT {3}\".format(busI,busJ,busK,cktID)\nstrToID = '3WXFR_{0}-{1}-{2}_ID:{3}'.format(busI,busJ,busK,cktID)\nf.write(\"CONTINGENCY '{0}'\".format(str(strToID))) #f.write(\"CONTINGENCY '{0}'\".format(str(contCounter)))\nf.write(\"\\n\")\nf.write(strToWrite)\nf.write(\"\\n\")\nf.write(\"END\")\nf.write(\"\\n\")\ncontCounter = contCounter+1\nf.write(\"END\")\nf.close()\nreturn\ndef getQAReports(CASEDIRECTORY,OUTPUTDIRECTORY,DESIRED_QA_LIST,AREALIST):\n### DESIRED_QA_LIST is a list of requested reports to be created, it may include the following entries:\n### '900k_buses','CNTB_check','out_of_range_buses','disconnected_shunts','disconnected_loads',\n### 'zero_loads', 'multiple_branches_terminating_on_node', 'invalid_Binit_switched_shunts',\n### 'TREE_islands', 'unterminated_elements', 'br_remote_end_voltage_inconsistencies',\n### 'bus_type_inconsistencies', 'incorrect_voltage_bus_limits', 'TLD_bus_updates',\n### 'check_solvability','check_CA_performance', 'PSSE_pf_checks'\n### create a dictionary of the request reports\navailable_reports = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads','disconnected_buses'\n]\nreport_dict = {}\nfor report in available_reports:\nif report in DESIRED_QA_LIST:\nreport_dict[report] = 1\nelse:\nreport_dict[report] = 0\n### Create temp directory for file management ###\n#TMP_DIR = makeTempDirectory()\ntemporary_directory = tempfile.TemporaryDirectory()\nTMP_DIR = temporary_directory.name\nprint('Created temp directory {0}.'.format(TMP_DIR))\n#### Supress all the PSSE outputs for now\nsuppressAllPSSEOutputs()\n### Get the list of raw cases to process and define\ntarget_directory = CASEDIRECTORY.GetPath()\ncase_list = sorted(glob.glob(target_directory+r'\\*.raw')) #to sort raws by name\n### Prepare the output directory\ntarget_output_directory = OUTPUTDIRECTORY.GetPath()+r'\\QA_results_{}'.format(str(datetime.datetime.now().date()))\nos.makedirs(target_output_directory) #create auto QA check output file\n### set up logger\ntoday_date = str(datetime.date.today())\nlogging.basicConfig(filename='{0}\\log_file'.format(target_output_directory),filemode='a',level=logging.DEBUG,format='%(name)s - %(levelname)s - %(message)s')\nlogging.debug('{0} execute start at {1}'.format(sys.argv[0],datetime.datetime.now()))\nlogging.debug('All required files and directories selected. Now running the following QA reports for the areas {0}:'.format(','.join(map(str,AREALIST))))\nlogging.debug(DESIRED_QA_LIST)\n### Prepare blank dataframes for results\nCNTB_messages = pd.DataFrame()\nBusData = pd.DataFrame()\nallBusInconsistencies = pd.DataFrame()\nallIslands = pd.DataFrame()\nallBrTerminalVoltageInconsistencies = pd.DataFrame()\nallDisconnectedLds = pd.DataFrame()\nallZeroLds = pd.DataFrame()\nallLoads = pd.DataFrame()\nallLoadsWithTotalsColumn = pd.DataFrame()\nallSwShuntsWithInvalidBinit = pd.DataFrame()\nalldisconnected_shunts = pd.DataFrame()\nall900k_buses = pd.DataFrame()\nalldisconnected_buses = pd.DataFrame()\nallCaseSolveData = pd.DataFrame()\nallVoltageViolations = pd.DataFrame()\nallThermalViolations = pd.DataFrame()\nallIncorrectShuntRemoteBuses = pd.DataFrame()\nallIncorrectGenRemoteBuses = pd.DataFrame()\nallCAData = pd.DataFrame()\nallUnsolvedContingencies = pd.DataFrame()\nallSwShuntsWithInvalidSetpoints = pd.DataFrame()\n# PSSE check powerflow data dataframes\nallPFCheckTypes = {'bus data':1,'load data':2,'plant data':3,'generator unit data':4,\n'induction machine data':5,'fixed bus shunt data':6,'switched shunt data':7,\n'non-transformer branch data':8,'two-winding transformer data':9,\n'three-winding transformer data':10,'transformer impedance table correciton data':11,\n'two-terminal dc line data':13,'multi-terminal dc line data':14,\n'VSC dc line data':15,'FACTS device data':16,'GNE device data':17,\n'area interchange data':18,'owner data':19,'zone data':20}\nallPFCheckResults = {}\nfor checkType in allPFCheckTypes:\nallPFCheckResults[checkType] = pd.DataFrame()\n### Process all raw files according to which reports were requested\ncounter = 1\nfor case in case_list:\n### read in the raw file\nprint('processesing case {0} out of {1}'.format(counter,len(case_list)))\nrawfilename = os.path.splitext(os.path.basename(case))[0]\nlogging.debug('processesing raw {0} -- case {1} out of {2}'.format(rawfilename,counter,len(case_list)))\ncounter = counter+1\npsspy.read(0,case) # open case\n### save the open case as a sav\nsavLocation = target_output_directory+r'\\{0}.sav'.format(rawfilename)\nPSSESaveCase(savLocation)\n### if no areas were chosen by the user, get a list of all areas in the open case\nif AREALIST == []:\nint_data_desired = ['NUMBER']\nint_ierr, iarray = psspy.aareaint(-1, 2, int_data_desired)\nallAreas = iarray[0]\nAREALIST = allAreas\n### if requested, do the solvability check. If the solvability check indicates that the case did not solve, then do not attempt CA check\nif (report_dict['check_solvability'] == 1)|(report_dict['check_CA_performance'] == 1):\n#allCaseSolveData = getSolutionData(rawfilename,allCaseSolveData)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nAllBusArea = getBusData(savLocation,target_output_directory,rawfilename,BusData,ALLAREALIST)[['NUMBER','AREA']] #get bus data for reports to join area to report results\nallCaseSolveData,allVoltageViolations,allThermalViolations = getSolutionData(rawfilename,allCaseSolveData,AREALIST,allVoltageViolations,allThermalViolations,TMP_DIR,AllBusArea)\nexcept:\nprint('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData().')\nlogging.debug('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData(): ', exc_info=True)\n### if requested, do the CA check. If the solvability check indicates that the case did not solve, then this will not be attempted.\nif report_dict['check_CA_performance'] == 1:\n# check last powerflow solution\nlatestSolution = allCaseSolveData.loc[(allCaseSolveData['Case']==rawfilename)&(allCaseSolveData['Step']==3)]\nlatestSolution = latestSolution.reset_index()\nif (latestSolution.at[0,'Solution Str'] != 'Met convergence tolerances                      '):\nnoData = pd.DataFrame({'Case':[rawfilename],'CANotAttemptedDuetoNon-SolvedRAW':['True']})\nallCAData = pd.concat([allCAData,noData],ignore_index=True)\nelse:\n#allCAData = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallCAData, allUnsolvedContingencies  = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR,allUnsolvedContingencies)\nexcept:\nprint('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData().')\nlogging.debug('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData(): ', exc_info=True)\n### if requested, do the CNTB check\nif report_dict['CNTB_check'] == 1:\n#CNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nCNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages,AREALIST)\nexcept:\nprint('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData().')\nlogging.debug('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData(): ', exc_info=True)\n### if any bus-related reports requested, get the bus data and extract the relevant data\nif (report_dict['900k_buses'] == 1)|(report_dict['disconnected_buses'] == 1): # for ERCOT-only distribution\n#BusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nBusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData(): ', exc_info=True)\nif (report_dict['900k_buses'] == 1) & (BusData.empty == False):\n#all900k_buses = get900kBuses(BusData) #to troubleshoot, uncomment this line and comment out the following try/except block\ntry:\nall900k_buses = get900kBuses(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().', exc_info=True)\nif (report_dict['disconnected_buses'] == 1) & (BusData.empty == False):\n#alldisconnected_buses = getDisconnectedBuses(BusData) #to troubleshoot, uncomment this line and comment out the following try/except block\ntry:\nalldisconnected_buses = getDisconnectedBuses(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedBuses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedBuses().', exc_info=True)\n### if requested, get all the load data\nif (report_dict['all_lds'] == 1)|(report_dict['disconnected_loads'] == 1)|(report_dict['zero_loads'] == 1):\n#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseAllLoadData = getLdDataTotalsReportedInCaseColumn(savLocation,allLoads,rawfilename,AREALIST)\nif allLoads.empty == True:\nallLoads = thisCaseAllLoadData\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(thisCaseAllLoadData,how='outer',on=['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn(): ', exc_info=True)"
  },
  {
    "id": "chunk_113",
    "text": "#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseLoadData = getLdData(savLocation,allLoadsWithTotalsColumn,rawfilename,AREALIST)\nif allLoadsWithTotalsColumn.empty == True:\nallLoadsWithTotalsColumn = thisCaseLoadData\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nelse:\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.merge(thisCaseLoadData,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData(): ', exc_info=True)\nif report_dict['disconnected_loads'] == 1:\n#allDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nallDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads()')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads(): ', exc_info=True)\nif report_dict['zero_loads'] == 1:\n#allZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds) #TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads(): ', exc_info=True)\n### if requested, get the disconnected shunts\nif report_dict['disconnected_shunts'] == 1:\n#alldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nalldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts(): ', exc_info=True)\n### if requested, get the bus inconsistencies\nif report_dict['bus_type_inconsistencies'] == 1:\n#allBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies(): ', exc_info=True)\n### if requested, get the islands from TREE\nif report_dict['TREE_islands'] == 1:\n#allIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands(): ', exc_info=True)\n### if requested, get the PSSE pf check reports\nif report_dict['PSSE_pf_checks'] == 1:\n#allPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks(): ', exc_info=True)\n### if requested, get the branch remote end voltage inconsistencies\nif report_dict['br_remote_end_voltage_inconsistencies'] == 1:\n#allBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies(): ', exc_info=True)\n### if any node-breaker checks are required, get the raw model in JSON format and extract the node breaker data\n# this is the if statement for the ERCOT-distributed version\nif ((report_dict['invalid_Binit_switched_shunts'] == 1)\\\n| (report_dict['incorrect_shunt_remote_buses'] == 1) | (report_dict['incorrect_gen_remote_buses'] == 1) \\\n| (report_dict['invalid_setpts_continuous_shunts'] == 1)):\n#RAW_JSON = getRawxJSON(TMP_DIR,rawfilename) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nRAW_JSON = getRawxJSON(TMP_DIR,rawfilename)\nexcept:\nprint('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON()')\nlogging.debug('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON(): ', exc_info=True)\n#IBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, ALL_ELEMENT_DATA_DICT = getNodeBreakerData(RAW_JSON)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nIBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, \\\nALL_ELEMENT_DATA_DICT, ALL_TERMABLE_EQUIP_W_NODE_DATA_INCL_SUBSWDS = getNodeBreakerData(RAW_JSON)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData(): ', exc_info=True)\nif report_dict['invalid_Binit_switched_shunts'] == 1:\n#allSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts(): ', exc_info=True)\nif report_dict['invalid_setpts_continuous_shunts'] == 1:\n#allSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts(): ', exc_info=True)\n### if requested, get the incorrect switched shun remote bus report\nif report_dict['incorrect_shunt_remote_buses'] == 1:\n#allIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses(): ', exc_info=True)\n### if requested, get the incorrect generator remote bus report\nif report_dict['incorrect_gen_remote_buses'] == 1:\n#allIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses(): ', exc_info=True)\n### Save the reports\nlogging.debug('Processing cases is complete. Now creating reports')\nsummaryReport = pd.DataFrame(columns=['Report','Number of Results','Location'])\n# make excel for CNTB messages\nif report_dict['CNTB_check']==1:\nlogging.debug('Creating CNTB Report')\n#CNTB_messages.to_csv(target_output_directory+r'\\all_CNTB_messages.csv')\nCNTB_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_CNTB_messages.xlsx')\nCNTB_errors = CNTB_messages.loc[CNTB_messages['Type']=='ERROR']\nCNTB_warnings = CNTB_messages.loc[CNTB_messages['Type']=='Warning']\n#CNTB_other = CNTB_messages.loc[CNTB_messages_tmp['Type']=='Other']\nCNTB_errors.to_excel(CNTB_excelWriter,sheet_name='Errors')\nCNTB_warnings.to_excel(CNTB_excelWriter,sheet_name='Warnings')\n#CNTB_other.to_excel(CNTB_excelWriter,sheet_name='Other')\nCNTB_excelWriter.save()\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['CNTB_errors','CNTB_warnings'],\n'Number of Results':[CNTB_errors.index.size,CNTB_warnings.index.size],\n'Location':[target_output_directory+r'\\all_CNTB_messages.xlsx',target_output_directory+r'\\all_CNTB_messages.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# make excel for PSSE_pf_check_results\nif report_dict['PSSE_pf_checks'] == 1:\nlogging.debug('Creating PSSE_pf_checks report')\nPSSEpfCheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_PSSE_pf_checks.xlsx')\nfor checkType in allPFCheckResults.keys():\nsheet_name_max = checkType[0:30]\nallPFCheckResults[checkType].to_excel(PSSEpfCheck_excelWriter,sheet_name='{0}'.format(sheet_name_max))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['PSSE PF Check - {0}'.format(checkType)],\n'Number of Results':[allPFCheckResults[checkType].index.size],\n'Location':[target_output_directory+r'\\all_PSSE_pf_checks.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\nPSSEpfCheck_excelWriter.save()\n# make excel for check_solvability from allVoltageViolations, allThermalViolations, and allCaseSolveData\nif report_dict['check_solvability'] == 1:\nlogging.debug('Creating solvability check excel report')\nSolCheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\Solution_checks.xlsx')\nallCaseSolveData.to_excel(SolCheck_excelWriter,sheet_name='SolvabilityResults')\nallVoltageViolations.to_excel(SolCheck_excelWriter,sheet_name='VoltageViolations')\nallThermalViolations.to_excel(SolCheck_excelWriter,sheet_name='ThermalViolations')\nSolCheck_excelWriter.save()\n# make excel for check_CA_performance from allUnsolvedContingencies and allCAData\nif report_dict['check_CA_performance'] == 1:\nlogging.debug('Creating CA performance check excel report')\nCACheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\CA_performance_checks.xlsx')\nallCAData.to_excel(CACheck_excelWriter,sheet_name='CA_Results')\nallUnsolvedContingencies.to_excel(CACheck_excelWriter,sheet_name='Unsolved_Contingencies')\nCACheck_excelWriter.save()\n# make csv reports for all the other reports\nreport_to_data_dictionary = {'900k_buses':all900k_buses,\\\n'disconnected_shunts':alldisconnected_shunts,\\\n'disconnected_loads':allDisconnectedLds,\\\n'zero_loads':allZeroLds,\\\n'invalid_Binit_switched_shunts':allSwShuntsWithInvalidBinit,\\\n'TREE_islands':allIslands,\\\n'br_remote_end_voltage_inconsistencies':allBrTerminalVoltageInconsistencies,\\\n'bus_type_inconsistencies':allBusInconsistencies,\\\n'all_lds':allLoads,\\\n#'check_solvability':allCaseSolveData,\\\n'incorrect_shunt_remote_buses':allIncorrectShuntRemoteBuses,\\\n'incorrect_gen_remote_buses':allIncorrectGenRemoteBuses,\\\n#'check_CA_performance':allCAData,\\\n'invalid_setpts_continuous_shunts':allSwShuntsWithInvalidSetpoints,\\\n'disconnected_buses':alldisconnected_buses}"
  },
  {
    "id": "chunk_114",
    "text": "for report in report_to_data_dictionary.keys():\nif report_dict[report]==1:\nlogging.debug('Creating {0} report'.format(report))\nreport_to_data_dictionary[report].to_csv(target_output_directory+r'\\{0}.csv'.format(report))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':[report],\n'Number of Results':[report_to_data_dictionary[report].index.size],\n'Location':[target_output_directory+r'\\{0}.csv'.format(report)]})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# create summary report\nlogging.debug('Creating summary report.')\nsummaryReport['Location'] = summaryReport['Location'].apply(lambda x: make_clickable(x, x))\nsummaryReport = summaryReport.sort_values(by=['Number of Results'],ascending=False)\nsummary_html = summaryReport.to_html(render_links=True,escape=False)\ntext_file = open(target_output_directory+r'\\SummaryReport.html','w')\ntext_file.write(summary_html)\ntext_file.close()\nlogging.debug('Reports completed.')\nlogging.debug('Done.')\nlogging.shutdown()\n######### XXX-only functions ########\ndef getallTempLookingSwitches(equipmentData,rawfilename,busData,allTempLookingSwitches,areaList):\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'area':'ibusarea'}),how='left',on='ibus')\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'ibus':'jbus','area':'jbusarea'}),how='left',on='jbus')\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'ibus':'kbus','area':'kbusarea'}),how='left',on='kbus')\nlookstmp = equipmentData.loc[(equipmentData['equipmentType'].isin(['system switching device','Subswd - GEN','Subswd - CB','Subswd - DSC']))&\\\n((equipmentData['name'].str.upper().str.contains(\"$PS\"))|\\\n(equipmentData['name'].str.upper().str.contains(\"$TS\"))|\\\n(equipmentData['name'].str.upper().str.contains(\"TEMP\")))&\\\n# ((equipmentData['name'].str.split(pat='$',expand=True)[[3]].str.upper().str.contains(\"PS\"))|\\\n# (equipmentData['name'].str.split(pat='$',expand=True)[[3]].str.upper().str.contains(\"TS\"))|\\\n# (equipmentData['name'].str.split(pat='$',expand=True)[[3]].str.upper().str.contains(\"TEMP\")))&\\\n((equipmentData['ibusarea'].isin(areaList))|\\\n(equipmentData['jbusarea'].isin(areaList))|\\\n(equipmentData['kbusarea'].isin(areaList)))]\nlookstmp['{0}'.format(rawfilename)] = 'TRUE'\nif allTempLookingSwitches.empty == True:\nallTempLookingSwitches = lookstmp\nallTempLookingSwitches = allTempLookingSwitches.drop_duplicates()\nelse:\nallTempLookingSwitches = allTempLookingSwitches.merge(lookstmp,how='outer',\\\non=['ibus','jbus','kbus','equipmentType','eqid','name','isub','inode','jsub','jnode','ksub','knode','ibusarea','jbusarea','kbusarea'])\nallTempLookingSwitches = allTempLookingSwitches.drop_duplicates()\nreturn allTempLookingSwitches\ndef getallMobileLoads(equipmentData,rawfilename,busData,allMobileLoads,areaList):\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'area':'ibusarea'}),how='left',on='ibus')\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'ibus':'jbus','area':'jbusarea'}),how='left',on='jbus')\nequipmentData = equipmentData.merge(busData[['ibus','area']].rename(columns={'ibus':'kbus','area':'kbusarea'}),how='left',on='kbus')\nlookstmp = equipmentData.loc[(equipmentData['equipmentType'].isin(['load']))&\\\n((equipmentData['eqid'].str.upper().str.contains(\"M\")))&\\\n((equipmentData['ibusarea'].isin(areaList))|\\\n(equipmentData['jbusarea'].isin(areaList))|\\\n(equipmentData['kbusarea'].isin(areaList)))]\nlookstmp['{0}'.format(rawfilename)] = 'TRUE'\nif allMobileLoads.empty == True:\nallMobileLoads = lookstmp\nallMobileLoads = allMobileLoads.drop_duplicates()\nelse:\nallMobileLoads = allMobileLoads.merge(lookstmp,how='outer',\\\non=['ibus','jbus','kbus','equipmentType','eqid','name','isub','inode','jsub','jnode','ksub','knode','ibusarea','jbusarea','kbusarea'])\nallMobileLoads = allMobileLoads.drop_duplicates()\nreturn allMobileLoads\ndef getnon_XXX_range_XXX_buses(BusData):\nnon_XXX_range_XXX_buses = BusData.loc[((BusData['NUMBER'] < 7000) | ((BusData['NUMBER'] > 7900) & (BusData['NUMBER'] < 71000)) |\\\n((BusData['NUMBER'] > 79000) & (BusData['NUMBER'] < 100000)) | ((BusData['NUMBER'] > 200000)&(BusData['NUMBER'] < 700000)))&\\\n(BusData['AREA'].isin([7,907]))]\nXXX_range_NonXXX_buses = BusData.loc[(((BusData['NUMBER']>=7000)&(BusData['NUMBER']<7900))|((BusData['NUMBER']>=71000)&(BusData['NUMBER']<79000)))&\\\n(BusData['AREA'].isin([7,907])==False)]\nbusesToReturn = pd.concat([non_XXX_range_XXX_buses,XXX_range_NonXXX_buses],ignore_index=True)\nreturn busesToReturn\ndef getincorrect_voltage_bus_limits(BusData):\nincorrect_voltage_bus_limits = BusData.loc[((BusData['NVLMLO']!=0.95)|(BusData['NVLMHI']!=1.05)|(BusData['EVLMLO']!=0.92)|(BusData['EVLMHI']!=1.05))&\\\n(((BusData['NUMBER'] >= 7000) & (BusData['NUMBER'] < 8000)) | ((BusData['NUMBER'] >= 71000) & (BusData['NUMBER'] < 80000)))]\nreturn incorrect_voltage_bus_limits\ndef getUnterminatedElements(all_termable_equip_with_nodes,rawfilename,allUnterminatedXXXElements):\n# keep track of which elements are not terminated on a node so that users are aware\nall_unterminated_elements = all_termable_equip_with_nodes.loc[(all_termable_equip_with_nodes['isub'].isna())\\\n|((all_termable_equip_with_nodes['jsub'].isna())&(all_termable_equip_with_nodes['jbus'].isna()==False))\\\n|((all_termable_equip_with_nodes['ksub'].isna())&(all_termable_equip_with_nodes['kbus'].isna()==False))]\nall_XXX_unterminated_elements = all_unterminated_elements.loc[\\\n(((all_unterminated_elements['ibus']>=7000)&(all_unterminated_elements['ibus']<8000))|((all_unterminated_elements['ibus']>=71000)&(all_unterminated_elements['ibus']<79000)))\\\n|(((all_unterminated_elements['jbus']>=7000)&(all_unterminated_elements['jbus']<8000))|((all_unterminated_elements['jbus']>=71000)&(all_unterminated_elements['jbus']<79000)))\\\n|(((all_unterminated_elements['kbus']>=7000)&(all_unterminated_elements['kbus']<8000))|((all_unterminated_elements['kbus']>=71000)&(all_unterminated_elements['kbus']<79000)))]\nall_XXX_unterminated_elements['{0}'.format(rawfilename)] = 'TRUE'\nall_XXX_unterminated_elements = all_XXX_unterminated_elements.drop(['EquipmentID'], axis = 1)\nif allUnterminatedXXXElements.empty == True:\nallUnterminatedXXXElements = all_XXX_unterminated_elements\nallUnterminatedXXXElements=allUnterminatedXXXElements.drop_duplicates()\nelse:\nallUnterminatedXXXElements = pd.merge(allUnterminatedXXXElements,all_XXX_unterminated_elements,how='outer',on=['ibus','jbus','kbus','eqid','equipmentType','type','name','isub','inode','jsub','jnode','ksub','knode','stat','nstat'])\nallUnterminatedXXXElements=allUnterminatedXXXElements.drop_duplicates()\nreturn allUnterminatedXXXElements\ndef getMultiBrOnNode(ibus_node_table, jbus_node_table, kbus_node_table, rawfilename, allBranchesTerminatedOnSameNode):\n#find where we have multiple bus branch elements terminated on the same node\nibus_node_table = ibus_node_table.rename(columns={'isub':'sub','inode':'node'})\njbus_node_table = jbus_node_table.rename(columns={'jsub':'sub','jnode':'node'})\nkbus_node_table = kbus_node_table.rename(columns={'ksub':'sub','knode':'node'})\nflattened_node_table = pd.concat([ibus_node_table,jbus_node_table,kbus_node_table],ignore_index=True)\nflattened_node_table_no_equipment_names = flattened_node_table[['EquipmentID','sub','node']]\nmultiple_branches_same_node = flattened_node_table_no_equipment_names.groupby(['sub','node']).agg(['nunique'])\nmultiple_branches_same_node = multiple_branches_same_node.loc[multiple_branches_same_node[('EquipmentID','nunique')]>1]\nmultiple_branches_same_node = multiple_branches_same_node.merge(flattened_node_table,how='left',on=['sub','node'])\nmultiple_branches_same_node = multiple_branches_same_node.loc[\\\n(((multiple_branches_same_node['ibus']>=7000)&(multiple_branches_same_node['ibus']<8000))|((multiple_branches_same_node['ibus']>=71000)&(multiple_branches_same_node['ibus']<79000)))\\\n|(((multiple_branches_same_node['jbus']>=7000)&(multiple_branches_same_node['jbus']<8000))|((multiple_branches_same_node['jbus']>=71000)&(multiple_branches_same_node['jbus']<79000)))\\\n|(((multiple_branches_same_node['kbus']>=7000)&(multiple_branches_same_node['kbus']<8000))|((multiple_branches_same_node['kbus']>=71000)&(multiple_branches_same_node['kbus']<79000)))]\nmultiple_branches_same_node=multiple_branches_same_node.rename(columns={('EquipmentID', 'nunique'):'Number Elements Terminating on Same Node'})\nmultiple_branches_same_node=multiple_branches_same_node[['ibus','jbus','kbus','eqid','equipmentType','name','sub','node','Number Elements Terminating on Same Node']]\nmultiple_branches_same_node['{0}'.format(rawfilename)] = 'TRUE'\nif allBranchesTerminatedOnSameNode.empty==True:\nallBranchesTerminatedOnSameNode = multiple_branches_same_node\nallBranchesTerminatedOnSameNode=allBranchesTerminatedOnSameNode.drop_duplicates()\nelse:\nallBranchesTerminatedOnSameNode = pd.merge(allBranchesTerminatedOnSameNode,multiple_branches_same_node,how='outer',on=['ibus','jbus','kbus','eqid','equipmentType','name','sub','node','Number Elements Terminating on Same Node'])\nallBranchesTerminatedOnSameNode=allBranchesTerminatedOnSameNode.drop_duplicates()\nreturn allBranchesTerminatedOnSameNode\ndef getTLDBusUpdates(savLocation,APIbusData,allTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate,rawfilename,SUBTERM_data,areaList):\nbusData_tmp = getAllBusData(savLocation)\n#check for TLD buses that need to be updated\nbusDataForTLDcheck = busData_tmp.loc[(busData_tmp['AREA'].isin(areaList))]\nsubDataForTLDcheck = SUBTERM_data[['isub','ibus']]\nsubDataForTLDcheck = subDataForTLDcheck.drop_duplicates()\nTLDBusesUpdateData = APIbusData.merge(busDataForTLDcheck,how='outer',left_on='BusNumber',right_on='NUMBER')\nTLDBusesUpdateData = TLDBusesUpdateData.merge(subDataForTLDcheck,how='left',left_on='NUMBER',right_on='ibus')\n#TLDBusesUpdateData.to_csv(target_output_directory+r'\\TLDBusesUpdateData.csv')\nTLDBusesUpdateData = TLDBusesUpdateData[['BusNumber','BusName','Voltage','ModelStatus',\\\n'PublishStatus','SSWGSubstationNumber','NAME','BASE','NUMBER','isub','Display']]\nTLDBusesToAdd = TLDBusesUpdateData.loc[(TLDBusesUpdateData['Display']!='TRUE')&\\\n(TLDBusesUpdateData['NUMBER'].isna()==False)&(TLDBusesUpdateData['BusNumber'].isna()==True)]\nTLDBusesToRemove = TLDBusesUpdateData.loc[(TLDBusesUpdateData['PublishStatus']!='Inactive')&\\\n(TLDBusesUpdateData['NUMBER'].isna()==True)]\nTLDBusesToUpdate = TLDBusesUpdateData.loc[\\\n((TLDBusesUpdateData['PublishStatus']!='Inactive')&(TLDBusesUpdateData['NUMBER'].isna()==False))&\n((TLDBusesUpdateData['BASE']!=TLDBusesUpdateData['Voltage'])|\n(TLDBusesUpdateData['NAME']!=TLDBusesUpdateData['BusName'])|\n((TLDBusesUpdateData['SSWGSubstationNumber'].isna()==False)&(TLDBusesUpdateData['SSWGSubstationNumber']!=TLDBusesUpdateData['isub'])))]\nTLDBusesToAdd['{0}'.format(rawfilename)] = 'TRUE'\nTLDBusesToRemove['{0}'.format(rawfilename)] = 'TRUE'\nTLDBusesToUpdate['{0}'.format(rawfilename)] = 'TRUE'\nif allTLDBusesToAdd.empty == True:\nallTLDBusesToAdd = TLDBusesToAdd\nallTLDBusesToAdd = allTLDBusesToAdd.drop_duplicates()\nelse:\nallTLDBusesToAdd = allTLDBusesToAdd.merge(TLDBusesToAdd,how='outer',on=['BusNumber','BusName'\\\n,'Voltage','ModelStatus','PublishStatus','SSWGSubstationNumber','NAME','BASE','NUMBER','isub','Display'])\nallTLDBusesToAdd = allTLDBusesToAdd.drop_duplicates()\nif allTLDBusesToRemove.empty == True:\nallTLDBusesToRemove = TLDBusesToRemove\nallTLDBusesToRemove = allTLDBusesToRemove.drop_duplicates()\nelse:\nallTLDBusesToRemove = allTLDBusesToRemove.merge(TLDBusesToRemove,how='outer',on=['BusNumber','BusName'\\\n,'Voltage','ModelStatus','PublishStatus','SSWGSubstationNumber','NAME','BASE','NUMBER','isub','Display'])\nallTLDBusesToRemove = allTLDBusesToRemove.drop_duplicates()\nif allTLDBusesToUpdate.empty == True:\nallTLDBusesToUpdate = TLDBusesToUpdate\nallTLDBusesToUpdate = allTLDBusesToUpdate.drop_duplicates()\nelse:\nallTLDBusesToUpdate = allTLDBusesToUpdate.merge(TLDBusesToUpdate,how='outer',on=['BusNumber','BusName'\\\n,'Voltage','ModelStatus','PublishStatus','SSWGSubstationNumber','NAME','BASE','NUMBER','isub','Display'])\nallTLDBusesToUpdate = allTLDBusesToUpdate.drop_duplicates()\nreturn (allTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate)\ndef getTLDBusList():\n# get TLD bus list for QA check\nurl = 'http://ts/api/lines/bus'\nresults = requests.get(url)\nresults_json = json.loads(results.content)\nresultsdf = pd.DataFrame.from_records(results_json)\nresultsdf = resultsdf.loc[resultsdf['Display']!='TRUE'] #only use the entries where Display is True\n#activebuses = resultsdf.loc[resultsdf['PublishStatus']!='Inactive']\nreturn resultsdf\ndef getQAReportsXXX(CASEDIRECTORY,OUTPUTDIRECTORY,DESIRED_QA_LIST,AREALIST):\n### DESIRED_QA_LIST is a list of requested reports to be created, it may include the following entries:\n### '900k_buses','CNTB_check','out_of_range_buses','disconnected_shunts','disconnected_loads',\n### 'zero_loads', 'multiple_branches_terminating_on_node', 'invalid_Binit_switched_shunts',\n### 'TREE_islands', 'unterminated_elements', 'br_remote_end_voltage_inconsistencies',\n### 'bus_type_inconsistencies', 'incorrect_voltage_bus_limits', 'TLD_bus_updates',\n### 'check_solvability','check_CA_performance', 'PSSE_pf_checks'\n### create a dictionary of the request reports\navailable_reports = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads','disconnected_buses',\n########## XXX-ONLY reports ##########\n'temp_looking_switches','mobile_loads','out_of_range_buses',\n'multiple_branches_terminating_on_node','unterminated_elements','incorrect_voltage_bus_limits','TLD_bus_updates'\n########## XXX-ONLY reports ##########\n]\nreport_dict = {}\nfor report in available_reports:\nif report in DESIRED_QA_LIST:\nreport_dict[report] = 1\nelse:\nreport_dict[report] = 0\n### Create temp directory for file management ###\n#TMP_DIR = makeTempDirectory()\ntemporary_directory = tempfile.TemporaryDirectory()\nTMP_DIR = temporary_directory.name\nprint('Created temp directory {0}.'.format(TMP_DIR))\n#### Supress all the PSSE outputs for now\nsuppressAllPSSEOutputs()\n### Get the list of raw cases to process and define\ntarget_directory = CASEDIRECTORY.GetPath()\ncase_list = sorted(glob.glob(target_directory+r'\\*.raw')) #to sort raws by name\n### Prepare the output directory\ntarget_output_directory = OUTPUTDIRECTORY.GetPath()+r'\\QA_results_{}'.format(str(datetime.datetime.now().date()))\nos.makedirs(target_output_directory) #create auto QA check output file\n### set up logger\ntoday_date = str(datetime.date.today())\nlogging.basicConfig(filename='{0}\\log_file'.format(target_output_directory),filemode='a',level=logging.DEBUG,format='%(name)s - %(levelname)s - %(message)s')\nlogging.debug('{0} execute start at {1}'.format(sys.argv[0],datetime.datetime.now()))\nlogging.debug('All required files and directories selected. Now running the following QA reports for the areas {0}:'.format(','.join(map(str,AREALIST))))\nlogging.debug(DESIRED_QA_LIST)\n#### try getting the TLD bus list for TLD Bus check, if requested. If the integration is broken, or the program can't reach the API endpoint, don't perform the TLD bus check, but provide a message to the user\nif report_dict['TLD_bus_updates'] == 1:\n#APIbusData = getTLDBusList() # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nAPIbusData = getTLDBusList()\nlogging.debug('Data for {} lines returned from getTLDBusList(): '.format(len(APIbusData.index)), exc_info=True)\nexcept:\nfailResult = pd.DataFrame({1:['Unable to perform a check on the TLD bus data. End point http://ts/api/lines/bus unavailable or unreachable.']})\nfailResult.to_csv(target_output_directory+r'\\TLD_BUS_UPDATE_FAILURE.csv')\nreport_dict['TLD_bus_updates'] == 0 # setting this to zero ensures that this report won't be generated.\nlogging.debug('PROBLEM WITH GETTING TLD BUS LIST. PROBLEM ENCOUNTERED WHILE RUNNING getTLDBusList(): ', exc_info=True)\n### Prepare blank dataframes for results\nCNTB_messages = pd.DataFrame()\nBusData = pd.DataFrame()\nallBusInconsistencies = pd.DataFrame()\nallIslands = pd.DataFrame()\nallBrTerminalVoltageInconsistencies = pd.DataFrame()\nallDisconnectedLds = pd.DataFrame()\nallZeroLds = pd.DataFrame()\nallLoads = pd.DataFrame()\nallLoadsWithTotalsColumn = pd.DataFrame()\nallSwShuntsWithInvalidBinit = pd.DataFrame()\nalldisconnected_shunts = pd.DataFrame()\nall900k_buses = pd.DataFrame()\nalldisconnectedBuses = pd.DataFrame()\nallCaseSolveData = pd.DataFrame()\nallVoltageViolations = pd.DataFrame()\nallThermalViolations = pd.DataFrame()\nallIncorrectShuntRemoteBuses = pd.DataFrame()\nallIncorrectGenRemoteBuses = pd.DataFrame()\nallCAData = pd.DataFrame()\nallUnsolvedContingencies = pd.DataFrame()\nallSwShuntsWithInvalidSetpoints = pd.DataFrame()\n# PSSE check powerflow data dataframes\nallPFCheckTypes = {'bus data':1,'load data':2,'plant data':3,'generator unit data':4,\n'induction machine data':5,'fixed bus shunt data':6,'switched shunt data':7,\n'non-transformer branch data':8,'two-winding transformer data':9,\n'three-winding transformer data':10,'transformer impedance table correciton data':11,\n'two-terminal dc line data':13,'multi-terminal dc line data':14,\n'VSC dc line data':15,'FACTS device data':16,'GNE device data':17,\n'area interchange data':18,'owner data':19,'zone data':20}\nallPFCheckResults = {}\nfor checkType in allPFCheckTypes:\nallPFCheckResults[checkType] = pd.DataFrame()\n########## XXX-ONLY reports ##########\nallTempLookingSwitches = pd.DataFrame()\nallMobileLoads = pd.DataFrame()\nnon_XXX_range_XXX_buses = pd.DataFrame()\nincorrect_voltage_bus_limits = pd.DataFrame()\nallUnterminatedXXXElements = pd.DataFrame()\nallBranchesTerminatedOnSameNode = pd.DataFrame()\nallTLDBusesToAdd = pd.DataFrame()\nallTLDBusesToRemove = pd.DataFrame()\nallTLDBusesToUpdate = pd.DataFrame()\n### Process all raw files according to which reports were requested\ncounter = 1\nfor case in case_list:\n### read in the raw file\nprint('processesing case {0} out of {1}'.format(counter,len(case_list)))"
  },
  {
    "id": "chunk_115",
    "text": "rawfilename = os.path.splitext(os.path.basename(case))[0]\nlogging.debug('processesing raw {0} -- case {1} out of {2}'.format(rawfilename,counter,len(case_list)))\ncounter = counter+1\npsspy.read(0,case) # open case\n### save the open case as a sav\nsavLocation = target_output_directory+r'\\{0}.sav'.format(rawfilename)\nPSSESaveCase(savLocation)\n### if no areas were chosen by the user, get a list of all areas in the open case\nif AREALIST == []:\nint_data_desired = ['NUMBER']\nint_ierr, iarray = psspy.aareaint(-1, 2, int_data_desired)\nallAreas = iarray[0]\nAREALIST = allAreas\n### if requested, do the solvability check. If the solvability check indicates that the case did not solve, then do not attempt CA check\nif (report_dict['check_solvability'] == 1)|(report_dict['check_CA_performance'] == 1):\n#allCaseSolveData = getSolutionData(rawfilename,allCaseSolveData)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nint_data_desired = ['NUMBER']\nint_ierr, iarray = psspy.aareaint(-1, 2, int_data_desired)\nallAreas = iarray[0]\nAllBusArea = getBusData(savLocation,target_output_directory,rawfilename,BusData,allAreas)[['NUMBER','AREA']] #get bus data for reports to join area to report results\nallCaseSolveData,allVoltageViolations,allThermalViolations = getSolutionData(rawfilename,allCaseSolveData,AREALIST,allVoltageViolations,allThermalViolations,TMP_DIR,AllBusArea)\nexcept:\nprint('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData().')\nlogging.debug('PROBLEM WITH CHECK SOLVABILITY. PROBLEM ENCOUNTERED WHILE RUNNING getSolutionData(): ', exc_info=True)\n### if requested, do the CA check. If the solvability check indicates that the case did not solve, then this will not be attempted.\nif report_dict['check_CA_performance'] == 1:\n# check last powerflow solution\nlatestSolution = allCaseSolveData.loc[(allCaseSolveData['Case']==rawfilename)&(allCaseSolveData['Step']==3)]\nlatestSolution = latestSolution.reset_index()\nif (latestSolution.at[0,'Solution Str'] != 'Met convergence tolerances                      '):\nnoData = pd.DataFrame({'Case':[rawfilename],'CANotAttemptedDuetoNon-SolvedRAW':['True']})\nallCAData = pd.concat([allCAData,noData],ignore_index=True)\nelse:\n#allCAData = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallCAData, allUnsolvedContingencies = getCAConvergenceData(savLocation,rawfilename,allCAData,AREALIST,TMP_DIR,allUnsolvedContingencies)\nexcept:\nprint('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData().')\nlogging.debug('PROBLEM WITH GETTING CA CONVERGENCE. PROBLEM ENCOUNTERED WHILE RUNNING getCAConvergenceData(): ', exc_info=True)\n### if requested, do the CNTB check\nif report_dict['CNTB_check'] == 1:\n#CNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nCNTB_messages = getCNTBCheckData(TMP_DIR,savLocation,target_output_directory,rawfilename,CNTB_messages,AREALIST)\nexcept:\nprint('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData().')\nlogging.debug('PROBLEM WITH GETTING CNTB REPORT. PROBLEM ENCOUNTERED WHILE RUNNING getCNTBCheckData(): ', exc_info=True)\n### if any bus-related reports requested, get the XXX bus data and extract the relevant data\n#if (report_dict['900k_buses'] == 1): # for ERCOT-only distribution\nif (report_dict['900k_buses'] == 1) | (report_dict['disconnected_buses'] == 1) | (report_dict['out_of_range_buses'] == 1) | (report_dict['incorrect_voltage_bus_limits'] == 1):\n#XXX_Buses = getBusData(savLocation,target_output_directory,rawfilename,XXX_Buses,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nBusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS DATA. PROBLEM ENCOUNTERED WHILE RUNNING getBusData(): ', exc_info=True)\nif (report_dict['900k_buses'] == 1) & (BusData.empty == False):\n#all900k_buses = get900kBuses(BusData) #to troubleshoot, uncomment this line and comment out the following try/except block\ntry:\nall900k_buses = get900kBuses(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING get900kBuses().', exc_info=True)\nif (report_dict['disconnected_buses'] == 1) & (BusData.empty == False):\n#alldisconnected_buses = getDisconnectedBuses(BusData) #to troubleshoot, uncomment this line and comment out the following try/except block\ntry:\nalldisconnected_buses = getDisconnectedBuses(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedBuses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedBuses().', exc_info=True)\n############################## XXX-only reports ##############################\nif (report_dict['out_of_range_buses'] == 1)& (BusData.empty == False):\n#non_XXX_range_XXX_buses = getnon_XXX_range_XXX_buses(XXX_Buses) #TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nint_data_desired = ['NUMBER']\nint_ierr, iarray = psspy.aareaint(-1, 2, int_data_desired)\nallAreas = iarray[0]\nALLAREALIST = allAreas\nAllBusData = getBusData(savLocation,target_output_directory,rawfilename,BusData,ALLAREALIST)\nnon_XXX_range_XXX_buses = getnon_XXX_range_XXX_buses(AllBusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getnon_XXX_range_XXX_buses().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getnon_XXX_range_XXX_buses(): ', exc_info=True)\nif (report_dict['incorrect_voltage_bus_limits'] == 1)& (BusData.empty == False):\n#incorrect_voltage_bus_limits = getincorrect_voltage_bus_limits(XXX_Buses) #TO TROUBLESHOOT, uncomment this line and comment out following try/except block\ntry:\nincorrect_voltage_bus_limits = getincorrect_voltage_bus_limits(BusData)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getincorrect_voltage_bus_limits().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getincorrect_voltage_bus_limits(): ', exc_info=True)\n##########################################################################################\n### if requested, get all the load data\nif (report_dict['all_lds'] == 1)|(report_dict['disconnected_loads'] == 1)|(report_dict['zero_loads'] == 1):\n#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseAllLoadData = getLdDataTotalsReportedInCaseColumn(savLocation,allLoads,rawfilename,AREALIST)\nif allLoads.empty == True:\nallLoads = thisCaseAllLoadData\nallLoads = allLoads.drop_duplicates()\nelse:\nallLoads = allLoads.merge(thisCaseAllLoadData,how='outer',on=['ID','NAME','LODTYPE','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoads = allLoads.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdDataTotalsReportedInCaseColumn(): ', exc_info=True)\n#thisCaseLoadData = getLdData(savLocation,allLoads,rawfilename,AREALIST) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nthisCaseLoadData = getLdData(savLocation,allLoadsWithTotalsColumn,rawfilename,AREALIST)\nif allLoadsWithTotalsColumn.empty == True:\nallLoadsWithTotalsColumn = thisCaseLoadData\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nelse:\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.merge(thisCaseLoadData,how='outer',on=['ID','NAME','LODTYPE','TOTALACT','NUMBER','STATION','AREA','ZONE','STATUS','OWNER'])\nallLoadsWithTotalsColumn = allLoadsWithTotalsColumn.drop_duplicates()\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING LOAD DATA. PROBLEM ENCOUNTERED WHILE RUNNING getLdData(): ', exc_info=True)\nif report_dict['disconnected_loads'] == 1:\n#allDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds) #FOR TROUBLESHOOTING, uncomment this line and comment out the following try/except block\ntry:\nallDisconnectedLds = getDisconnectedLoads(thisCaseLoadData,allDisconnectedLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads()')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedLoads(): ', exc_info=True)\nif report_dict['zero_loads'] == 1:\n#allZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds) #TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallZeroLds = getZeroLoads(thisCaseLoadData,allZeroLds)\nexcept:\nprint('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads().')\nlogging.debug('PROBLEM ENCOUNTERED WHILE RUNNING getZeroLoads(): ', exc_info=True)\n### if requested, get the disconnected shunts\nif report_dict['disconnected_shunts'] == 1:\n#alldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nalldisconnected_shunts = getDisconnectedShunts(savLocation,rawfilename,alldisconnected_shunts,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts().')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING SHUNT DATA. PROBLEM ENCOUNTERED WHILE RUNNING getDisconnectedShunts(): ', exc_info=True)\n### if requested, get the bus inconsistencies\nif report_dict['bus_type_inconsistencies'] == 1:\n#allBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallBusInconsistencies = getAllBusInconsistencies(rawfilename,allBusInconsistencies)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BUS INCONSISTENCIES. PROBLEM ENCOUNTERED WHILE RUNNING getAllBusInconsistencies(): ', exc_info=True)\n### if requested, get the islands from TREE\nif report_dict['TREE_islands'] == 1:\n#allIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nallIslands = getTREEIslands(TMP_DIR,rawfilename,allIslands)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING ISLAND DATA. PROBLEM ENCOUNTERED WHILE RUNNING getTREEIslands(): ', exc_info=True)\n### if requested, get the PSSE pf check reports\nif report_dict['PSSE_pf_checks'] == 1:\n#allPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block"
  },
  {
    "id": "chunk_116",
    "text": "try:\npsspy.case(savLocation) #re-open case in psse\nallPFCheckResults = getPSSEpfChecks(TMP_DIR,rawfilename,allPFCheckResults,allPFCheckTypes,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING PSSE PF CHECKS. PROBLEM ENCOUNTERED WHILE RUNNING getPSSEpfChecks(): ', exc_info=True)\n### if requested, get the branch remote end voltage inconsistencies\nif report_dict['br_remote_end_voltage_inconsistencies'] == 1:\n#allBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallBrTerminalVoltageInconsistencies = getBrEndVoltageInconsistencies(savLocation,rawfilename,allBrTerminalVoltageInconsistencies,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING BRANCH TERMINAL VOLTAGE INCONSISTENCIES. PROBLEM ENCOUNTERED WHEN RUNNING getBrEndVoltageInconsistencies(): ', exc_info=True)\n### if any node-breaker checks are required, get the raw model in JSON format and extract the node breaker data\n# this is the if statement for the ERCOT-distributed version\n# if ((report_dict['invalid_Binit_switched_shunts'] == 1)\\\n#     | (report_dict['incorrect_shunt_remote_buses'] == 1) | (report_dict['incorrect_gen_remote_buses'] == 1) \\\n#     | (report_dict['invalid_setpts_continuous_shunts'] == 1):\nif (report_dict['multiple_branches_terminating_on_node'] == 1) | (report_dict['unterminated_elements'] == 1) | (report_dict['invalid_Binit_switched_shunts'] == 1)\\\n| (report_dict['incorrect_shunt_remote_buses'] == 1) | (report_dict['incorrect_gen_remote_buses'] == 1) \\\n| (report_dict['temp_looking_switches'] == 1) | (report_dict['mobile_loads'] == 1) | (report_dict['TLD_bus_updates'] == 1) \\\n| (report_dict['invalid_setpts_continuous_shunts'] == 1):\n#RAW_JSON = getRawxJSON(TMP_DIR,rawfilename) # TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\npsspy.case(savLocation) #re-open case in psse\nRAW_JSON = getRawxJSON(TMP_DIR,rawfilename)\nexcept:\nprint('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON()')\nlogging.debug('PROBLEM ENCOUNTERED WHEN GETTING RAWX DATA FROM CASE. PROBLEM ENCOUNTERED WHILE RUNNING getRawxJSON(): ', exc_info=True)\n#IBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, ALL_ELEMENT_DATA_DICT = getNodeBreakerData(RAW_JSON)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nIBUS_NODE_DATA, JBUS_NODE_DATA, KBUS_NODE_DATA, ALL_TERMABLE_EQUIP_W_NODE_DATA, \\\nALL_ELEMENT_DATA_DICT, ALL_TERMABLE_EQUIP_W_NODE_DATA_INCL_SUBSWDS = getNodeBreakerData(RAW_JSON)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData()')\nlogging.debug('PROBLEM ENCOUNTERED WITH PROCESSESING NODE-BREAKER DATA. PROBLEM ENCOUNTERED WHILE RUNNING getNodeBreakerData(): ', exc_info=True)\nif report_dict['invalid_Binit_switched_shunts'] == 1:\n#allSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidBinit = getInvalidBinitShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidBinit,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID BINIT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidBinitShunts(): ', exc_info=True)\nif report_dict['invalid_setpts_continuous_shunts'] == 1:\n#allSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallSwShuntsWithInvalidSetpoints = getInvalidSetpointsContinuousShunts(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allSwShuntsWithInvalidSetpoints,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INVALID SHUNT SETPOINT VALUES. PROBLEM ENCOUNTERED WHILE RUNNING getInvalidSetpointsContinuousShunts(): ', exc_info=True)\n### if requested, get the incorrect switched shun remote bus report\nif report_dict['incorrect_shunt_remote_buses'] == 1:\n#allIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectShuntRemoteBuses = getIncorrectShuntRemoteBuses(ALL_ELEMENT_DATA_DICT['swshunt'],rawfilename,allIncorrectShuntRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT SHUNT REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectShuntRemoteBuses(): ', exc_info=True)\n### if requested, get the incorrect generator remote bus report\nif report_dict['incorrect_gen_remote_buses'] == 1:\n#allIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallIncorrectGenRemoteBuses = getIncorrectGenRemoteBuses(ALL_ELEMENT_DATA_DICT['generator'],rawfilename,allIncorrectGenRemoteBuses,savLocation,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING INCORRECT GENERATOR REMOTE BUSES. PROBLEM ENCOUNTERED WHILLE RUNNING getIncorrectGenRemoteBuses(): ', exc_info=True)\n############################## XXX-only reports ##############################\nif report_dict['multiple_branches_terminating_on_node'] == 1:\n#allBranchesTerminatedOnSameNode = getMultiBrOnNode(IBUS_NODE_DATA,JBUS_NODE_DATA,KBUS_NODE_DATA, rawfilename, allBranchesTerminatedOnSameNode)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallBranchesTerminatedOnSameNode = getMultiBrOnNode(IBUS_NODE_DATA,JBUS_NODE_DATA,KBUS_NODE_DATA, rawfilename, allBranchesTerminatedOnSameNode)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING MULTI BRANCH NODES. PROBLEM ENCOUNTERED WHILE RUNNING getMultiBrOnNode()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING MULTI BRANCH NODES. PROBLEM ENCOUNTERED WHILE RUNNING getMultiBrOnNode(): ', exc_info=True)\nif report_dict['unterminated_elements'] == 1:\n#allUnterminatedXXXElements = getUnterminatedElements(ALL_TERMABLE_EQUIP_W_NODE_DATA,rawfilename,allUnterminatedXXXElements)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallUnterminatedXXXElements = getUnterminatedElements(ALL_TERMABLE_EQUIP_W_NODE_DATA,rawfilename,allUnterminatedXXXElements)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING UNTERMINATED ELEMENTS. PROBLEM ENCOUNTERED WHILE RUNNING getUnterminatedElements()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING UNTERMINATED ELEMENTS. PROBLEM ENCOUNTERED WHILE RUNNING getUnterminatedElements(): ', exc_info=True)\nif report_dict['temp_looking_switches'] == 1:\ntry:\nallTempLookingSwitches = getallTempLookingSwitches(ALL_TERMABLE_EQUIP_W_NODE_DATA_INCL_SUBSWDS[['ibus','jbus','kbus','equipmentType',\\\n'eqid','name','isub','inode','jsub','jnode','ksub','knode']],rawfilename,ALL_ELEMENT_DATA_DICT['bus'],allTempLookingSwitches,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING TEMPORARY-LOOKING SWITCHES. PROBLEM ENCOUNTERED WHILLE RUNNING getallTempLookingSwitches()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING TEMPORARY-LOOKING SWITCHES. PROBLEM ENCOUNTERED WHILLE RUNNING getallTempLookingSwitches(): ', exc_info=True)\n### if requested, get the MOBILE LOADS report\nif report_dict['mobile_loads'] == 1:\ntry:\nallMobileLoads = getallMobileLoads(ALL_TERMABLE_EQUIP_W_NODE_DATA_INCL_SUBSWDS[['ibus','jbus','kbus','equipmentType','eqid','name','isub',\\\n'inode','jsub','jnode','ksub','knode']],rawfilename,ALL_ELEMENT_DATA_DICT['bus'],allMobileLoads,AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING MOBILE. PROBLEM ENCOUNTERED WHILLE RUNNING getallMobileLoads()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING MOBILE. PROBLEM ENCOUNTERED WHILLE RUNNING getallMobileLoads(): ', exc_info=True)\n### if requested, get the TLD bus update report\nif report_dict['TLD_bus_updates'] == 1:\n#allTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate = getTLDBusUpdates(savLocation,APIbusData,allTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate,rawfilename,ALL_ELEMENT_DATA_DICT['subterm'],AREALIST)# TO TROUBLESHOOT, uncomment this line and comment out the following try/except block\ntry:\nallTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate = getTLDBusUpdates(savLocation,APIbusData,allTLDBusesToAdd,allTLDBusesToRemove,allTLDBusesToUpdate,rawfilename,ALL_ELEMENT_DATA_DICT['subterm'],AREALIST)\nexcept:\nprint('PROBLEM ENCOUNTERED WITH GETTING THE TLD UPDATE LISTS. PROBLEM ENCOUNTERED WHILE RUNNING getTLDBusUpdates()')\nlogging.debug('PROBLEM ENCOUNTERED WITH GETTING THE TLD UPDATE LISTS. PROBLEM ENCOUNTERED WHILE RUNNING getTLDBusUpdates(): ', exc_info=True)\n########################################################################################################################\n### Save the reports\nlogging.debug('Processing cases is complete. Now creating reports')\nsummaryReport = pd.DataFrame(columns=['Report','Number of Results','Location'])\n# make excel for CNTB messages\nif report_dict['CNTB_check']==1:\nlogging.debug('Creating CNTB Report')\n#CNTB_messages.to_csv(target_output_directory+r'\\all_CNTB_messages.csv')\nCNTB_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_CNTB_messages.xlsx')\nCNTB_errors = CNTB_messages.loc[CNTB_messages['Type']=='ERROR']\nCNTB_warnings = CNTB_messages.loc[CNTB_messages['Type']=='Warning']\n#CNTB_other = CNTB_messages.loc[CNTB_messages_tmp['Type']=='Other']\nCNTB_errors.to_excel(CNTB_excelWriter,sheet_name='Errors')\nCNTB_warnings.to_excel(CNTB_excelWriter,sheet_name='Warnings')\n#CNTB_other.to_excel(CNTB_excelWriter,sheet_name='Other')\nCNTB_excelWriter.save()\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['CNTB_errors','CNTB_warnings'],\n'Number of Results':[CNTB_errors.index.size,CNTB_warnings.index.size],\n'Location':[target_output_directory+r'\\all_CNTB_messages.xlsx',target_output_directory+r'\\all_CNTB_messages.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# make excel for PSSE_pf_check_results\nif report_dict['PSSE_pf_checks'] == 1:\nlogging.debug('Creating PSSE_pf_checks report')\nPSSEpfCheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\all_PSSE_pf_checks.xlsx')\nfor checkType in allPFCheckResults.keys():\nsheet_name_max = checkType[0:30]\nallPFCheckResults[checkType].to_excel(PSSEpfCheck_excelWriter,sheet_name='{0}'.format(sheet_name_max))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['PSSE PF Check - {0}'.format(checkType)],\n'Number of Results':[allPFCheckResults[checkType].index.size],\n'Location':[target_output_directory+r'\\all_PSSE_pf_checks.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\nPSSEpfCheck_excelWriter.save()\n# make excel for check_solvability from allVoltageViolations, allThermalViolations, and allCaseSolveData\nif report_dict['check_solvability'] == 1:\nlogging.debug('Creating solvability check excel report')\nSolCheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\Solution_checks.xlsx')\nallCaseSolveData.to_excel(SolCheck_excelWriter,sheet_name='SolvabilityResults')\nallVoltageViolations.to_excel(SolCheck_excelWriter,sheet_name='VoltageViolations')\nallThermalViolations.to_excel(SolCheck_excelWriter,sheet_name='ThermalViolations')\nSolCheck_excelWriter.save()\n# make excel for check_CA_performance from allUnsolvedContingencies and allCAData\nif report_dict['check_CA_performance'] == 1:\nlogging.debug('Creating CA performance check excel report')\nCACheck_excelWriter = pd.ExcelWriter(target_output_directory+r'\\CA_performance_checks.xlsx')\nallCAData.to_excel(CACheck_excelWriter,sheet_name='CA_Results')\nallUnsolvedContingencies.to_excel(CACheck_excelWriter,sheet_name='Unsolved_Contingencies')\nCACheck_excelWriter.save()\n# make csv reports for all the other reports\nreport_to_data_dictionary = {'900k_buses':all900k_buses,\\\n'disconnected_shunts':alldisconnected_shunts,\\\n'disconnected_loads':allDisconnectedLds,\\\n'zero_loads':allZeroLds,\\\n'invalid_Binit_switched_shunts':allSwShuntsWithInvalidBinit,\\\n'TREE_islands':allIslands,\\\n'br_remote_end_voltage_inconsistencies':allBrTerminalVoltageInconsistencies,\\\n'bus_type_inconsistencies':allBusInconsistencies,\\\n'all_lds':allLoads,\\\n#'check_solvability':allCaseSolveData,\\\n'incorrect_shunt_remote_buses':allIncorrectShuntRemoteBuses,\\\n'incorrect_gen_remote_buses':allIncorrectGenRemoteBuses,\\\n#'check_CA_performance':allCAData,\\\n'invalid_setpts_continuous_shunts':allSwShuntsWithInvalidSetpoints,\\\n'disconnected_buses':alldisconnected_buses}\nfor report in report_to_data_dictionary.keys():\nif report_dict[report]==1:\nlogging.debug('Creating {0} report'.format(report))\nreport_to_data_dictionary[report].to_csv(target_output_directory+r'\\{0}.csv'.format(report))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':[report],\n'Number of Results':[report_to_data_dictionary[report].index.size],\n'Location':[target_output_directory+r'\\{0}.csv'.format(report)]})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# make excel for the TLD Bus updates\nlogging.debug('Creating TLD Bus Update report')\nif report_dict['TLD_bus_updates'] == 1:\nTLDBusUpdates_excelWriter = pd.ExcelWriter(target_output_directory+r'\\TLDBusUpdates.xlsx')\nallTLDBusesToAdd.to_excel(TLDBusUpdates_excelWriter,sheet_name='allTLDBusesToAdd')\nallTLDBusesToRemove.to_excel(TLDBusUpdates_excelWriter,sheet_name='allTLDBusesToRemove')\nallTLDBusesToUpdate.to_excel(TLDBusUpdates_excelWriter,sheet_name='allTLDBusesToUpdate')\nTLDBusUpdates_excelWriter.save()\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':['allTLDBusesToAdd','allTLDBusesToRemove','allTLDBusesToUpdate'],\n'Number of Results':[allTLDBusesToAdd.index.size,allTLDBusesToRemove.index.size,allTLDBusesToUpdate.index.size],"
  },
  {
    "id": "chunk_117",
    "text": "'Location':[target_output_directory+r'\\TLDBusUpdates.xlsx',target_output_directory+r'\\TLDBusUpdates.xlsx',target_output_directory+r'\\TLDBusUpdates.xlsx']})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# make csv reports for all the other reports\nXXX_report_to_data_dictionary = {'temp_looking_switches':allTempLookingSwitches,\\\n'mobile_loads':allMobileLoads,\\\n'out_of_range_buses':non_XXX_range_XXX_buses,\\\n'multiple_branches_terminating_on_node':allBranchesTerminatedOnSameNode,\\\n'unterminated_elements':allUnterminatedXXXElements,\\\n'incorrect_voltage_bus_limits':incorrect_voltage_bus_limits}\nfor report in XXX_report_to_data_dictionary.keys():\nif report_dict[report]==1:\nlogging.debug('Creating {0} report'.format(report))\nXXX_report_to_data_dictionary[report].to_csv(target_output_directory+r'\\{0}.csv'.format(report))\n# insert metadata to summaryReport\nsumData = pd.DataFrame({'Report':[report],\n'Number of Results':[XXX_report_to_data_dictionary[report].index.size],\n'Location':[target_output_directory+r'\\{0}.csv'.format(report)]})\nsummaryReport = pd.concat([summaryReport,sumData],ignore_index=True)\n# create summary report\nlogging.debug('Creating summary report.')\nsummaryReport['Location'] = summaryReport['Location'].apply(lambda x: make_clickable(x, x))\nsummaryReport = summaryReport.sort_values(by=['Number of Results'],ascending=False)\nsummary_html = summaryReport.to_html(render_links=True,escape=False)\ntext_file = open(target_output_directory+r'\\SummaryReport.html','w')\ntext_file.write(summary_html)\ntext_file.close()\nlogging.debug('Reports completed.')\nlogging.debug('Done.')\nlogging.shutdown()\n########### CLASS DEFINITIONS ##############\nclass SSWGCaseQA(wx.Frame):\ndef __init__(self):\nself.SelectedAreas = []\nself.SelectedBuses = []\nself.AllAreas = [] # replace with real data from case when the corresponding button is selected\nself.AllBuses = [] # replace with real data from case when the corresponding button is selected\nself.chosenAreas = []\nself.chosenBuses = []\nwx.Frame.__init__(self,None,wx.ID_ANY,\"Perform quality assurance checks on raw file(s).\",size =(1000,600))\nself.panel = wx.Panel(self, wx.ID_ANY)\n# make wrapper\nself.wrapper = wx.FlexGridSizer(4,1,20,20) # wx.FlexGridSizer(2,1,20,20)\nself.wrapper.AddGrowableCol(0)\n#select an SSWG cases directory\nself.label1 = wx.StaticText(self.panel)\nself.caseDirectory = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow1 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the SSWG raw case directory (all .raw files in the selected directory will be analyzed):'), orient=wx.HORIZONTAL)\nrow1.Add(self.label1,0,wx.TOP | wx.RIGHT,10)\nrow1.Add(self.caseDirectory)\nself.wrapper.Add(row1,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n#select model areas for report generation\nself.label3 = wx.StaticText(self.panel)\n#self.conFile = wx.FilePickerCtrl(self.panel, size=(800,25),wildcard=\"*.con\")\nself.reportAreas = wx.TextCtrl(self.panel, size=(800,25),value=\"\")\nrow3 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please provide a comma-separated list of areas for reporting (leave blank to get results for entire model):'), orient=wx.HORIZONTAL)\nrow3.Add(self.label3,0,wx.TOP | wx.RIGHT,10)\nrow3.Add(self.reportAreas)\nself.wrapper.Add(row3,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n# self.panel.SetSizerAndFit(wrapper)\n# self.Centre()\n#select an output directory\nself.label2 = wx.StaticText(self.panel)\nself.dirCtrl = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow2 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the output location for reports:'), orient=wx.HORIZONTAL)\nrow2.Add(self.label2,0,wx.TOP | wx.RIGHT,10)\nrow2.Add(self.dirCtrl)\nself.wrapper.Add(row2,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\nself.panel.SetSizerAndFit(self.wrapper)\nself.Centre()\n# report selection radio buttons\nself.RB_900k_buses = wx.CheckBox(self.panel,11,label='900k+ buses',pos =(100,275))\nself.RB_900k_buses.SetValue(True)\nself.RB_TREE_islands = wx.CheckBox(self.panel,22,label='TREE_islands',pos =(300,275))\nself.RB_TREE_islands.SetValue(True)\nself.RB_bus_type_inconsistencies = wx.CheckBox(self.panel,33,label='Bus type inconsistencies',pos =(500,275))\nself.RB_bus_type_inconsistencies.SetValue(True)\nself.RB_CNTB_check = wx.CheckBox(self.panel,33,label='CNTB check',pos =(700,275))\nself.RB_CNTB_check.SetValue(True)\nself.RB_disconnected_shunts = wx.CheckBox(self.panel,44,label='Disconnected shunts',pos =(100,300))\nself.RB_disconnected_shunts.SetValue(True)\nself.RB_invalid_Binit_switched_shunts = wx.CheckBox(self.panel,55,label='Invalid Binit sw. shunts',pos =(300,300))\nself.RB_invalid_Binit_switched_shunts.SetValue(True)\nself.RB_invalid_setpts_continuous_shunts = wx.CheckBox(self.panel,66,label='Invalid VHi-VLo cont. ctrl. shunts',pos =(500,300))\nself.RB_invalid_setpts_continuous_shunts.SetValue(True)\nself.RB_incorrect_shunt_remote_buses = wx.CheckBox(self.panel,77,label='Non-POI Shunt Remote Bus',pos =(700,300))\nself.RB_incorrect_shunt_remote_buses.SetValue(True)\nself.RB_incorrect_gen_remote_buses = wx.CheckBox(self.panel,88,label='Non-POI Gen Remote Bus',pos =(100,325))\nself.RB_incorrect_gen_remote_buses.SetValue(True)\nself.RB_br_remote_end_voltage_inconsistencies = wx.CheckBox(self.panel,99,label='Inconsistent line end voltages',pos =(300,325))\nself.RB_br_remote_end_voltage_inconsistencies.SetValue(True)\nself.RB_check_solvability = wx.CheckBox(self.panel,111,label='Check solvability',pos =(500,325))\nself.RB_check_solvability.SetValue(True)\nself.RB_check_CA_performance = wx.CheckBox(self.panel,222,label='Check CA performance (sng. br. elem)',pos =(700,325))\nself.RB_check_CA_performance.SetValue(True)\nself.RB_PSSE_pf_checks = wx.CheckBox(self.panel,333,label='PSSE pf checks',pos =(100,350))\nself.RB_PSSE_pf_checks.SetValue(True)\nself.RB_all_lds = wx.CheckBox(self.panel,444,label='All loads report',pos =(300,350))\nself.RB_all_lds.SetValue(True)\nself.RB_disconnected_loads = wx.CheckBox(self.panel,555,label='Disconnected loads',pos =(500,350))\nself.RB_disconnected_loads.SetValue(True)\nself.RB_zero_loads = wx.CheckBox(self.panel,666,label='0 MVA loads',pos =(700,350))\nself.RB_zero_loads.SetValue(True)\nself.RB_disconnected_buses = wx.CheckBox(self.panel,777,label='Disconnected buses',pos =(100,375))\nself.RB_disconnected_buses.SetValue(True)\n# button push\nself.generateQAReports = wx.Button(self.panel,-1, \"Generate Selected QA Reports\", pos=(400, 450))\nself.generateQAReports.Bind(wx.EVT_BUTTON, self.generateQAReportsBtnEvent, self.generateQAReports)\ndef generateQAReportsBtnEvent(self, event):\nif self.caseDirectory.GetPath() == '':\nself.nocaseDirectoryChosenMessage = wx.MessageBox('Choose a valid SSWG case directory to read the unprocessed raw files from.')\nreturn\nif self.dirCtrl.GetPath() == '':\nself.nooutputDirectoryChosenMessage = wx.MessageBox('Choose an output directory for the output reports.')\nreturn\nif self.reportAreas.GetLineText(0) == '':\nareaList = []\nelse:\ntry:\nareaList = self.reportAreas.GetLineText(0).split(\",\")\nareaList = [int(x) for x in areaList]\nexcept:\nareaList = None\nif areaList == None:\nself.areaErrorMessage = wx.MessageBox('Type a comma-separated list of areas for which to run the QA checks. (For example: \"1, 2, 3\"). Do not enter any newline characters. Leave this blank if you want to run the reports for the entire model, regardless of area.')\nrunAllReportsList = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads','disconnected_buses']\nreportSelections = [self.RB_900k_buses.GetValue(),\nself.RB_TREE_islands.GetValue(),\nself.RB_bus_type_inconsistencies.GetValue(),\nself.RB_CNTB_check.GetValue(),\nself.RB_disconnected_shunts.GetValue(),\nself.RB_invalid_Binit_switched_shunts.GetValue(),\nself.RB_invalid_setpts_continuous_shunts.GetValue(),\nself.RB_incorrect_shunt_remote_buses.GetValue(),\nself.RB_incorrect_gen_remote_buses.GetValue(),\nself.RB_br_remote_end_voltage_inconsistencies.GetValue(),\nself.RB_check_solvability.GetValue(),\nself.RB_check_CA_performance.GetValue(),\nself.RB_PSSE_pf_checks.GetValue(),\nself.RB_all_lds.GetValue(),\nself.RB_disconnected_loads.GetValue(),\nself.RB_zero_loads.GetValue(),\nself.RB_disconnected_buses.GetValue()]\nAllReportsDict = dict(zip(runAllReportsList,reportSelections))\nRequestedReportsDict = {key: value for key, value in AllReportsDict.items() if value == True}\n#trigger the report creation\nprint('All required files and directories selected. Now running the following QA reports:')\nprint(list(RequestedReportsDict.keys()))\ngetQAReports(CASEDIRECTORY=self.caseDirectory,OUTPUTDIRECTORY=self.dirCtrl,DESIRED_QA_LIST=list(RequestedReportsDict.keys()),AREALIST=areaList)\nprint('Done!')\nself.QAReportsComplete = wx.MessageBox('SSWG QA reports complete. Go to {} to see results.'.format(self.dirCtrl.GetPath()))\n##### XXX only Class Definitions #####\nclass XXXSSWGCaseQA(wx.Frame):\ndef __init__(self):\nself.SelectedAreas = []\nself.SelectedBuses = []\nself.AllAreas = [] # replace with real data from case when the corresponding button is selected\nself.AllBuses = [] # replace with real data from case when the corresponding button is selected\nself.chosenAreas = []\nself.chosenBuses = []\nwx.Frame.__init__(self,None,wx.ID_ANY,\"Perform quality assurance checks on raw file(s).\",size =(1000,600))\nself.panel = wx.Panel(self, wx.ID_ANY)\n# make wrapper\nself.wrapper = wx.FlexGridSizer(4,1,20,20) # wx.FlexGridSizer(2,1,20,20)\nself.wrapper.AddGrowableCol(0)\n#select an SSWG cases directory\nself.label1 = wx.StaticText(self.panel)\nself.caseDirectory = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow1 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the SSWG raw case directory (all .raw files in the selected directory will be analyzed):'), orient=wx.HORIZONTAL)\nrow1.Add(self.label1,0,wx.TOP | wx.RIGHT,10)\nrow1.Add(self.caseDirectory)\nself.wrapper.Add(row1,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n#select model areas for report generation\nself.label3 = wx.StaticText(self.panel)\n#self.conFile = wx.FilePickerCtrl(self.panel, size=(800,25),wildcard=\"*.con\")\nself.reportAreas = wx.TextCtrl(self.panel, size=(800,25),value=\"7, 907\")\nrow3 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please provide a comma-separated list of areas for reporting (leave blank to get results for entire model):'), orient=wx.HORIZONTAL)\nrow3.Add(self.label3,0,wx.TOP | wx.RIGHT,10)\nrow3.Add(self.reportAreas)\nself.wrapper.Add(row3,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\n# self.panel.SetSizerAndFit(wrapper)\n# self.Centre()\n#select an output directory\nself.label2 = wx.StaticText(self.panel)\nself.dirCtrl = wx.DirPickerCtrl(self.panel, size=(800,25))\nrow2 = wx.StaticBoxSizer(wx.StaticBox(self.panel, 1, 'Please select the output location for reports:'), orient=wx.HORIZONTAL)\nrow2.Add(self.label2,0,wx.TOP | wx.RIGHT,10)\nrow2.Add(self.dirCtrl)\nself.wrapper.Add(row2,50,wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER,20)\nself.panel.SetSizerAndFit(self.wrapper)\nself.Centre()\n# report selection radio buttons\nself.RB_900k_buses = wx.CheckBox(self.panel,11,label='900k+ buses',pos =(100,275))\nself.RB_900k_buses.SetValue(True)\nself.RB_TREE_islands = wx.CheckBox(self.panel,22,label='TREE_islands',pos =(300,275))\nself.RB_TREE_islands.SetValue(True)\nself.RB_bus_type_inconsistencies = wx.CheckBox(self.panel,33,label='Bus type inconsistencies',pos =(500,275))\nself.RB_bus_type_inconsistencies.SetValue(True)\nself.RB_CNTB_check = wx.CheckBox(self.panel,33,label='CNTB check',pos =(700,275))\nself.RB_CNTB_check.SetValue(True)\nself.RB_disconnected_shunts = wx.CheckBox(self.panel,44,label='Disconnected shunts',pos =(100,300))\nself.RB_disconnected_shunts.SetValue(True)\nself.RB_invalid_Binit_switched_shunts = wx.CheckBox(self.panel,55,label='Invalid Binit sw. shunts',pos =(300,300))\nself.RB_invalid_Binit_switched_shunts.SetValue(True)\nself.RB_invalid_setpts_continuous_shunts = wx.CheckBox(self.panel,66,label='Invalid VHi-VLo cont. ctrl. shunts',pos =(500,300))\nself.RB_invalid_setpts_continuous_shunts.SetValue(True)\nself.RB_incorrect_shunt_remote_buses = wx.CheckBox(self.panel,77,label='Non-POI Shunt Remote Bus',pos =(700,300))\nself.RB_incorrect_shunt_remote_buses.SetValue(True)\nself.RB_incorrect_gen_remote_buses = wx.CheckBox(self.panel,88,label='Non-POI Gen Remote Bus',pos =(100,325))\nself.RB_incorrect_gen_remote_buses.SetValue(True)\nself.RB_br_remote_end_voltage_inconsistencies = wx.CheckBox(self.panel,99,label='Inconsistent line end voltages',pos =(300,325))\nself.RB_br_remote_end_voltage_inconsistencies.SetValue(True)\nself.RB_check_solvability = wx.CheckBox(self.panel,111,label='Check solvability',pos =(500,325))\nself.RB_check_solvability.SetValue(True)\nself.RB_check_CA_performance = wx.CheckBox(self.panel,222,label='Check CA performance (sng. br. elem)',pos =(700,325))\nself.RB_check_CA_performance.SetValue(True)\nself.RB_PSSE_pf_checks = wx.CheckBox(self.panel,333,label='PSSE pf checks',pos =(100,350))\nself.RB_PSSE_pf_checks.SetValue(True)\nself.RB_all_lds = wx.CheckBox(self.panel,444,label='All loads report',pos =(300,350))\nself.RB_all_lds.SetValue(True)\nself.RB_disconnected_loads = wx.CheckBox(self.panel,555,label='Disconnected loads',pos =(500,350))\nself.RB_disconnected_loads.SetValue(True)\nself.RB_zero_loads = wx.CheckBox(self.panel,666,label='0 MVA loads',pos =(700,350))\nself.RB_zero_loads.SetValue(True)\n### XXX-Only\nself.RB_temp_looking_switches = wx.CheckBox(self.panel,777,label='Temp-looking switches',pos =(100,400))\nself.RB_temp_looking_switches.SetValue(True)\nself.RB_mobile_loads = wx.CheckBox(self.panel,888,label='Mobile loads',pos =(300,400))\nself.RB_mobile_loads.SetValue(True)\nself.RB_out_of_range_buses = wx.CheckBox(self.panel,999,label='Out-of-range buses',pos =(500,400))\nself.RB_out_of_range_buses.SetValue(True)\nself.RB_multiple_branches_terminating_on_node = wx.CheckBox(self.panel,1111,label='Nodes with multiple br term.',pos =(700,400))\nself.RB_multiple_branches_terminating_on_node.SetValue(True)\nself.RB_unterminated_elements = wx.CheckBox(self.panel,2222,label='Unterminated elements',pos =(100,425))\nself.RB_unterminated_elements.SetValue(True)\nself.RB_incorrect_voltage_bus_limits = wx.CheckBox(self.panel,3333,label='Incorrect voltage bus limits',pos =(300,425))\nself.RB_incorrect_voltage_bus_limits.SetValue(True)\nself.RB_TLD_bus_updates = wx.CheckBox(self.panel,3333,label='TLD Bus Updates',pos =(500,425))\nself.RB_TLD_bus_updates.SetValue(True)\nself.RB_disconnected_buses = wx.CheckBox(self.panel,777,label='Disconnected buses',pos =(100,375))\nself.RB_disconnected_buses.SetValue(True)\n# button push\nself.generateQAReports = wx.Button(self.panel,-1, \"Generate Selected QA Reports\", pos=(400, 450))"
  },
  {
    "id": "chunk_118",
    "text": "self.generateQAReports.Bind(wx.EVT_BUTTON, self.generateQAReportsBtnEvent, self.generateQAReports)\ndef generateQAReportsBtnEvent(self, event):\nif self.caseDirectory.GetPath() == '':\nself.nocaseDirectoryChosenMessage = wx.MessageBox('Choose a valid SSWG case directory to read the unprocessed raw files from.')\nreturn\nif self.dirCtrl.GetPath() == '':\nself.nooutputDirectoryChosenMessage = wx.MessageBox('Choose an output directory for the output reports.')\nreturn\nif self.reportAreas.GetLineText(0) == '':\nareaList = []\nelse:\ntry:\nareaList = self.reportAreas.GetLineText(0).split(\",\")\nareaList = [int(x) for x in areaList]\nexcept:\nareaList = None\nif areaList == None:\nself.areaErrorMessage = wx.MessageBox('Type a comma-separated list of areas for which to run the QA checks. (For example: \"1, 2, 3\"). Do not enter any newline characters. Leave this blank if you want to run the reports for the entire model, regardless of area.')\nrunAllReportsList = ['900k_buses','TREE_islands','bus_type_inconsistencies','CNTB_check',\n'disconnected_shunts', 'invalid_Binit_switched_shunts','invalid_setpts_continuous_shunts',\n'incorrect_shunt_remote_buses','incorrect_gen_remote_buses','br_remote_end_voltage_inconsistencies',\n'check_solvability','check_CA_performance','PSSE_pf_checks','all_lds','disconnected_loads',\n'zero_loads','disconnected_buses',\n# XXX-only Reports\n'temp_looking_switches','mobile_loads','out_of_range_buses',\n'multiple_branches_terminating_on_node','unterminated_elements','incorrect_voltage_bus_limits','TLD_bus_updates']\nreportSelections = [self.RB_900k_buses.GetValue(),\nself.RB_TREE_islands.GetValue(),\nself.RB_bus_type_inconsistencies.GetValue(),\nself.RB_CNTB_check.GetValue(),\nself.RB_disconnected_shunts.GetValue(),\nself.RB_invalid_Binit_switched_shunts.GetValue(),\nself.RB_invalid_setpts_continuous_shunts.GetValue(),\nself.RB_incorrect_shunt_remote_buses.GetValue(),\nself.RB_incorrect_gen_remote_buses.GetValue(),\nself.RB_br_remote_end_voltage_inconsistencies.GetValue(),\nself.RB_check_solvability.GetValue(),\nself.RB_check_CA_performance.GetValue(),\nself.RB_PSSE_pf_checks.GetValue(),\nself.RB_all_lds.GetValue(),\nself.RB_disconnected_loads.GetValue(),\nself.RB_zero_loads.GetValue(),\nself.RB_disconnected_buses.GetValue(),\nself.RB_temp_looking_switches.GetValue(),\nself.RB_mobile_loads.GetValue(),\nself.RB_out_of_range_buses.GetValue(),\nself.RB_multiple_branches_terminating_on_node.GetValue(),\nself.RB_unterminated_elements.GetValue(),\nself.RB_incorrect_voltage_bus_limits.GetValue(),\nself.RB_TLD_bus_updates.GetValue()]\nAllReportsDict = dict(zip(runAllReportsList,reportSelections))\nRequestedReportsDict = {key: value for key, value in AllReportsDict.items() if value == True}\n#trigger the report creation\nprint('All required files and directories selected. Now running the following QA reports:')\nprint(list(RequestedReportsDict.keys()))\ngetQAReportsXXX(CASEDIRECTORY=self.caseDirectory,OUTPUTDIRECTORY=self.dirCtrl,DESIRED_QA_LIST=list(RequestedReportsDict.keys()),AREALIST=areaList)\nprint('Done!')\nself.QAReportsComplete = wx.MessageBox('SSWG QA reports complete. Go to {} to see results.'.format(self.dirCtrl.GetPath()))\n############ MAIN ###############\nif __name__ == \"__main__\":\napp = wx.App(False)\nframe = XXXSSWGCaseQA()\n#frame = SSWGCaseQA() # for general SSWG distribution\nframe.Show()\napp.MainLoop()"
  }
]