#[accc_reports.py]  GET ACCC SOLUTION IN ARRAYS and CREATE CUSTOM REPORTS
# ====================================================================================================
'''
This is an example file showing how to use ACCC Solution Array fetch APIs
from Python to generate custom accc solution reports.

Following ACCC solutions can be retrieved:
    - post-contingency solution,
    - post-tripping solution, or
    - post-corrective action solution

These ACCC solutions can be obtained in Python lists for:
    - single contingency,
    - multiple contingencies, or
    - all contingencies

The APIs used in this program are part of python "arrbox.accc_pp" module.
    accobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)
    Following methods are defined for accobj.
    - accobj.summary and accobj.solution methods return ACCC solution
      in python object, which can be used to create custom reports, or
    - accobj.summary_report, accobj.solution_report or accobj.violations_report
      methods can be used to get pre-defined reports.

Get more info on as:
    help(arrbox.accc_pp.CONTINGENCY_PP)

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    run_accc_reports()
    You may want to change input arguments when you call this function.
    run_accc_reports(accfile, rptfile)
    
---------------------------------------------------------------------------------
Alternatively, use either of the following menu items to export ACCC file output to Excel.
- from Windows Start>Programs>PSSExx>Export Results to Excel OR
- from PSSE GUI, Power Flow>Reports>Export Results to Excel
'''
# ----------------------------------------------------------------------------------------------------

import sys, os, random, time

# ----------------------------------------------------------------------------------------------------

def create_accc_reports(accfile, rptfile):

    import psspy, arrbox.accc_pp

    if not os.path.exists(accfile):
        prgmsg = " Error: Input accfile '{0}' does not exist".format(accfile)
        print(prgmsg)
        return

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)

        rptfpath, rptext = os.path.splitext(rptfile)

    # ----------------------------------------------------------------------------------------------------
    # common variables values (assumed)
    busmsm    = 0.5
    sysmsm    = 5.0
    rating    = 'a'
    flowlimit = 80.0
    stype_cnt = 'contingency'
    stype_trp = 'tripping'
    stype_cact= 'caction'

    # ----------------------------------------------------------------------------------------------------
    # (1) Create object
    accobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)
    if accobj.ierr:
        prgmsg = " Error {0:d} creating 'accobj'.".format(accobj.ierr)
        print(prgmsg)
        return

    # ----------------------------------------------------------------------------------------------------
    # (2) ACCC summary report
    sumfile = None
    if rptfile:  sumfile = rptfpath + '_summary' + rptext
    accobj.summary_report(rptfile=sumfile)

    # ----------------------------------------------------------------------------------------------------
    # (3) ACCC post contingency solution report
    accobj.solution_options(stype=stype_cnt,busmsm=busmsm,sysmsm=sysmsm,rating=rating,flowlimit=flowlimit)
    cntsolnfile = None
    if rptfile:  cntsolnfile = rptfpath + '_solution_cnt' + rptext
    accobj.solution_report(colabels=None,rptfile=cntsolnfile)

    # ----------------------------------------------------------------------------------------------------
    # (4) ACCC post tripping solution report
    trpsolnfile = None
    if rptfile:  trpsolnfile = rptfpath + '_solution_trp' + rptext
    accobj.solution_options(stype=stype_trp)    # changed only solution type, other options remain same
    accobj.solution_report(colabels=None,rptfile=trpsolnfile)

    # ----------------------------------------------------------------------------------------------------
    # (5) ACCC post corrective action solution report
    cactsolnfile = None
    if rptfile:  cactsolnfile = rptfpath + '_solution_cact' + rptext
    accobj.solution_options(stype=stype_cact)    # changed only solution type, other options remain same
    accobj.solution_report(colabels=None,rptfile=cactsolnfile)

    # ----------------------------------------------------------------------------------------------------
    # (6) ACCC post contingency violations report
    cntviofile = None
    if rptfile:  cntviofile = rptfpath + '_violations_cnt' + rptext
    accobj.solution_options(stype=stype_cnt)
    accobj.violations_report(rptfile=cntviofile)

    # ----------------------------------------------------------------------------------------------------
    # (7) ACCC post tripping violations report
    trpviofile = None
    if rptfile:  trpviofile = rptfpath + '_violations_trp' + rptext
    accobj.solution_options(stype=stype_trp)
    accobj.violations_report(rptfile=trpviofile)

    # ----------------------------------------------------------------------------------------------------
    # (8) ACCC post corrective action violations report
    cactviofile = None
    if rptfile:  cactviofile = rptfpath + '_violations_cact' + rptext
    accobj.solution_options(stype=stype_cact)
    accobj.violations_report(rptfile=cactviofile)

    # ----------------------------------------------------------------------------------------------------
    # (9) Getting summary arrays and printing contingency lables in PSS(R)E progress window
    smryobj = accobj.summary()
        # note: returned "smryobj" is used in the following (10) to (16) examples of this program.
    psspy.progress('\n Contingency Labels:\n')
    for each in smryobj.colabel:
        psspy.progress('    '+each+'\n')

    # ----------------------------------------------------------------------------------------------------
    # (10) Getting solution arrays for one contingency and printing monitored element MVA and AMP flows
    #      in PSS(R)E progress window
    idx   = random.sample(list(range(len(smryobj.colabel))),1)   # select one contingency randomly
    colbl = smryobj.colabel[idx[0]]
    accobj.solution_options(stype=stype_cnt)
    solnobj  = accobj.solution(colabel=colbl)
    if solnobj!=None:        # contingency solution found/error, proceed
        rating = rating.strip().lower()
        try:
            rate = smryobj.rating.rating
        except:
            rate = smryobj.rating.a

        psspy.progress("\n Monitored Element Flows for contingency '%12s':\n" % colbl)
        psspy.progress("<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \
    <AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]
            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '

            txtstr = "%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars()
            psspy.progress(txtstr)

    # ----------------------------------------------------------------------------------------------------
    # (11) Getting solution arrays for three contingency and printing monitored element MVA and AMP flows
    #      in PSS(R)E progress window for converged contingencies

    # select upto maximum of 3 contingencies randomly
    idx    = random.sample(list(range(len(smryobj.colabel))),min(len(smryobj.colabel),3))
    colbls = [smryobj.colabel[x] for x in idx]

    rating = rating.strip().lower()
    try:
        rate = smryobj.rating.rating
    except:
        rate = smryobj.rating.a

    for lbl in colbls:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue          # contingency solution not found, move to next
        if not solnobj.cnvflag: continue    # contingency solution not converged, move to next
        psspy.progress("\n Monitored Element Flows for contingency '%12s':\n" % lbl)
        psspy.progress("<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \
<AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]

            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '

            txtstr = "%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars()
            psspy.progress(txtstr)
        psspy.progress('\n')

    # ----------------------------------------------------------------------------------------------------
    # (12) Creating Overload report (similar to PSS(R)E ACCC Spreadsheet Overload Report) in
    #      PSS(R)E progress window

    rating = rating.strip().lower()
    try:
        rate = smryobj.rating.rating
    except:
        rate = smryobj.rating.a

    psspy.progress("\n OVERLOAD Report\n")
    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue         # contingency solution not found, move to next
        if not solnobj.cnvflag: continue   # contingency solution not converged, move to next
        psspy.progress(" Monitored Element Flows above %g%% for contingency '%12s':\n" % (flowlimit,lbl))
        psspy.progress("<-----------------MONITORED ELEMENT------------------> <RATING> <MVAFLOW> \
<AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]

            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow_v = pctflow*100.0/rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '
                pctflow_v = 0

            if pctflow_v >= flowlimit:
                psspy.progress("%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars())
        psspy.progress('\n')

    # ----------------------------------------------------------------------------------------------------
    # (13) Creating Voltage Violations report in Text file, if provided

    if rptfile:  sumfile = rptfpath + '_summary' + rptext
    if rptfile:
        vviofpath, vviofext = os.path.splitext(rptfile)
        if not vviofext: vviofext = '.txt'
        vviofile   = vviofpath + '_vvio' + vviofext
        vviofile_h = open(vviofile,'w')
        report     = vviofile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    report("\n Post Contingency VOLTAGE VIOLATIONS Report\n")

    # get base case solution
    solnobj_basecase = accobj.solution(colabel="BASE CASE")

    if solnobj_basecase==None or not solnobj_basecase.cnvflag:
        report("    BASE CASE not converged\n")
    else:
        # remaining contingencies
        for lbl in smryobj.colabel[1:]:   # skipped "BASE CASE"
            solnobj  = accobj.solution(colabel=lbl)
            if solnobj==None: continue          # contingency solution not found, move to next
            if not solnobj.cnvflag: continue    # contingency solution not converged, move to next
            vvio_exists = False
            for r in range(len(solnobj.volts)):
                if solnobj.volts[r] == 0.0: continue # disconnected bus, move to next
                if smryobj.mvrectype[r]=='RANGE':
                    if smryobj.mvrecmin[r] and solnobj.volts[r] < smryobj.mvrecmin[r]:
                        vvio = solnobj.volts[r] - smryobj.mvrecmin[r]
                    elif smryobj.mvrecmax[r] and solnobj.volts[r] > smryobj.mvrecmax[r]:
                        vvio = solnobj.volts[r] - smryobj.mvrecmax[r]
                    else:
                        vvio = 0
                else: # DEVIATION
                    delta = solnobj.volts[r] - solnobj_basecase.volts[r]
                    if delta < 0:
                        if smryobj.mvrecmin[r] and abs(delta) > smryobj.mvrecmin[r]:
                            vvio =  delta + smryobj.mvrecmin[r]
                        else:
                            vvio = 0
                    else:
                        if smryobj.mvrecmax[r] and delta > smryobj.mvrecmax[r]:
                            vvio = delta - smryobj.mvrecmax[r]
                        else:
                            vvio = 0
                if vvio:
                    if not vvio_exists:
                        report(" Voltage Violations for contingency '%12s':\n" % (lbl))
                        report("<-----MONITORED BUS-----> <--MONITOR LABEL---> <--TYPE-> <-VMIN-> <-VMAX-> <-VINIT-> \
<-VOLT--> <-VVIO-->\n")
                        vvio_exists = True
                    mvbuslabel     = smryobj.mvbuslabel[r]
                    mvreclabel     = smryobj.mvreclabel[r]
                    mvrectype      = smryobj.mvrectype[r]
                    if smryobj.mvrecmin[r]:
                        mvrecmin   = "%8.5f" % smryobj.mvrecmin[r]
                    else:
                        mvrecmin   = '   --   '
                    if smryobj.mvrecmax[r]:
                        mvrecmax   = "%8.5f" % smryobj.mvrecmax[r]
                    else:
                        mvrecmax   = '   --   '
                    mvrecvolts_init= solnobj_basecase.volts[r]
                    mvrecvolts     = solnobj.volts[r]
                    report("%(mvbuslabel)25s %(mvreclabel)20s %(mvrectype)9s %(mvrecmin)s \
%(mvrecmax)s %(mvrecvolts_init)9.5f %(mvrecvolts)9.5f %(vvio)9.5f \n" %  vars())

            if vvio_exists: report('\n')

    if rptfile:
        vviofile_h.close()
        print('\n Voltage Violations Report saved to file %s' % vviofile)
    else:
        print('\n Voltage Violations Report created in Report window.')

    # ----------------------------------------------------------------------------------------------------
    # (14) Creating Post-Contingency Solution Load Shedding report in progress

    report = psspy.progress
    load_curtailment_exists = False
    report('\n Post-Contingency LOAD CURTAILMENTS Report\n')
    stype = stype_cnt
    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.lshedbus): continue  # no load shedding, move to next
        report("\n Load Curtailments for contingency '%12s':\n" % (lbl))
        if not load_curtailment_exists:
            if stype=='contingency' or stype=='tripping':
                report("<----------BUS----------> <LDSHED(MW)> <CONTINGENCY>\n")
            else:
                report("<----------BUS----------> <INITLD(MW)>  <LDSHED(MW)> <CONTINGENCY>\n")
            load_curtailment_exists = True

        for c in range(len(solnobj.lshedbus)):
            if stype=='contingency' or stype=='tripping':
                report("%25s %12.2f %-12s\n" % (solnobj.lshedbus[c],solnobj.loadshed[c],lbl))
            else:
                report("%25s %12.2f %12.2f %-12s\n" % (solnobj.lshedbus[c],solnobj.loadshed[0][c],
                                                       solnobj.loadshed[1][c],lbl))
    if not load_curtailment_exists:
        report('    None\n')

    # ----------------------------------------------------------------------------------------------------
    # (15) Creating Corrective Action Solution Generation Dispatch report in progress

    accobj.solution_options(stype=stype_cact)

    report = psspy.progress
    gen_disp_exists = False
    report('\n Corrective Action GENERATION DISPATCH  Report\n')

    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.gdispbus): continue  # no generation dispatch, move to next
        if not gen_disp_exists:
            report("<----------BUS----------> <INITGEN(MW)>  <GENDISP(MW)> <CONTINGENCY>\n")
            gen_disp_exists = True
        for c in range(len(solnobj.gdispbus)):
            report("%25s %9.2f %s %9.2f %s %-12s\n" % (solnobj.gdispbus[c],solnobj.gendisp[0][c],4*' ',
                                                      solnobj.gendisp[1][c],3*' ',lbl))

    if not gen_disp_exists:
        report('    None\n')

    # ----------------------------------------------------------------------------------------------------
    # (16) Creating Corrective Action Solution Phase Shifter Angle report in progress

    accobj.solution_options(stype=stype_cact)

    report = psspy.progress
    phsftr_exists = False
    report('\n Corrective Action PHASE SHIFTER ANGLE Report\n')

    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.phsftr): continue    # no generation dispatch, move to next
        if not phsftr_exists:
            report("<-------FROM BUS------------------TO BUS-----------ID> <INITANG(deg)> <NEWANG(deg)> \
<CONTINGENCY>\n")
            phsftr_exists = True
        for c in range(len(solnobj.phsftr)):
            report("%54s %9.2f %s %9.2f %s %-12s\n" % (solnobj.phsftr[c],solnobj.phsftrang[0][c],5*' ',
                                                       solnobj.phsftrang[1][c],3*' ',lbl))
    if not phsftr_exists:
        report('    None\n')

# =====================================================================================================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

# =====================================================================================================

def run_accc_reports(accfile='savnw.acc', rptfile='accc_reports_savnw.txt'):

    rptfile  = check_psse_example_folder(rptfile)
    
    create_accc_reports(accfile, rptfile)

# ====================================================================================================
# ====================================================================================================

if __name__ == '__main__':
    import psse35
    run_accc_reports()

# ====================================================================================================
#[ascc_demo.py]   Fault Calculations using ASCC
# =====================================================================================================
'''There are three different ways to calculate faults using ASCC.
1) Using activity ASCC (psspy.ascc_3)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.ascc.ascc_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run ASCC fault calculations using either of these methods.

---------------------------------------------------------------------------------
How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psse35

B) This file contain following functions that uses savnw.sav file run ASCC calculations.
    run_ascc_3_savnw(..)
    run_ascc_currents_savnw_txtrpt(..)
    run_ascc_currents_savnw_xls(..)
    run_fault_summary_ascc_savnw(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
# ========================================================================================
#
"""
Use any of these keywords to run psspy.ascc or arrbox.ascc.ascc_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default      Description
                       # STATUS array
fltlg     = 0          # 1  0=>omit, 1=>include
linout    = 0          # 2  0=>omit, 1=>include
linend    = 0          # 3  0=>omit, 1=>include
voltop    = 0          # 4  0=>from PF, 1=>at specified for all buses, 2=>at specified faulted bus
genxop    = 0          # 5  0=>X'' 1=>X', 2=>Xs
rptop     = -1         # 6  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl    = 0          # 7  number of contribution levels
tpunty    = 0          # 8  0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged, 3=>N unchanged and phi=0
dcload    = 1          # 9  0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec    = 1          # 10 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
flt3ph    = 0          # 11 0=>omit, 1=>include
fltllg    = 0          # 12 0=>omit, 1=>include
fltll     = 0          # 13 0=>omit, 1=>include
lnchrg    = 0          # 14 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop    = 0          # 15 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
loadop    = 0          # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
machpq    = 0          # 17 0=>from PF, 1=>0.0 (generator/motor PQ output)
                       # VALUES array
volts     = 1.0        # 1  specified bus voltage, used when voltop=1 or 2
                       # File args
relfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""
# ========================================================================================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

# ========================================================================================

def set_prg_rpt(prgfile='', rptfile=''):
    import psspy
    psspy.lines_per_page_one_device(1,10000000)
    if prgfile: psspy.progress_output(2,prgfile,[0,0])
    if rptfile: psspy.report_output(2,rptfile,[0,0])

# ========================================================================================

def reset_prg_rpt():
    import psspy
    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,'',[0,0])
    psspy.report_output(1,'',[0,0])

# ========================================================================================

class ASCC_DEMO:
    """ Run PSSE ASCC Calculations"""

    def __init__(self):
        import psspy
        self.ierr = psspy.psseinit(buses=150000)

    # ------------------------------------------------------------------------------------
    def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    # ------------------------------------------------------------------------------------
    def _frmted_z_xbyr(self, cnum):

        zstr = self._frmted_z(cnum)

        r=cnum.real
        x=abs(cnum.imag)
        if r==0:
            xbyr=''
        else:
            xbyr="%9.6f" % (x/r)

        cstr="%(zstr)s, %(xbyr)s" % vars()

        return cstr

    # ------------------------------------------------------------------------------------

    def _crnt_mag(self, fmt, cval):
        if fmt=='rectangular':
            return abs(cval)
        else:
            return cval.real

    # ------------------------------------------------------------------------------------

    def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    # ------------------------------------------------------------------------------------
    def run_ascc_api(self, sid, allbus, **kwds):
        import psspy
        ierr = psspy.ascc_3(sid, allbus, **kwds)

    # ------------------------------------------------------------------------------------
    def run_ascc_currents(self, sid, allbus, **kwds):
        import psspy, arrbox.ascc

        rlst = arrbox.ascc.ascc_currents(sid, allbus, **kwds)

        if rlst.ierr!=0:
            raise Exception("arrbox.ascc.ascc_currents error= {}\n".format(rlst.ierr))

        return rlst

    # ------------------------------------------------------------------------------------
    def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('ASCC', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    # ------------------------------------------------------------------------------------
    def report_ascc_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E ASCC SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        # ------------------------------------------------------------------------------------------------
        if rptfile:
            rptfile_h.close()
            print('\n Done .... ASCC FAULT Report saved to file %s' % rptfile)

    # ------------------------------------------------------------------------------------
    def excel_ascc_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using ASCC"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

# ========================================================================================
def run_ascc_3_savnw(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]
    rptfile = ''

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_3_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    asccobj.run_ascc_api(sid, allbus, **kwds)

    reset_prg_rpt()

# ========================================================================================
def run_ascc_currents_savnw_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_currents_{}.txt".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)
    asccobj.report_ascc_currents(rlst, rptfile)

# ========================================================================================
def run_ascc_currents_savnw_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_savnw_ascc_currents_{}".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)
    asccobj.excel_ascc_currents(rlst, xlsfile)

# ========================================================================================
def run_fault_summary_ascc_savnw(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_fault_summary_{}.txt".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    fltobj = asccobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

# ========================================================================================
def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_ascc_3_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_ascc_currents_savnw_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1)
    run_ascc_currents_savnw_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1)
    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

# ========================================================================================
if __name__=='__main__':
    pass
    import psse35
#[ascc_report.py]    Get ASCC fault currents in arrays and create custom report
# =====================================================================================================
'''
This is an example file showing how to use "ascc_currents" function from pssarrays module.

ASCC_CURRENTS function returns ASCC short circuit currents for each faulted bus and
each type of fault applied. They are:
    ia1   = Positive Sequence Current
    ia2   = Negative Sequence Current
    ia0   = Zero Sequence Current
    ia    = Phase A current
    ib    = Phase B current
    ic    = Phase C current

The APIs used in this program are part of python "pssarrays" module.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call function
    run_ascc_report()

    You may want to change inputs specified in this function.
    run_ascc_report(savfile, fltbuses, rptfile)
    Defaults:
        savfile  = 'savnw.sav'
        fltbuses = [151,154]
        rptfile  = 'ascc_report_savnw.txt'
                   When this script is called from PSSE's Example Folder,
                   report is created in subfolder 'Output_Pyscript'
'''

# =====================================================================================================

import os, time, math

# =====================================================================================================

def encode_complex_number_xbyr(cnum):
    r=cnum.real
    x=cnum.imag
    csign='+j'
    if x<0:
        csign='-j'
        x=abs(x)

    if r==0:
        rstr=''
        xbyr=''
    else:
        rstr="%9.6f" % r
        xbyr="%9.6f" % (x/r)

    if x==0:
        xstr=''
        csign=''
    else:
        xstr="%9.6f" % x

    cstr="%(rstr)s%(csign)s%(xstr)s, %(xbyr)s" % vars()

    return cstr

# =====================================================================================================

def get_cplx_mag(fmt, cmplxvalue):
    if fmt == 'rectangular':
        return abs(cmplxvalue)
    else:
        return cmplxvalue.real

# =====================================================================================================

def create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,
                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,
                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):

    import psspy, arrbox.ascc

    # open case
    if savfile: psspy.case(savfile)

    # Save pre-fault voltages
    sid  = -1
    flag = 2
    ierr, (buslst,)           = psspy.abusint(sid,  flag, ['NUMBER'])
    ierr, (busvltlst_preflt,) = psspy.abuscplx(sid, flag, ['VOLTAGE'])
    ierr, (busvltlst_base,)   = psspy.abusreal(sid, flag, ['BASE'])
    busdata_dict = {}
    for n, vpf, vnm in zip(buslst, busvltlst_preflt, busvltlst_base):
        busdata_dict[n] = {'prefltv': vpf, 'basekv': vnm}

    # set sc units and format
    psspy.short_circuit_units(1)         # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(0)   # 0=rectangular, 1=polar

    sid = 3
    if fltbuses:
        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])
        busall = 0
    else:
        busall = 1

    # call pssarrays routine
    rlst = arrbox.ascc.ascc_currents(sid, busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,
           fltll=fltll, linout=linout, linend=linend, voltop=voltop, genxop=genxop, tpunty=tpunty,
           dcload=dcload, zcorec= zcorec, lnchrg=lnchrg, shntop=shntop, loadop=loadop, machpq=machpq,
           volts=volts, relfile=relfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)

    if rlst.ierr!=0:
        raise Exception("arrbox.ascc.ascc_currents error= %d\n" % rlst.ierr)

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)
        rptfile_h = open(rptfile,'w')
        report    = rptfile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    nfbus=len(rlst.fltbus)

    ttlstr="PSS(R)E ASCC SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
    ln1str,ln2str=psspy.titldt()
    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
    report(ttlstr.center(maxlen))
    report("\n")
    report(ln1str.center(maxlen))
    report("\n")
    report(ln2str.center(maxlen))
    report("\n\n")

    sbase  = psspy.sysmva()

    scunit = rlst.scunit
    scfmt  = rlst.scfmt

    if scunit == 'pu':
        units = 'PU'
    else:
        units = 'AMP'
    unitstr   = units.center(10)
    clnhdr    = "   BUS     " + 6*unitstr + "\n"

    for i in range(nfbus):
        report("           <-SCMVA-> <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\n")
        report(clnhdr)
        fbus   = rlst.fltbus[i]
        basekv = busdata_dict[fbus]['basekv']
        baseamp = (1000.0 * sbase) / (math.sqrt(3.0) * basekv)

        if flt3ph:
            ttxt   = "%6d" % fbus
            spc    = '3PH'

            ia1    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia2)
            ia0    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.flt3ph[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.flt3ph[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.flt3ph[i].ic)

            scmva  = math.sqrt(3.0) * basekv * rlst.flt3ph[i].ia1 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltlg:
            if flt3ph:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = ' LG'
            ia1    = get_cplx_mag(scfmt,rlst.fltlg[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltlg[i].ia2)
            ia0    = get_cplx_mag(scfmt,3*rlst.fltlg[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltlg[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltlg[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltlg[i].ic)

            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltlg[i].ia0 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltllg:
            if flt3ph or fltlg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = 'LLG'
            ia1    = get_cplx_mag(scfmt,rlst.fltllg[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltllg[i].ia2)
            ia0    = get_cplx_mag(scfmt,3*rlst.fltllg[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltllg[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltllg[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltllg[i].ic)

            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltllg[i].ia0 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltll:
            if flt3ph or fltlg or fltllg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc     = ' LL'
            ia1    = get_cplx_mag(scfmt,rlst.fltll[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltll[i].ia2)
            ia0    = get_cplx_mag(scfmt,rlst.fltll[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltll[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltll[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltll[i].ic)

            scmva  = math.sqrt(3.0) * basekv * rlst.fltll[i].ib / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        report("\nTHEVENIN IMPEDANCE (pu), X/R\n")
        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)
        z1str ="Z1: " + z1str
        if fltlg or fltllg or fltll:
            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)
            z2str ="Z2: " + z2str
            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)
            z0str ="Z0: " + z0str
            tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
        else:
            tmptxt="%(z1str)s\n" % vars()
        report(tmptxt)

        if scunit != 'pu':
            report("\nTHEVENIN IMPEDANCE (ohms), X/R\n")
            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)
                z2str ="Z2: " + z2str
                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
            else:
                tmptxt="%(z1str)s\n" % vars()
            report(tmptxt)

        tmptxt=110*'-'
        report(tmptxt)
        report("\n")

    # Maximum Fault Currents
    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
    unitstr   = units.center(11)
    unitstr = ''
    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
        t = each+'('+units+')'
        t = ' ' + t.center(9) + ' '
        unitstr += t

    clnhdr    = "   BUS  " + unitstr + "  Description\n"
    report("\nBREAKER DUTY CURRENTS\n")
    report(clnhdr)
    for i in range(nfbus):
        fbus   = rlst.fltbus[i]
        ia1    = get_cplx_mag(scfmt,rlst.maxflt[i].ia1)
        ia2    = get_cplx_mag(scfmt,rlst.maxflt[i].ia2)
        ia0    = get_cplx_mag(scfmt,rlst.maxflt[i].ia0)
        ia     = get_cplx_mag(scfmt,rlst.maxflt[i].ia)
        ib     = get_cplx_mag(scfmt,rlst.maxflt[i].ib)
        ic     = get_cplx_mag(scfmt,rlst.maxflt[i].ic)
        dsc    = rlst.maxfltdsc[i]
        tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\n" % vars()
        report(tmptxt)

    # ------------------------------------------------------------------------------------------------
    if rptfile:
        rptfile_h.close()
        print('\n Done .... ASCC FAULT Report saved to file %s' % rptfile)
    else:
        print('\n Done .... ASCC FAULT Report created in Report window.')

# =====================================================================================================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

# =====================================================================================================

def run_ascc_report(savfile="savnw.sav", fltbuses=[151,154], rptfile='ascc_report_savnw.txt'):

    import psspy

    psspy.psseinit()

    # Inputs, change as required

    flt3ph  = 1       #
    fltlg   = 1       #
    fltllg  = 1       #
    fltll   = 1       #
    linout  = 0       #
    linend  = 0       #
    voltop  = 0       #
    genxop  = 0       #
    tpunty  = 0       #
    dcload  = 1       #
    zcorec  = 1       #
    lnchrg  = 0       #
    shntop  = 0       #
    loadop  = 0       #
    machpq  = 0       #

    volts   = 1.0     #

    rptfile = check_psse_example_folder(rptfile)

    relfile = ""
    fcdfile = ""
    scfile  = ""

    rprtyp  = -1      # no report
    rprlvl  = 0       # number of contribution levels

    create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,
                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,
                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)

# ====================================================================================================
if __name__ == '__main__':

    import psse35
    run_ascc_report()

# ====================================================================================================
import os
import string
from math import sqrt

# ----------------------------------------------------------------------------------------------------
def isfloat(str):
    """Checks if the string is a floating point number."""

    try:
        float(str)
        return True			#Returns true if the string is a floating point number
    except (ValueError, TypeError) as e:
        return False			#Returns false otherwise

# ----------------------------------------------------------------------------------------------------
def isint(str):
    """Checks if the string is an integer."""

    try:
        int(str)
        return True			#Returns true if the string is an integer
    except (ValueError, TypeError) as e:
        return False			#Returns false otherwise

# ----------------------------------------------------------------------------------------------------
def OpenFile():
    """Opens the BPA file specified in prompt."""

    psspy.prompt("Enter the BPA file path, followed by its name:\n")
    ierr, fnamestr = psspy.userin()		#User types in the path name

    if ierr != 0: return

    fpath, fext = os.path.splitext(fnamestr)
    if not fext: fnamestr = fpath + '.dat'	#To add the extension if left blank

    if os.path.isfile(fnamestr) == False:
        psspy.alert("The specified path or file name is invalid\n")
        return

    bpa_file = open(fnamestr, 'r')		#Opens the file in read mode

    return bpa_file

# ----------------------------------------------------------------------------------------------------
def GetMVA(bpa_file, bpa_str):
    """Gets the base MVA in the BPA file."""

    pos = string.find(bpa_str, "MVA_BASE")

    if pos != -1:
        bpa_file.seek(pos)
        bpa_file.readline()			#Just to position on to the next line
        mva_base_str = bpa_file.readline()
        mva_base_str = mva_base_str.replace(' ', '')	#To delete any spaces
        mva_base_str = mva_base_str.strip()	#To remove trailing and leading whitespaces
        mva_base_str = mva_base_str[10:]	#To remove the "/MVA_BASE=" part
        basemva = float(mva_base_str[:-1])

    else:
        basemva = 100.0				#The default base MVA in BPA is 100 MVA

    return basemva

# ----------------------------------------------------------------------------------------------------
def GetTitles(bpa_file, bpa_str):
    """Gets the titles from the BPA file."""

    pos = string.find(bpa_str, "CASEID")	#To find title1

    if pos != -1:
        bpa_file.seek(pos)
        title_data = bpa_file.readline()
        pos1 = string.find(title_data, '=')
        pos2 = string.find(title_data, ',')
        case_id = title_data[pos1 + 1 : pos2]
        case_id = case_id.strip()		#To remove trailing and leading whitespaces

    else:
        case_id = ""				#Title1 is blank by default


    pos = string.find(bpa_str, "PROJECT")	#To find title2

    if pos != -1:
        bpa_file.seek(pos)
        title_data = bpa_file.readline()
        pos1 = string.find(title_data, '=')
        pos2 = string.find(title_data, ',')	
        if pos2 == -1:				#If there are no other parameters, the line finishes with ')'
            pos2 = string.find(title_data, ')')

        project_id = title_data[pos1 + 1 : pos2]
        project_id = project_id.strip()		#To remove trailing and leading whitespaces

    else:
        project_id = ""				#Title2 is blank by default

    return case_id, project_id

# ----------------------------------------------------------------------------------------------------
def GetPCard(bpa_str_ar):
    """Gets the scale data from the BPA file."""

    scale_str = []

    for line in bpa_str_ar:			#Loop over every line of the BPA file
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#To continue if it is a blank line

        if line[0] == 'P' and line[2] == ' ':	#If the line is a P card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records
            scale_str.append(line)

    return scale_str				#Returns an array of P cards

# ----------------------------------------------------------------------------------------------------
def GetScaleData(scale_str, owner_name, zone_name, type_code):
    """Gets the scale factors for each load and generator."""

    scale_ar = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]		#Default factors are unit factors

    for line in scale_str:					#For each P card
        if line[1] == 'O' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])	#Generation Q factor is generation P factor

        elif line[1] == 'Z' and line[3:5].strip() == zone_name or line[1] == 'N' and line[3:5].strip() == zone_name and type_code == 'N':
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])	#Generation Q factor is generation P factor

        elif line[1] == 'A':
            if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
            if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
            elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

            if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
            if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
            elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])		#Generation Q factor is generation P factor

        elif line[1] == 'B' and type_code == 'X' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])		#Constant current load P factor
                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])		#Constant current load Q factor
                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])		#Constant current load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'B' and type_code == 'Y' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'C' and type_code == 'X' and line[3:5].strip() == zone_name:
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])		#Constant current load P factor
                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])		#Constant current load Q factor
                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])		#Constant current load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'C' and type_code == 'Y' and line[3:5].strip() == zone_name:
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

    return scale_ar		#Returns the scale factors
 
# ----------------------------------------------------------------------------------------------------
def CheckICard(bpa_str_ar, area_name):
    """To check if there is an I card with the specified area name."""

    for line in bpa_str_ar:			#Loop over every line of the BPA file
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#To continue if it is a blank line
        
        if line[0] == 'I' and line[2] == ' ':	#If it is an I card
            line = line + ' '*(34-len(line))	#To pad each line with spaces up to 34 records
            if line[3:13].strip() == area_name or line[14:24].strip() == area_name: return True		#Returns true if the area is found in an I card

    return False			#Returns false if the area has not been found in I cards

# ----------------------------------------------------------------------------------------------------
def GetXCard(bpa_str_ar, bus_name, Vmax, Vmin, remote_bus_name, RMPCT, remote_bus_nbr, bus_nbr):
    """Gets the switched shunts attached to the specified bus."""

    for line in bpa_str_ar:		#This loop is used to get the corresponding switched shunts
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#To continue if it is a blank line
        
        #--------------#
        #Default values#
        #--------------#
        intgar = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
        realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]

        if isfloat(line[28:32]): remote_kv = float(line[28:32])	#The remote bus base voltage
        else: remote_kv = 0.0

        if line[0] == 'X' and bus_name == (line[6:14].strip() + str(float(line[14:18]))) and remote_bus_name == (line[20:28].strip() + str(remote_kv)):
            if line[2] == ' ':					#The modification code for a new record
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records

                if isint(line[32]): intgar[0] = int(line[32])	#Number of steps for block 1
                if isint(line[38]): intgar[1] = int(line[38])	#Number of steps for block 2
                if isint(line[44]): intgar[2] = int(line[44])	#Number of steps for block 3
                if isint(line[50]): intgar[3] = int(line[50])	#Number of steps for block 4
                if isint(line[56]): intgar[4] = int(line[56])	#Number of steps for block 5
                if isint(line[62]): intgar[5] = int(line[62])	#Number of steps for block 6
                if isint(line[68]): intgar[6] = int(line[68])	#Number of steps for block 7
                if isint(line[74]): intgar[7] = int(line[74])	#Number of steps for block 8

                if isfloat(line[33:38]): realar[0] = float(line[33:38])	#Admittance increment for block 1
                if isfloat(line[39:44]): realar[1] = float(line[39:44])	#Admittance increment for block 2
                if isfloat(line[45:50]): realar[2] = float(line[45:50])	#Admittance increment for block 3
                if isfloat(line[51:56]): realar[3] = float(line[51:56])	#Admittance increment for block 4
                if isfloat(line[57:62]): realar[4] = float(line[57:62])	#Admittance increment for block 5
                if isfloat(line[63:68]): realar[5] = float(line[63:68])	#Admittance increment for block 6
                if isfloat(line[69:74]): realar[6] = float(line[69:74])	#Admittance increment for block 7
                if isfloat(line[75:80]): realar[7] = float(line[75:80])	#Admittance increment for block 8

                if isfloat(Vmax): realar[8] = float(Vmax)	#Upper voltage limit
                if isfloat(Vmin): realar[9] = float(Vmin)	#Lower voltage limit
                if isfloat(RMPCT):
                    realar[11] = float(RMPCT)	#The RMPCT
                    if realar[11] > 1.0: realar[11] = realar[11] / 100.0	#To bring back the RMPCT from percent to unit

                intgar[9] = remote_bus_nbr

                count_nbr = -1
                for nbr in realar[0:8]:		#This loop is used to get the reactors first in the list for PSS/E to work
                    count_nbr = count_nbr + 1
                    if nbr < 0.0 and count_nbr != 0:	#If the admittance is negative (reactor) and it is not already first in the list
                        realar.insert(0, nbr)
                        realar.pop(count_nbr + 1)
                        intgar.insert(0, intgar[count_nbr])
                        intgar.pop(count_nbr + 1)

                ierr = psspy.switched_shunt_data(bus_nbr, intgar, realar, '')	#The API used to load switched shunts in PSS/E

# ----------------------------------------------------------------------------------------------------
def GetACard(bpa_str_ar, zone_str, bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr):
    "Gets the area data from the BPA file."""

    if zone_str != "":			#Only look for area number if the zone is not blank
        for line in bpa_str_ar:		#This loop is used to get the corresponding area data
            line = line.lstrip()
            line = line.rstrip('\n')
            if line == "": continue	#To continue if the line is blank
            
            if line[0] == 'A' and line[1] != 'O':
                if line[2] == ' ':			#The modification code for a new record
                    line = line + ' '*(95-len(line))	#To pad each line with spaces up to 95 records
                    if zone_str == line[35:37].strip() or zone_str == line[38:40].strip() or zone_str == line[41:43].strip() or zone_str == line[44:46].strip()\
                    or zone_str == line[47:49].strip() or zone_str == line[50:52].strip() or zone_str == line[53:55].strip() or zone_str == line[56:58].strip()\
                    or zone_str == line[59:61].strip() or zone_str == line[62:64].strip() or zone_str == line[65:67].strip() or zone_str == line[68:70].strip()\
                    or zone_str == line[71:73].strip() or zone_str == line[74:76].strip() or zone_str == line[77:79].strip() or zone_str == line[80:82].strip()\
                    or zone_str == line[83:85].strip() or zone_str == line[86:88].strip() or zone_str == line[89:91].strip() or zone_str == line[92:94].strip():

                        if line[13:21].strip() + str(float(line[21:25])) not in bus_str:	#If the bus is not in the list, add it
                            bus_nbr = bus_nbr + 1
                            bus_str[line[13:21].strip() + str(float(line[21:25]))] = bus_nbr	#A new dictionnary entry
                            bus_flag = True							#True if the bus number has been incremented
                        else:
                            bus_nbr = bus_str[line[13:21].strip() + str(float(line[21:25]))]	#Get the bus number
                            bus_flag = False							#False if the bus number hasn't been incremented

                        if isfloat(line[26:34]):					#If the value of interchange is specified
                            if CheckICard(bpa_str_ar, line[3:13].strip()):		#If there is an I card, do not include interchange given
                                if (line[3:13].strip(), 0.0) not in area_str:	#If the area is not in the list, add it
                                    area_nbr = area_nbr + 1
                                    area_str[(line[3:13].strip(), 0.0)] = area_nbr
                                    area_slack_nbr.append(bus_nbr)			#An array with slack bus numbers for each area
                                else:
                                    area_nbr = area_str[(line[3:13].strip(), 0.0)]	#Get the area number
                            else:							#If there is no I card, include the interchange value given
                                if (line[3:13].strip(),float(line[26:34])) not in area_str:	#If the area is not in the list, add it
                                    area_nbr = area_nbr + 1
                                    area_str[(line[3:13].strip(), float(line[26:34]))] = area_nbr
                                    area_slack_nbr.append(bus_nbr)			#Add the corresponding slack bus number
                                else:
                                    area_nbr = area_str[(line[3:13].strip(),float(line[26:34]))]	#Get the area number

                        else:				#If there is no value of interchange specified
                            if (line[3:13].strip(), 0.0) not in area_str:		#If the area is not in the list, add it
                                area_nbr = area_nbr + 1
                                area_str[(line[3:13].strip(), 0.0)] = area_nbr
                                area_slack_nbr.append(bus_nbr)				#Add the corresponding slack bus number
                            else:
                                area_nbr = area_str[(line[3:13].strip(), 0.0)]		#Get the area number

                        area_flag = True		#True if the zone name has a corresponding area card

                        return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr


    area_flag = False		#The zone name has no corresponding area card
    bus_flag = False		#The bus number hasn't changed

    return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr

# ----------------------------------------------------------------------------------------------------
def GetBCard(bpa_str_ar, base_mva, scale_str):
    """Gets the AC bus data from the BPA file."""

    bus_data_str = []			#The array to contain all AC bus lines
    bus_str = {}			#A dictionnary with bus names and the corresponding bus numbers
    bus_owner_nbr = [0]			#An array with the owner number for each bus
    bus_zone_str = ["0"]		#An array with the zone of each bus
    load_id_ar = [0]			#An array used to determine the load CKT for each bus
    machine_id_ar = [0]			#An array used to determine the machine CKT for each bus
    owner_str = {'DEFAULT': 1}		#The default owner
    zone_str = {'DEFAULT': 1}		#The default zone
    area_str = {("DEFAULT", 0.0): 1}	#The default area is used for zones without A cards or for data without zones
    area_slack_nbr = [0]		#An array with the slack bus of each area
    bus_nbr = 0				#The bus number
    owner_nbr = 1			#The owner number
    zone_nbr = 1			#The zone number
    area_nbr = 1			#The area number

    for line in bpa_str_ar:		#This loop is used to fill the bus data array with each line of bus data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'B':		#If it is a bus
            if line[1] != 'D' and line[1] != 'M':	#But not a DC bus
                bus_data_str.append(line)		#Add the line to the array

    for line in bus_data_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

        #--------------#
        #Default values#
        #--------------#
        bus_intgar = [1, 0, 1, 0]
        load_intgar = [1, 1, 1, 1]
        machine_intgar = [0, 0, 0, 0, 0]
        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]
        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        plant_realar = [1.0, 1.0]
        remote_bus_nbr = 0
        remote_kv = 0.0

        if line[2] == ' ':			#The modification code for a new record
            if line[1] == ' ' or line[1] == 'T' or line[1] == 'C' or line[1] == 'V' or line[1] == 'F' or line[1] == 'J' or line [1] == 'X':
                bus_intgar[0] = 1		#The bus type code for a PQ bus
            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G' or line[1] == 'K' or line[1] == 'L':
                bus_intgar[0] = 2		#The bus type code for a PV bus
            elif line[1] == 'S':
                bus_intgar[0] = 3		#The bus type code for a swing bus

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr
                bus_intgar[3] = owner_nbr			#The owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                bus_intgar[3] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                bus_intgar[3] = 1				#The default owner number

            bus_namear = line[6:14].strip()		#The bus name
            bus_realar[2] = float(line[14:18])		#The bus base voltage in kV

            if bus_namear + str(bus_realar[2]) not in bus_str:	#If the bus is not in the list, add it (the bus could be in the list if assigned as a remote for another bus)
                bus_nbr = bus_nbr + 1
                bus_str[bus_namear + str(bus_realar[2])] = bus_nbr	#A new dictionnary entry
            else:
                bus_nbr = bus_str[bus_namear + str(bus_realar[2])]	#Get the bus number

            bus_owner_nbr.insert(bus_nbr + 1, bus_intgar[3])		#Insert the corresponding owner of the bus

            load_id_ar.append(0)	#To initialize the load CKT number
            machine_id_ar.append(0)	#To initialize the machine CKT number

            if line[18:20] != "  ":	#If the zone is not blank
                if line[18:20].strip() not in zone_str:	#If the zone is not in the list, add it
                    zone_nbr = zone_nbr + 1
                    zone_str[line[18:20].strip()] = zone_nbr
                    bus_intgar[2] = zone_nbr		#The zone number
                else:
                    bus_intgar[2] =  zone_str[line[18:20].strip()]	#Get the zone number

            bus_zone_str.insert(bus_nbr + 1, line[18:20].strip())	#Insert the corresponding zone of the bus

            if isfloat(line[20:25]): load_realar[0] = float(line[20:25])	#Load P in MW
            if isfloat(line[25:30]): load_realar[1] = float(line[25:30])	#Load Q in Mvar

            if isfloat(line[30:34]): bus_realar[0] = float(line[30:34])		#Fixed bus shunt active load
            if isfloat(line[34:38]): bus_realar[1] = float(line[34:38])		#Fixed bus shunt reactive load

            if isfloat(line[38:42]): machine_realar[4] = float(line[38:42])	#Maximum active power generation
            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])	#Actual active power generation

            if line[1] != ' ' and line[1] != 'C' and line[1] != 'T' and line[1] != 'V':	#If not a PQ bus
                if isfloat(line[47:52]): machine_realar[2] = float(line[47:52])	#Machine reactive upper limit
                if isfloat(line[52:57]): machine_realar[3] = float(line[52:57])	#Machine reactive lower limit

            if line[1] == ' ' or line[1] == 'C' or line[1] == 'T' or line[1] == 'V':	#If it is a PQ bus
                if isfloat(line[47:52]): 
                    machine_realar[2] = float(line[47:52])	#Machine reactive upper limit
                    machine_realar[3] = machine_realar[2]	#Machine reactive lower limit
                    machine_realar[1] = machine_realar[2]	#Machine reactive power output

            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G':		#If it is a PV bus
                if isfloat(line[57:61]): 
                    plant_realar[0] = float(line[57:61])			#Scheduled voltage
                    bus_realar[3] = float(line[57:61])				#Bus voltage magnitude

            elif line[1] == 'S':						#If it is a swing bus
                if isfloat(line[57:61]):
                    plant_realar[0] = float(line[57:61])			#Scheduled voltage
                    bus_realar[3] = float(line[57:61])				#Bus voltage magnitude
                if isfloat(line[61:65]): bus_realar[4] = float(line[61:65])	#The voltage phase angle

            if line[65:73] != "        ":					#If there is a remote bus
                remote_kv = float(line[73:77])					#The remote bus base voltage
                if line[65:73].strip() + str(remote_kv) not in bus_str:	#If the remote bus name is not in the list, add it
                    remote_bus_nbr = bus_nbr + 1
                    bus_str[line[65:73].strip() + str(remote_kv)] = remote_bus_nbr
                else:
                    remote_bus_nbr = bus_str[line[65:73].strip() + str(remote_kv)]	#Get the remote bus number

            if isfloat(line[77:80]):
                plant_realar[1] = float(line[77:80])	#The RMPCT
                if plant_realar[1] > 1.0: plant_realar[1] = plant_realar[1] / 100.0	#To bring back the RMPCT from percent to unit

            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)

            if bus_flag == True: bus_nbr = swing_bus_nbr	#To change the bus number if it has been incremented

            if area_flag == True:		#To assign the area number to the buses and loads
                bus_intgar[1] = area_nbr
                load_intgar[1] = area_nbr
            else:				#The default area number
                bus_intgar[1] = 1
                load_intgar[1] = 1
            
            ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)	#Loads the bus data in PSS/E

            if line[1] == 'X': GetXCard(bpa_str_ar, bus_namear + str(bus_realar[2]), line[57:61], line[61:65], line[65:73].strip() + str(remote_kv), line[77:80], remote_bus_nbr, bus_nbr)

            scale_ar = GetScaleData(scale_str, line[3:6].strip(), line[18:20].strip(), 'N')	#To get the scale factors

            load_realar[0] = load_realar[0] * scale_ar[0]		#To scale the load P
            load_realar[1] = load_realar[1] * scale_ar[1]		#To scale the load Q
            machine_realar[0] = machine_realar[0] * scale_ar[6]		#To scale the machine P
            machine_realar[1] = machine_realar[1] * scale_ar[7]		#To scale the machine Q

            if load_realar[0] != 0.0 or load_realar[1] != 0.0: 			#If there is a load
                load_intgar[2] = bus_intgar[2]		#The zone number
                load_intgar[3] = bus_intgar[3]		#The owner number
                load_id_ar[bus_nbr] = 1			#The load CKT number is now 1
                ierr = psspy.load_data(bus_nbr, '1', load_intgar, load_realar)	#Loads the load data in PSS/E

            if machine_realar[0] != 0.0:		#If there is a generator
                machine_intgar[0] = 1			#The machine status
                machine_intgar[1] = bus_intgar[3]	#The owner number
                machine_id_ar[bus_nbr] = 1		#The machine CKT number is now 1
                ierr = psspy.plant_data(bus_nbr, remote_bus_nbr, plant_realar)	#First load the plant data
                ierr = psspy.machine_data(bus_nbr, '1', machine_intgar, machine_realar)	#After add the generator data

            if remote_bus_nbr == bus_nbr + 1: bus_nbr = bus_nbr + 1	#To change the actual bus number

    return area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str

# ----------------------------------------------------------------------------------------------------
def GetRCard(bpa_str_ar, from_bus, to_bus, bus_str):
    """Gets the regulation parameters for the two-winding transformers."""

    #--------------#
    #Default values#
    #--------------#
    #Only the returned values are useful
    intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
    realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'R' and line[1] != 'Z':	#If it is a R card but not RZ
            if line[2] == ' ' and from_bus == (line[6:14].strip() + str(float(line[14:18]))) and to_bus == (line[19:27].strip() + str(float(line[27:31]))):
                line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

                if line[33:41] != "        ": intgar[9] = bus_str[line[33:41].strip() + str(float(line[41:45]))]	#Controlled bus number
                if isfloat(line[45:50]): realari[17] = float(line[45:50])	#Winding one ratio/angle high limit
                if isfloat(line[50:55]): realari[18] = float(line[50:55])	#Winding one ratio/angle low limit
                if isint(line[55:57]): intgar[6] = int(line[55:57])		#Number of tap positions

                if line[1] == ' ':	#If it is a R card
                    intgar[11] = 1	#Control mode = 1
                elif line[1] == 'V':	#If it is a RV card
                    intgar[11] = 1	#Control mode = 1
 
                elif line[1] == 'Q':	#If it is a RQ card
                    intgar[11] = 2	#Control mode = 2
                elif line[1] == 'N':	#If it is a RN card
                    intgar[11] = 2	#Control mode = 2
                    if isfloat(line[57:62]): realari[19] = float(line[57:62])	#Voltage or flow upper limit
                    else: realari[19] = 0.0					#Default
                    if isfloat(line[62:67]): realari[20] = float(line[62:67])	#Voltage or flow lower limit
                    else: realari[20] = 0.0					#Default

                elif line[1] == 'P':	#If it is a RP card
                    intgar[11] = 3	#Control mode = 3
                elif line[1] == 'M':	#If it is a RM card
                    intgar[11] = 3	#Control mode = 3
                    if isfloat(line[57:62]): realari[19] = float(line[57:62])	#Voltage or flow upper limit
                    else: realari[19] = 0.0					#Default
                    if isfloat(line[62:67]): realari[20] = float(line[62:67])	#Voltage or flow lower limit
                    else: realari[19] = 0.0					#Default

                return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]

    return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]

# ----------------------------------------------------------------------------------------------------
def GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva):
    """To get the multi-section line data from BPA.

    This function is recursive.
    """

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        #--------------#
        #Default values#
        #--------------#
        bus_intgar = [1, 1, 1, owner_nbr]
        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]
        line_intgar = [1, 0, 1, 0, 0, 0]
        line_realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        trans_intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
        trans_realari = [0.0, 0.0, base_mva, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

        if line[0] == 'L' and line[1] == ' ' and line[2] == ' ' or line[0] == 'E' and line[1] == ' ' and line[2] == ' ':
            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records
                section_nbr = section_nbr + 1			#To increment the section number
                dummy_nbr = dummy_nbr + 1			#To increment the dummy bus number
                bus_nbr = bus_nbr + 1				#To increment the bus number
                bus_namear = "DUMMY #" + str(dummy_nbr)		#The name of the new dummy bus
                bus_str[bus_namear] = bus_nbr			#Add the bus to the dictionnary
                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)	#Insert the owner number of that bus
                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])	#The bus base voltage
                multi_intgar[section_nbr - 2] = bus_nbr		#The bus number of the dummy bus
                from_bus = bus_nbr				#To remember the value of the from bus before recalling this function

                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)		#Loads the bus data in PSS/E

                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)	#Recursive function

                if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                    owner_nbr = owner_nbr + 1
                    owner_str[line[3:6].strip()] = owner_nbr		#A new dictionnary entry
                    line_intgar[2] = owner_nbr				#The new owner number
                elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                    line_intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
                elif line[3:6] == "   ":
                    line_intgar[2] = 1			#The default owner

                line_intgar[1] = from_bus		#Every section of the line is set as metered from (default)

                if isfloat(line[33:37]) and isfloat(line[14:18]): line_realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0	#The Rate A in MVA

                if line[31] != ' ': ckt = line[31]		#The circuit identifier
                else: ckt = '1'			#If none is mentionned, the default is 1

                if isfloat(line[38:44]): line_realar[0] = float(line[38:44])			#Nominal branch resistance
                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: line_realar[1] = float(line[44:50])	#Nominal branch reactance

                if line[0] == 'L':		#If it is an L card
                    if isfloat(line[50:56]):
                        line_realar[6] = float(line[50:56])/2.0					#Real line shunt at bus IARG end
                        line_realar[8] = line_realar[6]						#Real line shunt at bus JARG end
                    if isfloat(line[56:62]): line_realar[2] = float(line[56:62])*2.0		#Total line charging
                    if isfloat(line[62:66]): line_realar[10] = float(line[62:66])		#Line's length in miles

                else:				#If it is an E card
                    if isfloat(line[50:56]): line_realar[6] = float(line[50:56])		#Real line shunt at bus IARG end
                    if isfloat(line[56:62]): line_realar[7] = float(line[56:62])		#Reactive line shunt at bus IARG end
                    if isfloat(line[62:68]): line_realar[8] = float(line[62:68])		#Real line shunt at bus JARG end
                    if isfloat(line[68:74]): line_realar[9] = float(line[68:74])		#Reactive line shunt at bus JARG end

                #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual
                #if line[77:80] != "   ": line_intgar[0] = 0		#If there is an out of service date, the status is offline

                ierr = psspy.branch_data(from_bus, to_bus, ckt, line_intgar, line_realar)	#The API to load branch data in PSS/E

                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

        if line[0] == 'T' and line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:
            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records
                section_nbr = section_nbr + 1			#To increment the section number
                dummy_nbr = dummy_nbr + 1			#To increment the dummy bus number
                bus_nbr = bus_nbr + 1				#To increment the bus number
                bus_namear = "DUMMY #" + str(dummy_nbr)		#The name of the dummy bus
                bus_str[bus_namear] = bus_nbr			#A new dictionnary entry
                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)	#Insert the owner of this bus
                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])	#The bus base voltage
                multi_intgar[section_nbr - 2] = bus_nbr		#The bus number of the dummy bus
                from_bus = bus_nbr

                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)	#Loads the bus data in PSS/E

                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)	#Recursive function

                if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                    owner_nbr = owner_nbr + 1
                    owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                    trans_intgar[2] = owner_nbr			#The new owner number
                elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                    trans_intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
                elif line[3:6] == "   ":
                    trans_intgar[2] = 1			#The default owner

                trans_intgar[1] = from_bus		#Every section of the line is set as metered from (default)

                trans_intgar[8] = from_bus		#The winding one side

                if isfloat(line[14:18]): trans_realari[4] = float(line[14:18])		#Winding one nominal voltage

                if isfloat(line[27:31]): trans_realari[7] = float(line[27:31])		#Winding two nominal voltage

                if isfloat(line[33:37]): trans_realari[8] = float(line[33:37])		#The Rate A in MVA

                if line[31] != ' ': ckt = line[31]	#The circuit identifier
                else: ckt = '1'				#If none is mentionned, the default is 1

                if isfloat(line[38:44]): trans_realari[0] = float(line[38:44])	#Nominal transformer resistance
                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: trans_realari[1] = float(line[44:50])	#Nominal transformer reactance

                if isfloat(line[50:56]): trans_realari[15] = float(line[50:56])		#The magnetizing conductance

                if isfloat(line[56:62]): trans_realari[16] = float(line[56:62])		#The magnetization susceptance

                if line[1] == ' ':
                    if isfloat(line[62:67]): trans_realari[3] = float(line[62:67])		#The winding one ratio/voltage
                    if isfloat(line[67:72]): trans_realari[6] = float(line[67:72])		#The winding one ratio/voltage

                else:		#For the phase shifting transformer
                    if isfloat(line[62:67]): trans_realari[5] = float(line[62:67])		#The winding one phase shift angle
                    trans_realari[3] = trans_realari[4]
                    trans_realari[6] = trans_realari[7]

                #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual
                #if line[77:80] != "   ": trans_intgar[0] = 0		#If there is an out of service date, the status is offline

                trans_intgar[11], trans_intgar[9], trans_realari[17], trans_realari[18], trans_intgar[6], trans_realari[19], trans_realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)

                ierr, realaro  = psspy.two_winding_data(from_bus, to_bus, ckt, trans_intgar, trans_realari, "")	#The API to load transformer data in PSS/E

                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

    return jarg, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

# ----------------------------------------------------------------------------------------------------
def GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, base_mva):
    """Gets the symmetrical and asymmetrical lines from BPA."""

    line_str = []	#An array to contain all AC line data
    dummy_nbr = 0	#The dummy bus number for multi-section lines

    for line in bpa_str_ar:		#This loop is used to fill the branch data array with each line of branch data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'L' and line[1] == ' ' or line[0] == 'E' and line[1] == ' ': line_str.append(line)

    for line in line_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

        #--------------#
        #Default values#
        #--------------#
        intgar = [1, 0, 1, 0, 0, 0]
        realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]

        if line[2] == ' ':			#The modification code for a new record

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                intgar[2] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                intgar[2] = 1					#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]		#From bus
            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]		#To bus

            if line[18] == '1': intgar[1] = iarg	#The metered end is IARG
            elif line[18] == '2': intgar[1] = jarg	#The metered end is JARG
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg		#If both ends have the same owner, IARG is the metered end
                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg			#Else the end that has a different owner from the line is the metered end
                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg

            if isfloat(line[33:37]) and intgar[1] == iarg and isfloat(line[14:18]): realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0	#The Rate A in MVA
            elif isfloat(line[33:37]) and intgar[1] == jarg and isfloat(line[27:31]): realar[3] = sqrt(3)*float(line[33:37])*float(line[27:31])/1000.0	#The Rate A in MVA

            if line[31] != ' ': ckt = line[31]		#The circuit identifier
            else: ckt = '1'				#If none is mentionned, the default is 1

            if isfloat(line[38:44]): realar[0] = float(line[38:44])			#Nominal branch resistance
            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realar[1] = float(line[44:50])	#Nominal branch reactance

            if line[0] == 'L':		#If it is an L card
                if isfloat(line[50:56]):
                    realar[6] = float(line[50:56])/2.0					#Real line shunt at bus IARG end
                    realar[8] = realar[6]						#Real line shunt at bus JARG end
                if isfloat(line[56:62]): realar[2] = float(line[56:62])*2.0		#Total line charging
                if isfloat(line[62:66]): realar[10] = float(line[62:66])		#Line's length in miles

            else:			#If it is an E card
                if isfloat(line[50:56]): realar[6] = float(line[50:56])		#Real line shunt at bus IARG end
                if isfloat(line[56:62]): realar[7] = float(line[56:62])		#Reactive line shunt at bus IARG end
                if isfloat(line[62:68]): realar[8] = float(line[62:68])		#Real line shunt at bus JARG end
                if isfloat(line[68:74]): realar[9] = float(line[68:74])		#Reactive line shunt at bus JARG end

            #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual
            #if line[77:80] != "   ": intgar[0] = 0		#If there is an out of service date, the status is offline

            if line[32] == ' ': ierr = psspy.branch_data(iarg, jarg, ckt, intgar, realar)	#The API to load branch data in PSS/E

            elif line[32] == '1':	#If the branch is the section number 1
                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]
                section_nbr = 2		#To search for a section number 2
                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)

                intgar[1] = iarg	#The metered end is IARG
                ierr = psspy.branch_data(iarg, to_bus, ckt, intgar, realar)	#The API to load branch data in PSS/E
                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, "&" + ckt, multi_intgar)	#The API to load the multi-section line data in PSS/E	

    return owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr

# ----------------------------------------------------------------------------------------------------
def GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, base_mva):
    """Gets the two-winding transformer data from BPA."""

    transformer_str = []	#An array to contain all lines with two-winding transformers connecting AC buses

    for line in bpa_str_ar:		#This loop is used to fill the transformer data array with each line of transformer data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'T' and line[1] == ' ' or line[0] == 'T' and line[1] == 'P': transformer_str.append(line)

    for line in transformer_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

        #--------------#
        #Default values#
        #--------------#
        intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
        realari = [0.0, 0.0, basemva, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

        if line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                intgar[2] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                intgar[2] = 1					#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]		#From bus
            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]		#To bus

            intgar[8] = iarg						#The winding one side

            if isfloat(line[14:18]): realari[4] = float(line[14:18])	#Winding one nominal voltage

            if line[18] == '1': intgar[1] = iarg	#The metered end is IARG
            elif line[18] == '2': intgar[1] = jarg	#The metered end is JARG
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg		#If both ends have the same owner, IARG is the metered end
                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg			#Else the end that has a different owner from the line is the metered end
                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg

            if isfloat(line[27:31]): realari[7] = float(line[27:31])	#Winding two nominal voltage

            if isfloat(line[33:37]): realari[8] = float(line[33:37])	#The Rate A in MVA

            if line[31] != ' ': ckt = line[31]		#The circuit identifier
            else: ckt = '1'				#If none is mentionned, the default is 1

            if isfloat(line[38:44]): realari[0] = float(line[38:44])			#Nominal transformer resistance
            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realari[1] = float(line[44:50])	#Nominal transformer reactance

            if isfloat(line[50:56]): realari[15] = float(line[50:56])		#The magnetizing conductance

            if isfloat(line[56:62]): realari[16] = float(line[56:62])		#The magnetizing susceptance

            if line[1] == ' ':
                if isfloat(line[62:67]): realari[3] = float(line[62:67])	#The winding one ratio/voltage
                if isfloat(line[67:72]): realari[6] = float(line[67:72])	#The winding two ratio/voltage

            else:
                if isfloat(line[62:67]): realari[5] = float(line[62:67])	#The winding one phase shift angle
                realari[3] = realari[4]						#The winding one ratio/voltage
                realari[6] = realari[7]						#The winding two ratio/voltage

            #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual
            #if line[77:80] != "   ": intgar[0] = 0		#If there is an out of service date, the status is offline

            intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)

            if line[32] == ' ': ierr, realaro  = psspy.two_winding_data(iarg, jarg, ckt, intgar, realari, "")	#The API to load transformer data in PSS/E

            elif line[32] == '1':	#If the transformer is section number 1
                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]
                section_nbr = 2		#To search for section number 2
                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)

                intgar[1] = iarg	#The metered end is IARG
                ierr, realaro  = psspy.two_winding_data(iarg, to_bus, ckt, intgar, realari, "")		#The API used to load two-winding data in PSS/E
                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, "&" + ckt, multi_intgar)	#The API used to load multi-section line in PSS/E

    return owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr

# ----------------------------------------------------------------------------------------------------
def GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, base_mva, scale_str, bus_zone_str):
    """Gets the bus supplement data from BPA."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        #--------------#
        #Default values#
        #--------------#
        load_intgar = [1, 1, 1, 1]
        machine_intgar = [0, 0, 0, 0, 0]
        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        plant_realar = [1.0, 1.0]

        if line[0] == '+' and line[2] == ' ':	#If it is a + card
            line = line + ' '*(77-len(line))	#To pad each line with spaces up to 77 records

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                load_intgar[3] = owner_nbr			#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                load_intgar[3] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                load_intgar[3] = 1				#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]	#The from bus number

            if line[18:20] == "*I" or line[18:20] == "01":			#If it is a constant current load
                if isfloat(line[20:25]): load_realar[2] = float(line[20:25])	#Constant current load P
                if isfloat(line[25:30]): load_realar[3] = float(line[25:30])	#Constant current load Q
            elif line[18:20] == "*P" or line[18:20] == "02":			#If it is a constant power load
                if isfloat(line[20:25]): load_realar[0] = float(line[20:25])	#Constant power load P
                if isfloat(line[25:30]): load_realar[1] = float(line[25:30])	#Constant power load Q

            if isfloat(line[30:34]): load_realar[4] = float(line[30:34])	#Constant impedance load P
            if isfloat(line[34:38]): load_realar[5] = float(line[34:38])	#Constant impedance load Q

            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])	#Generation P
            if isfloat(line[47:52]): machine_realar[1] = float(line[47:52])	#Generation Q

            if line[1] != 'A' and line[1] != 'F' and line[1] != 'I' and line[1] != 'P': type_code = 'N'	#Non-industrial load or generation
            elif line[1] == 'F' or line[1] == 'I' or line[1] == 'P': type_code = 'I'			#Industrial load
            elif line[1] == 'A' and line[18:20] == "*I" or line[18:20] == "01": type_code = 'X'		#If it is a +A card with constant current load
            elif line[1] == 'A' and line[18:20] == "*P" or line[18:20] == "02": type_code = 'Y'		#If is is a +A card with constant power load

            scale_ar = GetScaleData(scale_str, line[3:6].strip(), bus_zone_str[iarg], type_code)	#To get the scale factors

            load_realar[0] = load_realar[0] * scale_ar[0]		#To scale the constant power load P
            load_realar[1] = load_realar[1] * scale_ar[1]		#To scale the constant power load Q
            load_realar[2] = load_realar[2] * scale_ar[2]		#To scale the constant current load P
            load_realar[3] = load_realar[3] * scale_ar[3]		#To scale the constant current load Q
            load_realar[4] = load_realar[4] * scale_ar[4]		#To scale the constant impedance load P
            load_realar[5] = load_realar[5] * scale_ar[5]		#To scale the constant impedance load Q
            machine_realar[0] = machine_realar[0] * scale_ar[6]		#To scale the generation P
            machine_realar[1] = machine_realar[1] * scale_ar[7]		#To scale the generation Q

            if load_realar[0] != 0.0 or load_realar[1] != 0.0 or load_realar[2] != 0.0 or load_realar[3] != 0.0 or load_realar[4] != 0.0 or load_realar[5] != 0.0:
                load_id_ar[iarg] = load_id_ar[iarg] + 1		#To increment the load CKT
                ierr = psspy.load_data(iarg, str(load_id_ar[iarg]), load_intgar, load_realar)	#Loads the load data in PSS/E

            if machine_realar[0] != 0.0 or machine_realar[1] != 0.0:	#If there is a generator
                machine_id_ar[iarg] = machine_id_ar[iarg] + 1		#To increment the machine CKT
                machine_intgar[0] = 1					#The machine status
                machine_intgar[1] = owner_nbr				#The owner number
                if machine_id_ar[iarg] == 1:				#If it is the first generator on this bus
                    ierr = psspy.plant_data(iarg, 0, plant_realar)	#First load the plant data
                ierr = psspy.machine_data(iarg, str(machine_id_ar[iarg]), machine_intgar, machine_realar)	#After add the generator data

    return owner_str, owner_nbr

# ----------------------------------------------------------------------------------------------------
def GetICard(bpa_str_ar, area_str, area_slack_nbr):
    """Gets the inter-area transfer data from BPA."""

    inter_nbr = 48			#In order to start to the character '1' in the transfer ID

    for line in bpa_str_ar:		#This loop is used to get the inter-area transfer data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if it is a blank line

        #--------------#
        #Default values#
        #--------------#
        ia = 1				#Default area number
        ja = 1				#Default area number
        realar = [0.0]			#Default transfer

        if line[0] == 'I' and line[2] == ' ':		#If it is an I card
            line = line + ' '*(34-len(line))		#To pad each line with spaces up to 34 records
            for (x,y), z in area_str.items():
                if x == line[3:13].strip(): ia = z	#The 'from' area number
                if x == line[14:24].strip(): ja = z	#The 'to' area number

            if isfloat(line[26:34]): realar[0] = float(line[26:34])	#The amount of MW in the transfer

            inter_nbr = inter_nbr + 1	#To increment the transfer ID

            if inter_nbr == 123:	#After the 'Z' character, PSS/E do not accept the other ASCII characters
                psspy.alert(" WARNING: MAXIMUM NUMBER OF INTER-AREA TRANSFERS REACHED\n")
                return

            ierr = psspy.transfer_data(1, ia, ja, chr(inter_nbr), realar[0])	#The transfer data API

# ----------------------------------------------------------------------------------------------------
def GetRZCard(bpa_str_ar):
    """Gets the line series compensation from BPA."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'R' and line[1] == 'Z':	#If it is an RZ card
            line = line + ' '*(60-len(line))	#To pad each line with spaces up to 60 records

            #Found no equivalent way to model this series compensation device in PSS/E
            psspy.alert(" WARNING: THE RZ CARD GOING FROM BUS [" + line[6:18] + "] TO BUS [" + line[19:31] + "] CANNOT BE IMPORTED\n")

# ----------------------------------------------------------------------------------------------------
def GetZCard(bpa_str_ar, zone_str):
    """Gets the renamed zone names from BPA."""

    zone_str_temp = {}		#A dictionnary containing the modified zone names

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue

        if line[0] == 'Z':
            line = line + ' '*(77-len(line))	#To pad each line with spaces up to 77 records

            for x, y in zone_str.items():
                if x == line[3:5].strip(): zone_str_temp[line[5:7].strip()] = y
                elif x == line[8:10].strip(): zone_str_temp[line[10:12].strip()] = y
                elif x == line[13:15].strip(): zone_str_temp[line[15:17].strip()] = y
                elif x == line[18:20].strip(): zone_str_temp[line[20:22].strip()] = y
                elif x == line[23:25].strip(): zone_str_temp[line[25:27].strip()] = y
                elif x == line[28:30].strip(): zone_str_temp[line[30:32].strip()] = y
                elif x == line[33:35].strip(): zone_str_temp[line[35:37].strip()] = y
                elif x == line[38:40].strip(): zone_str_temp[line[40:42].strip()] = y
                elif x == line[43:45].strip(): zone_str_temp[line[45:47].strip()] = y
                elif x == line[48:50].strip(): zone_str_temp[line[50:52].strip()] = y
                elif x == line[53:55].strip(): zone_str_temp[line[55:57].strip()] = y
                elif x == line[58:60].strip(): zone_str_temp[line[60:62].strip()] = y
                elif x == line[63:65].strip(): zone_str_temp[line[65:67].strip()] = y
                elif x == line[68:70].strip(): zone_str_temp[line[70:72].strip()] = y
                elif x == line[73:75].strip(): zone_str_temp[line[75:77].strip()] = y
                else: zone_str_temp[x] = y

            zone_str.clear()			#To clear the dictionnary
            zone_str.update(zone_str_temp)	#To copy the contents of the temporary dictionnary

    return zone_str

# ----------------------------------------------------------------------------------------------------
def GetDZCard(bpa_str_ar, zone_str):
    """Gets the deleted zone names from BPA and remove connected buses and equipment."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'D' and line[1] == 'Z':	#If it is a DZ card
            line = line + ' '*(5-len(line))	#To pad each line with spaces up to 5 records
            if line[3:5].strip() in zone_str:
                ierr = psspy.bsys(0, 0, [0.0,0.0], 0, [], 0, [], 0, [], 1, [zone_str[line[3:5].strip()]])	#A bus subsystem of this zone
                ierr = psspy.extr(0, 0, [1, 0])						#To delete this subsystem
                ierr = psspy.bsys(0, 1, [0.0, 9999.], 0, [], 0, [], 0, [], 0, [])	#To bring back the original unfiltered view
                del zone_str[line[3:5].strip()]						#To delete the zone

            else: psspy.alert(" WARNING: THE ZONE [" +  line[3:5].strip() + "] SPECIFIED IN THE DZ CARD CANNOT BE FOUND\n")	#If the zone is not found

    return zone_str

# ----------------------------------------------------------------------------------------------------
def GetDCOwners(bpa_str_ar, from_bus, to_bus):
    """Gets the owners of the DC buses for the two-terminal DC lines in BPA."""

    owner_1 = ""	#The owner of bus 'converter 1'
    owner_2 = ""	#The owner of bus 'converter 2'

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':	#If it is a BD card
            if from_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_1 = line[3:6].strip()
            elif to_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_2 = line[3:6].strip()

    return owner_1, owner_2

# ----------------------------------------------------------------------------------------------------
def GetTwoTermConv(bpa_str_ar, from_bus, to_bus, dc_line_nbr, flow_flag, bus_str):
    """Gets the converter data for two-terminal lines in BPA."""

    #--------------#
    #Default values#
    #--------------#
    intgar_1 = [0, 0, 0, 0, 0]
    realari_1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    intgar_2 = [0, 0, 0, 0, 0]
    realari_2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':	#If it is a BD card
            line = line + ' '*(62-len(line))	#To pad each line with spaces up to 62 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])):	#If the bus is converter 1
                if flow_flag: cnvflg_1 = 1	#If the flow is positive, the converter 1 is a rectifier
                else: cnvflg_1 = 2		#If the flow is negative, the converter 1 is an inverter

                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_1[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter 1 bus number

                if isint(line[23:25]): intgar_1[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[30:35]): realari_1[0] = float(line[30:35])	#Minimum firing angle
                if isfloat(line[35:40]): realari_1[1] = float(line[35:40])	#Maximum firing angle

            elif to_bus == line[6:14].strip() + str(float(line[14:18])):	#If the bus is converter 2
                if flow_flag: cnvflg_2 = 2	#If the flow is positive, the converter 2 is an inverter
                else: cnvflg_2 = 1		#If the flow is negative, the converter 2 is a rectifier

                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_2[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter 2 bus number

                if isint(line[23:25]): intgar_2[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[30:35]): realari_2[0] = float(line[30:35])	#Minimum firing angle
                if isfloat(line[35:40]): realari_2[1] = float(line[35:40])	#Maximum firing angle

        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':		#If it is a T card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[38:44]): realari_1[2] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): realari_1[3] = float(line[44:50])	#Commutating reactance

                realari_1[4] = float(line[14:18])				#Primary base voltage

                if isfloat(line[67:72]): realari_1[5] = float(line[67:72])	#Transformer ratio
                if isfloat(line[62:67]): realari_1[6] = float(line[62:67])	#Tap setting

            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[38:44]): realari_2[2] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): realari_2[3] = float(line[44:50])	#Commutating reactance

                realari_2[4] = float(line[14:18])				#Primary base voltage

                if isfloat(line[67:72]): realari_2[5] = float(line[67:72])	#Transformer ratio
                if isfloat(line[62:67]): realari_2[6] = float(line[62:67])	#Tap setting

        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':		#If it is a R card
            line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): realari_1[7] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): realari_1[8] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: realari_1[9] = (realari_1[7] - realari_1[8])/int(line[55:57])	#Tap step

            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): realari_2[7] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): realari_2[8] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: realari_2[9] = (realari_2[7] - realari_2[8])/int(line[55:57])	#Tap step

    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_1, dc_line_nbr, intgar_1, realari_1, "")	#To load the converter 1 in PSS/E
    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_2, dc_line_nbr, intgar_2, realari_2, "")	#To load the converter 2 in PSS/E

# ----------------------------------------------------------------------------------------------------
def GetTwoTermLine(bpa_str_ar, bus_str):
    """Gets the two-terminal DC line data from BPA."""

    dc_line_nbr = 0	#The two-terminal DC line number

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'D' and line[2] == ' ':	#If it is a LD card
            line = line + ' '*(78-len(line))	#To pad each line with spaces up to 78 records

            #--------------#
            #Default values#
            #--------------#
            intgar = [1, 0]
            realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

            dc_line_nbr = dc_line_nbr + 1	#To increment the DC line number

            if isfloat(line[56:61]): realari[0] = float(line[56:61])	#Scheduled power demand
            if isfloat(line[61:66]): realari[1] = float(line[61:66])	#Scheduled DC voltage
            if isfloat(line[37:43]): realari[4] = float(line[37:43])	#DC line resistance

            if line[55] == 'I': realari[5] = 0			#Compounding resistance = 0 if Vdc is controlled at the inverter
            elif line[55] == 'R': realari[5] = realari[4]	#Compounding resistance = Rdc if Vdc is controlled at the rectifier

            if line[18] == '1':				#If the metered side is converter 1
                if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                else: metrar = 'I'			#The metered side is the inverter if the flow is negative

            elif line[18] == '2':			#If the metered side is converter 2
                if realari[0] >= 0.0: metrar = 'I'	#The metered side is the inverter if the flow is positive
                else: metrar = 'R'			#The metered side is the rectifier if the flow is negative

            elif line[18] == ' ':			#If the metered side is left blank, BPA chooses
                owner_1, owner_2 = GetDCOwners(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])))
                if owner_1 == owner_2:		#If both DC buses have the same owner
                    if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                    else: metrar = 'I'			#The metered side is the inverter if the flow is negative
                elif owner_1 == line[3:6].strip():  #If the owner of converter 1 is the same as the line
                    if realari[0] >= 0.0: metrar = 'I'	#The metered side is the inverter if the flow is positive
                    else: metrar = 'R'			#The metered side is the rectifier if the flow is negative
                elif owner_2 == line[3:6].strip():  #If the owner of converter 2 is the same as the line
                    if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                    else: metrar = 'I'			#The metered side is the inverter if the flow is negative

            ierr, realaro = psspy.two_terminal_dc_line_data(dc_line_nbr, intgar, realari, metrar)	#The API to load two-terminal DC line in PSS/E

            GetTwoTermConv(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), dc_line_nbr, realari[0] >= 0.0, bus_str)	#To get the 2 converters data

# ----------------------------------------------------------------------------------------------------
def GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, bus_name):
    """Gets the T and R card corresponding to the converter bus specified."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':	#If it is a T card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[67:72]): conv_realari[3] = float(line[67:72])	#Transformer ratio
                if isfloat(line[38:44]): conv_realari[4] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): conv_realari[5] = float(line[44:50])	#Commutating reactance

                conv_realari[6] = float(line[14:18])				#Winding one base voltage

                if isfloat(line[62:67]): conv_realari[7] = float(line[62:67])	#Tap setting

        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':		#If it is a R card
            line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): conv_realari[8] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): conv_realari[9] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: conv_realari[10] = (conv_realari[8] - conv_realari[9])/int(line[55:57])	#Tap step

    return conv_intgar, conv_realari

# ----------------------------------------------------------------------------------------------------
def GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr):
    """Gets the converter data for multi-terminal lines and creates DC buses."""

    dc_bus_nbr = 0		#The DC bus number for multi-terminal lines
    dc_bus_str = {}		#The dictionnary to contain DC bus names and numbers
    dc_bus_owner = ["DEFAULT"]	#An array of the owners of each DC bus

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'M' and line[2] == ' ':	#If it is a BM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records
            
            #--------------#
            #Default values#
            #--------------#
            conv_intgar = [0, 0, 0, 0]
            conv_realari = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.5, 0.51, 0.00625, 0.0, 1.0]
            bus_intgar = [0, 0, 0, 0, 0]
            bus_realari = 0.0

            if line[6:14].strip() + str(float(line[14:18])) not in dc_bus_str:		#If the bus is not in the list, add it
                dc_bus_nbr = dc_bus_nbr + 1
                dc_bus_str[line[6:14].strip() + str(float(line[14:18]))] = dc_bus_nbr		#A new dictionnary entry
            else:
                dc_bus_nbr = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]		#Get the bus number

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr		#A new dictionnary entry
                bus_intgar[3] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                bus_intgar[3] =  owner_str[line[3:6].strip()]		#Get the owner number
            elif line[3:6] == "   ":
                bus_intgar[3] = 1					#The default owner

            dc_bus_owner.insert(dc_bus_nbr + 1, line[3:6].strip())	#Insert the owner number of this bus

            if line[18:20] != "  ":
                if line[18:20].strip() not in zone_str:		#If the zone is not in the list, add it
                    zone_nbr = zone_nbr + 1
                    zone_str[line[18:20].strip()] = zone_nbr		#A new dictionnary entry
                    bus_intgar[2] = zone_nbr				#The new zone number
                else:
                    bus_intgar[2] =  zone_str[line[18:20].strip()]	#Get the zone number

            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)

            if area_flag == True:		#To assign the area number to the DC buses
                bus_intgar[1] = area_nbr
            else:				#The default area number
                bus_intgar[1] = 1

            if line[62] != ' ':			#If it is not a passive DC bus
                conv_intgar[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter bus number
                bus_intgar[0] = conv_intgar[0]						#Converter bus number

                if isint(line[23:25]): conv_intgar[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[69:75]):
                    if float(line[69:75]) != 0.0: conv_realari[0] = float(line[69:75])	#Scheduled power
                    elif isfloat(line[75:80]): conv_realari[0] = float(line[75:80])	#Scheduled voltage

                if line[62] == 'R' and isfloat(line[30:35]): conv_realari[1] = float(line[30:35])	#Minimum firing angle

                elif line[62] == 'I' and isfloat(line[66:69]) or line[62] == 'M' and isfloat(line[66:69]):
                    conv_realari[1] = float(line[66:69])			#Minimum extinction angle

                if isfloat(line[35:40]): conv_realari[2] = float(line[35:40])	#Maximum firing angle

                conv_intgar, conv_realari = GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, line[6:14].strip() + str(float(line[14:18])))	#To get the corresponding T and R parameters

                ierr,realaro = psspy.multi_term_dc_convr_data(1, conv_intgar, conv_realari)	#The API to load multi-terminal DC line converter data in PSS/E

            ierr,realaro = psspy.multi_term_dc_bus_data(1, dc_bus_nbr, bus_intgar, bus_realari, line[6:14].strip())	#The API to load multi-terminal DC line bus data in PSS/E

    return dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr

# ----------------------------------------------------------------------------------------------------
def GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner):
    """Gets the multi-terminal link data from the BPA file."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':	#If it is a LM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            #--------------#
            #Default values#
            #--------------#
            intgar = 0
            realar = [0.0, 0.0]

            ibus = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]	#The from bus
            jbus = dc_bus_str[line[19:27].strip() + str(float(line[27:31]))]	#The to bus

            if line[18] == '1': intgar = ibus		#The metered end is IBUS
            elif line[18] == '2': intgar = jbus		#The metered end is JBUS
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if dc_bus_owner[ibus] == dc_bus_owner[jbus]: intgar = ibus	#If both ends have the same owner, IBUS is the metered end
                elif dc_bus_owner[ibus] == line[3:6].strip(): intgar = jbus	#Else the end that has a different owner from the line is the metered end
                elif dc_bus_owner[jbus] == line[3:6].strip(): intgar = ibus

            if isfloat(line[37:43]): realar[0] = float(line[37:43])	#DC link resistance
            if isfloat(line[43:49]): realar[1] = float(line[43:49])	#DC link inductance

            ierr = psspy.multi_term_dc_link_data(1, ibus, jbus, '1', intgar, realar)	#The API used to load multi-terminal DC line link data in PSS/E

# ----------------------------------------------------------------------------------------------------
def GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr):
    """Gets the multi-terminal lines from the BPA file."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':	#If it is a LM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            #--------------#
            #Default values#
            #--------------#
            intgari = 1
            realar = 0.0

            ierr, intgaro = psspy.multi_term_dc_line_data(1, intgari, realar)	#The API used to load multi-terminal DC line data in PSS/E

            #To get the converter, DC bus and DC link data
            dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr)
            GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner)

            return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr

    return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr

# ----------------------------------------------------------------------------------------------------
bpa_file = OpenFile()

if bpa_file:					#If the file opened successfully

    psspy.progress("\n\nFile opened successfully, starting the conversion:\n")

    bpa_str = bpa_file.read()			#The string containing the text file, to use the find() function
    bpa_file.seek(- bpa_file.tell(), 1)		#To position back at the beginning
    bpa_str_ar = bpa_file.readlines()		#The array that is containing all the lines of the BPA file

    basemva = GetMVA(bpa_file, bpa_str)		#To get the MVA base
    psspy.progress("\n-Base MVA: " + str(basemva))

    titl1, titl2 = GetTitles(bpa_file, bpa_str)	#To get the title data
    psspy.progress("\n-Title 1: " + titl1)
    psspy.progress("\n-Title 2: " + titl2 + "\n")

    ierr = psspy.newcas(basemva, titl1, titl2)	#To create the new case

    scale_str = GetPCard(bpa_str_ar)		#To get the P cards for scaling

    area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str = GetBCard(bpa_str_ar, basemva, scale_str)

    owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr = GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, basemva)

    owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr = GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, basemva)

    owner_str, owner_nbr = GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, basemva, scale_str, bus_zone_str)

    GetTwoTermLine(bpa_str_ar, bus_str)
    zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr)

    zone_str = GetZCard(bpa_str_ar, zone_str)	#To get Z cards
    zone_str = GetDZCard(bpa_str_ar, zone_str)	#To get DZ cards

    for x, y in zone_str.items():
        ierr = psspy.zone_data(y, x)	#The API used to load zone data in PSS/E

    for (x,y), z in area_str.items():
        ierr = psspy.area_data(z, area_slack_nbr[z - 1], [y, 0.0], x)	#The API used to load zone data in PSS/E

    GetICard(bpa_str_ar, area_str, area_slack_nbr)	#To get the I cards

    for x, y in owner_str.items():
        ierr = psspy.owner_data(y, x)	#The API used to load owner data in PSS/E

    GetRZCard(bpa_str_ar)	#To get RZ cards

    psspy.progress("\n\nConversion completed\n")

    bpa_file.close()	#To close the BPA file
#[brnflows_csv.py]  Export BRANCH FLOWS to COMMA SEPARATED FILE (CSV)
# ====================================================================================================
'''
This is an example file showing how to use "subsystem data retrieval APIs
from Python to save branch flows to Comma Separated File.
    Input : Solved PSS(R)E saved case file name
    Output: CSV file name to save
    When 'savfile' is provided, FNSL with default options is used to solve the case.
    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.
    When 'csvfile' is provided, branch flows is saved in ASCII text file 'csvfile'.
    When 'csvfile' is not provided, it produces report in PSS(R)E report window.

The subsystem data retrieval APIs return values as List of Lists. For example:
When "abusint" API is called with "istrings" as defined below:
    istrings = ['number','type','area','zone','owner','dummy']
    ierr, idata = psspy.abusint(sid, flag_bus, istrings)
The returned list will have format:
    idata=[[list of 'number'],[list of 'type'],[],[],[],[list of 'dummy']]

This example is written such that, such returned lists are converted into dictionary with
keys as strings specified in "istrings". This makes it easier to refer and use these lists.
    ibuses = array2dict(istrings, idata)

So ibuses['number'] gives the bus numbers returned by "abusint".

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call function
    run_brnflowscsv()
    You may want to change input arguments when you call this function.
    run_brnflowscsv(savfile, csvfile)

'''
# ----------------------------------------------------------------------------------------------------
import os

# ----------------------------------------------------------------------------------------------------
def array2dict(dict_keys, dict_values):
    '''Convert array to dictionary of arrays.
    Returns dictionary as {dict_keys:dict_values}
    '''
    tmpdict = {}
    for i in range(len(dict_keys)):
        tmpdict[dict_keys[i].lower()] = dict_values[i]
    return tmpdict

# ----------------------------------------------------------------------------------------------------
def busindexes(busnum, busnumlist):
    '''Find indexes of a bus in list of buses.
    Returns list with indexes of 'busnum' in 'busnumlist'.
    '''
    busidxes = []
    startidx = 0
    buscounts = busnumlist.count(busnum)
    if buscounts:
        for i in range(buscounts):
            tmpidx = busnumlist.index(busnum,startidx)
            busidxes.append(tmpidx)
            startidx = tmpidx+1
    return busidxes

# ----------------------------------------------------------------------------------------------------
def splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

# ----------------------------------------------------------------------------------------------------
def brnflows_csv(savfile,csvfile):
    '''Generates power flow result report.
    When 'savfile' is provided, FNSL with default options is used to solve the case.
    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.
    When 'csvfile' is provided, report is saved in ASCII text file 'csvfile'.
    When 'csvfile' is not provided, it produces report in PSS(R)E report window.
    '''

    import psspy
    psspy.psseinit()

    # Set Save and CSV files according to input file names
    if savfile:
        ierr = psspy.case(savfile)
        if ierr != 0: return
        fpath, fext = os.path.splitext(savfile)
        if not fext: savfile = fpath + '.sav'
    else:   # saved case file not provided, check if working case is in memory
        ierr, nbuses = psspy.abuscount(-1,2)
        if ierr != 0:
            print('\n No working case in memory.')
            print(' Either provide a Saved case file name or open Saved case in PSSE.')
            return
        savfile, snapfile = psspy.sfiles()

    if csvfile:  # open CSV file to write
        csvfile_h = open(csvfile,'w')
        report    = csvfile_h.write
    else:        # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    # ================================================================================================
    # PART 1: Get the required results data
    # ================================================================================================

    # Select what to report
    if psspy.bsysisdef(0):
        sid = 0
    else:   # Select subsytem with all buses
        sid = -1

    flag_brflow  = 1    # in-service
    owner_brflow = 1    # use bus ownership, ignored if sid is -ve
    ties_brflow  = 5    # ignored if sid is -ve

    # ------------------------------------------------------------------------------------------------
    # Branch Flow Data
    # Branch Flow Data - Integer
    istrings = ['fromnumber','tonumber','status','nmeternumber','owners','own1','own2','own3','own4']
    ierr, idata = psspy.aflowint(sid, owner_brflow, ties_brflow, flag_brflow, istrings)
    if ierr != 0: return
    iflow = array2dict(istrings, idata)
    # Branch Flow Data - Real
    rstrings = ['amps','pucur','pctrate','pctratea','pctrateb','pctratec','pctmvarate',
                'pctmvaratea','pctmvarateb',#'pctmvaratec','fract1','fract2','fract3',
                'fract4','rate','ratea','rateb','ratec',
                'p','q','mva','ploss','qloss',
                'o_p','o_q','o_mva','o_ploss','o_qloss'
                ]
    ierr, rdata = psspy.aflowreal(sid, owner_brflow, ties_brflow, flag_brflow, rstrings)
    if ierr != 0: return
    rflow = array2dict(rstrings, rdata)
    # Branch Flow Data - Complex
    xstrings = ['pq','pqloss','o_pq','o_pqloss']
    ierr, xdata = psspy.aflowcplx(sid, owner_brflow, ties_brflow, flag_brflow, xstrings)
    if ierr != 0: return
    xflow = array2dict(xstrings, xdata)
    # Branch Flow Data - Character
    cstrings = ['id','fromname','fromexname','toname','toexname','nmetername','nmeterexname']
    ierr, cdata = psspy.aflowchar(sid, owner_brflow, ties_brflow, flag_brflow, cstrings)
    if ierr != 0: return
    cflow = array2dict(cstrings, cdata)

    # ================================================================================================
    # PART 2: Write acquired results to Report file
    # ================================================================================================

    report("Branch flows from Saved case: %s\n" %savfile)

    clnttls = "%6s,%18s,%6s,%18s,%3s,%3s,%9s,%9s,%9s,%6s,%8s,%8s\n" %('FRMBUS',
             'FROMBUSEXNAME','TOBUS','TOBUSEXNAME','CKT','STS','MW','MVAR','MVA','%I','MWLOSS','MVARLOSS')
    report(clnttls)
    for i in range(len(iflow['fromnumber'])):
        fromnum    = iflow['fromnumber'][i]
        fromexname = cflow['fromexname'][i]
        tonum      = iflow['tonumber'][i]
        toexname   = cflow['toexname'][i]
        ckt        = cflow['id'][i]
        status     = iflow['status'][i]
        p          = rflow['p'][i]
        q          = rflow['q'][i]
        mva        = rflow['mva'][i]
        ploss      = rflow['ploss'][i]
        qloss      = rflow['qloss'][i]
        pcti       = rflow['pctrate'][i]
        report("%(fromnum)6d,%(fromexname)18s,%(tonum)6d,%(toexname)18s,%(ckt)3s,%(status)3d,\
%(p)9.2F,%(q)9.2F,%(mva)9.2F,%(pcti)6.2F,%(ploss)8.2F,%(qloss)8.2F\n" %vars())
    # ------------------------------------------------------------------------------------------------
    if csvfile:
        csvfile_h.close()
        print('\n Done .... Power Flow Results Report saved to file %s' % csvfile)
    else:
        print('\n Done .... Power Flow Results Report created in Report window.')

# =====================================================================================================

def check_psse_example_folder(csvfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(csvfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        csvfile  = os.path.join(outdir, rptfnam)

    return csvfile

# =====================================================================================================

def run_brnflows_csv(savfile='savnw.sav', csvfile='brnflows_csv_savnw.csv'):

    csvfile  = check_psse_example_folder(csvfile)

    brnflows_csv(savfile, csvfile)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':

    import psse35
    run_brnflows_csv()

# ====================================================================================================
#[dyntools_demo.py]  Demo for using functions from dyntools module
# ====================================================================================================
'''
'dyntools' module provide access to data in PSS(R)E Dynamic Simulation Channel Output file.
This module has functions:
- to get channel data in Python scripts for further processing
- to get channel information and their min/max range
- to export data to text files, excel spreadsheets
- to open multiple channel output files and post process their data using Python scripts
- to plot selected channels
- to plot and insert plots in word document

This is an example file showing how to use various functions available in dyntools module.

Other Python modules 'matplotlib', 'numpy' and 'python win32 extension' are required to be
able to use 'dyntools' module.
Self installation EXE files for these modules are available at:
   PSSE User Support Web Page and follow link 'Python Modules used by PSSE Python Utilities'.

- This version of the dyntools module is developed and tested using these open source modules.
  Python 3.7.3 [64 bit]
  matplotlib-3.1.1
  numpy-1.16.4
  pywin32-224

  Versions later than these may work.

---------------------------------------------------------------------------------
How to use this file?
- Open Python IDLE (or any Python Interpreter shell)
- Open this file
- run (F5)

Note: Do NOT run this file from PSS(R)E GUI. The 'xyplots' function from dyntools can
save plots to eps, png, pdf or ps files. However, creating only 'eps' files from inside
PSS(R)E GUI works. This is because different backends matplotlib uses to create different
plot types.
When run from any Python interpreter (outside PSS(R)E GUI) plots can be saved to any of
these four (eps, png, pdf or ps) file types.

Get information on functions available in dyntools as:
import dyntools
help(dyntools)

---------------------------------------------------------------------------------
How to use PSSE and Python modules like numpy, matplotlib together?
(a) In your python script, call following function before any of these modules are imported.
    psspy.set_fpcw_py()
(b) Call following function before exiting your python script.
    psspy.set_fpcw_psse()
To get details why this is needed, get help(..) on either of these functions.
Refer function test2_subplots_one_trace(..) in this script for usage of these functions.

'''

import os, sys, collections

# =============================================================================================
def get_demotest_file_names(outdir, outvrsn):

    if outvrsn==0:
        extn = '.out'
        prgfile  = os.path.join(outdir,'progress.txt')
    else:
        extn = '.outx'
        prgfile  = os.path.join(outdir,'progressX.txt')

    outfile1 = os.path.join(outdir,'bus154_fault{}'.format(extn))
    outfile2 = os.path.join(outdir,'bus3018_gentrip{}'.format(extn))
    outfile3 = os.path.join(outdir,'brn3005_3007_trip{}'.format(extn))

    return outfile1, outfile2, outfile3, prgfile

# =============================================================================================
# PSSE version Example folder
def get_example_folder():
    import psspy
    pn = os.path.dirname(psspy.__file__)
    p, jnk = os.path.split(pn)
    examdir = os.path.join(p, 'Example')
    return examdir

# =============================================================================================
# Run Dynamic simulation on SAVNW to generate .out files

def run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn):

    import psspy
    psspy.psseinit()

    examdir = get_example_folder()

    savfile = 'savcnv.sav'
    snpfile = 'savnw.snp'

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    snpfile = os.path.join(datapath, snpfile)

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])

    ierr = psspy.case(savfile)
    if ierr:
        psspy.progress_output(1,"",[0,0])
        print(" psspy.case Error")
        return
    ierr = psspy.rstr(snpfile)
    if ierr:
        psspy.progress_output(1,"",[0,0])
        print(" psspy.rstr Error")
        return

    psspy.set_chnfil_type(outvrsn)

    psspy.strt(0,outfile1)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_bus_fault(154,1, 230.0,[0.0,-0.2E+10])
    psspy.run(0, 1.05,1000,1,0)
    psspy.dist_clear_fault(1)
    psspy.run(0, 5.0,1000,1,0)

    psspy.case(savfile)
    psspy.rstr(snpfile)
    psspy.strt(0,outfile2)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_machine_trip(3018,'1')
    psspy.run(0, 5.0,1000,1,0)

    psspy.case(savfile)
    psspy.rstr(snpfile)
    psspy.strt(0,outfile3)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_branch_trip(3005,3007,'1')
    psspy.run(0, 5.0,1000,1,0)

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])

# =============================================================================================
# 0. Run savnw dynamics simulation to create .out files

def test0_run_simulation(datapath=None, outpath=None, outvrsn=0):

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)
    run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn)

    print(" Test0:Done SAVNW dynamics simulation")

# =============================================================================================
# 1. Data extraction/information

def test1_data_extraction(outpath=None, show=True, outvrsn=0, prg2file=True):

    import psspy
    import dyntools

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    # create object
    chnfobj = dyntools.CHNF(outfile1, outvrsn=outvrsn)

    if chnfobj.ierr: return

    if prg2file:
        p, nx = os.path.split(outfile1)
        n, x  = os.path.split(nx)
        rptnam = "{}_test1_output.txt".format(n)
        if outpath:
            rptfile = os.path.join(outpath, rptnam)
        else:
            rptfile = os.path.join(p, rptnam)
        rptfile_h = open(rptfile,'w')
        report = rptfile_h.write
    else:
        report = sys.stdout.write

    report('\n Test1:Testing call to get_data\n')
    #sh_ttl, ch_id, ch_data = chnfobj.get_data()
    sh_ttl, ch_id, ch_data = chnfobj.get_data(['time', 4, 5, 55])
    #sh_ttl, ch_id, ch_data = chnfobj.get_data('')
    #sh_ttl, ch_id, ch_data = chnfobj.get_data([4, 5, 55])
    s_in = [str(ch) for ch in ch_data.keys()]
    s_ch = ', '.join(s_in)
    report(sh_ttl)
    report("{}".format(ch_id))
    report(" Test1:Data extracted for Channels = {}\n".format(s_ch))

    report('\n Test1:Testing call to get_id\n')
    sh_ttl, ch_id = chnfobj.get_id()
    report(sh_ttl)
    report("{}".format(ch_id))
    report('\n')

    report('\n Test1:Testing call to get_range\n')
    ch_range = chnfobj.get_range()
    report("{}".format(ch_range))
    report('\n')

    report('\n Test1:Testing call to get_scale\n')
    ch_scale = chnfobj.get_scale()
    report("{}".format(ch_scale))
    report('\n')

    if not prg2file:
        report('\n Test1:Testing call to print_scale\n')
        chnfobj.print_scale()
        report('\n')

    pn, x = os.path.splitext(outfile1)

    report('\n Test1:Testing call to txtout\n')
    chnfobj.txtout(channels=[1,4], txtfile=pn)
    report('\n')

    report('\n Test1:Testing call to csvout\n')
    chnfobj.csvout(channels=[1,4,41,5], csvfile=pn)
    report('\n')

    report('\n Test1:Testing call to xlsout\n')
    try:
        chnfobj.xlsout(channels=[2,3,4,7,8,10], show=show, xlsfile=pn)
    except:
        pass

    if prg2file:
        rptfile_h.close()
        txt = ' Test1_data_extraction report saved to file:\n    {}\n'.format(rptfile)
        print(txt)

# =============================================================================================
# 2. Multiple subplots in a figure, but one trace in each subplot
#    Channels specified with normal dictionary

# See how "set_plot_legend_options" method can be used to place and format legends

def test2_subplots_one_trace(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':True, 'showoutfnam':True, 'showlogo':True,
                'legendtype':1, 'addmarker':True}

    optnchn1 = {1:{'chns':6,                'title':'Ch#6,bus154_fault, P(pu)'},
                2:{'chns':[6, 'v*100'],     'title':'Ch#6,bus154_fault, P(MW)'},
                3:{'chns':11,               'title':'Ch#11,bus154_fault'},
                4:{'chns':40,               'title':'Ch#40,bus154_fault'},
                5:{'chns':26,               'title':'Ch#26,bus154_fault, Frequency (pu)'},
                6:{'chns':[26, '(1+v)*60'], 'title':'Ch#26,bus154_fault, Frequency (Hz)'},
                }
    pn,x     = os.path.splitext(outfile1)
    pltfile1 = pn+'.pdf'

    optnchn2 = {1:{'chns':{outfile2:6},                'title':'Channel 6 from bus3018_gentrip, P(pu)'},
                2:{'chns':{outfile2:[6, 'v*100']},     'title':'Channel 6 from bus3018_gentrip, P(MW)'},
                3:{'chns':{outfile2:11}},
                4:{'chns':{outfile2:16}},
                5:{'chns':{outfile2:26},               'title':'Ch#26,bus3018_gentrip, Frequency (pu)'},
                6:{'chns':{outfile2:[26, '(1+v)*60']}, 'title':'Ch#26,bus3018_gentrip, Frequency (Hz)'},
                }
    pn,x     = os.path.splitext(outfile2)
    pltfile2 = pn+'.png'

    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)

    chnfobj.set_plot_legend_options(loc='lower center', borderpad=0.2, labelspacing=0.5,
                                    handlelength=1.5, handletextpad=0.5, fontsize=8, frame=False)

    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':False}

    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)

    if figfiles1 or figfiles2:
        txt = ' Test2:Plot files saved:\n'
        if figfiles1: txt += "     {}\n".format(figfiles1[0])
        if figfiles2: txt += "     {}\n".format(figfiles2[0])
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

# =============================================================================================
# 3. Multiple subplots in a figure and more than one trace in each subplot
#    Channels specified with normal dictionary

def test3_subplots_mult_trace(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':True}

    optnchn1 = {1:{'chns':[1]},2:{'chns':[2]},3:{'chns':[3]},4:{'chns':[4]},5:{'chns':[5]}}
    pn,x     = os.path.splitext(outfile1)
    pltfile1 = pn+'.png'

    optnchn2 = {1:{'chns':{outfile2:1}},
                2:{'chns':{'v82_test1_bus_fault.out':3}},
                3:{'chns':4},
                4:{'chns':[5]}
               }
    pn,x     = os.path.splitext(outfile2)
    pltfile2 = pn+'.pdf'

    optnchn3 = {1:{'chns':{outfile1:1}},
                2:{'chns':{outfile2:[1,5]}},
                3:{'chns':{outfile3:3}},
                4:{'chns':[4,'v-v0',5,'v-v0']},  # arbitrary function
               }
    pn,x     = os.path.splitext(outfile3)
    pltfile3 = pn+'.png'

    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)
    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)
    figfiles3 = chnfobj.xyplots(optnchn3,optnfmt,pltfile3)

    figfiles = figfiles1[:]
    figfiles.extend(figfiles2)
    figfiles.extend(figfiles3)
    if figfiles:
        txt = ' Test3:Plot files saved:\n'
        for f in figfiles:
            txt += "    {}\n".format(f)
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

# =============================================================================================
# 4. Multiple subplots in a figure, but one trace in each subplot
#    Channels specified with Ordered dictionary

def test4_subplots_mult_trace_OrderedDict(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':True}

    optnchn  = {1:{'chns':collections.OrderedDict([(outfile1,26), (outfile2,26), (outfile3,26)]),
                   'title':'Frequency(pu)'},
                2:{'chns':collections.OrderedDict([(outfile1,[26, '(1+v)*60']),
                                                   (outfile2,[26, '(1+v)*60']),
                                                   (outfile3,[26, '(1+v)*60'])]),
                   'title':'Frequency(Hz)'}
               }
    p,nx     = os.path.split(outfile1)
    pltfile  = os.path.join(p, 'plot_chns_ordereddict.png')

    figfiles = chnfobj.xyplots(optnchn,optnfmt,pltfile)

    if figfiles:
        txt = ' Test4:Plot files saved:\n'
        for f in figfiles:
            txt += "    {}\n".format(f)
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

# =============================================================================================
# 5. Do XY plots and insert them into word file
# Does not work because win32 API to Word does not work.

def test5_plots2word(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    p,nx       = os.path.split(outfile1)
    docfile    = os.path.join(p,'savnw_response')
    overwrite  = True
    caption    = True
    align      = 'center'
    captionpos = 'below'
    height     = 0.0
    width      = 0.0
    rotate     = 0.0

    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':True}

    optnchn  = {1:{'chns':{outfile1:1,  outfile2:1,  outfile3:1} },
                2:{'chns':{outfile1:[7,'v*100'],  outfile2:[7,'v*100'],  outfile3:[7,'v*100']} },
                3:{'chns':{outfile1:17, outfile2:17, outfile3:17} },
                4:{'chns':[1,2,3,4,5]},
                5:{'chns':{outfile2:[26,'(1+v)*60',27,'(1+v)*60',28,'(1+v)*60',29,'(1+v)*60']},
                   'title':'Frequency(Hz)'},
                6:{'chns':{outfile3:[1,2,3,4,5]} },
               }
    ierr, docfile = chnfobj.xyplots2doc(optnchn,optnfmt,docfile,show,overwrite,caption,align,
                        captionpos,height,width,rotate)

    if not ierr:
        txt  = ' Test5:Plots saved to file:\n    {}'.format(docfile)
        print(txt)
    else:
        txt  = ' Test5:Error saving plots to Word = {}'.format(ierr)
        print(txt)

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

# =============================================================================================
# Run all tests and save plot and report files.

def run_all_tests(outvrsn, datapath=None, prg2file=True):

    show = False

    run_tests('all', outvrsn, show, datapath=datapath, prg2file=prg2file)

# =============================================================================================

def run_tests(which, outvrsn, show, datapath=None, prg2file=True):

    import psspy

    datapath = datapath

    outdnam  = "dyntools_demo_output_outvrn{}".format(outvrsn)
    outpath  = os.path.join(os.getcwd(), outdnam)
    if not os.path.exists(outpath): os.mkdir(outpath)

    if which in [0, 'all']:
        print(" <<<<<< Begin TEST=0 >>>>>>")
        test0_run_simulation(datapath, outpath, outvrsn)
        print(" Output files folder:{}".format(outpath))

    if which in [1, 'all']:
        print(" <<<<<< Begin TEST=1 >>>>>>")
        test1_data_extraction(outpath=outpath, show=show, outvrsn=outvrsn, prg2file=prg2file)

    if which in [2, 'all']:
        print(" <<<<<< Begin TEST=2 >>>>>>")
        test2_subplots_one_trace(outpath, show, outvrsn)

    if which in [3, 'all']:
        print(" <<<<<< Begin TEST=3 >>>>>>")
        test3_subplots_mult_trace(outpath, show, outvrsn)

    if which in [4, 'all']:
        print(" <<<<<< Begin TEST=4 >>>>>>")
        test4_subplots_mult_trace_OrderedDict(outpath, show, outvrsn)

    if which in [5, 'all']:
        print(" <<<<<< Begin TEST=5 >>>>>>")
        try:
            test5_plots2word(outpath, show, outvrsn)
        except:
            pass

# =============================================================================================

if __name__ == '__main__':

    import psse35

    show = True     # True  --> create, save and show Excel spreadsheets and Plots when done
                    # False --> create, save but do not show Excel spreadsheets and Plots when done

                    # Channel file format
    outvrsn = 0     # =0, for no Extended Channel output file type (.out)
                    # =1, for Extended Channel output file type (.outx) (default)

    prg2file = False

    #(a) Run one test a time
    #
    # 1) which=0
    # Need to run "test0_run_simulation(..)" before running other tests.
    #
    # 2)
    # which = 1 or 2 or 3 or 4 or 5
    # After running "test0_run_simulation(..)", run other tests one at a time with

    # which = 0
    # run_tests(which, outvrsn, show, prg2file)

    #(b) Run all tests
    #    Just uncomment next line to run all tests in this file.
    #run_all_tests(outvrsn)

# =============================================================================================
#[excelpy_howto_qv_export.py]  Get QV solution and Export to Excel using excelpy Module
# ====================================================================================================
'''
This is an example file showing how to use excelpy Module to populate Excel Spreadsheets.
As an example, here PSSE QV solution is exported to Excel.

Get more info on as:
    help(arrbox.qv_pp.QV_PP)
    help(excelpy)

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psseXX
    where XX is PSSE version number like 34, 35, 3500, 3501.
    
- call funtion
    run_export(qvfile)
    or
    run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd())

Excel file is saved to a file name derived from qvfile name.
'''

import os

shtlst = ['bus voltage', 'summary', 'generator dispatch', 'mismatch']

# ====================================================================================================
def qv_summary(xlsobj,sheet,smry):
    '''
    Use this to create ->
    QV worksheet: 'Summary'
    '''
    xlsobj.set_active_sheet(sheet)
    row, col = 1, 1
    xlsobj.set_cell((row,col),"QV SOLUTION RESULTS",fontStyle="bold",fontSize=14, fontColor="blue")

    tmplst=[
        smry.casetitle.line1,
        smry.casetitle.line2,
        'QV output file                             = %s' % smry.file.qv,
        'Saved Case file                            = %s' % smry.file.sav]

    if smry.file.thr:
        tmplst.append('Load throwover file                        = %s' % smry.file.thr)

    tlst = [
        'DFAX file                                  = %s' % smry.file.dfx,
        'Subsystem file                             = %s' % smry.file.sub,
        'Monitored Element file                     = %s' % smry.file.mon,
        'Contingency Description file               = %s' % smry.file.con]

    tmplst.extend(tlst)

    if smry.file.inl:
        tmplst.append('Inertia and Governor Response file         = %s' % smry.file.inl)
    if smry.file.zip:
        tmplst.append('Incremental Save Case Archive file         = %s' % smry.file.zip)

    tlst = [
        ' ',                                                                       # blank row
        'Number of Contingencies+Base Case          = %d' % smry.qvsize.ncase,
        'Number of Monitored Generators(Plants)     = %d' % smry.qvsize.nmgnbus,
        'Number of Voltage Monitored Buses          = %d' % smry.qvsize.nmvbus,
        'Number of Voltage Monitored Records        = %d' % smry.qvsize.nmvrec,
        'Number of maximum voltage setpoint changes = %d' % smry.qvsize.nmxvstp,
        ]

    tmplst.extend(tlst)

    row_optn_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+opt ttl
    jnklst=[' ', 'QV Solution Options:']
    for i in range(len(smry.options)):
        j=smry.options[i]
        ti=str(i+1).rjust(2)
        tj=str(j)
        t1=arrbox.qv_pp._QV_INT_OPTIONS_NAMES[i]
        if (i+1)==arrbox.qv_pp._QV_INT_OPTIONS_STUDY_BUS_INDEX:
            jnklst.append("option(%(ti)s): %(t1)s =%(tj)s" % vars())
        else:
            t2=arrbox.qv_pp._QV_INT_OPTIONS_LIST[i][j]
            jnklst.append("option(%(ti)s): %(t1)s =%(tj)s =%(t2)s" % vars())

    tmplst.extend(jnklst)
    row_vals_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+val ttl

    jnklst=[' ', 'QV Solution Values:']
    for i in range(len(smry.realvalues)):
        ti=str(i+1)
        tn=arrbox.qv_pp._QV_REAL_VALUES_NAMES[i]
        tv="%g" % smry.realvalues[i]
        jnklst.append("value(%(ti)s): %(tn)s =%(tv)s" % vars())

    tmplst.extend(jnklst)
    del jnklst

    row += 2
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True)
    xlsobj.font_color((row,col,row+1,col),'brown')
    xlsobj.font_color((row_optn_ttl,col),'red')
    xlsobj.font_color((row_vals_ttl,col),'red')

    if smry.qvsize.ncase:
        row = bottomRow+2
        xlsobj.set_cell((row,col),"QV Contingencies",fontStyle="Bold",fontSize=12, fontColor="red")

        conlst = [['CON#', 'LABEL', 'Min Vstp', 'Max Vstp', 'Min MVAR', 'Max MVAR',
                   'Max Mismatch', 'DESCRIPTION']]
        # determine rows for which QV is failed maxmsm>smry.realvalues[0]
        rfrm = row+1
        rto  = row+1
        failrows = []
        for i in range(smry.qvsize.ncase):
            rfrm += 1
            rto  += 1
            if i==0:
                srnum = ' '
            else:
                srnum = str(i)
            nam  = smry.colabel[i]
            minvstp = smry.minvstp[i]
            maxvstp = smry.maxvstp[i]
            minmvar = smry.minmvar[i]
            maxmvar = smry.maxmvar[i]
            maxmsm  = smry.maxmsm[i]
            for j in range(len(smry.codesc[i])):
                dsc = smry.codesc[i][j]
                if j==0:
                    conlst.append([srnum,nam,minvstp,maxvstp,minmvar,maxmvar,maxmsm,dsc])
                else:
                    conlst.append(['' ,'' ,'' ,'' ,'' ,'' ,'' ,dsc])
                    rto += 1
            if maxmsm>smry.realvalues[0]:
                failrows.append([rfrm, rto])
            else:
                failrows.append([0, 0])
            rfrm = rto

        row += 1
        bottomRow,rightCol = xlsobj.set_range(row,col,conlst)
        xlsobj.font_color((row,col,row,rightCol), "dgreen")
        xlsobj.font((row,col+2,bottomRow,col+3),numberFormat='0.00')  # Min Vstp and Max Vstp
        xlsobj.font((row,col+4,bottomRow,col+6),numberFormat='0.000') # Min MVAR, Max MVAR and Max MSM
        xlsobj.align((row,col),'right')
        xlsobj.font((row,col,row,rightCol),fontStyle=('Bold',))
        xlsobj.autofit_columns((row,col+1,row,rightCol))
        for each in failrows:
            r1 = each[0]
            r2 = each[1]
            if r1 and r2:
                xlsobj.font((r1,col,r2,rightCol),fontColor="cyan",fontStyle='bold')
    else:
        xlsobj.set_cell((row,col),"No Contingencies..",fontStyle="Bold",fontSize=12, fontColor="red")

# ====================================================================================================
def qv_mismath(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,mvaworst,mvatotal,cnvflag,cnvcond):
    '''
    Use this to create ->
    QV worksheet: 'Mismatch'
    '''
    
    # assemble data in columns: 1st=MW Transfer, 2nd=MVAWORST and 3rd=MVATOTAL
    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label
    cnvyesno = []
    noclns   = []
    i = 1
    for each in cnvflag:
        i += 1
        if each:
            cnvyesno.append('YES')
            noclns.append(0)
        else:
            cnvyesno.append('NO')
            noclns.append(i)

    tmplst = [ rowttl ]
    for i in range(len(mwtransfer)):
        tmplst.append([mwtransfer[i],mvaworst[i],mvatotal[i],cnvyesno[i],cnvcond[i]])

    xlsobj.set_active_sheet(sheet)
    col = 1
    # added 1 to row in violation check for 'contitle' row
    xlsobj.set_cell((row,col+1),contitle,fontStyle='bold',fontSize=12,fontColor="dgreen")
    row += 1
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True,numberFormat="0.00000")
    xlsobj.font((row,col,row,rightCol),fontColor="red",fontStyle='bold',numberFormat="0.000")
    xlsobj.align((row,col,row,rightCol),'h_center')
    xlsobj.align((row+3,col,row+3,rightCol),'h_center')
    xlsobj.align((row,col,bottomRow,col),'right')
    xlsobj.font((row+1,col,bottomRow,col),fontColor="blue",fontStyle='bold')
    for each in noclns:
        if each:
            xlsobj.font((row+3,each,bottomRow,each),fontColor="cyan",fontStyle='bold')

    row = bottomRow + 2 # one blank row

    return row

# ====================================================================================================
def qv_one(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,solnvalue,options,cnvflag=[]):
    '''
    Use this to create ->
    QV worksheets: 'Bus Voltage', 'Generator Dispatch'
    '''

    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label
    namesplit = options[0]
    nttlclns  = options[1]
    transpose = options[2]

    # determine non-converged solution columns
    noclns = []
    i = nttlclns
    for each in cnvflag:
        i += 1
        if each:
            noclns.append(0)
        else:
            noclns.append(i)

    # assemble data in columns: 1st=MW Transfer, rest=solution values
    t = []
    for i in range(len(mwtransfer)):
        t1 = list(solnvalue[i])
        t1.insert(0,mwtransfer[i])
        t.append(t1)
        
    tmplst = t
    tmplst.insert(0,rowttl)
    xlsobj.set_active_sheet(sheet)
    col = 1
    xlsobj.set_cell((row,col+nttlclns),contitle,fontStyle='bold',fontSize=12,fontColor="dgreen")
    row += 1
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=transpose)
    xlsobj.font((row,col+nttlclns-1,row,rightCol),fontColor="red",fontStyle='bold')
    xlsobj.font((row,col+nttlclns,bottomRow,rightCol),numberFormat="0.000")
    xlsobj.align((row,col,row,rightCol),'h_center')
    if namesplit: xlsobj.merge((row,col,row,nttlclns))
    xlsobj.align((row,col),'right')
    xlsobj.font((row+1,col,bottomRow,nttlclns),fontColor="blue",fontStyle='bold')
    for each in noclns:
        if each:
            xlsobj.font((row+1,each,bottomRow,each),fontColor="cyan")
    row = bottomRow + 2 # one blank row

    return row

# ====================================================================================================

def run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd()):
    import arrbox.qv_pp
    import excelpy
    
    if not os.path.exists(qvfile):
        msgstr = " Error - QV file does not exist, no export.\n     {}." .format(qvfile)
        print(msgstr)
        return
        
    p, nx = os.path.split(qvfile)
    xlnam, x = os.path.splitext(nx)
    xlnam = "{}_qv".format(xlnam)
    xlsfile = os.path.join(outpath, xlnam)

    # -----------------------------------------------------------
    xlsobj = excelpy.workbook(xlsfile, shtlst[0], overwritesheet=overwritesheet)
    if show:
        xlsobj.show()
    else:
        xlsobj.hide()

    xlsobj.show_alerts(0) # do not show pop-up alerts
    xlsfnam = xlsobj.XLSFNAM

    for shtnam in shtlst[1:]:
        xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)
    
    xlsobj.page_format(orientation="landscape",left=1.0,right=1.0,
                       top=0.5,bottom=0.5,header=0.25,footer=0.25)
    xlsobj.page_footer(left='page number of page total', right='date, time')
    xlsobj.page_header(center='file name:sheet name')
    xlsobj.font_sheet()

    # -----------------------------------------------------------
    # Retrive QV data
    qvobj = arrbox.qv_pp.QV_PP(qvfile)
    smry = qvobj.summary()

    qv_summary(xlsobj, 'summary', smry)

    row_msm = 1
    msmlabel = ['VOLTAGE SETPOINT->', 'LARGEST MVA MISMATCH', 'TOTAL MVA MISMATCH', 'CONVERGED', 'CONVERGE CONDITION']

    row_vlt = 1
    options_vlt = [False,1,True]
    mvbuslabel = list(smry.mvbuslabel)
    mvbuslabel.insert(0,'VOLTAGE SETPOINT->')

    row_gen = 1
    options_gen = [False,1,True]
    mgenbuslabel = list(smry.mgenbus)
    mgenbuslabel.insert(0,'VOLTAGE SETPOINT->')
    
    ret_ierr = 0
    for lbl in smry.colabel:
        soln = qvobj.solution(lbl)
        if soln==None: continue                 # contingency solution not found, move to next
        if soln.ierr !=0: ret_ierr = soln.ierr  # return any non-zero ierr

        row_msm = qv_mismath(xlsobj, 'mismatch',lbl,'Mismatch (MVA)',
                             row_msm,msmlabel,soln.vsetpoint,soln.mvaworst,soln.mvatotal,
                             soln.cnvflag, soln.cnvcond)
        
        row_vlt = qv_one(xlsobj,'bus voltage',lbl,'Voltage (pu)',
                         row_vlt,mvbuslabel,soln.vsetpoint,soln.volts,options_vlt,soln.cnvflag)

        row_gen = qv_one(xlsobj,'generator dispatch',lbl,'Plant (MVAR)',
                         row_gen,mgenbuslabel,soln.vsetpoint,soln.mgenmvar,options_gen,soln.cnvflag)

    # --------------------------------------
    # Format worksheets
    xlsobj.autofit_columns((1,1),'mismatch')
    xlsobj.autofit_columns((1,1),'bus voltage')
    xlsobj.autofit_columns((1,1),'generator dispatch')

    if show: xlsobj.set_active_sheet('bus voltage')
    
    # -----------------------------------------------------------
    # Save the workbook and close the Excel application
    xlsfile = xlsobj.save()

    if not show:
        xlsobj.close()
        msgstr = "\n Done ...QV Export saved to file:\n     {}." .format(xlsfnam)
        print(msgstr)

# ====================================================================================================
if (__name__ == "__main__"):
    pass
    # Change appropriately 'psseXX' and 'qvfile' values below.
    import psseXX
    qvfile = "savnw.qv"
    run_export(qvfile, overwritesheet=True, show=True)
#[gic_demo.py]    GIC Analysis in PSSE
# =====================================================================================================
'''This is an example file showing how to run different GIC Events with and without supplemental
event moving boxes.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- call function
    Run various functions from this file as desired.
    See notes in _run_one_test_api(..) (end of this file).
'''

"""
Use any of these keywords to run GIC_8.
Keyword               Default          Description
                                     # INTGOPTNS[]
tielevels           = 0              #  1  Number of levels of inter-tie buses to add to study subsystem
study_year          = 0              #  2  Year number to scale benchmark event GMD storm. These scaling factors account in the influence of geomagnetic latitude on the estimated geoelectric field magnitude and are provided in NERC TPL-007.
sid_supp            = 0              #  3  Subsystem sid for supplemental GMD event
thermal_ana_optn    = 0              #  4  Option for Transformer Thermal Analysis
degscan_pf_optn     = 0              #  5  Option to run power flow for each degree scan calculation
boundary_trn        = 0              #  6  Option to include buses of boundary transformers in study subsystem
worstcase_trn       = 0              #  7  Option for Transformers to include in worst case determination
supp_evt            = 0              #  8  Option for Supplemental event and moving box
supp_box_num        = 0              #  9  Option for number of Supplemental event moving boxes. It is not used when intgoptns(8)=0 and intgoptns(8)=4
brn_seg_efld        = 0              # 10  Option for treatment of the transmission line that intersect with Supplemental event moving box
                                     # REALOPTNS[]
efield_mag          = 8.0            #  1  electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform or supplemental
efield_deg          = 0              #  2  electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform or supplemental
substation_r        = 0.1            #  3  substation grounding dc resistance in ohms
branch_xbyr         = 30             #  4  transmission line X/R ratio, must be > 0, used to calculate branch DC resistance if R=0.0 in network data
transformer_xbyr    = 30             #  5  transformer winding X/R ratio, must be > 0, used to calculate winding DC resistance if R=0.0 in network data
efield_mag_supp     = 12.0           #  6  supplemental event electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform
efield_deg_supp     = 0.0            #  7  local GMD hot spots electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform
branch_rac2rdc      = 1.0            #  8  transmission line AC to DC resistance conversion factor, must be > 0
transformer_rac2rdc = 1.0            #  9  transformer winding AC to DC resistance conversion factor, must be > 0
degscan_step        = 10.0           # 10  Degree Scan step size, range 1.0 to 180 degrees
magscan_step        = 4.0            # 11   Magnitude Scan step size, must be > 1.0 V/km
pf_qpct_step        = 100.0          # 12   Percent GMD Mvar loss step size. Total GMD Mvar losses added incrementally to the base case to obtain power flow solution, must be > 1.0
magscan_max         = 20.0           # 13   Magnitude Scan maximum storm strength, must be > 1.0
supp_box_ns_km      = 100.0          # 14   Supplemental event moving box North-South length in km, must be > 1.0, used when intgoptns(8)>0
supp_box_ew_km      = 500.0          # 15   Supplemental event moving box East-West length in km, must be > 1.0, used when intgoptns(8)>0
supp_box_lon_c      = 0.0            # 16   Supplemental event moving box center point longitude in degrees, used only when intgoptns(8)=4
supp_box_lat_c      = 0.0            # 17   Supplemental event moving box center point latitude in degrees, used only when intgoptns(8)=4
                                     # CHAROPTNS[]
efield_type         = "uniform"      #  1  Electric Field Type
efield_unit         = "v/km"         #  2  Units of Electric Field Magnitude
addfile_optn        = "rdch"         #  3  Option to add GIC updates to base case
gic2mvar_optn       = "kfactors"     #  4  Option to select method for GIC to Mvar Calculation
earth_model_name    = ""             #  5  Earth Model Name. A Standard or User defined model name must be provided when Benchmark Event or Non-uniform electric field is to be modeled or Transformer Thermal Analysis is to be performed.
scan_storm_event    = ""             #  6  Option to scan storm event scenarios
power_flow_optn     = ""             #  7 Option to solve Power Flow with GIC losses added to the base case
                                     # EJETOPTNS[]
ejet_million_amps   = 1.0            #  1  eletrojet current in million amperes, must be > 0
ejet_halfwidth_km   = 200.0          #  2  Cauchy distribution half-width in km, must be > 0
ejet_period_min     = 5.0            #  3  period of variation in minutes, must be > 0
ejet_height_km      = 100.0          #  4  height of current in km, must be > 0
ejet_center_deg     = 54.0           #  5  latitude of center of electrojet in degrees
                                     # FILEOPTNS[]
addfile             = ""             #  2  GIC updates to Base Case file name (output).
purgfile            = ""             #  3  RDCH file to remove GIC updates from GIC updated case in working memory to set it back to Base Case network condition (output).
rnwkfile            = ""             #  4  GIC dc resistive network raw file. This represents the dc network used to calculate GIC flow (output).
pygicfile           = "nooutput"     #  5  GIC Results map data file for given Efield magnitude and degrees OR Efield magnitude and degrees scans which give maximum Var losses when scans are performed (output).  This is used by GICMAPS to plot GIC results on network map.
gictfile            = "nooutput"     #  6  Transformer Thermal Analysis GIC(t) CSV file (output).
                                     # REPTOPTNS[]
rptoptn             = -1             #  1  what to report
rptbrn_indv         = 1              #  2  report induced branch voltages
rptdc_busv          = 1              #  3  report DC bus voltages
rptbrn_gic          = 1              #  4  report branch GIC flows
rpttrn_gic          = 1              #  5  report transformer GIC flows
rptstn_gic          = 1              #  6  report substation GIC flows
rpttrn_q            = 1              #  7  report transformer losses
rpt_sid             = 0              #  8  Subsystem sid for report
"""

import sys, os, time, collections

# =========================================================================

def start_timer():
    '''start_time = start_timer()
    Start timer and return time in seconds since the Epoch.
    '''
    start_time = time.time()
    return start_time

# -------------------------------------------------------------------------

def finish_timer(start_time):
    '''timstr = finish_timer(start_time)
    Finish timer and return elapsed time as string.
    where start_time is value returned by start_timer().
    '''
    finish_time = time.time()
    elapsed_sec = finish_time - start_time
    hr,mn1 = divmod(elapsed_sec,3600)
    mn,sc  = divmod(mn1,60)
    timstr = " Elapsed time: Hours=%d , Minutes=%d, Seconds=%g\n" % (hr, mn, sc)
    return timstr

# =========================================================================

# PSSE version Example folder
def get_example_folder():
    import psspy
    pn = os.path.dirname(psspy.__file__)
    p, jnk = os.path.split(pn)
    examdir = os.path.join(p, 'Example')
    return examdir

# -------------------------------------------------------------------------

def get_output_dir(outpath=''):
    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.path.dirname(__file__)
        outdir = os.path.join(outdir, 'gic_demo_output')
        if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# -------------------------------------------------------------------------

def get_output_filename(fname, outpath=''):

    outdir = get_output_dir(outpath)
    retvfile = os.path.join(outdir, fname)

    return retvfile

# =========================================================================

def run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds):

    import psspy

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()

    name,major,minor,modlvl,date,stat = psspy.psseversion()
    vrsn = "v{}{}{}".format(major,minor,modlvl)

    if 'efield_type' not in kwds: kwds['efield_type'] = "benchmark"

    # add suffix to prg/rpt names (to make them unique, so they are not overwritten.)
    optn_nam_dict = collections.OrderedDict([
        ('efield_deg'      , 'deg' ),
        ('scan_storm_event', ''    ),
        ('power_flow_optn' , ''    ),
        ('boundary_trn'    , 'btrn'),
        ('worstcase_trn'   , 'wtrn'),
        ('supp_evt'        , 'optnbx' ),
        ('brn_seg_efld'    , 'brnseg'),
        ])

    sid_supp, supp_evt, brn_seg = 0, 0, 0
    if 'sid_supp' in kwds: sid_supp = kwds['sid_supp']
    if 'supp_evt' in kwds: supp_evt = kwds['supp_evt']
    if 'supp_box_num' in kwds: supp_box_num = kwds['supp_box_num']
    if 'supp_box_lon_c' in kwds: supp_box_lon_c = kwds['supp_box_lon_c']
    if 'supp_box_lat_c' in kwds: supp_box_lat_c = kwds['supp_box_lat_c']
    if 'brn_seg_efld' in kwds:brn_seg = kwds['brn_seg_efld']

    s_brnseg = ''
    subdir = ''
    outfsfx = kwds['efield_type'][0]
    if (supp_evt==1 and sid_supp>0)             or \
       (supp_evt in [2,3,4] and supp_box_num>0) or \
       (supp_evt==5 and abs(supp_box_lon_c)>0 and abs(supp_box_lat_c)>0):
        outfsfx += "+s"
        s_brnseg = "bseg{}".format(brn_seg)
        if supp_evt in [2,3] and supp_box_num>0:
            subdir = "supp_opbx{}_numbx{}_brnseg{}".format(supp_evt, supp_box_num, brn_seg)

    for k, s_nam in optn_nam_dict.items():
        if k in kwds:
            vin = kwds[k]
            if vin:
                if s_nam:
                    if supp_evt==1:
                        outfsfx += "_sid"
                    else:
                        outfsfx += "_{}{}".format(s_nam, vin)
                else:
                    outfsfx += "_{}".format(vin)

    if s_brnseg:
        outfsfx += "_{}".format(s_brnseg)

    outdir = get_output_dir(outdir)
    if subdir:
        outdir = os.path.join(outdir, subdir)
        if not os.path.exists(outdir): os.mkdir(outdir)

    if prg2file:
        nam = "{}_{}_progress.txt".format(outnam, outfsfx)
        prgfile = os.path.join(outdir, nam)

    if rpt2file:
        nam = "{}_{}_report.txt".format(outnam, outfsfx)
        rptfile = os.path.join(outdir, nam)

    # Create output file names when they are not provided
    for sfx in ['add', 'purg', 'rnwk', 'pygic', 'gict']:
        k = "{}file".format(sfx)
        if k not in kwds:
            s0 = sfx
            if sfx=='pygic': s0 = 'map'
            fnam = "{}_{}_{}".format(outnam, outfsfx, s0)
            kwds[k] = os.path.join(outdir, fnam)

    # run activity gic_8
    if prg2file: psspy.progress_output(2,prgfile,[0,0])
    if rpt2file: psspy.report_output(2,rptfile,[0,0])

    start_time = start_timer()
    psspy.gic_8(sid, allbus, **kwds)
    timstr = finish_timer(start_time)

    if prg2file: psspy.progress_output(1,"",[0,0])
    if rpt2file: psspy.report_output(1,"",[0,0])

    print(timstr)

    if rpt2file:
        print("  --------- Report saved to: {} ".format(rptfile))

# =========================================================================

def run_test_sample(**optns):
    import psspy
    psspy.psseinit()

    gicfilevrsn = optns.get('gicfilevrsn', 4)

    if gicfilevrsn>4:
        savfnam = r'sample_nb.sav'      # SAV file with Node Breaker Modeling
        gicfnam = r'sample_fv5.gic'     # GIC file version 5
    else:
        savfnam = r'sample.sav'         # SAV file with NO Node Breaker Modeling
        gicfnam = r'sample_fv4.gic'     # GIC file version 4

    examdir = get_example_folder()

    savfile = os.path.join(examdir, savfnam)
    gicfile = os.path.join(examdir, gicfnam)

    sid      = 0
    allbus   = 1

    outnam, jnk = os.path.splitext(savfnam)

    outdir   = get_output_dir()
    prg2file = True
    rpt2file = True

    study_year = 2019
    earth_model_name = 'SHIELD'

    kwds = {}
    kwds['study_year'] = study_year
    kwds['earth_model_name'] = earth_model_name
    kwds['addfile']  = ''
    kwds['purgfile'] = ''

    for k, v in optns.items():
        if k=='gicfilevrsn': continue
        kwds[k] = v

    if 'thermal_ana_optn' not in kwds:
        kwds['thermal_ana_optn'] = -1

    psspy.case(savfile)
    psspy.gic_read(gicfile)

    if 'sid_supp' in kwds:
        kwds['sid_supp'] = 4
        areas = [5]
        ierr = psspy.bsys(kwds['sid_supp'], numarea=len(areas), areas=areas)

    run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds)

# =========================================================================

def run_gicmaps(pygicfile):
    import arrbox.gicmaps

    outdir   = get_output_dir()
    fpth, nx = os.path.split(pygicfile)
    outnam, fxtn = os.path.splitext(nx)
    if not fpth: pygicfile = os.path.join(outdir, pygicfile)

    outdir_maps = os.path.join(outdir, 'maps')
    if not os.path.exists(outdir_maps): os.mkdir(outdir_maps)

    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    gicmapsobj.enable_draw_supp_box()

    pngfile = get_output_filename("{}_ssflow.png".format(outnam), outdir_maps)

    sublst = list(gicmapsobj.pygicobj.substation.keys())
    gicmapsobj.annotate_substations(sublst, color='blue', fontsize=10)

    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(pngfile, markersize=20)

    oufile_seg = get_output_filename("{}_brnsegments.txt".format(outnam), outdir_maps)
    gicmapsobj.report_supp_box_line_segments(rptfile=oufile_seg)

    oufile_evt = get_output_filename("{}_element_events.txt".format(outnam), outdir_maps)
    gicmapsobj.report_network_element_events(rptfile=oufile_evt)

    gicmapsobj.plots_show()

# =========================================================================

def _template_sample():
    # 1) Benchmark event
    #    No storm scan, No supplemental event, No power flow solution
    run_test_sample(efield_type='benchmark', gicfilevrsn=5)

    # 2) Supplemental event
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='supplemental', gicfilevrsn=5)

    # 3) Benchmark + Supplemental event
    #    Supplemental event defined by subsystem
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4, gicfilevrsn=5)

    # 4) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank substations with maximum GIC flows as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2, gicfilevrsn=5)

    # 5) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank transformers with maximum GIC flows as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2, gicfilevrsn=5)

    # 6) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Use substation number provided as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10, gicfilevrsn=5)

    # 7) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Use location provided as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0, gicfilevrsn=5)

    # 8) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank substations with maximum GIC flows as center of the moving box

    #    Degree Scan with specified settings [step=1 deg, add Qloss in steps of 100%]
    #    FDNS - run PowerFlow for each scan step
    #       Number of degree scans = 1+ 180/degscan_step = 181
    #       Number PF due % Qstep = 100/pf_qpct_step = 5
    #       Number PF due to moving boxes = supp_box_num = 20
    #    Number of GIC calculations = 181 (for ranking) + 181*20 (one each supp box) = 3801
    #    Number of PF solved = 181*20*5 = 18100
##    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,
##                    scan_storm_event="scan_deg", power_flow_optn='fdns',
##                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20,
##                    gicfilevrsn=5)

    print(" all done - _template_sample")

# =========================================================================
def _run_one_test_api():
    # Just run one of these calls as desired.

    run_test_sample(efield_type='benchmark')
    run_test_sample(efield_type='benchmark', gicfilevrsn=5)
    run_test_sample(efield_type='benchmark', gicfilevrsn=4)
    run_test_sample(efield_type='supplemental')
    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4)
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2)
    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2)
    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10)
    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0)
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,
                    scan_storm_event="scan_deg", power_flow_optn='fdns',
                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20)

    # Creat a function similar to "run_test_sample(..)"
    # - to use any power flow study cases
    # - define common arguments
    # - output directory etc
    # Then use that function to run the GIC study of interest.

# =========================================================================
def _run_one_test_maps():
    # Just run one of these calls as desired.
    # The 'pygic' files created by tests in "_run_one_test_api" serve as input
    # for these tests.

    run_gicmaps(r"sample_b+s_sid_bseg0_map(deg)-oldVrsn.pygic")
    run_gicmaps(r"sample_b_map(deg).pygic")
    run_gicmaps(r"sample_s_map(deg).pygic")
    run_gicmaps(r"sample_b+s_sid_bseg0_map(deg).pygic")
    run_gicmaps(r"sample_b+s_optnbx4_bseg0_map(deg).pygic")
    run_gicmaps(r"sample_b+s_optnbx5_bseg0_map(deg).pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx2_numbx2_brnseg0\sample_b+s_optnbx2_bseg0_map(deg)_supp_box1.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx2_numbx2_brnseg0\sample_b+s_optnbx2_bseg0_map(deg)_supp_box2.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx3_numbx2_brnseg0\sample_b+s_optnbx3_bseg0_map(deg)_supp_box1.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx3_numbx2_brnseg0\sample_b+s_optnbx3_bseg0_map(deg)_supp_box2.pygic")

# =========================================================================
if __name__=="__main__":
    pass
    #import psse35
#[gic_report.py]    GIC Analysis in PSSE
# =====================================================================================================
'''This is an example file showing how to:
- Create GIC data file templates in Excel spreadsheets and create GIC data file from those
  Excel spredsheets
- Perform GIC analysis, post process GIC results, create customized GIC analysis reports
- Perform GIC analysis, post process GIC results, export GIC analysis results to Excel
- Map GIC results on network maps

Python module "gicdata" is used for creating GIC data files.
    See help(gicdata) for details.

Result retrival Python module "pssarrays" is converted to Python package "arrbox".
This is done to provide object access instead of function access.

Using Python package "arrbox" it is possible to create multiple objects and compare
PSSE results.

Now Python module 'pssarrays' provide aliases to modules in package "arrbox".

GIC related objects 'GIC' and 'GICMAPS' in module 'pssarrays' will work as is (that is
without any code changes in your script). However, better way to access them is from
package arrbox as shown in this script.

See detailed help on GIC related objects in arrbox as:
import arrbox.gic;help(arrbox.gic.GIC)
import arrbox.gicmaps;help(arrbox.gicmaps.GICMAPS)

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    Run various functions from this file as desired. See notes in _run_one_test(..) (end of this file).

See function gic_results_on_network_map_custom(..) to know how you can decorate default plots with
data point annotations or any other custom settings.

---------------------------------------------------------------------------------
How to use PSSE and Python modules like numpy, matplotlib, Basemap together?
(a) In your python script, call following function before any of these modules are imported.
    psspy.set_fpcw_py()
(b) Call following function before exiting your python script.
    psspy.set_fpcw_psse()
To get details why this is needed, get help(..) on either of these functions.
Refer function gic_results_on_network_map(..) in this script for usage of these functions.
'''

# -----------------------------------------------------------------------------------------------------

import sys, os, time

# -----------------------------------------------------------------------------------------------------
# PSSE version Example folder
def get_example_folder():
    import psspy
    pn = os.path.dirname(psspy.__file__)
    p, jnk = os.path.split(pn)
    examdir = os.path.join(p, 'Example')
    return examdir

# -----------------------------------------------------------------------------------------------------

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()

    outdir = os.path.join(outdir, 'gic_report_output')
    if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# -----------------------------------------------------------------------------------------------------

def get_output_filename(outpath, fname):

    outdir = get_output_dir(outpath)
    retvfile = os.path.join(outdir, fname)

    return retvfile

# -----------------------------------------------------------------------------------------------------

def _get_outfnam_event(pfx, efield_type, efield_mag, efield_deg, scan_storm_event):

    if efield_type=='nonuniform':
        outfnam = r"{}_{}".format(pfx, efield_type[0])
    else:
        if scan_storm_event:
            outfnam = r"{}_{}_{:g}(mag)_{:g}(deg)_{}".format(pfx, efield_type[0], efield_mag, efield_deg, scan_storm_event)
        else:
            outfnam = r"{}_{}_{:g}(mag)_{:g}(deg)".format(pfx, efield_type[0], efield_mag, efield_deg)

    return outfnam

# -----------------------------------------------------------------------------------------------------

def _get_formatted_real_value(vin):

    if vin<_BIGREL:
        rstr = "{:12.5f}".format(vin)
    else:
        rstr = "{:12s}".format(' ')

    return rstr

# -----------------------------------------------------------------------------------------------------
def _get_filenam_sfx(areas):

    if areas:
        s_lst = ["{}".format(e) for e in areas[:3]]
        s_sfx = "".join(s_lst)
    else:
        s_sfx = 'all'

    return s_sfx

# -----------------------------------------------------------------------------------------------------
def create_gicdata_template_sample(datapath=None, outpath=None, areas=[], showexcel=True):
    """ Create GIC data Excel template using sample.sav file from PSSE Example folder.
"""
    import psspy, gicdata

    f_sfx = _get_filenam_sfx(areas)

    savfile   = 'sample.sav'
    excelfile = 'gicdata_sample_template_{}'.format(f_sfx)

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    excelfile = get_output_filename(outpath, excelfile)

    basekv    = []
    areas     = areas
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    psspy.psseinit()

    excelfile = gicdata.template_excel(savfile, excelfile, basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
                           tielevels=tielevels, showexcel=showexcel)
    return excelfile

# -----------------------------------------------------------------------------------------------------
def transfer_gicdata_sample(datapath=None, outpath=None, areas=[], showexcel=True):
    """ Transfer GIC data from .gic file into blank GIC data Excel template.
"""
    import psspy, gicdata

    f_sfx = _get_filenam_sfx(areas)

    gicfile_in   = 'sample_fv4.gic'
    tmplfile_in  = 'gicdata_sample_template_{}.xlsx'.format(f_sfx)
    excelfile_ou = 'gicdata_sample_{}.xlsx'.format(f_sfx)

    if not datapath: datapath = get_example_folder()

    gicfile_in   = os.path.join(datapath, gicfile_in)
    tmplfile_in  = get_output_filename(outpath, tmplfile_in)
    excelfile_ou = get_output_filename(outpath, excelfile_ou)

    showexcel = showexcel
    dbgout    = False
    prgfile   = None
    xlsfile = gicdata.transfer_data(gicfile_in, tmplfile_in, excelfile_ou,
                    showexcel=showexcel, prgfile=prgfile, dbgout=dbgout)

    return xlsfile

# -----------------------------------------------------------------------------------------------------
def gicdata_excel2gicfile(outpath=None, areas=[]):
    """ Create GIC data text file (.gic) from GIC data Excel file.
"""
    import gicdata

    f_sfx = _get_filenam_sfx(areas)
    excelfile = 'gicdata_sample_{}.xlsx'.format(f_sfx)
    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)

    excelfile = get_output_filename(outpath, excelfile)
    gicfile = get_output_filename(outpath, gicfile)

    gicdata.excel2gicfile(excelfile, gicfile)

    return gicfile

# -----------------------------------------------------------------------------------------------------
def gicdata_gicfile2excel(outpath=None, areas=[], showexcel=True):
    """ Create GIC data Excel file from GIC data text file (.gic).
"""
    import gicdata

    f_sfx = _get_filenam_sfx(areas)

    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)
    excelfile = 'gicdata_sample_{}(txt2xl).xlsx'.format(f_sfx)

    gicfile = get_output_filename(outpath, gicfile)
    excelfile = get_output_filename(outpath, excelfile)

    gicdata.gicfile2excel(gicfile, excelfile, showexcel=showexcel)

    return gicfile

# -----------------------------------------------------------------------------------------------------
def gicdata_merge(outpath=None, showexcel=True):
    """ Merge GIC data Excel files into one GIC data Excel file.
"""
    import gicdata

    flist = ['gicdata_sample_123.xlsx', 'gicdata_sample_456.xlsx']
    xl_list = []
    for fnam in flist:
        fou = get_output_filename(outpath, fnam)
        xl_list.append(fou)

    outxlnam   = "merged_sample.xlsx"
    prgfnam    = "merged_sample_progress.txt"

    outexcel = get_output_filename(outpath, outxlnam)
    prgfile  = get_output_filename(outpath, prgfnam)
    dbgout   = False

    #Allowed kwds: outexcel='', showexcel=False, prgfile=None, dbgout=False
    xlsfile = gicdata.merge_data_excel(*xl_list, outexcel=outexcel, showexcel=showexcel,
                                       prgfile=prgfile, dbgout=dbgout)

    return xlsfile

# -----------------------------------------------------------------------------------------------------
def run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):
    """ Use IEEE GIC Test Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.
Returns results in gicboj.
"""
    import psspy
    import arrbox.gic

    savfile = 'ieee_gic_test_case.sav'
    gicfile = 'ieee_gic_test_case.gic'

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    gicfile = os.path.join(datapath, gicfile)

    outdir = get_output_dir(outpath)

    if efield_type=='benchmark':
        efield_mag = 8.0
    else:
        efield_mag = 1.0

    efield_deg = 0.0

    outfnam   = _get_outfnam_event("ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    prgfile   = os.path.join(outdir, outfnam+'progress.txt')
    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')
    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')

    ejet_million_amps = 1.0
    ejet_halfwidth_km = 200.0
    ejet_period_min   = 5.0
    ejet_height_km    = 100.0
    ejet_center_deg   = 54.0

    earth_model_name = 'shield'

    efield_unit      = 'V/km'
    substation_r     = 0.1
    branch_xbyr      = 30.0
    transformer_xbyr = 30.0
    addfile          = ''
    addfile_optn     = 'rdch'
    purgfile         = ''
    rnwkfile         = ''

    basekv    = []  # specify subsystem options
    areas     = []
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    power_flow_optn  = ''   # specify power flow solution options
    pf_itmxn   = 100
    pf_toln    = 0.1
    pf_tap     = 0
    pf_area    = 0
    pf_phshft  = 0
    pf_dctap   = 1
    pf_swsh    = 1
    pf_flat    = 0
    pf_varlmt  = 99
    pf_nondiv  = 0

    psspy.psseinit()

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])
    psspy.alert_output(2,prgfile,[0,0])

    psspy.case(savfile)
    psspy.gic_read(gicfile)
    sid = 0
    busall = 1

    # run gic analysis
    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,
        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,
        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,
        efield_mag_local=0.0, efield_deg_local=0.0,
        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,
        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,
        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,
        power_flow_optn=power_flow_optn,
        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,
        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,
        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,
        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],
        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,
        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,
        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,
        pf_nondiv=pf_nondiv,
        )

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])
    psspy.alert_output(1,"",[0,0])

    return gicobj

# -----------------------------------------------------------------------------------------------------
def run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.
Returns results in gicboj.
"""
    import psspy
    import arrbox.gic

    savfile = 'sample.sav'
    gicfile = 'sample_fv4.gic'

    outdir = get_output_dir(outpath)

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    gicfile = os.path.join(datapath, gicfile)

    if efield_type=='benchmark':
        efield_mag = 8.0
    else:
        efield_mag = 1.0

    efield_deg = 0.0

    outfnam   = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    prgfile   = os.path.join(outdir, outfnam+'progress.txt')
    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')
    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')

    ejet_million_amps = 1.0
    ejet_halfwidth_km = 200.0
    ejet_period_min   = 5.0
    ejet_height_km    = 100.0
    ejet_center_deg   = 54.0

    earth_model_name = 'shield'

    efield_unit      = 'V/km'
    substation_r     = 0.1
    branch_xbyr      = 30.0
    transformer_xbyr = 30.0
    addfile          = ''
    addfile_optn     = 'rdch'
    purgfile         = ''
    rnwkfile         = ''

    basekv    = []  # specify subsystem options
    areas     = []
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    pf_itmxn   = 100    # specify power flow solution options
    pf_toln    = 0.1
    pf_tap     = 0
    pf_area    = 0
    pf_phshft  = 0
    pf_dctap   = 1
    pf_swsh    = 1
    pf_flat    = 0
    pf_varlmt  = 99
    pf_nondiv  = 0

    psspy.psseinit()

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])

    print(savfile)
    print(gicfile)

    psspy.case(savfile)
    psspy.gic_read(gicfile)
    sid = 0
    busall = 1

    # run gic analysis
    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,
        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,
        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,
        efield_mag_local=0.0, efield_deg_local=0.0,
        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,
        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,
        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,
        power_flow_optn=power_flow_optn,
        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,
        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,
        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,
        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],
        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,
        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,
        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,
        pf_nondiv=pf_nondiv,
        )

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])

    return gicobj

# -----------------------------------------------------------------------------------------------------
def run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):
    """ Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and create text report.
"""

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("ieee", efield_type, efield_mag, efield_deg, scan_storm_event)

    rptfile  = os.path.join(outdir, rptnam+'.txt')
    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')

    gicobj.text_report(rptfile)
    gicobj.qtotal_report(qrptfile)

    msg = " Report created in file: {:s}".format(rptfile)
    print(msg)

# -----------------------------------------------------------------------------------------------------
def run_gic_ieee_text_report_DIY(datapath=None, outpath=None):
    """ Run GIC Analysis on IEEE GIC Test Case provided in PSSE Example folder and create customized report.
"""
    global _BIGREL

    import psspy
    _BIGREL = psspy.getdefaultreal()     # Largest real value

    efield_mag = 1.0
    efield_deg = 0.0
    efield_type = 'uniform'
    scan_storm_event = ''

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("DIY_ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    rptfile = os.path.join(outdir, rptnam+'.txt')

    rptfobj = open(rptfile, 'w')
    report  = rptfobj.write

    elecfld_mag = "{:10.2f}".format(gicobj.misc.efield_mag)
    elecfld_mag = elecfld_mag.strip()

    elecfld_unt = gicobj.misc.efield_unit

    elecfld_deg = "{:10.2f}".format(gicobj.misc.efield_deg)
    elecfld_deg = elecfld_deg.strip()

    txt  = "\n GMD Event: Uniform Electric Field, {} {}, {} deg\n".format(elecfld_mag, elecfld_unt, elecfld_deg)

    txt += "\n GIC data file: {}\n".format(gicobj.gicfile)
    txt += " Power flow data file: {}\n".format(gicobj.savfile)

    if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:
        txt += "\n Subsystem used for GIC studiies is defined as:\n"
        if gicobj.basekv: txt += "     Voltage = {}\n".format(str(gicobj.basekv))
        if gicobj.areas:  txt += "     Areas   = {}\n".format(str(gicobj.areas))
        if gicobj.buses:  txt += "     Buses   = {}\n".format(str(gicobj.buses))
        if gicobj.owners: txt += "     Owners  = {}\n".format(str(gicobj.owners))
        if gicobj.zones:  txt += "     Zones   = {}\n".format(str(gicobj.zones))
        txt += "     Subsystem Inter tie Levels = {}\n".format(gicobj.tielevels)
    else:
        txt += "\n Subsystem used for GIC studiies comprises entire network.\n"

    txt += "\n Number of buses in study subsystem        = {}\n".format(gicobj.misc.nbus_study)
    txt += " Number of substations in study subsystem  = {}\n".format(gicobj.misc.nsubstation_study)
    txt += " Number of branches in study subsystem     = {}\n".format(gicobj.misc.nbranch_study)
    txt += " Number of transformers in study subsystem = {}\n".format(gicobj.misc.ntransformer_study)
    report(txt)

    txt  = '\n Bus DC Voltages\n'
    txt += "    Bus Substation DC Voltage(V)\n"
    report(txt)

    buslist = list(gicobj.bus.keys())
    buslist.sort()
    for eachbus in buslist:
        # all of these work, shows how to use them
        #print "attr lower-->", eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts
        #print "dict lower-->", eachbus, gicobj.bus[eachbus]['substation'], gicobj.bus[eachbus]['dcvolts']
        #print "attr mixed-->", eachbus, gicobj.bus[eachbus].suBSTation, gicobj.bus[eachbus].dcVolts
        #print "dict mixed-->", eachbus, gicobj.bus[eachbus]['subStation'], gicobj.bus[eachbus]['DCvolts']
        txt = " {:6d}     {:6d}  {:12.5f}\n".format(eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts)
        report(txt)

    txt  = '\n Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground\n'
    txt += " Substation Name         Latitude(deg) Longitude(deg) DC Voltage(V)    GIC(Amps)\n"
    report(txt)

    sslist = list(gicobj.substation.keys())
    sslist.sort()
    for ss in sslist:
        txt = "     {:6d} {:12s}  {:12.6f}   {:12.6f}  {:12.5f} {:12.5f}\n".format(ss, gicobj.substation[ss].name,
                            gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,
                            gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic)
        report(txt)

    # Non-Transformer Branches
    txt  = '\n GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus\n'
    txt += " FromBus  ToBus Ckt  Distance(km) per-Phase(A)   3-Phase(A)\n"
    report(txt)

    brnlist = list(gicobj.branch.keys())
    brnlist.sort()
    for brn in brnlist:
        txt = "  {:6d} {:6d}  {:2s}  {:12.5f} {:12.5f} {:12.5f}\n".format(brn[0], brn[1], brn[2],
                            gicobj.branch[brn].distance, gicobj.branch[brn].gic,
                            3*gicobj.branch[brn].gic)
        report(txt)

    # Transformers
    trnlist = list(gicobj.transformer.keys())
    trnlist.sort()

    no_2wdg_nrml = "\n     No two winding transformers in GIC studied network.\n"
    no_2wdg_auto = "\n     No two winding auto transformers in GIC studied network.\n"
    no_3wdg_nrml = "\n     No three winding transformers in GIC studied network.\n"
    no_3wdg_auto = "\n     No three winding auto transformers in GIC studied network.\n"

    # Two Winding Transformers - normal
    txt  = '\n Two Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += "   Ibus   Jbus Ckt       Igic(A)      Jgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)

    for trn in trnlist:
        kbus  = trn[2]
        if kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if (autoi or autoj): continue

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(trn[0], trn[1], trn[3], igic, jgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_2wdg_nrml: no_2wdg_nrml=''

    if no_2wdg_nrml: report(no_2wdg_nrml)

    # Two Winding Transformers - auto
    txt  = '\n Two Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on Series Winding bus in power flow\n"
    txt += " Common Series Ckt Common gic(A) Series gic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)
    for trn in trnlist:
        kbus  = trn[2]
        if kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if ( (not autoi) or (not autoj) ): continue
        if autoi==1:
            ibus = trn[0]
            jbus = trn[1]
        else:
            ibus = trn[1]
            jbus = trn[0]

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:7.3f} {:s} {:s}\n".format(ibus, jbus, trn[3], igic, jgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_2wdg_auto: no_2wdg_auto=''

    if no_2wdg_auto: report(no_2wdg_auto)

    # Three Winding Transformers - normal
    txt  = '\n Three Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += "   Ibus   Jbus   Kbus Ckt       Igic(A)      Jgic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)

    for trn in trnlist:
        kbus  = trn[2]
        if not kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        autok = gicobj.transformer[trn].wdg3_auto
        if (autoi or autoj or autok): continue

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(trn[0], trn[1], trn[2], trn[3], igic, jgic, kgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_3wdg_nrml: no_3wdg_nrml=''

    if no_3wdg_nrml: report(no_3wdg_nrml)

    # Three Winding Transformers - auto
    txt  = '\n Three Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += " Common Series   Kbus Ckt Common gic(A) Series gic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)
    for trn in trnlist:
        kbus  = trn[2]
        if not kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if ( (not autoi) or (not autoj) ): continue
        if autoi==1:
            ibus = trn[0]
            jbus = trn[1]
        else:
            ibus = trn[1]
            jbus = trn[0]

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_3wdg_auto: no_3wdg_auto=''

    if no_3wdg_auto: report(no_3wdg_auto)

    # Total Qloss
    if no_2wdg_nrml:
        qwdg2_nrml = '        None'
    else:
        qwdg2_nrml = "{:12.5f} Mvar".format(gicobj.qtotal.wdg2_normal)
    if no_2wdg_auto:
        qwdg2_auto = '        None'
    else:
        qwdg2_auto = "{:12.5f} Mvar".format(gicobj.qtotal.wdg2_auto)
    if no_3wdg_nrml:
        qwdg3_nrml = '        None'
    else:
        qwdg3_nrml = "{:12.5f} Mvar".format(gicobj.qtotal.wdg3_normal)
    if no_3wdg_auto:
        qwdg3_auto = '        None'
    else:
        qwdg3_auto = "{:12.5f} Mvar".format(gicobj.qtotal.wdg3_auto)
    txt  = '\n Transformer Reactive Power Loss Summary\n'
    txt += ' Two Winding Transformers        = {:s}\n'.format(qwdg2_nrml)
    txt += ' Two Winding Auto Transformers   = {:s}\n'.format(qwdg2_auto)
    txt += ' Three Winding Transformers      = {:s}\n'.format(qwdg3_nrml)
    txt += ' Three Winding Auto Transformers = {:s}\n'.format(qwdg3_auto)
    txt += '                           Total = {:12.5f} Mvar\n'.format(gicobj.qtotal.total)
    report(txt)

    # done - close report file
    if rptfile:
        rptfobj.close()
        txt = "\n GIC analysis output report saved to file: {:s}\n".format(rptfile)
        sys.stdout.write(txt)

# -----------------------------------------------------------------------------------------------------
def run_gic_ieee_excel_export_DIY(datapath=None, outpath=None, show=True):
    """ Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.
"""
    import psspy
    import excelpy

    _BIGREL = psspy.getdefaultreal()     # Largest real value

    efield_mag = 1.0
    efield_deg = 0.0
    efield_type = 'uniform'
    scan_storm_event = ''

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("DIY_ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    xlsfile = os.path.join(outdir, rptnam)

    # What to export?
    overwritesheet = True
    do_sheets = ['optn', 'bus', 'sub', 'brn', 'trn']

    _EXPORT_QTY_GIC   = {
    'optn': 'options'     ,
    'bus' : 'bus'         ,
    'sub' : 'substation'  ,
    'brn' : 'branch'      ,
    'trn' : 'transformer' ,
    }

    _WORKSHT_SEQ_GIC = ['optn','bus','sub','brn','trn']

    _WORKSHT_COLUMN_LABELS_GIC = {
        'bus': ['Bus', 'Substation', 'DC Voltage(V)'],
        'sub': ['Substation', 'Name', 'Latitude(deg)', 'Longitude(deg)', 'DC Voltage(V)', 'GIC(Amps)'],
        'brn': ['FromBus', 'ToBus', 'Ckt', 'Distance(km)', 'per-Phase(A)', '3-Phase(A)'],
        'trn_nrml': ['Ibus', 'Jbus', 'Kbus', 'Ckt', 'Igic(A)', 'Jgic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],
        'trn_auto': ['Common', 'Series', 'Kbus', 'Ckt', 'Common gic(A)', 'Series gic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],
        }

    _WORKSHT_INFO_TXT_GIC = {
        'bus': ['Bus DC Voltages'],
        'sub': ['Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground'],
        'brn': ['GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus'],
        'trn_nrml': ['Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',
                     'Reactive power loss, represented as constant current load on highest voltage bus in power flow'],
        'trn_auto': ['Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',
                     'Reactive power loss, represented as constant current load on Series Winding bus in power flow'],
        }

    gicshts = []
    for each in _WORKSHT_SEQ_GIC:
        if each in do_sheets:
            if each=='trn':
                gicshts.extend( [ _EXPORT_QTY_GIC[each], 'auto '+_EXPORT_QTY_GIC[each] ] )
            else:
                gicshts.append(_EXPORT_QTY_GIC[each])

    for i, shtnam in enumerate(gicshts):
        if i==0:
            xlsobj = excelpy.workbook(xlsfile, shtnam, overwritesheet=overwritesheet)
            if show:
                xlsobj.show()
            else:
                xlsobj.hide()

            xlsobj.show_alerts(0) # do not show pop-up alerts
            xlsfnam = xlsobj.XLSFNAM
        else:
            xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)
        xlsobj.page_format(orientation="landscape",left=1.0,right=1.0,
                           top=0.5,bottom=0.5,header=0.25,footer=0.25)
        xlsobj.page_footer(left='page number of page total', right='date, time')
        xlsobj.page_header(center='file name:sheet name')
        xlsobj.font_sheet()

    if not xlsobj:
        print("Excel file and worksheets not created.\n")

    # Options
    do_key = 'optn'
    if do_key in do_sheets:

        elecfld_mag = "{:10.2f}".format(gicobj.misc.efield_mag)
        elecfld_mag = elecfld_mag.strip()

        elecfld_unt = gicobj.misc.efield_unit

        elecfld_deg = "{:10.2f}".format(gicobj.misc.efield_deg)
        elecfld_deg = elecfld_deg.strip()

        txt  = "\n GMD Event: Uniform Electric Field, {:s} {:s}, {:s} deg\n".format(elecfld_mag, elecfld_unt, elecfld_deg)

        txt += "\n GIC data file: {:s}\n".format(gicobj.gicfile)
        txt += " Power flow data file: {:s}\n".format(gicobj.savfile)

        if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:
            txt += "\n Subsystem used for GIC studies is defined as:\n"
            if gicobj.basekv: txt += "     Voltage = {:s}\n".format(str(gicobj.basekv))
            if gicobj.areas:  txt += "     Areas   = {:s}\n".format(str(gicobj.areas))
            if gicobj.buses:  txt += "     Buses   = {:s}\n".format(str(gicobj.buses))
            if gicobj.owners: txt += "     Owners  = {:s}\n".format(str(gicobj.owners))
            if gicobj.zones:  txt += "     Zones   = {:s}\n".format(str(gicobj.zones))
            txt += "     Subsystem Inter tie Levels = {:d}\n".format(gicobj.tielevels)
        else:
            txt += "\n Subsystem used for GIC studies comprises entire network.\n"

        txt += "\n Number of buses in study subsystem        = {:d}\n".format(gicobj.misc.nbus_study)
        txt += " Number of substations in study subsystem  = {:d}\n".format(gicobj.misc.nsubstation_study)
        txt += " Number of branches in study subsystem     = {:d}\n".format(gicobj.misc.nbranch_study)
        txt += " Number of transformers in study subsystem = {:d}\n".format(gicobj.misc.ntransformer_study)

        optnlist = txt.split("\n")

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br, rc = 1, 1
        br, rc = xlsobj.set_range(br, rc, optnlist, transpose=True)

    # DC Bus voltages
    do_key = 'bus'
    if do_key in do_sheets:
        buslist = list(gicobj.bus.keys())
        buslist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for eachbus in buslist:
            tlst = [eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")

    # Substation
    do_key = 'sub'
    if do_key in do_sheets:
        sslist = list(gicobj.substation.keys())
        sslist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for ss in sslist:
            tlst = [ss, gicobj.substation[ss].name, gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,
                    gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")


    # Non-Transformer Branches
    do_key = 'brn'
    if do_key in do_sheets:
        brnlist = list(gicobj.branch.keys())
        brnlist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for brn in brnlist:
            tlst = [brn[0], brn[1], brn[2], gicobj.branch[brn].distance, gicobj.branch[brn].gic,3*gicobj.branch[brn].gic]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")

    # Transformers
    do_key = 'trn'
    if do_key in do_sheets:
        do_key_nrml = 'trn_nrml'
        do_key_auto = 'trn_auto'

        trnlist = list(gicobj.transformer.keys())
        trnlist.sort()

        rowdata_nrml = [_WORKSHT_COLUMN_LABELS_GIC[do_key_nrml]]
        rowdata_auto = [_WORKSHT_COLUMN_LABELS_GIC[do_key_auto]]

        for trn in trnlist:
            kbus  = trn[2]
            igic  = gicobj.transformer[trn].wdg1_gic
            jgic  = gicobj.transformer[trn].wdg2_gic
            if kbus:
                kgic = gicobj.transformer[trn].wdg3_gic
            else:
                kgic = None

            effgic  = gicobj.transformer[trn].eff_gic
            qloss   = gicobj.transformer[trn].qloss
            kftr    = gicobj.transformer[trn].kfactor
            kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

            autoi = gicobj.transformer[trn].wdg1_auto
            autoj = gicobj.transformer[trn].wdg2_auto
            if autoi or autoj:
                if autoi==1:
                    ibus = trn[0]
                    jbus = trn[1]
                else:
                    ibus = trn[1]
                    jbus = trn[0]
            else:
                ibus = trn[0]
                jbus = trn[1]

            if igic:
                if igic>=_BIGREL: igic = ''
            else:
                igic = ''

            if jgic:
                if jgic>=_BIGREL: jgic = ''
            else:
                jgic = ''

            if kgic:
                if kgic>=_BIGREL: kgic = ''
            else:
                kgic = ''

            if effgic:
                if effgic>=_BIGREL: effgic = ''
            else:
                effgic = ''

            if qloss:
                if qloss>=_BIGREL: qloss = ''
            else:
                qloss = ''

            tlst = [ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic, kftr, kftrtyp, qloss]
            if autoi or autoj:
                rowdata_auto.append(tlst)
            else:
                rowdata_nrml.append(tlst)

        # Total Qloss
        txt  = ' Transformer Reactive Power Loss Summary\n'
        txt += ' Two Winding Transformers        = {:g} Mvar\n' .format(gicobj.qtotal.wdg2_normal)
        txt += ' Two Winding Auto Transformers   = {:g} Mvar\n' .format(gicobj.qtotal.wdg2_auto)
        txt += ' Three Winding Transformers      = {:g} Mvar\n' .format(gicobj.qtotal.wdg3_normal)
        txt += ' Three Winding Auto Transformers = {:g} Mvar\n' .format(gicobj.qtotal.wdg3_auto)
        txt += '                           Total = {:g} Mvar'   .format(gicobj.qtotal.total)
        qlosslist = txt.split("\n")

        # normal transformers
        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 4, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata_nrml)
        del rowdata_nrml
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][0],fontStyle="bold",fontSize=12, fontColor="blue")
        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][1],fontStyle="bold",fontSize=12, fontColor="blue")

        br, rc = br+2, 1
        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)

        # auto transformers
        xlsobj.set_active_sheet('auto '+_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 4, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata_auto)
        del rowdata_auto
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][0],fontStyle="bold",fontSize=12, fontColor="blue")
        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][1],fontStyle="bold",fontSize=12, fontColor="blue")

        br, rc = br+2, 1
        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)

    # done exporting
    xlsobj.save(xlsfile)

    if not show:
        txt = "\n GIC analysis output report saved to file: \n    {0}\n".format(xlsobj.XLSFNAM)
        xlsobj.close()
        sys.stdout.write(txt)

# -----------------------------------------------------------------------------------------------------
def run_gic_sample_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder, run GIC calculations and create text report.
"""

    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    if power_flow_optn:  rptnam += '_pf'

    rptfile  = os.path.join(outdir, rptnam+'.txt')
    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')

    gicobj.text_report(rptfile)
    gicobj.qtotal_report(qrptfile)

    msg = "\n Report created in file: {:s}".format(rptfile)
    print(msg)

# -----------------------------------------------------------------------------------------------------
def run_gic_sample_excel_export(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, show=True,
                                datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.
"""
    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    if power_flow_optn:  rptnam += '_pf'

    xlfile = os.path.join(outdir, rptnam)
    string = ''
    overwritesheet = True
    xlfile = gicobj.excel_export(string, xlfile, show, overwritesheet)

    msg = "\n Spreadsheet created in file:\n    {0}".format(xlfile)
    print(msg)

# -----------------------------------------------------------------------------------------------------
def gic_results_on_network_map(pygicfile, outpath=None, outfext='.pdf', show=True):
    """ Plot GIC results on map.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.
    import arrbox.gicmaps

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(pygicfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(pygicfile):
            pygicfile = os.path.join(outdir, pygicfile)

    pltfiles = collections.OrderedDict()
    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',
              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:
        if outfext=='.pdf':
            pltfiles[k] = None
        else:
            fnam = "{}_{}{}".format(pyfnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    gicmapsobj  = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(pyfnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        gicmapsobj.pdf_open(pdffile)

    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_base'], case='base', limit='min', markersize=100)

    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_gic'], case='gic', limit='min', markersize=100)

    # combine substations GICs flowing in and out on one legend
    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic1'], markersize=20)

    # separate substations GICs flowing in and out on two legends
    gicmapsobj.set_legend_options_ss_gic_values(loc=None)
    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic2'], markersize=20)

    gicmapsobj.plot_branch_gicflows(figfile=pltfiles['brngic'])

    gicmapsobj.plot_qtotal(figfile=pltfiles['qtline'])

    gicmapsobj.plot_qtotal_barchart(figfile=pltfiles['qtbar'])

    gicmapsobj.plot_effgic(figfile=pltfiles['effgic'], gicmax=False)

    gicmapsobj.plot_effgic(figfile=pltfiles['effgicmax'], gicmax=True)

    if show:
        gicmapsobj.plots_show()
    else:
        gicmapsobj.plots_close()

    if outfext=='.pdf':
        gicmapsobj.pdf_close()

    if outfext=='.pdf':
        msg  = "\n GIC analysis custom plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC analysis custom plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

# -----------------------------------------------------------------------------------------------------
def gic_results_on_network_map_custom(pygicfile, outpath=None, outfext='.pdf', show=True):
    """ Plot GIC results on map with custom legends, annotations.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()
    import arrbox.gicmaps

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(pygicfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(pygicfile):
            pygicfile = os.path.join(outdir, pygicfile)

    outnam  = '{}_custom'.format(pyfnam)

    pltfiles = collections.OrderedDict()
    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',
              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:
        if outfext!='.pdf':
            fnam = "{}_{}{}".format(outnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(outnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        pdf2fobj = gicmapsobj.pdf2_open(pdffile)  # open pdf2 object to save custom plots to pdf file

    gicmapsobj.set_figure_size(6,4.8)

    gicmapsobj.set_state_boundary_options(show=True, color='#CCCCCC', linewidth=1.0)
    gicmapsobj.set_latitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 1], fontsize=10)
    gicmapsobj.set_longitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 3], fontsize=10)

    gicmapsobj.annotate_substations([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], color='blue', fontsize=10)

    # Plot1 - GIC case bus voltage
    pf_flag = gicmapsobj.pygicobj.power_flow_solution_flag
    if pf_flag==0:
        case = 'gic'
        if outfext!='.pdf': figfile = pltfiles['busvpu_gic']
        ttl = 'Bus Voltages - GIC Case'
    else:
        case = 'base'
        if outfext!='.pdf': figfile = pltfiles['busvpu_base']
        ttl = 'Bus Voltages - Base Case'
    ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None, case=case, limit='min', markersize=100,
                                 title=ttl)
    if ax is None:
        if outfext=='.pdf':
            gicmapsobj.pdf_close()
        return

    # data point annotation
    anptobj.set_options(xytext=(-15,-40), textcoords='offset points')
    anptobj.set_annote_from_key(5)                          # use SS number as key
    #anptobj.set_annote_from_key('ss05_mississippi')        # use SS name as key
    anptobj.set_options(xytext=(-40,-100), textcoords='offset points')
    anptobj.set_annote_from_key(7)                          # use SS number as key
    #anptobj.set_annote_from_key('ss07_yukon')
    anptobj.set_options(xytext=(-20,25), textcoords='offset points')
    anptobj.set_annote_from_key(13)                         # use SS number as key
    #anptobj.set_annote_from_key('ss13_oxus')               # use SS number as key
    anptobj.set_options(xytext=(-40,25), textcoords='offset points')
    #anptobj.set_annote_from_key(15)                        # use SS number as key
    anptobj.set_annote_from_key('ss15_heilong')             # use SS number as key

    # custom annotation
    gicmapsobj.annotate_text('LabelLeft', -89, 30.2, ax, basemap, xycoords='long_lat', color='cyan', fontsize=15)
    x, y = gicmapsobj.datapoint_xy_from_longitude_latiude(basemap, -84, 30.2)
    gicmapsobj.annotate_text('LabelRight', x, y, ax, basemap, xycoords='data', color='magenta', fontsize=15)

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)               # add custom plot to pdf file
    else:
        fig.savefig(figfile, dpi=300, bbox_inches='tight')   # save custom plot to file

    # Plot2 - Base case bus voltage
    if pf_flag==0:
        ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None,  case='base', limit='min', markersize=100,
                                     title='Bus Voltages - Base Case')
        anptobj.set_options(xytext=(-50,-50), textcoords='offset points')
        anptobj.set_annote_from_key(15)

        if outfext=='.pdf':
            gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
        else:
            fig.savefig(pltfiles['busvpu_base'], dpi=300, bbox_inches='tight')

    # Plot3 - substations GICs (combine GICs flowing in and out on one legend)
    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)

    anptobj.set_options(xytext=(-65,40), textcoords='offset points')
    anptobj.set_annote_from_key('ss01_nile')
    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')
    anptobj.set_annote_from_key('ss02_yangtze')
    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')
    anptobj.set_annote_from_key('ss03_arkansas')
    anptobj.set_options(xytext=(-20,-35), textcoords='offset points')
    anptobj.set_annote_from_key('ss09_indus')

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['ssgic1'], dpi=300, bbox_inches='tight')

    # Plot4 - substations GICs (separate GICs flowing in and out on two legends)
    gicmapsobj.set_legend_options_ss_gic_values(loc=None)
    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)
    anptobj.set_options(xytext=(-50,-50), textcoords='offset points')
    anptobj.set_annote_from_key(1)
    anptobj.set_annote_from_key(3)
    anptobj.set_annote_from_key(8)

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['ssgic2'], dpi=300, bbox_inches='tight')

    # Plot5 - Effective GIC
    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=False)
    anptobj.set_options(xytext=(-30,-30), textcoords='offset points')
    anptobj.set_annote_from_key('catdog_xmer')          # use transformer name as key
    anptobj.set_annote_from_key((3018, 3008, '11'))     # use transformer id tuple: (wdg1bus, wdg2bus, 'ckt')
                                                        # or (wdg1bus, wdg2bus, wdg3bus, 'ckt')
    anptobj.set_options(xytext=(-65,30), textcoords='offset points')
    anptobj.set_annote_from_key((203, 202, 't7'))

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['effgic'], dpi=300, bbox_inches='tight')

    # Plot6 - Maximum Effective GIC
    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=True)
    anptobj.set_options(xytext=(-30,-40), textcoords='offset points')
    anptobj.set_annote_from_key('catdog_xmer')
    anptobj.set_options(xytext=(-30,-60), textcoords='offset points')
    anptobj.set_annote_from_key(('urb tx'))
    anptobj.set_options(xytext=(-10,20), textcoords='offset points')
    anptobj.set_annote_from_key(('mid ltc'))

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['effgicmax'], dpi=300, bbox_inches='tight')

    if show:
        gicmapsobj.plots_show()
    else:
        gicmapsobj.plots_close()

    if outfext=='.pdf':
        gicmapsobj.pdf2_close(pdf2fobj)

    if outfext=='.pdf':
        msg  = "\n GIC analysis custom plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC analysis custom plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()

# -----------------------------------------------------------------------------------------------------
def gict_result_plots(gictfile, outpath=None, top_trn=10, nrows=2, ncols=2, outfext='.pdf', show=True):
    """ Plot GIC Thermal results.
top_trn - plot so many transformers with maximum GICs
nrows   - numbers of rows in plot figure
ncols   - numbers of columns in plot figure
nrows X ncols subplots are drawn on one figure.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()
    import arrbox.gicthermal

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(gictfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(gictfile):
            gictfile = os.path.join(outdir, gictfile)

    outnam  = '{}'.format(pyfnam)

    pltfiles = collections.OrderedDict()
    for k in ['evt','trn']:
        if outfext=='.pdf':
            pltfiles[k] = None
        else:
            fnam = "{}_{}{}".format(outnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    thermalobj = arrbox.gicthermal.GICTHERMAL(gictfile)

    if thermalobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(outnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        thermalobj.pdf_open(pdffile)

    evtnamlst, figdict, axdict = thermalobj.plot_events(figfile=pltfiles['evt'], show=show)

    figlst, axdict = thermalobj.plot_transformer_gict(figfile=pltfiles['trn'], top=top_trn, nrows=nrows, ncols=ncols, show=show)

    if show:
        thermalobj.plots_show()
    else:
        thermalobj.plots_close()

    if outfext=='.pdf':
        thermalobj.pdf_close()

    if outfext=='.pdf':
        msg  = "\n GIC Transformer Thermal GICT(t) profile plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC Transformer Thermal GICT(t) profile plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()

# =============================================================================================================

def run_all_tests(datapath=None, outpath=None, efields='ubn', scan='d', pf='fdns', outfext='.pdf'):

    outdir = get_output_dir(outpath)

    efield_type_lst = []
    scan_lst = []
    pf_lst = []

    if efields:
        s_efld = efields.lower()
        if 'u' in s_efld: efield_type_lst.append('uniform')
        if 'b' in s_efld: efield_type_lst.append('benchmark')
        if 'n' in s_efld: efield_type_lst.append('nonuniform')

    if scan:
        s_scan = scan.lower()
        if 'd' in s_scan: scan_lst.append('scan_deg')
        if 'm' in s_scan: scan_lst.append('scan_mag')
        if 'd_m' in s_scan: scan_lst.append('scan_d_m')

    if pf:
        pf_lst.append(pf)

    if not efield_type_lst: efield_type_lst = ['uniform']
    if not scan_lst: scan_lst = ['']
    if not pf_lst: pf_lst = ['']

    # -----------------------------------------

    print ("\n >>>>>>>>>>>>> Running create_gicdata_template_sample")
    excelfile = create_gicdata_template_sample(datapath, outpath, showexcel=False)

    print ("\n >>>>>>>>>>>>> Running excel2gicfile")
    gicdata_excel2gicfile(outpath)

    efield_mag = 1.0
    efield_deg = 0.0

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_text_report")
    for efield_type in efield_type_lst:
        for scan_storm_event in scan_lst:
            run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event,datapath, outpath)
            break

    print ("\n >>>>>>>>>>>>> Running run_gic_sample_text_report")
    for efield_type in efield_type_lst:
        for scan_storm_event in scan_lst:
            for power_flow_optn in pf_lst:
                run_gic_sample_text_report(efield_mag, efield_deg, efield_type,
                                           scan_storm_event, power_flow_optn, datapath, outpath)
                break

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_text_report_DIY")
    run_gic_ieee_text_report_DIY(datapath, outpath)

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_excel_export_DIY")
    run_gic_ieee_excel_export_DIY(datapath, outpath, show=False)


    print ("\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, no scan, no powerflow")
    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='',
                                power_flow_optn='',     show=False, datapath=datapath, outpath=outpath)

    print ("\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, scan_deg, fdns")
    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='scan_deg',
                                power_flow_optn='fdns', show=False, datapath=datapath, outpath=outpath)


    pygicfile = ''
    for fnam in os.listdir(outdir):
        n, x = os.path.splitext(fnam)
        if x=='.pygic':
            i = n.find('sample')
            if i>=0:
                pygicfile = os.path.join(outdir, fnam)
                break

    print ("\n >>>>>>>>>>>>> Running gic_results_on_network_map")
    if pygicfile:
        gic_results_on_network_map(pygicfile, outpath, outfext=outfext, show=False)
    else:
        print ("    mapdata file does not exist.\n    {}\n".format(pygicfile))

    print ("\n >>>>>>>>>>>>> Running gic_results_on_network_map_custom")
    if pygicfile:
        gic_results_on_network_map_custom(pygicfile, outpath, outfext=outfext, show=False)
    else:
        print ("    mapdata file does not exist.\n    {}\n".format(pygicfile))

    gictfile = ''
    for fnam in os.listdir(outdir):
        n, x = os.path.splitext(fnam)
        if x=='.csv':
            i = n.find('sample')
            if i>=0:
                gictfile = os.path.join(outdir, fnam)
                break

    print ("\n >>>>>>>>>>>>> Running gicthermal")
    if gictfile:
        gict_result_plots(gictfile, outpath, outfext=outfext, show=False)
    else:
        print ("    GIC results gict CSV file does not exist.\n")

# =============================================================================================================

def run_gicdata_templates(outpath=None):
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[], showexcel=True)
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[4,5,6], showexcel=False)

# =============================================================================================================

def run_gicdata_transfer(outpath=None):
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[], showexcel=False)
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[4,5,6], showexcel=False)

# =============================================================================================================

def run_gicdata_excel2gicfile(outpath=None):
    gicfile = gicdata_excel2gicfile(outpath=outpath, areas=[])
    gicfile = gicdata_excel2gicfile(outpath=outpath, areas=[1,2,3])
    gicfile = gicdata_excel2gicfile(outpath=outpath, areas=[4,5,6])

# =============================================================================================================

def run_gicdata_gicfile2excel(outpath=None):
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[], showexcel=False)
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[4,5,6], showexcel=False)

# =============================================================================================================

def run_gicdata_merge(outpath=None):
    excelfile = gicdata_merge(outpath=outpath, showexcel=False)

# =============================================================================================================

def run_gicdata_all(outpath=None):
    """ Run all gicdata tests.
"""
    run_gicdata_templates(outpath)
    run_gicdata_transfer(outpath)
    run_gicdata_excel2gicfile(outpath)
    run_gicdata_gicfile2excel(outpath)
    run_gicdata_merge(outpath)

# =============================================================================================================
def _run_one_test():

    # Run these one by one in __main__ (just copy each line in __main__ and run).
    #
    # - Function create_gicdata_template_sample() must be run before running gicdata_excel2gicfile().
    # - Functions run_gic_ieee_text_report(..) and run_gic_sample_text_report(..) return pygicfile name.
    #   Use that as input to gic_results_on_network_map(..) and gic_results_on_network_map_custom(..).

    # GIC data tests
    run_gicdata_templates()
    run_gicdata_transfer()
    run_gicdata_excel2gicfile()
    run_gicdata_gicfile2excel()
    run_gicdata_merge()

    # GIC calculation tests
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg')
    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg')    # scan not allowed, so does not scan

    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_mag', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_d_m', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg', power_flow_optn='fdns') # scan not allowed, so does not scan

    run_gic_ieee_text_report_DIY()
    run_gic_ieee_excel_export_DIY(show=True)

    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',   scan_storm_event='',         power_flow_optn='',     show=True)
    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_deg', power_flow_optn='fdns', show=True)
    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_d_m', power_flow_optn='fdns', show=True)

    pygicfile = r"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic"
    gic_results_on_network_map(pygicfile, show=False)

    pygicfile = r"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic"
    gic_results_on_network_map_custom(pygicfile, show=False)

    # ---------------------------------
    run_all_tests(datapath=datapath, outpath=outpath, efields='ubn', scan='d_m', pf='fdns')
    run_all_tests(datapath=None, outpath=None, efields='b', scan='', pf='', outfext='.png')

# =============================================================================================================
if __name__ == '__main__':
    pass
    import psse35
#[harmonics_demo.py]    Harmonics Analysis in PSSE
# =====================================================================================================
'''This is an example file showing how to run Harmonics Analysis.
   Plot frequency scan results.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- call function
    Run various functions from this file as desired.
    Refer test1(..) ... functions towards end of this file.
'''

"""
Use any of these keywords to run har_analysis_2.
Keyword     Default     Description
                      # INTGAR[]
fscanoptn   = 1       # 1 frequency scan option: 0 no; =1 yes
dstnoptn    = 1       # 2 distortion calculations option: 0 no; =1 yes

linmdl      = 0       # 3 line model option:  =0 nominal pi; =1 long line with skin effect;
                      #                       =2 long line but no skin effect
dstnbuop    = 0       # 4 bus option in dstn: =0 all buses; =1 only study subsystem buses
dstnrptop   = 0       # 5 bus option in dstn: =0 only THDs; =1 THDs + contributions
imachimpop  = 0       # 6 induction machine impedance option =0 from power flow data; =1 from sequene data
dcimpop     = 0       # 7 2TDC, VSCDC and MTDC equivalent impedance option in fscan =0 block; 1=consider
triplenop   = 0       # 8 Triplen Harmonics Option in distortion calculations =0 ignore; =1 consider
genimpop    = 0       # 9 generatir impedance option:  =0 Use ZSORCE impedance from power flow data
                      #                                =1 Use subtransient impedance from sequence data
                      #                                =2 Use transient impedance from sequence data
                      #                                =3 Use synchronous impedance from sequence data
                      #                                =4 Use negative sequence impedance from sequence data
mdltypop    = 0       # 10 harmonics Model Type Option, allowed 0 or 1
load_mdltyp = 0       # 11 load model type
gen_mdltyp  = 0       # 12 gen model type
brnsh_mdltyp= 0       # 13 branch shunt model type
trn_mdltyp  = 0       # 14 trn model type
fctsh_mdltyp= 0       # 15 facts shunt model type
fctse_mdltyp= 0       # 16 facts series model type
imach_mdltyp= 0       # 17 induction machine model type

                      # REALAR[]
hord_min    =  0.1    # 1 Minimum Harmonic Order
hord_max    = 50.0    # 2 Maximum Harmonic Order
hord_stp    =  0.1    # 3 Harmonic Order Step
                      # FILEAR[]
hrsfile     = ''      # 1 Binary Results File Name (.hrs)
dstnfile    = ''      # 2 Distortion Calculation Report File Name (.txt)
resnfile    = ''      # 3 Frequency Scan Resonance Report File Name (.txt)
"""

import sys, os, math, traceback, textwrap

_COLOR_PREFERENCE = ['orange', 'green', 'blue', 'red']
_COLOR_PREFERENCE_BUS = ['red', 'blue']
_ALLOWED_FIG_FILE_TYPES = ['eps', 'jpeg', 'jpg', 'pdf', 'pgf', 'png', 'ps', 'raw', 'rgba', 'svg', 'svgz', 'tif', 'tiff']

# ==============================================================================

# This data is from file CASE1TB.XLS of IEEE Task Force on Harmonics Modeling & Simulation
# Frequency Scan Thevenin Impedance
# Distributed Line Model: ZRdist, ZXdist, Zdist
# Pi Line Model: Zpi

#    HORD       , ZRdist        ,  ZXdist       , Zdist , Zpi
_ieee_tf_scan_results = [
    [1.00	, 0.0534	, 0.2197	, 0.226	, 0.226  ],
    [1.33	, 0.0793	, 0.3239	, 0.334	, 0.334  ],
    [1.67	, 0.1371	, 0.4711	, 0.491	, 0.492  ],
    [2.00	, 0.2075	, 0.5667	, 0.603	, 0.606  ],
    [2.33	, 0.5381	, 0.9926	, 1.129	, 1.136  ],
    [2.67	, 1.7230	, 1.1320	, 2.062	, 2.081  ],
    [3.00	, 2.0150	, -0.9333	, 2.221	, 2.217  ],
    [3.33	, 0.7628	, -1.0731	, 1.317	, 1.312  ],
    [3.67	, 0.3951	, -0.7590	, 0.856	, 0.855  ],
    [4.00	, 0.3626	, -0.5387	, 0.649	, 0.652  ],
    [4.33	, 0.3141	, -0.7507	, 0.814	, 0.806  ],
    [4.67	, 0.0891	, -0.5594	, 0.566	, 0.564  ],
    [5.00	, 0.0570	, -0.4405	, 0.444	, 0.443  ],
    [5.33	, 0.0460	, -0.3673	, 0.370	, 0.370  ],
    [5.67	, 0.0430	, -0.3170	, 0.320	, 0.320  ],
    [6.00	, 0.0378	, -0.2885	, 0.291	, 0.291  ],
    [6.33	, 0.0219	, -0.2551	, 0.256	, 0.256  ],
    [6.67	, 0.0166	, -0.2223	, 0.223	, 0.224  ],
    [7.00	, 0.0144	, -0.1957	, 0.196	, 0.197  ],
    [7.33	, 0.0131	, -0.1732	, 0.174	, 0.175  ],
    [7.67	, 0.0122	, -0.1537	, 0.154	, 0.155  ],
    [8.00	, 0.0116	, -0.1364	, 0.137	, 0.138  ],
    [8.33	, 0.0112	, -0.1211	, 0.122	, 0.123  ],
    [8.67	, 0.0105	, -0.1076	, 0.108	, 0.109  ],
    [9.00	, 0.0091	, -0.0949	, 0.095	, 0.096  ],
    [9.33	, 0.0077	, -0.0823	, 0.083	, 0.084  ],
    [9.67	, 0.0072	, -0.0702	, 0.071	, 0.071  ],
    [10.00	, 0.0071	, -0.0593	, 0.060	, 0.060  ],
    [10.33	, 0.0067	, -0.0498	, 0.050	, 0.050  ],
    [10.67	, 0.0051	, -0.0409	, 0.041	, 0.041  ],
    [11.00	, 0.0029	, -0.0311	, 0.031	, 0.031  ],
    [11.33	, 0.0014	, -0.0207	, 0.021	, 0.021  ],
    [11.67	, 0.0008	, -0.0105	, 0.011	, 0.010  ],
    [12.00	, 0.0007	, -0.0009	, 0.001	, 0.001  ],
    [12.33	, 0.0007	, 0.0081	, 0.008	, 0.008  ],
    [12.67	, 0.0008	, 0.0168	, 0.017	, 0.017  ],
    [13.00	, 0.0008	, 0.0251	, 0.025	, 0.025  ],
    [13.33	, 0.0009	, 0.0331	, 0.033	, 0.033  ],
    [13.67	, 0.0010	, 0.0410	, 0.041	, 0.041  ],
    [14.00	, 0.0010	, 0.0487	, 0.049	, 0.049  ],
    [14.33	, 0.0010	, 0.0562	, 0.056	, 0.057  ],
    [14.67	, 0.0010	, 0.0636	, 0.064	, 0.065  ],
    [15.00	, 0.0010	, 0.0709	, 0.071	, 0.072  ],
    [15.33	, 0.0010	, 0.0782	, 0.078	, 0.080  ],
    [15.67	, 0.0009	, 0.0855	, 0.085	, 0.087  ],
    [16.00	, 0.0009	, 0.0927	, 0.093	, 0.095  ],
    [16.33	, 0.0009	, 0.0998	, 0.100	, 0.102  ],
    [16.67	, 0.0009	, 0.1070	, 0.107	, 0.110  ],
    [17.00	, 0.0010	, 0.1141	, 0.114	, 0.117  ],
    [17.33	, 0.0010	, 0.1213	, 0.121	, 0.124  ],
    [17.66	, 0.0010	, 0.1285	, 0.129	, 0.132  ],
    [18.00	, 0.0010	, 0.1357	, 0.136	, 0.139  ],
    [18.33	, 0.0011	, 0.1430	, 0.143	, 0.147  ],
    [18.66	, 0.0011	, 0.1504	, 0.150	, 0.154  ],
    [19.00	, 0.0012	, 0.1579	, 0.158	, 0.162  ],
    [19.33	, 0.0012	, 0.1654	, 0.165	, 0.170  ],
    [19.66	, 0.0013	, 0.1732	, 0.173	, 0.178  ],
    [20.00	, 0.0014	, 0.1811	, 0.181	, 0.186  ],
    [20.33	, 0.0015	, 0.1892	, 0.189	, 0.194  ],
    [20.66	, 0.0016	, 0.1975	, 0.198	, 0.203  ],
    [21.00	, 0.0018	, 0.2062	, 0.206	, 0.211  ],
    [21.33	, 0.0019	, 0.2153	, 0.215	, 0.218  ],
    [21.66	, 0.0022	, 0.2247	, 0.225	, 0.224  ],
    [22.00	, 0.0025	, 0.2348	, 0.235	, 0.229  ],
    [22.33	, 0.0029	, 0.2456	, 0.246	, 0.236  ],
    [22.66	, 0.0034	, 0.2573	, 0.257	, 0.245  ],
    [23.00	, 0.0041	, 0.2703	, 0.270	, 0.254  ],
    [23.33	, 0.0052	, 0.2850	, 0.285	, 0.263  ],
    [23.66	, 0.0068	, 0.3023	, 0.302	, 0.273  ],
    [24.00	, 0.0094	, 0.3239	, 0.324	, 0.282  ],
    [24.33	, 0.0142	, 0.3530	, 0.353	, 0.292  ],
    [24.66	, 0.0258	, 0.3988	, 0.400	, 0.302  ],
    [25.00	, 0.0767	, 0.4914	, 0.497	, 0.313  ],
    [25.33	, 0.3804	, 0.4516	, 0.590	, 0.324  ],
    [25.66	, 0.2886	, 0.2076	, 0.355	, 0.336  ],
    [26.00	, 0.1861	, 0.1507	, 0.239	, 0.350  ],
    [26.33	, 0.0983	, 0.1640	, 0.191	, 0.366  ],
    [26.66	, 0.0543	, 0.2017	, 0.209	, 0.391  ],
    [27.00	, 0.0341	, 0.2359	, 0.238	, 0.384  ],
    [27.33	, 0.0239	, 0.2646	, 0.266	, 0.348  ],
    [27.66	, 0.0184	, 0.2898	, 0.290	, 0.374  ],
    [28.00	, 0.0152	, 0.3130	, 0.313	, 0.392  ],
    [28.33	, 0.0133	, 0.3355	, 0.336	, 0.407  ],
    [28.66	, 0.0122	, 0.3581	, 0.358	, 0.422  ],
    [29.00	, 0.0117	, 0.3815	, 0.382	, 0.437  ],
    [29.33	, 0.0118	, 0.4067	, 0.407	, 0.451  ],
    [29.66	, 0.0123	, 0.4343	, 0.434	, 0.466  ],
    [30.00	, 0.0133	, 0.4655	, 0.466	, 0.481  ],
    [30.33	, 0.0151	, 0.5019	, 0.502	, 0.497  ],
    [30.66	, 0.0179	, 0.5456	, 0.546	, 0.513  ],
    [31.00	, 0.0225	, 0.6004	, 0.601	, 0.530  ],
    [31.33	, 0.0301	, 0.6723	, 0.673	, 0.547  ],
    [31.66	, 0.0439	, 0.7735	, 0.775	, 0.565  ],
    [32.00	, 0.0731	, 0.9304	, 0.933	, 0.583  ],
    [32.33	, 0.1517	, 1.2148	, 1.224	, 0.603  ],
    [32.66	, 0.5070	, 1.8932	, 1.960	, 0.623  ],
    [33.00	, 4.5494	, 1.5400	, 4.803	, 0.645  ],
    [33.33	, 0.7725	, -1.1678	, 1.400	, 0.667  ],
    [33.66	, 0.2861	, -0.3206	, 0.430	, 0.691  ],
    [34.00	, 0.3196	, 0.1241	, 0.343	, 0.716  ],
    [34.33	, 0.9273	, 0.2502	, 0.960	, 0.743  ],
    [34.66	, 0.5444	, -0.5749	, 0.792	, 0.771  ],
    [35.00	, 0.1669	, -0.3331	, 0.373	, 0.801  ],
    [35.33	, 0.0812	, -0.1640	, 0.183	, 0.834  ],
    [35.66	, 0.0508	, -0.0578	, 0.077	, 0.870  ],
    [36.00	, 0.0367	, 0.0179	, 0.041	, 0.909  ],
    [36.33	, 0.0293	, 0.0777	, 0.083	, 0.952  ],
    [36.66	, 0.0255	, 0.1291	, 0.132	, 1.001  ],
    [37.00	, 0.0242	, 0.1773	, 0.179	, 1.058  ],
    [37.33	, 0.0257	, 0.2270	, 0.228	, 1.125  ],
    [37.66	, 0.0320	, 0.2852	, 0.287	, 1.201  ],
    [38.00	, 0.0506	, 0.3663	, 0.370	, 1.266  ],
    [38.33	, 0.1213	, 0.5124	, 0.527	, 1.224  ],
    [38.66	, 0.6464	, 0.7361	, 0.980	, 1.079  ],
    [39.00	, 0.4533	, -0.3164	, 0.553	, 1.047  ],
    [39.33	, 0.1071	, -0.0794	, 0.133	, 1.102  ],
    [39.66	, 0.0490	, 0.0401	, 0.063	, 1.178  ],
    [40.00	, 0.0302	, 0.1057	, 0.110	, 1.260  ],
    ]

# Reference:
# "Test Systems for Harmonics Modeling and Simulation",
# IEEE Transactions on Power Delivery, Vol. 11, No. 1, January 1996, Pages 466-474
#     Bus, Nominal kV,  LF Volts pu, LF Ang deg,  THD%
_ieee_tf_dstn_pf_thd_results = [
    [   1,      230.0,       1.0600,       0.00,  1.767 ],
    [   2,      230.0,       1.0450,      -5.68,  2.177 ],
    [   3,      230.0,       1.0427,     -15.30,  1.516 ],
    [   4,      230.0,       1.0282,     -11.41,  0.755 ],
    [   5,      230.0,       1.0337,      -9.82,  1.462 ],
    [   6,      115.0,       1.0700,     -15.87,  0.468 ],
    [   7,      230.0,       1.0193,     -14.47,  0.423 ],
    [   8,       13.8,       1.0209,     -14.49,  0.522 ],
    [   9,      115.0,       1.0147,     -16.09,  0.482 ],
    [  10,      115.0,       1.0168,     -16.33,  0.421 ],
    [  11,      115.0,       1.0394,     -16.21,  0.394 ],
    [  12,      115.0,       1.0528,     -16.72,  0.391 ],
    [  13,      115.0,       1.0458,     -16.73,  0.376 ],
    [  14,      115.0,       1.0154,     -17.39,  0.343 ],
    [ 301,       35.4,       1.0417,     -16.18,  9.169 ],
    [ 302,       35.4,       1.0417,     -16.18,  9.169 ],
    ]

#   Hord,   %mag,    deg
_ieee_tf_dstn_cursrc_hvdc = [
    [  1, 100.00, -49.56 ],
    [  5,  19.41, -67.77 ],
    [  7,  13.09,  11.9  ],
    [ 11,   7.58,  -7.13 ],
    [ 13,   5.86,  68.57 ],
    [ 17,   3.79,  46.53 ],
    [ 19,   3.29, 116.46 ],
    [ 23,   2.26,  87.47 ],
    [ 25,   2.41, 159.32 ],
    [ 29,   1.93, 126.79 ],
    ]

_ieee_tf_dstn_cursrc_tcr = [
    [  1, 100.00,   46.92 ],
    [  5,   7.02, -124.40 ],
    [  7,   2.50,  -29.87 ],
    [ 11,   1.36,  -23.75 ],
    [ 13,   0.75,   71.50 ],
    [ 17,   0.62,   77.12 ],
    [ 19,   0.32,  173.43 ],
    [ 23,   0.43,  178.02 ],
    [ 25,   0.13,  -83.45 ],
    [ 29,   0.40,  -80.45 ],
    ]

# ===========================================================================================
# IEEE 519-2022 and IEEE 519-2014
#
# Table 1 - Voltage Distortion Limits
# All values should be in percent of the rated power frequency voltage at the PCC.
# Applies to voltage harmonics whose frequencies are integer multiples of the power frequency.
_ieee519_table1_thd_limits = {
    1.0  : {'indv': 5.0, 'thd': 8.0},                   # V <= 1.0 kV
    69.0 : {'indv': 3.0, 'thd': 5.0},                   # 1 kV < V <= 69.0 kV
    161.0: {'indv': 1.5, 'thd': 2.5},                   # 69.0 kV < V <= 161.0 kV
    999.0: {'indv': 1.0, 'thd': 1.5, 'thd_hvdc': 2.0},  # 161.0 kV < V
    }

_ieee519_vlimits = list(_ieee519_table1_thd_limits.keys())
_ieee519_vlimits.sort()

# ==============================================================================

def get_ieee_tf_scan_results():
    """Get IEEE Harmonics Task Force Test Case Frequency Scan Results.
    """
    hord_lst, zcal_lst, zdst_lst, zpi_lst = [], [], [], []
    for eachlist in _ieee_tf_scan_results:
        h, zr, zx, z1d, z1pi = eachlist
        zrx = complex(zr, zx)
        z = abs(zrx)
        hord_lst.append(h)
        zcal_lst.append(z)
        zdst_lst.append(z1d)
        zpi_lst.append(z1pi)

    return hord_lst, zcal_lst, zdst_lst, zpi_lst

# ==============================================================================

def get_ieee_tf_dstn_pf_thd_results():
    """Get IEEE Harmonics Task Force Test Case Distortion Calculation Results.
    """
    tf_keytup = ('bus', 'basekv', 'vmag', 'vang', 'thd')

    tfresults_pf_thd_dict = {}
    for row in _ieee_tf_dstn_pf_thd_results:
        for dk, val in zip(tf_keytup, row):
            if dk=='bus':
                bus = val
                tfresults_pf_thd_dict[bus] = {}
            else:
                tfresults_pf_thd_dict[bus][dk] = val

    return tfresults_pf_thd_dict

# ==============================================================================

def get_ieee_tf_dstn_cursrc():
    """Get IEEE Harmonics Task Force Test Case Harmonic Current Source Spectrum.
    """

    tfresults_cursrc_dict = {'hvdc':{}, 'tcr':{}}

    for eachrow in _ieee_tf_dstn_cursrc_hvdc:
        hord, imag, iang = eachrow
        tfresults_cursrc_dict['hvdc'][hord] = {'imag':imag, 'iang':iang}

    tfresults_cursrc_tcr_dict = {}
    for eachrow in _ieee_tf_dstn_cursrc_tcr:
        hord, imag, iang = eachrow
        tfresults_cursrc_dict['tcr'][hord] = {'imag':imag, 'iang':iang}

    return tfresults_cursrc_dict

# ==============================================================================

def get_resn_legends(peak_lst_h, peak_lst_rx, valley_lst_h=None, valley_lst_rx=None):
    """Get Frequency Scan Resonance legends.
    """
    txtlst = []
    txtlst.append("")
    txtlst.append("Parallel (peaks)")
    if peak_lst_rx:
        txtlst.append("Hord, Z")
        for h, pu in zip(peak_lst_h, peak_lst_rx):
            txt = "{:g}, {:g}".format(h, pu)
            txtlst.append(txt)
    else:
        txt = " None"
        txtlst.append(txt)

    if valley_lst_h:
        txtlst.append("")
        txtlst.append("Series (valleys)")
        if valley_lst_rx:
            txtlst.append("H,  Z")
            for h, pu in zip(valley_lst_h, valley_lst_rx):
                txt = "{:4.2f}, {:5.3f}".format(h, pu)
                txtlst.append(txt)
        else:
            txt = " None"
            txtlst.append(txt)

    return txtlst

# ==============================================================================
def _write_verbose_report(txt, report):
    if report is not None:
        report(txt)

class _SimpleObject(object):
    """Used for creating dummy object and set attributes as needed.
    """
    pass

def _set_rsn_object(**kwds):
    rsnobj = _SimpleObject()
    for k in ['x1', 'y1', 'x2', 'y2', 'inam', 'hidx', 'rflg']:
        setattr(rsnobj, k, kwds[k])
    return rsnobj

def _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=None, dltn=None):
    ok1, ok2 = False, False

    ok_pctc1 = pctc>=pctmx1
    ok_pctc2 = pctc>=pctmx2

    if dltp is not None:
        ok_dltp1 = dltp>=dpctpn1
        ok_dltp2 = dltp>=dpctpn2

    if dltn is not None:
        ok_dltn1 = dltn>=dpctpn1
        ok_dltn2 = dltn>=dpctpn2

    if dltp is None:
        ok1 = ok_pctc1 and ok_dltn1
        ok2 = ok_pctc2 and ok_dltn2
    elif dltn is None:
        ok1 = ok_pctc1 and ok_dltp1
        ok2 = ok_pctc2 and ok_dltp2
    else:
        ok1 = ok_pctc1 and (ok_dltp1 or ok_dltn1)
        ok2 = ok_pctc2 and (ok_dltp2 or ok_dltn2)

    found = ok1 or ok2

    return found

def _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report):

    resn_pks_hord, resn_pks_zmag = [], []

    txtlst = []
    txtlst.append("")
    txtlst.append("Parallel (peaks)")

    if not resn_pkvls:
        txt = " None"
        txtlst.append(txt)

        txt = "\n".join(txtlst)
        _write_verbose_report(txt, report)

        return resn_pks_hord, resn_pks_zmag

    # ------------

    nnlst = len(resn_pkvls)

    txtlst.append("   X1,     Y1,     X2,     Y2,  %Ymax,  %dltY,  Found")

    for ii in range(nnlst):

        pt_crnt = resn_pkvls[ii]
        inam = pt_crnt.inam
        if inam!='peak': continue

        ipt_p = False
        ipt_n = False

        if ii==0:
            if nnlst>1:
                ipt_n = True
                pt_next = resn_pkvls[ii+1]
        elif ii==nnlst-1:
            ipt_p = True
            pt_prev = resn_pkvls[ii-1]
        else:
            ipt_p = True
            ipt_n = True
            pt_prev = resn_pkvls[ii-1]
            pt_next = resn_pkvls[ii+1]

        pctc = pt_crnt.y2*100/ymxpk                 # current value in percent of max

        found = False
        if ii==0:
            if ipt_n:
                dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2
                found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltn=dltn)
        elif ii==nnlst-1:
            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2
            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp)
        else:
            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2
            dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2
            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp, dltn=dltn)

        if found:
            resn_pkvls[ii].rflg = 1

        if ipt_p:
            txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}".format(pt_prev.x1, pt_prev.y1, pt_prev.x2, pt_prev.y2, '', dltp)
            txtlst.append(txt)

        txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6.2f}, {:6s},  {}".format(pt_crnt.x1, pt_crnt.y1, pt_crnt.x2, pt_crnt.y2, pctc, '', found)
        txtlst.append(txt)

        if ipt_n:
            txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}".format(pt_next.x1, pt_next.y1, pt_next.x2, pt_next.y2, '', dltn)
            txtlst.append(txt)

        txtlst.append("")

    txt = "\n".join(txtlst)
    _write_verbose_report(txt, report)

    # done filtering
    for rsnobj in resn_pkvls:
        inam = rsnobj.inam
        rflg = rsnobj.rflg
        if inam=='peak' and rflg==1:
            resn_pks_hord.append(rsnobj.x2)
            resn_pks_zmag.append(rsnobj.y2)

    return resn_pks_hord, resn_pks_zmag

def check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=None):
    """Check and find Frequency Scan Resonances.
    """

    resn_pkvls = []
    nhord = len(hlst)
    for hh in range(nhord):
        hord = hlst[hh]
        zmag = zlst[hh]
        if hh==0:
            x1, y1 = hord, zmag
            xb, yb = hord, zmag    # beginning point
            ymxpk  = zmag
        else:
            x2, y2 = hord, zmag
            m2 = (y1-y2)/(x1-x2)
            if hh>1:
                if m1>0 and m2<0:           # found peak
                    inam = 'peak'
                    if y1>y2:
                        pt = 0
                    else:
                        pt = 1
                elif m1<0 and m2>0:         # found valley
                    inam = 'valy'
                    if y1<y2:
                        pt = 0
                    else:
                        pt = 1
                else:
                    inam = 'none'

                if inam!='none':
                    if pt==0:
                        xn = x1
                        yn = y1
                        hidx = hh-1
                    else:
                        xn = x2
                        yn = y2
                        hidx = hh

                    if inam=='peak' and yn>ymxpk:
                        ymxpk = yn

                    rsnobj = _set_rsn_object(x1=xb, y1=yb, x2=xn, y2=yn, inam=inam, hidx=hidx, rflg=0)
                    resn_pkvls.append(rsnobj)

                    # next segment begin point
                    xb, yb = xn, yn

            # update and go to next point
            m1, x1, y1 = m2, x2, y2

    # Filter Peak Resonance Points
    resn_pks_hord, resn_pks_zmag = _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report)
    _write_verbose_report('\n', report)

    return resn_pks_hord, resn_pks_zmag

# ==============================================================================

def get_fscan_csvdata(csvfile):
    """Get frequency scan Thevenin Impedance data from PSSE results file.
    """
    import csv

    thevz_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        for row in reader:
            bus   = row[0]
            sec   = row[1]
            nam   = row[2]
            basekv= row[3]
            desc  = row[4].strip()
            if desc=='HORD':
                thevz_dict['hord'] = [float(v) for v in row[5:]]
            else:
                iext = int(bus)
                try:
                    isec = int(sec)
                except:
                    isec = 0
                if isec>0:
                    dkey = (iext, isec)
                else:
                    dkey = iext
                if desc=='pu abs(thevz)':
                    bnam = nam.strip()
                    bkv  = float(basekv)
                    thevz_dict[dkey] = {'basekv': bkv, 'name': bnam}
                    thevz_dict[dkey]['mag'] = [float(v) for v in row[5:]]
                elif desc=='deg phase(thevz)':
                    thevz_dict[dkey]['phase'] = [float(v) for v in row[5:]]
                else:
                    txt = "Reading Harmonics FSCAN CSVFILE error, should not come here."
                    raise Exception(txt)

    return thevz_dict

# ==============================================================================

def get_hord_thevz_list(thevz_dict, busnum=None):
    """Get frequency scan Thevenin impedance harmonic orders.
    """
    found = False
    klst = list(thevz_dict.keys())
    for k in klst:
        if k=='hord': continue
        if busnum is None:
            busnum = k
            found = True
            break
        else:
            if k==busnum:
                found = True
                break

    if found:
        hord_lst = thevz_dict['hord'][:]
        thevz_mag_lst = thevz_dict[busnum]['mag'][:]
        thevz_phs_lst = thevz_dict[busnum]['phase'][:]
        ierr = False
    else:
        ierr = True
        hord_lst, thevz_mag_lst, thevz_phs_lst = [], [], []

    return ierr, hord_lst, thevz_mag_lst, thevz_phs_lst

# ==============================================================================

def get_dstn_csvdata_volt(csvfile):
    """Get Distortion Calculations Bus Voltage THD data from PSSE results file.
    """
    import csv

    dkeytup = ('hord', 'bus', 'sec', 'basekv', 'vrpu', 'vxpu', 'vmagpu', 'vangdeg', 'thd_indv')
    dtyptup = ('r'   , 'i'  , 'i'  , 'r'     , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       )

    errmsg0 = " Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile)

    _NCLNS = len(dkeytup)

    volt_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        nrow = 0
        for row in reader:
            nrow += 1
            if nrow==1: continue # skip column header line
            nclns = len(row)
            if nclns!=_NCLNS:
                txt = "    ROW {} has {} data items. It should have {} data items.".format(nrow, nclns, _NCLNS)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)
            tempdct = {}
            for dk, dt, v0 in zip(dkeytup, dtyptup, row):
                if dt=='s':
                    val = v0
                elif dt=='i':
                    if dk=='sec':
                        try:
                            val = int(v0)
                        except:
                            val = 0
                    else:
                        val = int(v0)
                else:
                    val = float(v0)
                tempdct[dk] = val

            hord = tempdct['hord']
            ibus = tempdct['bus']
            isec = tempdct['sec']
            bus_sec = (ibus, isec)

            if bus_sec not in volt_dict:
                volt_dict[bus_sec] = {}

            if hord not in volt_dict[bus_sec]:
                volt_dict[bus_sec][hord] = {}
            else:
                txt = "    Duplicate harmonic order={} data found for '{}', at {}".format(hord, desc, srcktup)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)

            if hord==1.0:
                kk = 'thd'
            else:
                kk = 'indv'
            volt_dict[bus_sec][hord]['basekv'] = tempdct['basekv']
            volt_dict[bus_sec][hord]['vmag']   = tempdct['vmagpu']
            volt_dict[bus_sec][hord]['vang']   = tempdct['vangdeg']
            # When hord=1.0, pct is THD, else pct is indv
            volt_dict[bus_sec][hord]['pct']    = tempdct['thd_indv']

    # add this test here
##    txt = "    Fundamental harmonic order data not found for bus={}, section={}".format(ibus, isec)
##    errmsg = "{}{}".format(errmsg0, txt)
##    raise Exception(errmsg)

    return volt_dict

# ==================================================================================================

def get_dstn_csvdata_cursrc(csvfile):
    """Get Distortion Calculations Harmonic Current Source Spectrum data from PSSE results file.
    """
    import csv

    dkeytup = ('hord', 'ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec', 'ckt', 'irpu', 'ixpu', 'imagpu', 'iangdeg', 'thd_indv', 'desc')
    dtyptup = ('r'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 's'  , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       , 's'   )

    errmsg0 = " Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile)

    _NCLNS = len(dkeytup)

    cursrc_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        nrow = 0
        for row in reader:
            nrow += 1
            if nrow==1: continue # skip column header line
            nclns = len(row)
            if nclns!=_NCLNS:
                txt = "    ROW {} has {} data items. It should have {} data items.".format(nrow, nclns, _NCLNS)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)
            tempdct = {}
            srcklst = []
            for dk, dt, v0 in zip(dkeytup, dtyptup, row):
                if dt=='s':
                    val = v0.strip().lower()
                elif dt=='i':
                    if dk in ['isec', 'jbus', 'jsec', 'kbus', 'ksec']:
                        try:
                            val = int(v0)
                        except:
                            val = 0
                    else:
                        val = int(v0)
                else:
                    val = float(v0)

                if dk in ['ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec']:
                    if val>0:
                        srcklst.append(val)
                elif dk in ['ckt']:
                    if val:
                        srcklst.append(val)
                else:
                    tempdct[dk] = val

            srcktup = tuple(srcklst)
            hord = tempdct['hord']
            desc = tempdct['desc']

            if desc not in cursrc_dict:
                cursrc_dict[desc] = {}

            if srcktup not in cursrc_dict[desc]:
                cursrc_dict[desc][srcktup] = {}

            if hord not in cursrc_dict[desc][srcktup]:
                cursrc_dict[desc][srcktup][hord] = {}
            else:
                txt = "    Duplicate harmonic order={} data found for '{}', at {}".format(hord, desc, srcktup)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)

            if hord==1.0:
                kk = 'thd'
            else:
                kk = 'indv'
            cursrc_dict[desc][srcktup][hord]['imag'] = tempdct['imagpu']
            cursrc_dict[desc][srcktup][hord]['iang'] = tempdct['iangdeg']
            cursrc_dict[desc][srcktup][hord][kk]     = tempdct['thd_indv']

    # add this test here
##    txt = "    Fundamental harmonic order data not found for '{}', at {}".format(desc, srcktup)
##    errmsg = "{}{}".format(errmsg0, txt)
##    raise Exception(errmsg)

    return cursrc_dict

# ==================================================================================================

def _get_dstn_volt_ieee519_busgrps(volt_dict):

    hord = 1.0  # just consider HORD=1.0 to get bus information

    ierr = 0
    ieee519_vlmt_dict  = {}
    case_bus_vlmt_dict = {}
    for ii, lmtkv in enumerate(_ieee519_vlimits):
        if ii==0:
            vmn, vmx = 0, lmtkv
        else:
            vmn, vmx = _ieee519_vlimits[ii-1], lmtkv

        if vmn<=0.0:
            s_lmt = "kV <= {}".format(vmx)
        elif vmx>=999.0:
            s_lmt = "{} < kV".format(vmn)
        else:
            s_lmt = "{} < kV <= {}".format(vmn, vmx)

        ieee519_vlmt_dict[ii] = {'lmtkv':lmtkv, 'vmin':vmn, 'vmax':vmx, 'lmt_lgd':s_lmt}

    buses_not_added_to_grps = []
    for bus_sec, vdict in volt_dict.items():
        buskv = vdict[hord]['basekv']
        found = False
        for ii, lmtkv in enumerate(_ieee519_vlimits):
            if ii==0:
                vmn, vmx = 0, lmtkv
            else:
                vmn, vmx = _ieee519_vlimits[ii-1], lmtkv

            if buskv>vmn and buskv<=vmx:
                case_bus_vlmt_dict[bus_sec] = ii
                found = True
                break

        if not found:
            buses_not_added_to_grps.append(bus_sec) # should never happen

    if buses_not_added_to_grps:
        txtlst = []
        for each in buses_not_added_to_grps:
            txt = "{}".format(each)
            txtlst.append(txt)
        txt = " Error - These (bus, sec) are not added to IEEE 519 Voltage THD Bus Groups:"
        print(txt)
        alltxt = ", ".join(txtlst)
        tlnlst = textwrap.wrap(alltxt, width=90, initial_indent="    ", subsequent_indent="    ")
        tlntxt = "\n".join(tlnlst)
        print(tlntxt)

    if not case_bus_vlmt_dict:
        ierr = 1

    return ierr, ieee519_vlmt_dict, case_bus_vlmt_dict

# =========================================================================

def get_dstn_volt_study_bus_results(volt_dict, *buses):
    """Return distortion results assembled in arrays for XY plots for specified study buses.
    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)
    """

    ierr = 0
    each_bus_xy = {}
    all_bus_xy = {}

    ierr, ieee519_vlmt_dict, case_bus_vlmt_dict = _get_dstn_volt_ieee519_busgrps(volt_dict)
    if ierr:
        return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy

    case_bus_exst_dict = {}
    for bus_sec, lmtidx in case_bus_vlmt_dict.items():
        bus, sec = bus_sec
        case_bus_exst_dict[bus] = 1

    if not buses: buses = [-1]

    stdy_bus_dict = {}
    if len(buses)==1 and buses[0]==-1:
        for bus, flag in case_bus_exst_dict.items():
            stdy_bus_dict[bus] = 1
    else:
        for bus in buses:
            if bus in case_bus_exst_dict:
                stdy_bus_dict[bus] = 1

    for bus_sec, vdict in volt_dict.items():
        bus, sec = bus_sec
        if bus not in stdy_bus_dict: continue
        if sec:
            xt = "{}-{}".format(bus, sec)
        else:
            xt = "{}".format(bus)

        idx = case_bus_vlmt_dict[bus_sec]

        # Each bus THD and INDV for all HORD
        # 'pct' key contains both THD and INDV
        each_bus_xy[bus_sec] = {'xnam':xt, 'hord':[], 'pct':[], 'lmtidx':idx}
        for hord, vdct2 in vdict.items():
            each_bus_xy[bus_sec]['hord'].append(hord)
            each_bus_xy[bus_sec]['pct'].append(vdct2['pct'])

    # THD and max INDV for all buses

    for kk in ['bus_sec', 'xnam', 'thd', 'indv', 'indv_hord', 'lmtidx']:
        all_bus_xy[kk] = []

    for bus_sec, vdict in each_bus_xy.items():
        all_bus_xy['bus_sec'].append(bus_sec)
        all_bus_xy['xnam'].append(vdict['xnam'])
        all_bus_xy['lmtidx'].append(vdict['lmtidx'])

        mx_indv = 0.0
        mx_indv_hord = 0.0
        for hord, pct in zip(vdict['hord'], vdict['pct']):
            if hord==1.0:
                thd = pct
            else:
                if pct>mx_indv:
                    mx_indv = pct
                    mx_indv_hord = hord

        all_bus_xy['thd'].append(thd)
        all_bus_xy['indv'].append(mx_indv)
        all_bus_xy['indv_hord'].append(mx_indv_hord)

##    print("\n each_bus_xy\n", each_bus_xy)
##    print("\n all_bus_xy\n",  all_bus_xy)

    return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy

# ==================================================================================================

def compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc):
    # Compare PSSE Distortion Calculation Results and IEEE Task Force Results

    if not os.path.exists(csvfile_volt):
        msg0 = " Distortion Calculation comparison table for IEEE Test case not done."
        msg  = " File not found.{}\n    {}".format(msg0, csvfile_volt)
        print(msg)
        return

    # get task force results table in dictionary
    tfresults_pf_thd_dict = get_ieee_tf_dstn_pf_thd_results()
    tfresults_cursrc_dict = get_ieee_tf_dstn_cursrc()

    # get distotion bus volts CSV data in dictionary
    volt_dict   = get_dstn_csvdata_volt(csvfile_volt)
    cursrc_dict = get_dstn_csvdata_cursrc(csvfile_cursrc)

    # create comparison table
    errmsg0 = " Error: Processing Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile_volt)

    hdr1 = " IEEE Task Force (TF) Harmonics Test Case: TF and PSSE Results Comparison\n"
    hdr2 = " (1) Power Flow Solution Bus Voltages and Harmonics %THD\n"
    hdr3 = "    Bus |nominal| IEEE TF| IEEE TF|IEEE TF|  PSSE  |  PSSE  | PSSE  |   DIFF   |   DIFF   |   DIFF   |"
    hdr4 = " Number |  kV   |  V pu  |  V deg | THD % |  V pu  |  V deg | THD % |   V pu   |   V deg  |   THD %  |\n"

    oubflst = []
    oubflst.append(hdr1)
    oubflst.append(hdr2)
    oubflst.append(hdr3)
    oubflst.append(hdr4)

    buslist = list(tfresults_pf_thd_dict.keys())
    buslist.sort()
    for bus in buslist:
        tfdct = tfresults_pf_thd_dict[bus]
        tf_basekv = tfdct['basekv']
        tf_mag    = tfdct['vmag']
        tf_ang    = tfdct['vang']
        tf_thd    = tfdct['thd']

        sec = 0
        bus_sec = (bus, sec)
        dstndct = volt_dict[bus_sec]

        hord = 1.0

        p_basekv = dstndct[hord]['basekv']
        p_mag    = dstndct[hord]['vmag']
        p_ang    = dstndct[hord]['vang']
        p_thd    = dstndct[hord]['pct']

        if p_basekv!=tf_basekv:
            txt1 = "    Nominal bus voltage does not match for bus={}\n".format(bus)
            txt2 = "    Bus voltage (kV)  TF paper={}, PSSE case={}\n".format(tf_basekv, p_basekv)
            errmsg = "{}{}{}".format(errmsg0, txt1, txt2)
            raise Exception(errmsg)

        tf_txt = "{:6d} | {:5.1f} | {:6.4f} | {:6.2f} | {:5.3f} |".format(bus, tf_basekv, tf_mag, tf_ang, tf_thd)
        p_txt  = "{:6.4f} | {:6.2f} | {:5.3f} |".format(p_mag, p_ang, p_thd)

        df_mag = tf_mag - p_mag
        df_ang = tf_ang - p_ang
        df_thd = tf_thd - p_thd
        df_txt = "{:8.5f} | {:8.4f} | {:8.5f} |".format(df_mag, df_ang, df_thd)

        txt = " {} {} {}".format(tf_txt, p_txt, df_txt)
        oubflst.append(txt)

    hdr1 = "\n (2) Harmonic Current Source Spectrum applied for Distortion Calculations\n"
    hdr2 = " Hord |    Bus |  IEEE TF |  IEEE TF |   PSSE   |   PSSE   |   DIFF   |"
    hdr3 = "      | Number |   %I     |   I deg  |   %I     |   I deg  |   %I     |\n"

    oubflst.append(hdr1)
    oubflst.append(hdr2)
    oubflst.append(hdr3)

    p_keylist = list(cursrc_dict['load'].keys())
    buslist.sort()

    tf_hord_list = list(tfresults_cursrc_dict['hvdc'].keys())
    p_elmt = 'load'

    for hord in tf_hord_list:
        for srcktup in p_keylist:
            ibus = srcktup[0]
            if ibus==8:
                tfk = 'tcr'
            else:
                tfk = 'hvdc'

            p_imag  = cursrc_dict[p_elmt][srcktup][hord]['imag']
            p1_imag = cursrc_dict[p_elmt][srcktup][1.0]['imag']
            p_pct   = p_imag*100/p1_imag

            p_iang  = cursrc_dict[p_elmt][srcktup][hord]['iang']

            tf_imag = tfresults_cursrc_dict[tfk][hord]['imag']
            tf_iang = tfresults_cursrc_dict[tfk][hord]['iang']

            df_pct  = tf_imag - p_pct

            txt = " {:4.1f} | {:6d} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.5f} |".format(hord, ibus, tf_imag, tf_iang, p_pct, p_iang, df_pct)
            oubflst.append(txt)

    #
    txt1 = "\n For multiple harmonic sources, the phase angles of harmonic current injections are"
    txt2 = " re-calculated considering power flow solution phase angle, spectrum phase angles and"
    txt3 = " harmonic order. Hence TF spectrum phase angles and PSSE phase angles are different."
    oubflst.extend([txt1, txt2, txt3])

    # write to output file
    pth, nx  = os.path.split(csvfile_volt)
    nam, xtn = os.path.splitext(nx)
    oufname = "{}_tf_THD_compare.txt".format(nam)
    outfile = os.path.join(outpath, oufname)
    outfobj = open(outfile, 'w')

    oubflst.append("")
    alltxt = "\n".join(oubflst)
    outfobj.write(alltxt)
    outfobj.close()

    msg = " IEEE Task Force Harmonics Test Case: TF and PSSE Results Comparison saved to file:\n    {}\n".format(outfile)
    print(msg)

# ==============================================================================

def plot_main_fscan_ieee_test_and_tf(outpath, **kwds):
    """Plot IEEE Test Case frequency scan impedance.
    Results from PSSE and IEEE Task Force are plotted.
    """

    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    filetyp = kwds.get('filetyp', 'png')
    verbose = kwds.get('verbose', False)
    pctmx1  = kwds.get('pctmx1',  60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx2',  20.0)
    dpctpn2 = kwds.get('dpctpn2', 85.0)

    flag_show = kwds.get('flag_show', True)

    casnam = "ieee_tf_psse"
    busnum = 3

    hmajor = []
    for ii in range(0, 41, 5):
        hmajor.append(ii)

    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]

    csv_dict = {
        1: {'nam': "ieee_testcase_linmdl=0_fscan.csv", 'ttl': "nominal PI"},
        2: {'nam': "ieee_testcase_linmdl=1_fscan.csv", 'ttl': "long line distibuted with skin effect"},
        3: {'nam': "ieee_testcase_linmdl=2_fscan.csv", 'ttl': "long line distibuted but no skin effect"},
        }

    csv_exists_dict = {}
    for k, vdict in csv_dict.items():
        nam = vdict['nam']
        csvfile = os.path.join(outpath, nam)
        if os.path.exists(csvfile):
            csv_exists_dict[k] = vdict

    if not csv_exists_dict:
        msg = "\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\n    {}".format(outpath)
        print(msg)
        return

    # PSSE results
    ierr_pi, ierr_dst_skin, ierr_dst = True, True, True
    ii = 0
    for k, vdict in csv_exists_dict.items():
        nam = vdict['nam']
        ttl = vdict['ttl']
        csvfile = os.path.join(outpath, nam)
        thevz_dict = get_fscan_csvdata(csvfile)
        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
        if not ierr:
            if ii==0:
                hlst_pi = hlst[:]
                zlst_pi = zlst[:]
                ttl_pi = ttl
                ierr_pi = False
            elif ii==1:
                hlst_dst_skin = hlst[:]
                zlst_dst_skin = zlst[:]
                ttl_dst_skin = ttl
                ierr_dst_skin = False
            elif ii==2:
                hlst_dst = hlst[:]
                zlst_dst = zlst[:]
                ttl_dst  = ttl
                ierr_dst = False
        ii += 1

    if ierr_pi or ierr_dst:
        print(" Error -- PSSE getting results data")
        return

    tf_hlst, tf_zlst_cal, tf_zlst_dst, tf_zlst_pi = get_ieee_tf_scan_results()

    peak_lst_h, peak_lst_rx = check_resonance(hlst_dst, zlst_dst, pctmx1, dpctpn1, pctmx2, dpctpn2)
    resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
    resn_lgd_lst.insert(0, "Resonance: distibuted but no skin")
    resn_lgd = "\n".join(resn_lgd_lst)

    clr_lst = ['red', 'blue', 'black', 'green', 'magenta']
    sty_lst = ['-', ':', '--', '-.', '-']
    wdt_lst = [2, 2, 1, 1, 1]

    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(8.0, 9.0)

    ii=0
    ax.plot(hlst_dst, zlst_dst, label=ttl_dst+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=1
    ax.plot(tf_hlst, tf_zlst_dst, label=ttl_dst+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=2
    ax.plot(hlst_pi, zlst_pi, label=ttl_pi+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=3
    ax.plot(tf_hlst, tf_zlst_pi, label=ttl_pi+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ax.set_xticks(hmajor)
    ax.set_yticks(ymajor)
    #ax.set_yscale('log')
    ax.set_xlabel("Harmonic Order")
    ax.set_ylabel("Harmonic Impedance (pu)")
    ax.set_title("IEEE 14 Bus Harmonics Test System")
    ax.grid(True, which='both')
    ax.legend()
    ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')

    if filetyp=='pdf':
        pdffile = os.path.join(outpath, "{}.pdf".format(casnam))
        pdfobj  = PdfPages(pdffile)
    else:
        figfile = os.path.join(outpath, "{}.png".format(casnam))

    if filetyp=='pdf':
        pdfobj.savefig(fig, bbox_inches='tight')
        pdfobj.close()
        print(" Plots saved: {}".format(pdffile))
    else:
        fig.savefig(figfile, bbox_inches='tight')
        print(" Plots saved: {}".format(figfile))

    if filetyp!='pdf':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

# ==============================================================================

def plot_main_fscan_ieee_test(outpath, **kwds):
    """Plot IEEE Test Case frequency scan Thevenin impedance.
    """
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    filetyp = kwds.get('filetyp', 'png')
    verbose = kwds.get('verbose', False)
    pctmx1  = kwds.get('pctmx1',  60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx2',  20.0)
    dpctpn2 = kwds.get('dpctpn2', 85.0)

    flag_show = kwds.get('flag_show', True)

    if verbose:
        report = sys.stdout.write
    else:
        report = None

    csv_dict = {
        1: {'nam': "ieee_testcase_linmdl=0_fscan.csv", 'ttl': "nominal PI"},
        2: {'nam': "ieee_testcase_linmdl=1_fscan.csv", 'ttl': "long line distibuted with skin effect"},
        3: {'nam': "ieee_testcase_linmdl=2_fscan.csv", 'ttl': "long line distibuted but no skin effect"},
        }

    csv_exists_dict = {}
    for k, vdict in csv_dict.items():
        nam = vdict['nam']
        csvfile = os.path.join(outpath, nam)
        if os.path.exists(csvfile):
            csv_exists_dict[k] = vdict

    if not csv_exists_dict:
        msg = "\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\n    {}".format(outpath)
        print(msg)
        return

    hmajor = []
    for ii in range(0, 41, 5):
        hmajor.append(ii)

    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]

    busnum = 3

    clr_lst = ['black', 'green', 'red']
    sty_lst = ['--', ':', '-']
    wdt_lst = [2, 3, 1]

    resn_lgd = ''
    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(8.0, 9.0)
    ii = 0
    for k, vdict in csv_exists_dict.items():
        nam = vdict['nam']
        ttl = vdict['ttl']
        csvfile = os.path.join(outpath, nam)
        thevz_dict = get_fscan_csvdata(csvfile)
        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
        if not ierr:
            ax.plot(hlst, zlst, label=ttl, color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])
            if k==3:
                peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=report)
                resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
                resn_lgd_lst.insert(0, "Resonance: linmdl-distibuted but no skin")
                resn_lgd = "\n".join(resn_lgd_lst)

        ii += 1

    ax.set_xticks(hmajor)
    ax.set_yticks(ymajor)
    #ax.set_yscale('log')
    ax.set_xlabel("Harmonic Order")
    ax.set_ylabel("Harmonic Impedance (pu)")
    ax.set_title("IEEE 14 Bus Harmonics Test System")
    ax.grid(True, which='both')
    ax.legend()
    if resn_lgd: ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')

    casnam = 'ieee_test'
    if filetyp=='pdf':
        pdffile = os.path.join(outpath, "{}_fscan.pdf".format(casnam))
        pdfobj  = PdfPages(pdffile)
    else:
        figfile = os.path.join(outpath, "{}_fscan.png".format(casnam))

    if filetyp=='pdf':
        pdfobj.savefig(fig, bbox_inches='tight')
        pdfobj.close()
        print(" Plots saved: {}".format(pdffile))
    else:
        fig.savefig(figfile, bbox_inches='tight')
        print(" Plots saved: {}".format(figfile))

    if filetyp!='pdf':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

# =========================================================================

def _har_ana_ieee_test(**kwds):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    Allowed kwds:

    outpath  = os.getcwd(), Folder name to save outfile files
    rpt2file = False, Save Report to file

    Thresholds to filter Thevenin Impedance
        dft_thresholds = True, Use defualt thresholds

        pctmx1  = kwds.get('pctmx1' , 60.0)
        dpctpn1 = kwds.get('dpctpn1', 75.0)
        pctmx2  = kwds.get('pctmx2' , 20.0)
        dpctpn2 = kwds.get('dpctpn2', 85.0)
    """
    import psspy

    name,major,minor,modlvl,date,stat = psspy.psseversion()

    kwds_api = {}
    kwds_api['anaoptn'   ] = 0
    kwds_api['dstnbuop'  ] = 0
    kwds_api['dstnrptop' ] = 1
    kwds_api['imachimpop'] = 0
    kwds_api['dcimpop'   ] = 0
    kwds_api['triplenop' ] = 0
    kwds_api['genimpop'  ] = 0

    kwds_api['hord_min' ] = 0.0
    kwds_api['hord_max' ] = 40.0
    kwds_api['hord_stp' ] = 0.33

    kwds_api['hrsfile'  ] = ''

    fscan_buslist = [3]
    sid = 3
    busall = 0
    psspy.bsys(sid, numbus=len(fscan_buslist), buses=fscan_buslist)

    outpath = kwds.get('outpath', os.getcwd())
    rpt2file = kwds.get('rpt2file', False)
    dft_thresholds = kwds.get('dft_thresholds', True)

    inherit = kwds.get('inherit', False)
    if inherit:
        kwds_api['load_mdltyp'] = 7

    if not dft_thresholds:
        pctmx1  = kwds.get('pctmx1' , 60.0)
        dpctpn1 = kwds.get('dpctpn1', 75.0)
        pctmx2  = kwds.get('pctmx2' , 20.0)
        dpctpn2 = kwds.get('dpctpn2', 85.0)

        s_pctmx1  = "{:g}".format(pctmx1)
        s_dpctpn1 = "{:g}".format(dpctpn1)
        s_pctmx2  = "{:g}".format(pctmx2)
        s_dpctpn2 = "{:g}".format(dpctpn2)
        usr_thresholds = "thresholds_usr_{}_{}_{}_{}".format(s_pctmx1, dpctpn1, s_pctmx2, dpctpn2)

    for linmdl in [0, 1, 2]:
        outnam = "ieee_testcase_linmdl={}".format(linmdl)
        if dft_thresholds:
            if not inherit:
                outpath1 = os.path.join(outpath,"dft_thresholds")
            else:
                outpath1 = os.path.join(outpath,"dft_thresholds_inherit")
        else:
            outpath1 = os.path.join(outpath,usr_thresholds)

        if not os.path.exists(outpath1): os.makedirs(outpath1)

        if rpt2file:
            dstnfile = os.path.join(outpath1, "{}_dstn.txt".format(outnam))
            resnfile = os.path.join(outpath1, "{}_resn.txt".format(outnam))
        else:
            dstnfile = ''
            resnfile = ''

        kwds_api['linmdl']   = linmdl
        kwds_api['dstnfile'] = dstnfile
        kwds_api['resnfile'] = resnfile

        if dft_thresholds:
            psspy.har_set_resn_thresholds_default()
        else:
            psspy.har_set_resn_thresholds(pctmx1=pctmx1, dpctpn1=dpctpn1, pctmx2=pctmx2, dpctpn2=dpctpn2)

        ierr = psspy.har_analysis_2(sid, busall, **kwds_api)

        if not ierr:
            if kwds_api['anaoptn'] in [0, 1]:
                fscan_csvfile = os.path.join(outpath1, "{}_fscan.csv".format(outnam))
                psspy.har_export_fscan(fscan_csvfile)

                msg = "\n Frequency Scan Thevenin impedance exported to file:\n    {}".format(fscan_csvfile)
                print(msg)

            ok350402 = major==35 and minor>=4 and modlvl>=2
            ok3505   = major>=35 and minor>=5
            ok3600   = major>=36

            if ok350402 or ok3505 or ok3600:
                if kwds_api['anaoptn'] in [0, 2]:
                    dstn_csvfile = os.path.join(outpath1, "{}_dstn.csv".format(outnam))
                    voltoptn, flowoptn, cursrcoptn = 2, 2, 2
                    psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )

                    pn, xtn = os.path.splitext(dstn_csvfile)
                    msg  = "\n Distortion calculation results exported to files:\n"
                    msg += "    {}_volt{}\n".format(pn, xtn)
                    msg += "    {}_flow{}\n".format(pn, xtn)
                    msg += "    {}_cursrc{}\n".format(pn, xtn)
                    print(msg)

# =========================================================================

def _ieee_test_get_names(datapath, outpath):

    if datapath is None:        # use Example folder
        exampath = os.path.dirname(__file__)
        datapath = exampath

    savfile = os.path.join(datapath, 'ieee_harmonics_test_case.sav')
    harfile = os.path.join(datapath, 'ieee_harmonics_test_case_har.rawx')

    if not os.path.exists(savfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(savfile)
        print(msg)

    if not os.path.exists(harfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(harfile)
        print(msg)

    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee')
        if not os.path.exists(outpath): os.makedirs(outpath)

    return savfile, harfile, outpath

# =========================================================================

def run_ieee_test(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    _har_ana_ieee_test(outpath=outpath, rpt2file=True)

# =========================================================================

def run_ieee_test_inherit(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    hnam, hext = os.path.splitext(harfile)
    harfile = "{}_inherit{}".format(hnam, hext)
    if not os.path.exists(harfile):
        msg = " Error - harmonics data file not found, calculations terminated\n    {}".format(harfile)
        print(msg)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    _har_ana_ieee_test(outpath=outpath, rpt2file=True, inherit=True)

# =========================================================================

def run_ieee_test_thevz_thresholds(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    kwds = {}
    kwds['outpath' ] = outpath
    kwds['rpt2file' ] = True
    kwds['dft_thresholds' ] = False

    kwds['pctmx1' ] = 60.0
    kwds['dpctpn1'] = 75.0
    kwds['pctmx2' ] = 20.0
    kwds['dpctpn2'] = 65.0

    _har_ana_ieee_test(**kwds)

# =========================================================================
def plot_fscan_ieee_test(outpath=None, **kwds):
    """Plot PSSE Harmonic Analysis Frequency Scan results of IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

##    kwds = {}
##    kwds['filetyp'] = 'png'
##    kwds['verbose'] = verbose
##    kwds['pctmx1' ] = pctmx1
##    kwds['dpctpn1'] = dpctpn1
##    kwds['pctmx2' ] = pctmx2
##    kwds['dpctpn2'] = dpctpn2

    plot_main_fscan_ieee_test(outpath, **kwds)

# =========================================================================
def plot_fscan_ieee_test_tf_psse(outpath=None, **kwds):
    """Plot Frequency Scan results of PSSE Harmonic Analysis and IEEE Task Force for IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

##    kwds = {}
##    kwds['filetyp'] = 'png'
##    kwds['verbose'] = verbose
##    kwds['pctmx1' ] = pctmx1
##    kwds['dpctpn1'] = dpctpn1
##    kwds['pctmx2' ] = pctmx2
##    kwds['dpctpn2'] = dpctpn2

    plot_main_fscan_ieee_test_and_tf(outpath, **kwds)

# =========================================================================
def compare_dstn_ieee_test(outpath=None, inherit=False):

    if outpath is None:
        exampath = os.path.dirname(__file__)
        if not inherit:
            outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
        else:
            outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds_inherit')

    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

    csvnam_volt   = "ieee_testcase_linmdl=2_dstn_volt.csv"
    csvnam_flow   = "ieee_testcase_linmdl=2_dstn_flow.csv"
    csvnam_cursrc = "ieee_testcase_linmdl=2_dstn_cursrc.csv"

    csvfile_volt   = os.path.join(outpath, csvnam_volt)
    csvfile_cursrc = os.path.join(outpath, csvnam_cursrc)
    compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc)

# =========================================================================
def plot_dstn_ieee_test_volt_ieee519(outpath=None, *buses, **kwds):
    """Plot PSSE Harmonic Distortion Calculations results of IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

    csvfnam = r"ieee_testcase_linmdl=2_dstn_volt.csv"
    csvfile = os.path.join(outpath, csvfnam)

    figfnam = 'ieee_testcase_linmdl=2_dstn_volt'
    figfile = os.path.join(outpath, figfnam)

    kwds2 = {}
    kwds2['figfiletyp'  ] = kwds.get('figfiletyp'  , 'pdf'   )
    kwds2['figfile'     ] = kwds.get('figfile'     , figfile )
    kwds2['flag_thd'    ] = kwds.get('flag_thd'    , True    )
    kwds2['flag_indv'   ] = kwds.get('flag_indv'   , True    )
    kwds2['flag_busgrps'] = kwds.get('flag_busgrps', False   )
    kwds2['plt_buses'   ] = kwds.get('plt_buses'   , [-1]    )
    kwds2['flag_show'   ] = kwds.get('flag_show'   , True    )

    plot_distortion_volt_ieee519(csvfile, *buses, **kwds2)

# =========================================================================

def _run_har_ana_main(*fscanbuses, **kwds):
    # Run Harmonic Analysis using working case
    import psspy

    name,major,minor,modlvl,date,stat = psspy.psseversion()

    # subsystem
    onezerobus = False
    if fscanbuses:
        if len(fscanbuses)==1:
            if fscanbuses[0]==0:
                onezerobus = True

    if fscanbuses:
        if not onezerobus:
            sid = 3
            busall = 0
            psspy.bsys(sid, numbus=len(fscanbuses), buses=fscanbuses)
        else:
            # no scan, just run distortion calculations
            sid = 0
            busall = 0
    else:
        totbus = psspy.totbus()
        # if case has <100 buses, run scan on all buses
        if totbus<100:
            sid = 0
            busall = 1
        else:
            # no scan, just run distortion calculations
            sid = 0
            busall = 0

    ierr = True
    outfdict = {}
    outfdict['dstn'] = ''
    outfdict['resn'] = ''
    outfdict['scan'] = ''

    anaoptn = kwds.get('anaoptn', 0)
    if sid==0 and busall==0:
        if anaoptn==0:
            kwds['anaoptn'] = 2  # only distortion anlysis
        elif anaoptn==2:
            pass
        else:
            msg = "\n Error- Specify frequency scan buses, terminated"
            print(msg)
            return ierr, outfdict

    outfnam  = kwds.get('outfnam' , '')
    outpath  = kwds.get('outpath' , '')

    if not outfnam:
        savfile, snpfile = psspy.sfiles()
        if not savfile:
            outfnam = "tmpout"
        else:
            p, nx = os.path.split(savfile)
            outfnam, xtn = os.path.splitext(nx)

    if outpath:
        if not os.path.exists(outpath): os.makedirs(outpath)
        dstnfile = os.path.join(outpath, "{}_dstn.txt".format(outfnam))
        resnfile = os.path.join(outpath, "{}_resn.txt".format(outfnam))
    else:
        dstnfile = ''
        resnfile = ''

    kwds['hrsfile']  = ''
    kwds['dstnfile'] = dstnfile
    kwds['resnfile'] = resnfile

    if 'outpath' in kwds: del kwds['outpath']
    if 'outfnam' in kwds: del kwds['outfnam']

    ierr = psspy.har_analysis(sid, busall, **kwds)

    fscan_csvfile = ''
    dstn_volt_csvfile = ''
    dstn_flow_csvfile = ''
    dstn_cursrc_csvfile = ''

    if not ierr and outpath:
        if anaoptn in [0,1]:
            if not ierr and outpath:
                fscan_csvfile = os.path.join(outpath, "{}_fscan.csv".format(outfnam))
                psspy.har_export_fscan(fscan_csvfile)
                msg = "\n Frequency Scan Thevenin impedance saved to file:\n    {}".format(fscan_csvfile)
                print(msg)

        ok350402 = major==35 and minor>=4 and modlvl>=2
        ok3505   = major>=35 and minor>=5
        ok3600   = major>=36

        if ok350402 or ok3505 or ok3600:
            if anaoptn in [0, 2]:
                dstn_csvfile = os.path.join(outpath, "{}_dstn.csv".format(outfnam))
                voltoptn, flowoptn, cursrcoptn = 2, 2, 2

                psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )

                pn, xtn = os.path.splitext(dstn_csvfile)
                dstn_volt_csvfile = r"{}_volt{}".format(pn, xtn)
                dstn_flow_csvfile = r"{}_flow{}".format(pn, xtn)
                dstn_cursrc_csvfile = r"{}_cursrc{}".format(pn, xtn)

                msg += r"    {}\n".format(dstn_volt_csvfile)
                msg += r"    {}\n".format(dstn_flow_csvfile)
                msg += r"    {}\n".format(dstn_cursrc_csvfile)
                print(msg)

    outfdict['dstn'] = dstnfile
    outfdict['resn'] = resnfile
    outfdict['scan'] = fscan_csvfile
    outfdict['dstn_volt'] = dstnfile
    outfdict['dstn_flow'] = resnfile
    outfdict['dstn_cursrc'] = fscan_csvfile

    return ierr, outfdict

# =========================================================================
def run_har_analysis(savfile, *fscanbuses, **kwds):
    """Run PSSE Harmonic Analysis using savfile and harfile provided.

    Arguments:
        savfile (str): PSSE Saved Case file name

        fscanbuses (int): One or bus numbers at which frequency scan done

        kwds (dict):  All PSSE har_analysis() API keywords plus followng
            are allowed key words.

            harfile (str) : PSSE harmonics data (.har) file
            outpath (str) : Output Results File Folder name
            outfnam (str) : Output Results File Name prefix
    """

    import psspy

    if not os.path.exists(savfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(savfile)
        print(msg)
        return True, {}

    harfile = kwds.get('harfile', '')
    if harfile:
        if not os.path.exists(harfile):
            msg = "\n Error- File not found, ignored:\n    {}".format(harfile)
            print(msg)
            harfile = ''

    psspy.psseinit()

    ierr = psspy.case(savfile)
    if ierr:
        msg = "\n Error- reading SAV file, terminated:\n    {}".format(savfile)
        print(msg)
        return True, {}

    if harfile:
        ierr = psspy.readrawx(harfile, 'harmonics', 'new')
        if ierr:
            msg = "\n Error- reading Harmonics data file, terminated:\n    {}".format(harfile)
            print(msg)
            return True, {}

    if 'harfile' in kwds: del kwds['harfile']
    ierr, outfdict = _run_har_ana_main(*fscanbuses, **kwds)

    return ierr, outfdict

# ==============================================================================

def _plot_fscan_one(ax, hlst, zlst, **kwds):
    #  main plot function
    basemva  = kwds.get('basemva' , 100.0)
    basekv   = kwds.get('basekv'  , None)
    hmajor   = kwds.get('hmajor'  , [])
    ymajor   = kwds.get('ymajor'  , [])
    plotzpu  = kwds.get('plotzpu' , False)
    title    = kwds.get('title'   , '')
    add_xlbl = kwds.get('add_xlbl', None)
    add_lgnd = kwds.get('add_lgnd', False)
    annot_xy = kwds.get('annot_xy', (0.5, 0.5))

    pctmx1  = kwds.get('pctmx1' , 60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx1' , 20.0)
    dpctpn2 = kwds.get('dpctpn1', 85.0)
    report  = kwds.get('report' , None)

    if add_lgnd:
        peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report)

    ylbl = "Thevenin Impedance (pu)"
    if not plotzpu:
        if basemva and basekv:
            zbase = basekv*basekv/basemva
            zlst_ohm = [zbase*each for each in zlst]
            zlst = zlst_ohm[:]
            del zlst_ohm
            ylbl = "Thevenin Impedance (ohm)"

            if add_lgnd:
                peak_lst_rx_ohm = [zbase*each for each in peak_lst_rx]
                peak_lst_rx = peak_lst_rx_ohm[:]
                del peak_lst_rx_ohm

    if add_lgnd:
        resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
        resn_lgd = "\n".join(resn_lgd_lst)

    if add_lgnd:
        ax.plot(hlst, zlst, label=resn_lgd)
    else:
        ax.plot(hlst, zlst)
    #ax.set_yscale('log')
    if hmajor: ax.set_xticks(hmajor)
    if ymajor: ax.set_yticks(ymajor)
    if (add_xlbl): ax.set_xlabel("Harmonic Order")
    ax.set_ylabel(ylbl)

    ax.grid(True, which='both')

    if add_lgnd:
        ax.legend(loc='best')

    if title: ax.set_title(title)

# =========================================================================

def _set_output_figfile_name(outfigfile, figfiletyp):

    figfiletyp_in = figfiletyp
    if figfiletyp_in:
        if figfiletyp_in not in _ALLOWED_FIG_FILE_TYPES:
            figfiletyp_in = ''

    opth, nx = os.path.split(outfigfile)
    n, x = os.path.splitext(nx)

    if x:
        figfiletyp_fl = ''
        xlw = x.lower().strip()
        if xlw:
            if xlw[1:] in _ALLOWED_FIG_FILE_TYPES:
                figfiletyp_fl = xlw[1:]

    if figfiletyp_in:
        figfiletyp = figfiletyp_in
    elif figfiletyp_fl:
        figfiletyp = figfiletyp_fl
    else:
        figfiletyp = 'pdf'

    xlw = ".{}".format(figfiletyp)

    if not opth: opth = os.getcwd()
    outfigfile = os.path.join(opth, "{}{}".format(n, xlw))

    return outfigfile, figfiletyp

# =========================================================================

def plot_frequency_scan(busnum, *csvfiles, **kwds):
    """Plot Harmonics Frequency Scan Thevenin Impedance.
    for one bus from multiple Frequency Scan Result Files

    Arguments:
        busnum (int): Bus Number. The 'csvfiles' provided must have Thevenin Impedance
            for this bus.

        csvfiles (str): One or more CSV files that contain Frequency Scan results.
            These files are created by api psspy.har_export_fscan(..).

        kwds (dict):  Followng are allowed key words.

            (A) These keywords are for plot figure options.

            figfiletyp (str): File type to which plots are saved.
                              ='pdfobj' -- files are saved to already created pdfobj
                              [Create pdfobj = PdfPages(pdffile). This is done so
                              as to save many plots to one pdffile.]
                              ='pdf', 'png', 'jpg' etc. [all allowed file types].
                              (default: '')
            figfile (str)   : Name of the file or pdfobj to save plots
                              When file name is not provided plot is not saved.
                              (default: '')
            flag_show (bool): Flag (True or False), Option to show plots on screen or not.
                              (default: True)
            basemva (float) : Base MVA (used to calculate Thev Z in ohms)
                              (default: 100.0)
            basekv  (float) : Base kV of the bus (used to calculate Thev Z in ohms)
                              (default: No default allowed)
            hmajor  (float) : List of Harmonics Orders (used to draw X axis grid)
                              (default: [])
            ymajor  (float) : List of Thev Z (used to draw X axis grid)
                              (default: [])
            ttl_lst (str)   : Title list (one for each csvfile provided)
                              When one title is provided, same title is used for all.
                              (default: [])
            plotzpu (bool)  : True for Plot PU Thev Z
                              (default: False)
            add_lgnd (bool) : True to add resonance rrequeny legend
                              (default: False)
            annot_xy (tuple): Resonance Frequency legend location
                              Specify normalized (0 through 1) XY co-ordinates of a point
                              (default: (0.5, 0.5))
            subplts (bool)  : True, plot as subplots for more than one csvfiles.
                              (default: True) Subplots are drawn with 3 rows and 1 column.
            fwidth  (float) : Figure Width in inches
                              (default: matplotlib rcParms default figure width)
            fheight (float) : Figure Height in inches
                              (default: matplotlib rcParms default figure height)

            (B) These keywords are for filtering and reporting Thevenin Impedance Peaks.

            - Criterion 1 to select Thevenin Impedance Peak - slow rising peak point
            pctmx1 (float)     : current point in percent of maximum peak value
                                 (default:60.0)
            dpctpn1 (float)    : delta previous and delta next points in percent of current point
                                 (default:75.0)

            - Criterion 2 to select Thevenin Impedance Peak - fast rising peak point
            pctmx2 (float)     : current point in percent of maximum peak value
                                 (default:20.0)
            dpctpn2 (float)    : delta previous and delta next points in percent of current point
                                 (default:85.0)

            verbose (bool)     : Show verbose (detailed) output of Thevenin Impedance filtering
                                 (default: False)
            verbose_file (str) : File name to write verbose output.
                                 (default: '')
    """
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    # Use outfigfile to save output figure file and
    # also use its path to find csvfile when csvfile path is not provided.
    csvpath = ''

    figfiletyp = kwds.get('figfiletyp', '')
    figfiletyp = figfiletyp.lower()

    outfigfile = kwds.get('figfile', '')
    flag_show  = kwds.get('flag_show', True)

    if outfigfile:
        if figfiletyp=='pdfobj':
            pass
        else:
            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)
    else:
        figfiletyp = ''

    title = ''
    has_ttl4each = False
    ttl_lst = kwds.get('ttl_lst', [])
    nttl = len(ttl_lst)
    ncsv = len(csvfiles)
    if nttl==ncsv:
        has_ttl4each = True
    elif nttl==1 and ncsv>1:
        title = ttl_lst[0]

    exists_csvfiles = []
    exists_titles   = []
    for ii, csvnam in enumerate(csvfiles):
        if has_ttl4each:
            ttl = ttl_lst[ii]
        else:
            ttl = title
        if os.path.exists(csvnam):
            exists_csvfiles.append(csvnam)
            exists_titles.append(ttl)
        else:
            p, nx = os.path.split(csvnam)
            if not p and csvpath:
                csvnam2 = os.path.join(csvpath, nx)
                if os.path.exists(csvnam2):
                    exists_csvfiles.append(csvnam2)
                    exists_titles.append(ttl)
            else:
                msg = " File not found: {}".format(csvnam)
                print(msg)

    if not exists_csvfiles:
        return

    fwidth  = kwds.get('fwidth',  None)
    fheight = kwds.get('fheight', None)
    subplts = kwds.get('subplts', True)

    verbose  = kwds.get('verbose', False)
    verbose_file = kwds.get('verbose_file', '')
    report = None
    if verbose:
        if verbose_file:
            verbose_fobj = open(verbose_file, 'w')
            report = verbose_fobj.write
        else:
            report = sys.stdout.write

    if subplts:
        if fwidth is None or fheight is None:
            fwidth, fheight = 8.0, 9.0

    nfigs = len(exists_csvfiles)
    if not subplts:
        npages = nfigs
        nrows = 1
    else:
        if nfigs>3:
            npages = int(math.ceil(nfigs/3.0))   # three subplots per page
            nrows = 3
        else:
            npages = 1
            nrows = nfigs

    if outfigfile and figfiletyp=='pdf':
        pdffile = outfigfile
        pdfobj = PdfPages(pdffile)
    elif outfigfile and figfiletyp=='pdfobj':
        pdfobj = outfigfile

    nn = 0
    for pp in range(npages):
        fig, axlst = plt.subplots(nrows,1)
        if nrows==1: axlst = [axlst]
        fig.subplots_adjust(hspace=0.25)
        if fwidth is not None or fheight is not None:
            fig.set_size_inches(fwidth, fheight)

        for nr in range(nrows):
            ii = pp*nrows + nr
            if ii<nfigs:
                csvfile = exists_csvfiles[ii]
                ttl = exists_titles[ii]
                ax = axlst[nr]
                if (nr+1==nrows):
                    add_xlbl = True
                else:
                    add_xlbl = False

                kwds['title'] = ttl
                kwds['add_xlbl'] = add_xlbl
                kwds['report'] = report

                thevz_dict = get_fscan_csvdata(csvfile)
                ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
                if not ierr:
                    _plot_fscan_one(ax, hlst, zlst, **kwds)
            else:
                axlst[nr].set_visible(False)

        if outfigfile:
            if figfiletyp=='pdf':
                pdfobj.savefig(fig, bbox_inches='tight')
            elif figfiletyp=='pdfobj':
                try:
                    pdfobj.savefig(fig, bbox_inches='tight')
                except:
                    traceback.print_last()
            else:
                if npages>1:
                    pn, x = os.path.splitext(outfigfile)
                    zn = "{}".format(pp).zfill(2)
                    tmpfnam = "{}_{}{}".format(pn,zn,x)
                else:
                    tmpfnam = outfigfile
                fig.savefig(tmpfnam, bbox_inches='tight')

    if outfigfile:
        if figfiletyp=='pdf':
            pdfobj.close()

        if figfiletyp=='pdfobj':
            plt.close(fig=fig)
        else:
            print(" Plots saved: {}".format(outfigfile))

    if verbose:
        if verbose_file:
            verbose_fobj.close()

    if figfiletyp!='pdfobj':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

# =========================================================================

def plot_distortion_volt_ieee519(csvfile, *buses, **kwds):
    """Plot Distortion Calculations Bus Voltages THD and Individual Harmonic levels with
    IEEE 519 Voltage Distortion Limits.
    Arguments:
        csvfile (str): CSV file that contain Distortion Calculations Bus Voltages results.
            This file is created by api psspy.har_export_dstn(..).
            No default allowed.

        buses (int): One or more Study Bus Numbers. THD and Individual harmonic levels are plotted
            for these many buses when provided.
            (default - consider all buses)

        kwds (dict):  Followng are allowed key words.

            (A) These keywords are for plot figure options.

            figfiletyp (str)   : File type to which plots are saved.
                                 ='pdfobj' -- files are saved to already created pdfobj
                                 [Create pdfobj = PdfPages(pdffile). This is done so
                                 as to save many plots to one pdffile.]
                                 ='pdf', 'png', 'jpg' etc. [all allowed file types].
                                 (default: '')
            figfile (str)      : Name of the file or pdfobj to save plots
                                 When file name is not provided plot is not saved.
                                 (default: '')
            flag_thd (bool)    : Flag (True or False), Option to plot THD of all study buses.
                                 (default: True)
            flag_indv (bool)   : Flag (True or False), Option to plot maximum individual harmonic levels
                                 of all study buses. For each bus, maximum individual harmonic level among all
                                 harmonic orders is found and plotted.
                                 (default: True)
            flag_busgrps (bool): Flag (True or False) Option to plot bus THD and INDV of bus groups.
                                 True -- Group buses as per their nominal voltage and IEEE 519 - Table 1
                                 voltage at PCC. Plot those bus groups in separate figures.
                                 False -- Plot all buses in one figure.
                                 (default: True)
            plt_buses (list)   : List of bus numbers (subset of Study Bus Numbers) to plot harmonic distortions.
                                 Bus THD and INDV harmonic distortions are plotted on the same figure.
                                 A separate figure created for each bus.
                                 Specify =[-1] or =-1 to plot all study buses.
                                 (default: [])
            flag_show (bool)   : Flag (True or False), Option to show plots on screen or not.
                                 (default: True)
            flag_xtick (bool)  : Flag (True or False), Option to Lable and Tick all X axis bus numbers.
                                 (default: True). Set this false if plotting for many numbers. Plot
                                 automatically assigns few labels and ticks in that case.
    """

    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    if not os.path.exists(csvfile):
        msg = " Distortion Bus Volts file not found: {}".format(csvfile)
        print(msg)
        return

    volt_dict = get_dstn_csvdata_volt(csvfile)

    # get organized Distortion results data
    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)
    if ierr==1:
        msg = " IEEE 519 Bus Groups not found in Distortion Bus Volts file: {}".format(csvfile)
        print(msg)
        return

    all_xnam = all_bus_xy['xnam']
    all_xnum = range(len(all_xnam))

    # separate groups and plot their bars so as to have ONE legend lable for a group
    bar_grps = {}
    for idx, xnum, thd, indv, indv_hord in zip(all_bus_xy['lmtidx'], all_xnum, all_bus_xy['thd'],
                                               all_bus_xy['indv'], all_bus_xy['indv_hord']):
        if idx not in bar_grps:
            bar_grps[idx] = {'xnum':[], 'thd':[], 'indv':[], 'indv_hord':[]}
        bar_grps[idx]['xnum'].append(xnum)
        bar_grps[idx]['thd'].append(thd)
        bar_grps[idx]['indv'].append(indv)
        bar_grps[idx]['indv_hord'].append(indv_hord)

    # preserve legend order
    grpidx_ordr = list(bar_grps.keys())
    grpidx_ordr.sort()

    # Use outfigfile to save output figure file and
    # also use its path to find csvfile when csvfile path is not provided.

    figfiletyp = kwds.get('figfiletyp', '')
    figfiletyp = figfiletyp.lower()

    outfigfile = kwds.get('figfile', '')

    flag_thd     = kwds.get('flag_thd', True)
    flag_indv    = kwds.get('flag_indv', True)
    flag_busgrps = kwds.get('flag_busgrps', False)
    plt_buses    = kwds.get('plt_buses', [])
    flag_show    = kwds.get('flag_show', True)
    flag_xtick   = kwds.get('flag_xtick', True)

    # validate plt_buses
    ok_pltbus_list = []
    if plt_buses:
        bus_ok_dict = {}
        for bus_sec, vdict in each_bus_xy.items():
            bus, sec = bus_sec
            if bus not in bus_ok_dict:
                bus_ok_dict[bus] = []
            bus_ok_dict[bus].append(bus_sec)

        if type(plt_buses)==int:
            buslst = [plt_buses]
        elif type(plt_buses) in [list, tuple]:
            buslst = plt_buses[:]
        else:
            buslst = []
            msg = " Invalid plt_buses={} specified, ignored. Individual Bus plots not done.".format(plt_buses)
            print(msg)

        if len(buslst)==1 and buslst[0]==-1:
            for bus in bus_ok_dict:
                ok_pltbus_list.extend(bus_ok_dict[bus])
        else:
            buslst.sort()
            for bus in buslst:
                if bus not in bus_ok_dict:
                    msg = " Invalid plt_bus={}, ignored. Bus does not exist in results.".format(bus)
                    print(msg)
                else:
                    ok_pltbus_list.extend(bus_ok_dict[bus])

    if outfigfile:
        if figfiletyp=='pdfobj':
            pass
        else:
            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)
    else:
        figfiletyp = ''

    if outfigfile and figfiletyp=='pdf':
        pdffile = outfigfile
        pdfobj = PdfPages(pdffile)
    elif outfigfile and figfiletyp=='pdfobj':
        pdfobj = outfigfile

    fignum = 0
    if flag_thd:
        bgn_allbus_thd = False
        for idx in grpidx_ordr:
            if flag_busgrps:
                fignum += 1
                fig = plt.figure(num=fignum)
                ax = fig.add_subplot(111)
                do_lbls = True
            else:
                if not bgn_allbus_thd:
                    bgn_allbus_thd = True
                    fignum += 1
                    fig = plt.figure(num=fignum)
                    ax = fig.add_subplot(111)
                if idx==grpidx_ordr[-1]:
                    do_lbls = True
                else:
                    do_lbls = False

            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']
            lmt_hvdc = _ieee519_table1_thd_limits[lmtkv].get('thd_hvdc', 0.0)
            if lmt_hvdc>0.0:
                lbl = "{} [{}] [with HVDC={}%]".format(lmt_thd, lbl, lmt_hvdc)
            else:
                lbl = "{} [{}]".format(lmt_thd, lbl)
            clr = _COLOR_PREFERENCE[idx]
            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['thd'], width=0.1, label=lbl, color=clr)

            # draw limit lines
            ax.axhline(y=lmt_thd, color=clr, linestyle='--', linewidth=1.5)
            if lmt_hvdc>0.0:
                ax.axhline(y=lmt_hvdc, color=clr, linestyle='--', linewidth=1.5)

            # labels and title
            if do_lbls:
                ttl = " Voltage THD"
                ax.set_title(ttl)
                ax.set_xlabel("Bus Numbers")
                ax.set_ylabel("% THD")
                if flag_xtick:
                    ax.set_xticks(all_xnum, all_xnam)
                h_lgd = ax.legend(title="IEEE 519 %THD Limits")
                h_lgd.get_frame().set_linewidth(0)
                h_lgd.set_draggable(True)

                if outfigfile:
                    if figfiletyp=='pdf':
                        pdfobj.savefig(fig, bbox_inches='tight')
                    elif figfiletyp=='pdfobj':
                        try:
                            pdfobj.savefig(fig, bbox_inches='tight')
                        except:
                            traceback.print_last()
                    else:
                        pn, x = os.path.splitext(outfigfile)
                        if flag_busgrps:
                            tmpfnam = "{}_thd_{}{}".format(pn,idx,x)
                        else:
                            tmpfnam = "{}_thd{}".format(pn,x)
                        fig.savefig(tmpfnam, bbox_inches='tight')

    if flag_indv:
        bgn_allbus_indv = False
        for idx in grpidx_ordr:
            if flag_busgrps:
                fignum += 1
                fig = plt.figure(num=fignum)
                ax = fig.add_subplot(111)
                do_lbls = True
            else:
                if not bgn_allbus_indv:
                    bgn_allbus_indv = True
                    fignum += 1
                    fig = plt.figure(num=fignum)
                    ax = fig.add_subplot(111)
                if idx==grpidx_ordr[-1]:
                    do_lbls = True
                else:
                    do_lbls = False

            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']
            lbl     = "{} [{}]".format(lmt_indv, lbl)
            clr = _COLOR_PREFERENCE[idx]
            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['indv'], width=0.1, label=lbl, color=clr)

            do_bar_lbl_nam = False
            if flag_busgrps:
                do_bar_lbl_nam = True
            else:
                if all_xnum[0]==bar_grps[idx]['xnum'][0]:
                    do_bar_lbl_nam = True

            lbls = []
            for hord in bar_grps[idx]['indv_hord']:
                if do_bar_lbl_nam:
                    lbls.append("HORD={}".format(int(hord)))
                    do_bar_lbl_nam = False
                else:
                    lbls.append("{}".format(int(hord)))
            if flag_xtick:
                ax.bar_label(h, labels=lbls, padding=2)

            # draw limit lines
            ax.axhline(y=lmt_indv, color=clr, linestyle='--', linewidth=1.5)

            # labels and title
            if do_lbls:
                ttl = " Voltage Individual Harmonic Levels (maximum)"
                ax.set_title(ttl)
                ax.set_xlabel("Bus Numbers")
                ax.set_ylabel("% INDV")
                if flag_xtick:
                    ax.set_xticks(all_xnum, all_xnam)
                h_lgd = ax.legend(title="IEEE 519 %INDV Limits")
                h_lgd.get_frame().set_linewidth(0)
                h_lgd.set_draggable(True)

                if outfigfile:
                    if figfiletyp=='pdf':
                        pdfobj.savefig(fig, bbox_inches='tight')
                    elif figfiletyp=='pdfobj':
                        try:
                            pdfobj.savefig(fig, bbox_inches='tight')
                        except:
                            traceback.print_last()
                    else:
                        pn, x = os.path.splitext(outfigfile)
                        if flag_busgrps:
                            tmpfnam = "{}_indv_{}{}".format(pn,idx,x)
                        else:
                            tmpfnam = "{}_indv{}".format(pn,x)
                        fig.savefig(tmpfnam, bbox_inches='tight')

    if ok_pltbus_list:
        for bus_sec in ok_pltbus_list:
            vdict = each_bus_xy[bus_sec]
            xnam  = vdict['xnam']

            idx     = vdict['lmtidx']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']
            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']

            lbl_thd = "%THD={}".format(lmt_thd)
            lbl_indv = "%INDV={}".format(lmt_indv)

            fignum += 1
            fig = plt.figure(num=fignum)
            ax = fig.add_subplot(111)

            clr_thd = _COLOR_PREFERENCE_BUS[0]
            h = ax.bar(vdict['hord'][0], vdict['pct'][0], width=0.3, label=lbl_thd, color=clr_thd)

            clr_indv = _COLOR_PREFERENCE_BUS[1]
            h = ax.bar(vdict['hord'][1:], vdict['pct'][1:], width=0.3, label=lbl_indv, color=clr_indv)

            # draw limit lines if any limit is violated
            maxpct = max(vdict['pct'])
            if maxpct>lmt_thd or maxpct>lmt_indv:
                ax.axhline(y=lmt_thd,  color=clr_thd, linestyle='--', linewidth=1.5)
                ax.axhline(y=lmt_indv, color=clr_indv, linestyle='--', linewidth=1.5)

            ttl = " Bus={}, Voltage THD and Individual Harmonic Levels".format(xnam)
            ax.set_title(ttl)
            ax.set_xlabel("Harmonic Order")
            ax.set_ylabel("%THD and % INDV")
            if flag_xtick:
                ax.set_xticks(vdict['hord'])
            h_lgd = ax.legend(title="IEEE 519 Limits")
            h_lgd.get_frame().set_linewidth(0)
            h_lgd.set_draggable(True)

            if outfigfile:
                if figfiletyp=='pdf':
                    pdfobj.savefig(fig, bbox_inches='tight')
                elif figfiletyp=='pdfobj':
                    try:
                        pdfobj.savefig(fig, bbox_inches='tight')
                    except:
                        traceback.print_last()
                else:
                    pn, x = os.path.splitext(outfigfile)
                    tmpfnam = "{}_thd_bus_{}{}".format(pn,xnam,x)
                    fig.savefig(tmpfnam, bbox_inches='tight')

    if outfigfile:
        if figfiletyp=='pdf':
            pdfobj.close()

        if figfiletyp=='pdfobj':
            plt.close(fig=fig)
        else:
            if figfiletyp=='pdf':
                print(" Plots saved: {}".format(outfigfile))
            else:
                pn, x = os.path.splitext(outfigfile)
                print(" Plots saved: {}..., File Type={}".format(pn, x[1:]))

    if figfiletyp!='pdfobj':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

# =========================================================================

def test1():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Uses Example folder files.
    Compare PSSE and TF distortion calculation results.
    """
    run_ieee_test()
    compare_dstn_ieee_test()

def test1A():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Specify Load Models from API argument and specify them as inherit in harmonics data file.
    Uses Example folder files.
    """
    run_ieee_test_inherit()
    compare_dstn_ieee_test(inherit=True)

def test1B():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Also specify thresholds to filter thevenin resonance frequencies.
    Uses Example folder files.
    """
    run_ieee_test_thevz_thresholds()

def test2():
    """Plot Harmonics Test PSSE Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test()

def test2A():
    """Plot Harmonics Test PSSE Results.
    Also specify thresholds to filter thevenin resonance frequencies.
    Uses Example folder files.
    """
    plot_fscan_ieee_test(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0)

def test3(figfiletyp='pdf', flag_show=True):
    """Plot Harmonics Test PSSE and harmonics Task Force Results.
    Also specify thresholds to filter thevenin resonance frequencies.
    Plot Distortion Calculation Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test_tf_psse(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0, figfiletyp=figfiletyp, flag_show=flag_show)
    plot_dstn_ieee_test_volt_ieee519(figfiletyp=figfiletyp, flag_show=flag_show)

def test3A():
    """Plot Harmonics Test PSSE and harmonics Task Force Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test_tf_psse()

def test4():
    """Run Harmonics Analysis on Example folder 'sample' case.
    Output Reports created in Report Window
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample.sav")
    harfile  = os.path.join(datapath, "sample_har.rawx")
    run_har_analysis(savfile, harfile=harfile)

def test5():
    """Run Harmonics Analysis on Example folder 'sample_zils' case.
    Output Reports created in 'outpath' folder with savfile name used for file name prefix.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir,  "output_harmonics_demo", "sample_zils")
    run_har_analysis(savfile, harfile=harfile, outpath=outpath)

def test6():
    """Run Harmonics Analysis on Example folder 'sample_nb' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_nb.sav")
    harfile  = os.path.join(datapath, "sample_har.rawx")
    outfnam  = "sample_nbXX"
    outpath  = os.path.join(workdir, "output_harmonics_demo", outfnam)
    run_har_analysis(savfile, harfile=harfile, outpath=outpath, outfnam=outfnam)

def test7():
    """Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    Also specified values to some API arguments.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils_nb_sec.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec")
    run_har_analysis(savfile, harfile=harfile, outpath=outpath, linmdl=1,
                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)

def test8():
    """Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    Also specified values to some API arguments.
    Do frequency scan on few buses.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils_nb_sec.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    run_har_analysis(savfile, 101, 212, 154, harfile=harfile, outpath=outpath, linmdl=1,
                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)

def test9():
    """Plot Frequency Scan, one file
    """
    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    kwds['figfile'] = os.path.join(outpath, "fscan_bus101_ohms.png")
    kwds['flag_show'] = True
    plot_frequency_scan(101, csvfile1, **kwds)

def test10():
    """Plot Frequency Scan, two files
    """
    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils")
    csvfile2 = os.path.join(outpath, "sample_zils_fscan.csv")
    kwds['figfile'] = os.path.join(outpath, "fscan_bus101_ohms.pdf")
    kwds['flag_show'] = True
    plot_frequency_scan(101, csvfile1, csvfile2, **kwds)

def test11():
    """Plot Frequency Scan, two files, figfiletype=pdfobj
    """
    from matplotlib.backends.backend_pdf import PdfPages

    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils")
    csvfile2 = os.path.join(outpath, "sample_zils_fscan.csv")

    pdffile = os.path.join(outpath, "fscan_bus101_ohms_2.pdf")
    pdfobj = PdfPages(pdffile)

    kwds['figfiletyp'] = 'pdfobj'
    kwds['figfile'] = pdfobj
    kwds['flag_show'] = True

    plot_frequency_scan(101, csvfile1, **kwds)
    plot_frequency_scan(101, csvfile2, **kwds)

    pdfobj.close()
    print(" Plots saved: {}".format(pdffile))

# ----------------------------
def _temp():
    pass
    # Available tests
    # Note 1: Run tests 2, 2A, 3, 3A, 9, 10, 11 from outside of PSSE GUI.
    # Note 2: Other tests can be run from inside as well as outside of PSSE GUI.
    # Note 3: Copy and Modify test4() and later tests to use on any SAV and HAR files.
    #
    test1()    # (a) Run Harmonics Analysis using IEEE Test case
               # (b) Compare PSSE and TF distortion calculation results
    test1A()   # (a) Run Harmonics Analysis using IEEE Test case, but use inherit load model in data file
               # (b) Compare PSSE and TF distortion calculation results
    test1B()   # Run Harmonics Analysis using IEEE Test case and specify thresholds to filter thevenin resonance frequencies
    test2()    # Plot IEEE Test case Frequency scan.
    test2A()   # Plot IEEE Test case PSSE Results and specify thresholds to filter thevenin resonance frequencies
    test3()    # (a) Plot Harmonics Test case PSSE and harmonics Task Force Frequency scan Results
               #     with thresholds specified to filter thevenin resonance frequencies.
               # (b) Plot distortion calculation results.
    test3A()   # Plot IEEE Test case PSSE and harmonics Task Force Results (default thresholds)
    test4()    # Run Harmonics Analysis on Example folder 'sample' case, Output Reports created in Report Window
    test5()    # Run Harmonics Analysis on Example folder 'sample_zils' case, Output Reports created in files
    test6()    # Run Harmonics Analysis on Example folder 'sample_nb' case
    test7()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case
    test8()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case and frequency scan on few buses
    test9()    # Plot Frequency Scan, one file [sample_zils_nb_sec_few]
    test10()   # Plot Frequency Scan, two files [sample_zils_nb_sec_fscan, sample_zils_fscan]
    test11()   # Plot Frequency Scan, two files, figfiletype=pdfobj

    # To compare PSSE and IEEE Test Case Results, run following tests.
    test1()    # Run Analysis
    test3()    # Write DSTN results comparison report, plot FSCAN TF and PSSE results, plot DSTN results
    # or run test3() with
    # figfiletyp as below, so as to create png file that can be inserted into DOC report
    # flag_show as below to create and save plots to files, do not show plots to the screen
    test3(figfiletyp='png')
    test3(figfiletyp='png', flag_show=False)

# ==============================================================================
if __name__=="__main__":
    pass
    # Modify following two lines as desired and run.
    #import psse3506
    #test1()    # Run Analysis
#[harmonics_demo.py]    Harmonics Analysis in PSSE
# =====================================================================================================
'''This is an example file showing how to use arrbox.harmonics module to post process
   harmonic analysis results.

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- Refer ieee_test_pp function that shows
    - how to get frequency scan results in python object
    - how to get distortion calculation results in python object
    - set desired voltage distortion limits
    - create voltage distortion limits violations report
    - plot and decorate frequency scan and voltage distortion results

- Refer API manual arrbox > HAR_PP object for all available methods.
'''

import os
import sys

# =========================================================================

def ieee_test_pp(do_fscan_plts=False, do_dstn_plts=False, show_plts=False):
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Uses Example folder files.
    """

    # Use from Example folder to run har_analysis.
    import harmonics_demo

    import arrbox.harmonics

    outpath = os.path.dirname(__file__)
    outpath = os.path.join(outpath, "output_har_demo_arrbox")
    if not os.path.exists(outpath): os.makedirs(outpath)

    harmonics_demo.run_ieee_test(outpath=outpath)

    outpath2 = os.path.join(outpath, "har_pp")
    if not os.path.exists(outpath2): os.makedirs(outpath2)

    prgfile = os.path.join(outpath2, "ieee_test_har_demo_arrbox_progress.txt")
    prgfile_fobj = open(prgfile, 'w')
    progress = prgfile_fobj.write

    harobj = arrbox.harmonics.HAR_PP(progress=progress)

    # Frequency Scan Results
    ierr = harobj.fscan_obj()
    fscanobj = harobj.fscan

    buses = list(fscanobj.bus.keys())
    progress("fscanobj.ierr={}\n".format(fscanobj.ierr))
    progress("fscanobj.hord=\n{}\n".format(fscanobj.hord))

    for b in buses:
        progress("Scanned Bus={}\n".format(b))
        progress("{}\n".format(fscanobj['bus'][b].keys()))
        progress("name={}, basekv={}\n".format(fscanobj.bus[b].name, fscanobj.bus[b].basekv))
        progress("{}\n".format(fscanobj.bus[b].mag))
        progress("{}\n".format(fscanobj.bus[b].phase))

    # Distortion Calculation Results
    ierr = harobj.dstn_obj()
    dstn_vltobj = harobj.dstn.volt

    progress("dstn_vltobj.keys()={}\n".format(dstn_vltobj.keys()))

    progress("dstn_vltobj.thd.bus={}\n{}\n".format(len(dstn_vltobj.thd.bus), dstn_vltobj.thd.bus))
    progress("dstn_vltobj.thd.pct={}\n{}\n".format(len(dstn_vltobj.thd.pct), dstn_vltobj.thd.pct))

    progress("dstn_vltobj.indv.bus={}\n{}\n".format(len(dstn_vltobj.indv.bus), dstn_vltobj.indv.bus))
    progress("dstn_vltobj.indv.hord_max={}\n{}\n".format(len(dstn_vltobj.indv.hord_max), dstn_vltobj.indv.hord_max))
    progress("dstn_vltobj.indv.pct_max={}\n{}\n".format(len(dstn_vltobj.indv.pct_max), dstn_vltobj.indv.pct_max))

    progress("dstn_vltobj.bus.keys()={}\n".format(dstn_vltobj.bus.keys()))
    buslist = harobj.dstn.volt.bus
    for bus in buslist:
        basekv = harobj.dstn.volt.bus[bus].basekv
        lmt_thd = harobj.dstn.volt.bus[bus].lmt_thd
        lmt_indv = harobj.dstn.volt.bus[bus].lmt_indv

        vdict = harobj.dstn.volt.bus[bus].hord
        for hord, vdc2 in  vdict.items():
            vr, vx, vmag, vang, pct  = vdc2.vr,  vdc2.vx, vdc2.vmag,  vdc2.vang, vdc2.pct
            txt = "{}, {}, {}, {}, {}, {}, {}, basekv={}, lmt_indv={}, lmt_thd={}\n".\
                  format(bus, hord, vr, vx, vmag, vang, pct, basekv, lmt_indv, lmt_thd)
            progress(txt)

    harobj.show_vlt_dstn_limits()

    vlmt_dict = harobj.get_vlt_dstn_limits()
    progress("vlmt_dict\n")
    for lmtkv, vdct in vlmt_dict.items():
        progress("   key={}, value={}\n".format(lmtkv, vdct))
    progress('\n')

    progress("\nVoltage violations report - rptoptn=0\n")
    harobj.report_vlt_dstn_limits_violations(rptfile=None)

    progress("\nVoltage violations report - rptoptn=1\n")
    harobj.report_vlt_dstn_limits_violations(rptoptn=1, rptfile=None)

    progress("\nVoltage violations report - rptoptn=2\n")
    harobj.report_vlt_dstn_limits_violations(rptoptn=2, rptfile=None)

    prgfile_fobj.close()
    print(" Progress Saved to file: {}".format(prgfile))

    # Frequency Scan Plots
    if do_fscan_plts:
        if not harobj.fscan.ierr:
            fig1, ax1 = harobj.plot_fscan_mag(3, color='r')
            fig1.savefig("zz_001.png")

            fig1, ax1 = harobj.plot_fscan_mag(3, color='r', marker='D', markevery=(0, 0.2))
            harobj.plot_decorate(ax1, xmin=10)
            fig1.savefig("zz_001-1.png")

            harobj.plot_decorate(ax1, add_legend=True)

            if show_plts:
                harobj.plot_show()
            else:
                harobj.plot_close()

    # Distortion Calculation Plots
    if do_dstn_plts:
        if not harobj.dstn.ierr:
            pdffile = os.path.join(outpath2, 'zplt_dstn_1.pdf')
            harobj.plot_pdf_open(pdffile)
            fig1, ax1 = harobj.plot_vlt_dstn_thd(0, 1, optn_lmtgrp=True, optn_lmtlin=True)
            #harobj.plot_decorate(ax1, add_legend=True)
            #harobj.plot_decorate(ax1, add_legend=True, xticks='all')
            harobj.plot_decorate(ax1, add_legend=True, xticks=[302, 301, 11, 3, 4])

            fig2, ax2 = harobj.plot_vlt_dstn_indv(0, 1, optn_lmtgrp=True, optn_lmtlin=True)
            harobj.plot_decorate(ax2, add_legend=True, xticks='all')

            fig3, ax3 = harobj.plot_vlt_dstn_bus(1)
            harobj.plot_decorate(ax3, xscale='log', yscale='log')

            harobj.plot_pdf_add_figure(fig1, fig2, fig3)
            harobj.plot_pdf_close()

            figfile = os.path.join(outpath2, 'zplt_dstn_2.pdf')
            harobj.plot_save(figfile, fig1, fig2)

            figfile = os.path.join(outpath2, 'zplt21_dstn')
            harobj.plot_save(figfile, fig1)

            figfile = os.path.join(outpath2, 'zplt22_dstn')
            harobj.plot_save(figfile, fig1, fig2)

            figfile = os.path.join(outpath2, 'zplt23_dstn')
            harobj.plot_save(figfile, fig1, fig2, fig3)

            if show_plts:
                harobj.plot_show()
            else:
                harobj.plot_close()

# =========================================================================
def _temp():
    pass
    ieee_test_pp()
    ieee_test_pp(do_fscan_plts=True, do_dstn_plts=True, show_plts=True)

# ==============================================================================
if __name__=="__main__":
    pass
    # Modify following two lines as desired and run.
    #import psse3506
    #ieee_test_pp()
#[iec60909_testnetwork_calculations.py]    Calculation of IEC Test Network 3 Phase Fault Currents by Network Reduction
# =====================================================================================================
'''
This file calculates 3 Phase Fault Currents for IEC Test Network (IEC 60909-4, Figure 16) by network reduction.
Refer to Program Application Guide, Volume I, Chapter 10 for schematics and equations.
It uses network data from IEC 60909-4 Table 11.
This impedance data (corrected if necessary) of the electrical equipment
(see figure 16) is referred to the 110 kV side. Z(2) = Z(1) = Z
Results from these calculations are compared against results from PSS(R)E and those provided in
IEC 60909-4 Table 12.
'''

import os, math, time
sqrt3 = math.sqrt(3.0)
sbase = 100.0     # MVA

str_time = time.strftime("%Y%m%d_%H%M%S_", time.localtime())
fnamout  = str_time + 'iec60909_testnetwork_calculations.txt'
fnamout  = os.path.join(os.getcwd(),fnamout)
foutobj  = open(fnamout,'w')

# =================================================================================
def format_complex(v):
    vre = v.real
    vim = abs(v.imag)
    if v.imag<0:
        sgn = '-'
    else:
        sgn = '+'
    retv = '%-10.6g %s j %-10.6g' % (vre, sgn, vim)
    return retv

def format_z_ratio(vlst,method=None):
    retvlst = []
    for v in vlst:
        vstr = format_complex(v)
        xbyr = v.imag/v.real
        if method=='C':
            xbyr = xbyr/0.4
        elif method=='DC':
            xbyr = xbyr/0.055
        retv = '%s, %-10.6g' % (vstr, xbyr)
        retvlst.append(retv)
    return retvlst

def print_complex(nam, v):
    vstr = format_complex(v)
    retv = '%-7s = %s\n' % (nam, vstr)
    #print retv.strip()
    return retv

def print_impedance_xr_ratio(nam, v, adj=1.0):
    vstr = format_complex(v)
    xbyr = adj*v.imag/v.real
    if adj!=1.0:
        retv = '%-6s = %s  X/R adj = %-10.6g\n' % (nam, vstr, xbyr)
    else:
        retv = '%-6s = %s  X/R     = %-10.6g\n' % (nam, vstr, xbyr)
    print(retv.strip())
    return retv

def print_fault_current(nam,v):
    vrect = format_complex(v)
    vmag = abs(v)
    vang = math.degrees(math.atan(v.imag/v.real))
    #retv = '%-6s = %s    OR %-10.6g / %-5.2g deg\n' % (nam, vrect, vmag, vang)
    retv = '%-6s = %-10.6g\n' % (nam, vmag)
    print(retv.strip())
    return retv

# =================================================================================

def print_z():
    dat_from_table11 = True
    txt = ''
    txt  += print_complex('zq1',    zq1)
    txt  += print_complex('zq1t',   zq1t)
    txt  += print_complex('zq2',    zq2)
    txt  += print_complex('zt3amv', zt3amv)
    txt  += print_complex('zt3bmv', zt3bmv)
    txt  += print_complex('zt3cmv', zt3cmv)
    txt  += print_complex('zt5mv',  zt5mv)
    if not dat_from_table11:
        txt  += print_complex('zt1mv',  zt1mv)
        txt  += print_complex('zg1',    zg1)
        txt  += print_complex('zg1t',   zg1t)
    txt  += print_complex('zs1',     zs1)
    if not dat_from_table11:
        txt  += print_complex('zt2mv',  zt2mv)
        txt  += print_complex('zg2',    zg2)
        txt  += print_complex('zg2t',   zg2t)
    txt  += print_complex('zs2',    zs2)
    txt  += print_complex('zg3',    zg3)
    txt  += print_complex('zg3t',   zg3t)
    txt  += print_complex('zm1',    zm1)
    txt  += print_complex('zm1t',   zm1t)
    txt  += print_complex('zm2',    zm2)
    txt  += print_complex('zm2t',   zm2t)
    txt  += print_complex('zl1',    zl1)
    txt  += print_complex('zl2',    zl2)
    txt  += print_complex('zl3',    zl3)
    txt  += print_complex('zl4',    zl4)
    txt  += print_complex('zl5',    zl5)
    txt  += print_complex('zl6',    zl6)
    txt  += print_complex('zl6t',   zl6t)
    return txt

def print_network_reduction_z(txstr,zdct):
    for k,v in list(zdct.items()):
        txstr += print_complex(k,v)
    return txstr

# =================================================================================

def table11_data(xftr,peak=False):
    # peak = True, calculations are for Peak current, use Rgf for generators.
    
    global zq1, zq1t, zq2, zt3amv, zt3bmv, zt3cmv, zt5mv, zs1
    global zs2, zg3, zg3t, zm1, zm1t, zm2, zm2t
    global zl1, zl2, zl3, zl4, zl5, zl6, zl6t

    # TABLE 11 Data
    zq1    =  0.631933 +   6.319335j
    zq1t   =  0.056874 +   0.568740j
    zq2    =  0.434454 +   4.344543j

    zt3amv =  0.045714 +   8.096989j
    zt3bmv =  0.053563 -   0.079062j
    zt3cmv =  0.408568 +  20.292035j

    zt5mv  =  2.046454 +  49.072241j

    # power station unit 1 data
    #Ks       = 0.995975
    #zg1t     = (0.059977324263+12.3433333333j)
    #zg1t*Ks  = (0.0597359155329+12.2936514167j)
    #zt1mv*Ks = (0.439058979167+14.0430253611j)
    #zs1 = Ks*(zg1t + zt1mv) = (0.4987948947+26.3366767778j)

    Ks1    =  0.995975
    zg1    =  0.059977 +  12.343333j
    zg1c   =  0.059736 +  12.293651j
    zt1c   =  0.439059 +  14.043025j
    #zs1    =  0.498795 +  26.336676j
    zs1    =  zg1c + zt1c

    # power station unit 2 data
    #Ks       = 0.876832
    #zg2t     = (0.65306122449+23.04j)
    #zg2t*Ks  = (0.572624979592+20.20220928j)
    #zt2mv*Ks = (0.63131904+15.1384987665j)
    #zs2 = Ks*(zg2t + zt2mv) = (1.20394401959+35.3407080465j)

    Ks2    =  0.876832
    zg2    =  0.653061 +  23.04j
    zg2c   =  0.572625 +  20.202214j
    zt2c   =  0.631319 +  15.138499j
    #zs2    =  1.203944 +  35.340713j
    zs2    =  zg2c + zt2c

    zg3    =  0.017790 +   1.089623j
    zg3t   =  2.133964 + 130.705301j

    zm1    =  0.341497 +   3.414968j
    zm1t   = 40.964124 + 409.641243j
    zm2    =  0.412137 +   4.121368j
    zm2t   = 49.437719 + 494.377190j

    zl1    = 2.4   + 7.8j
    zl2    = 1.2   + 3.9j
    zl3    = 0.3   + 0.975j
    zl4    = 0.96  + 3.88j
    zl5    = 1.8   + 5.79j
    zl6    = 0.082 + 0.086j
    zl6t   = 9.836281 + 10.316100j

    # Fictitious resistances RGf may be used for the calculation of the peak short circuit current
    # RGf = 0.05 X''d for generators with UrG > 1 kV and SrG >= 100 MVA
    # RGf = 0.07 X''d for generators with UrG > 1 kV and SrG < 100 MVA
    # RGf = 0.15 X''d for generators with UrG <= 1 000 V
    if peak:
        # G1 -> 150 MVA, 21 kV
        # G2 -> 100 MVA, 10.5 kV
        # RGf = 0.05 X''d
        zg1  = complex(0.05*zg1.imag, zg1.imag)
        zg1c = zg1*Ks1
        zs1  = zg1c + zt1c

        zg2  = complex(0.05*zg2.imag, zg2.imag)
        zg2c = zg2*Ks2
        zs2  = zg2c + zt2c

        zg3  = complex(0.07*zg3.imag, zg3.imag)
        zg3t = complex(0.07*zg3t.imag, zg3t.imag)

    if xftr != 1.0:
        zq1    = complex(zq1.real,    zq1.imag*xftr)
        zq1t   = complex(zq1t.real,   zq1t.imag*xftr)
        zq2    = complex(zq2.real,    zq2.imag*xftr)
        zt3amv = complex(zt3amv.real, zt3amv.imag*xftr)
        zt3bmv = complex(zt3bmv.real, zt3bmv.imag*xftr)
        zt3cmv = complex(zt3cmv.real, zt3cmv.imag*xftr)
        zt5mv  = complex(zt5mv.real,  zt5mv.imag*xftr)
        zs1    = complex(zs1.real,    zs1.imag*xftr)
        zs2    = complex(zs2.real,    zs2.imag*xftr)
        zg3    = complex(zg3.real,    zg3.imag*xftr)
        zg3t   = complex(zg3t.real,   zg3t.imag*xftr)
        zm1    = complex(zm1.real,    zm1.imag*xftr)
        zm1t   = complex(zm1t.real,   zm1t.imag*xftr)
        zm2    = complex(zm2.real,    zm2.imag*xftr)
        zm2t   = complex(zm2t.real,   zm2t.imag*xftr)
        zl1    = complex(zl1.real,    zl1.imag*xftr)
        zl2    = complex(zl2.real,    zl2.imag*xftr)
        zl3    = complex(zl3.real,    zl3.imag*xftr)
        zl4    = complex(zl4.real,    zl4.imag*xftr)
        zl5    = complex(zl5.real,    zl5.imag*xftr)
        zl6    = complex(zl6.real,    zl6.imag*xftr)
        zl6t   = complex(zl6t.real,   zl6t.imag*xftr)

# =================================================================================

def parallel(zp,zq):
    return (zp*zq)/(zp+zq)

def calculate_3ph_fault_zthev():
    # Reduction at Bus 5
    z7g  = parallel(zm1t, zm2t)
    z6g1 = zl6t + z7g
    z6g2 = parallel(zg3t, z6g1)
    z56  = zt5mv/2.0
    z5g1 = z56 + z6g2
    z5g2 = parallel(zq2, z5g1)

    rdzstr = ''
    rdzstr = print_network_reduction_z(rdzstr,{'z7g':z7g, 'z6g1':z6g1, 'z6g2':z6g2, 'z56':z56, 'z5g1':z5g1, 'z5g2':z5g2})

    # Reduction at Bus 2
    z12t3   = zt3amv + zt3bmv
    z12t3t4 = z12t3/2.0
    z2g1    = zq1t + z12t3t4
    
    rdzstr = print_network_reduction_z(rdzstr,{'z12t3':z12t3, 'z12t3t4':z12t3t4, 'z2g1':z2g1})

    # delta to star of buses 2, 3, 5, star point=N1
    zden1 = zl1 + zl3 + zl4
    za    = (zl1*zl3) / zden1
    zb    = (zl1*zl4) / zden1
    zc    = (zl3*zl4) / zden1

    rdzstr = print_network_reduction_z(rdzstr,{'za':za, 'zb':zb, 'zc':zc})

    # star to delta of buses N1, 3, 4, and ground
    znum1 = zb*zs2 + zb*zl2 + zs2*zl2
    zd = znum1/zs2
    ze = znum1/zl2
    zf = znum1/zb

    rdzstr = print_network_reduction_z(rdzstr,{'zd':zd, 'ze':ze, 'zf':zf})

    # delta to star of buses N1, 4, 5, star point=N2
    zden2 = zc + zd + zl5
    zg    = (zc*zd)  / zden2
    zh    = (zd*zl5) / zden2
    zi    = (zc*zl5) / zden2

    rdzstr = print_network_reduction_z(rdzstr,{'zg':zg, 'zh':zh, 'zi':zi})

    # Zthev at Bus 4
    z1    = z2g1 + za
    z2    = parallel(z1, ze)
    z3    = z2 + zg
    z4    = zi + z5g2
    z5    = parallel(z3, z4)
    z6    = z5 + zh
    z7    = parallel(z6,zf)
    zthv4 = parallel(z7, zs1)

    rdzstr = print_network_reduction_z(rdzstr,{'z1':z1, 'z2':z2, 'z3':z3, 'z4':z4, 'z5':z5, 'z6':z6, 'z7':z7})

    # Zthev at Bus 5
    z8    = parallel(zs1,zf)
    z9    = z8 + zh
    z10   = parallel(z3,z9)
    z11   = zi + z10
    zthv5 = parallel(z11, z5g2)

    rdzstr = print_network_reduction_z(rdzstr,{'z8':z8, 'z9':z9, 'z10':z10, 'z11':z11})

    # Zthev at Bus 2
    z12   = parallel(z4,z9)
    z13   = z12 + zg
    z14   = parallel(z13,ze)
    z15   = za + z14
    zthv2 = parallel(z15, z2g1)

    rdzstr = print_network_reduction_z(rdzstr,{'z12':z12, 'z13':z13, 'z14':z14, 'z15':z15})

    # Zthev at Bus 1
    z16   = z15 + z12t3t4
    z17   = z16*(400.*400.)/(120.*120.)
    zthv1 = parallel(z17, zq1)

    rdzstr = print_network_reduction_z(rdzstr,{'z16':z16, 'z17':z17})

    # Zthev at Bus 6
    zt5lv = zt5mv*(10.5*10.5)/(115.0*115.0)
    z21   = parallel(z11, zq2)
    z21lv = z21*(10.5*10.5)/(115.0*115.0)
    z22   = z21lv + zt5lv*0.5
    z24   = parallel(zm1, zm2)
    z25   = zl6 + z24
    z26   = parallel(zg3, z25)
    zthv6 = parallel(z22, z26)

    rdzstr = print_network_reduction_z(rdzstr,{'zt5lv':zt5lv, 'z21':z21, 'z21lv':z21lv, 'z22':z22, 'z24':z24, 'z25':z25, 'z26':z26})

    # Zthev at Bus 7
    z27   = parallel(z22, zg3)
    z28   = z27 + zl6
    zthv7 = parallel(z28, z24)

    rdzstr = print_network_reduction_z(rdzstr,{'z27':z27, 'z28':z28})

    zthev = [zthv1, zthv2, zthv4, zthv5, zthv6, zthv7]
    
    return zthev, rdzstr

# =================================================================================

def calculate_3ph_fault_ik(zthev):

    zthv1 = zthev[0]
    zthv2 = zthev[1]
    zthv4 = zthev[2]
    zthv5 = zthev[3]
    zthv6 = zthev[4]
    zthv7 = zthev[5]

    vflt = 1.1*110.0/sqrt3
    if2   = vflt/zthv2
    if4   = vflt/zthv4
    if5   = vflt/zthv5

    vflt1 = 1.1*380.0/sqrt3
    if1   = vflt1/zthv1

    vfl67 = 1.1*10.0/sqrt3
    if6   = vfl67/zthv6
    if7   = vfl67/zthv7

    ik = [if1, if2, if4, if5, if6, if7]
    return ik

# =================================================================================

def calculate_k_factor_method_B(bus,zc):
    r = zc.real
    x = zc.imag
    rx = r/x
    rbyx = -3.0*rx
    k = 1.02 + 0.98*math.exp(rbyx)
    if bus==7: k = k*1.15   # add safety factor for bus 7 faults
    if k>2.0: k=2.0
    return k    
    
def calculate_k_factor_method_C(zc):
    r = zc.real
    x = zc.imag
    rx = r/x
    rbyx = 0.4*rx
    rbyx = -3.0*rbyx
    k = 1.02 + 0.98*math.exp(rbyx)
    #print 'K factor for r/x=%f, is k=%f' % (rbyx,k)
    return k

def calculate_ip(buslst,iklst,zclst,method):
    klst  = []
    iplst = []
    for bus,ik,zc in zip(buslst,iklst,zclst):
        ik = abs(ik)
        if method=='B':
            k  = calculate_k_factor_method_B(bus,zc)
        if method=='C':
            k  = calculate_k_factor_method_C(zc)
        ip = k*math.sqrt(2.0)*ik
        klst.append(k)
        iplst.append(ip)

    return klst, iplst

def back_calculate_k(iklst,iplst):
    klst = []
    for ik,ip in zip(iklst,iplst):
        # ip=k*sprt(2)*ik
        k = ip/(math.sqrt(2)*ik)
        klst.append(k)
    return klst

def calculate_idc(iklst,zlst):
    # idc = sprt(2)*ik*e^(-2piftR/X)
    idclst = []
    for ik,z in zip(iklst,zlst):
        r = z.real
        x = z.imag
        rx = r/x
        rx = 0.055*rx
        rbyx = -2.0*math.pi*50.0*0.1*rx
        k = math.exp(rbyx)
        idc = math.sqrt(2)*abs(ik)*k
        #print 'dc component: z, k, abs(ik), idc = ',z,k,abs(ik),idc
        idclst.append(idc)
    return idclst
    
# =================================================================================

foutobj.write('IEC 60909-4:2000 Figure 16 (Page 121) 3-phase Fault Calculations with Network reduction')
foutobj.write(' '+time.asctime())
foutobj.write('\n')

buses = [1,2,4,5,6,7]

# Base frequency calculations
xftr = 1.0
table11_data(xftr)
base_z = print_z()

zthev_bas, rdzstr_bas = calculate_3ph_fault_zthev()

ik_bas = calculate_3ph_fault_ik(zthev_bas)

# Method B
# Method B peak currents are worse (compared to results in standard) when Rgf is used.
#xftr = 1.0
#table11_data(xftr,peak=True)
#mthdB_z = print_z()
#zthev_b, rdzstr_b = calculate_3ph_fault_zthev()
#k_b, ip_b = calculate_ip(buses,ik_bas,zthev_b,method='B')
k_b, ip_b = calculate_ip(buses,ik_bas,zthev_bas,method='B')

# Method C
xftr = 20.0/50.0
table11_data(xftr,peak=True)
mthdC_z = print_z()

zthev_c, rdzstr_c = calculate_3ph_fault_zthev()
k_c, ip_c = calculate_ip(buses,ik_bas,zthev_c,method='C')

# DC Component
# tmin=0.1 s, f*t = 50*0.1 = 5, fc/f=0.055
xftr = 0.055
table11_data(xftr,peak=False)
dc_z = print_z()

zthev_dc, rdzstr_dc = calculate_3ph_fault_zthev()
idc_cal = calculate_idc(ik_bas,zthev_dc)

# Table 12 from Standard
ik1_tbl12   = 40.6447
ip1_b_tbl12 = 100.5766
ip1_c_tbl12 = 100.5677
ib1_tbl12   = 40.645

ik2_tbl12   = 31.7831
ip2_b_tbl12 = 80.8249
ip2_c_tbl12 = 80.6079
ib2_tbl12   = 31.570

ik4_tbl12   = 16.2277
ip4_b_tbl12 = 36.8041
ip4_c_tbl12 = 36.8427
ib4_tbl12   = 16.017

ik5_tbl12   = 33.1894
ip5_b_tbl12 = 83.6266
ip5_c_tbl12 = 83.4033
ib5_tbl12   = 32.795

ik6_tbl12   = 37.5629
ip6_b_tbl12 = 99.1910
ip6_c_tbl12 = 98.1434
ib6_tbl12   = 34.028

ik7_tbl12   = 25.5895
ip7_b_tbl12 = 51.3864*1.15
ip7_c_tbl12 = 51.6899
ib7_tbl12   = 23.212

ik_tbl12   = [ik1_tbl12,   ik2_tbl12,   ik4_tbl12,   ik5_tbl12,   ik6_tbl12,   ik7_tbl12  ] 
ip_b_tbl12 = [ip1_b_tbl12, ip2_b_tbl12, ip4_b_tbl12, ip5_b_tbl12, ip6_b_tbl12, ip7_b_tbl12] 
ip_c_tbl12 = [ip1_c_tbl12, ip2_c_tbl12, ip4_c_tbl12, ip5_c_tbl12, ip6_c_tbl12, ip7_c_tbl12] 
ib_tbl12   = [ib1_tbl12,   ib2_tbl12,   ib4_tbl12,   ib5_tbl12,   ib6_tbl12,   ib7_tbl12  ] 

k_b_tbl12  = back_calculate_k(ik_tbl12,ip_b_tbl12)
k_c_tbl12  = back_calculate_k(ik_tbl12,ip_c_tbl12)

# PSS(R)E Results
# Bus Nums      1        2        4        5        6       7
ik_psse  = [ 40.6447, 31.7830, 16.2277, 33.1894, 37.5628, 25.5894]
ipb_psse = [100.5766, 80.5119, 36.8041, 83.6265, 99.1908, 59.0943]
ipc_psse = [100.5676, 80.6079, 36.8427, 83.4033, 98.1432, 51.6898]
idc_psse = [  2.7396, 12.7917,  2.6296,  3.9796, 15.1072,  0.0671]
ibs_psse = [ 40.6426, 31.5777, 16.0211, 32.8065, 34.0131, 23.1936]
iba_psse = [ 40.7348, 34.0702, 16.2354, 33.0470, 37.2171, 23.1937]

# Print Base frequency and Method C impedances
base_z_lst  = base_z.split('\n')
mthdC_z_lst = mthdC_z.split('\n')
dc_z_lst = dc_z.split('\n')

rdzstr_bas_lst = rdzstr_bas.split('\n')
rdzstr_c_lst   = rdzstr_c.split('\n')
rdzstr_dc_lst  = rdzstr_dc.split('\n')

hdr = r"""NETWORK ELEMENT IMPEDANCES in OHMS (COMPARE this to TABLE 11, PP 127)
|---------- BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|"""
foutobj.write(hdr)
foutobj.write('\n')

for v1,v2,v3 in zip(base_z_lst, mthdC_z_lst,dc_z_lst):
    if not v1: continue
    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\n'
    foutobj.write(txt)
    

hdr = r"""
NETWORK REDUCTION  CALCULATION IMPEDANCES in OHMS 
|---------- BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|"""
foutobj.write(hdr)
foutobj.write('\n')

for v1,v2,v3 in zip(rdzstr_bas_lst, rdzstr_c_lst, rdzstr_dc_lst):
    if not v1: continue
    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\n'
    foutobj.write(txt)

hdr = r"""
Thevenin Impedance in OHMS calculated with NETWORK REDUCTION (R+jX, X/R ratio)
|BUS| |---------- BASE FREQUENCY --------|    |   |----- METHOD C FREQ (fc/f=0.4)----|    |   |---- DC COMPONENT (fc/f=0.055)----|"""
foutobj.write(hdr)
foutobj.write('\n')

zstrlst_bas = format_z_ratio(zthev_bas)
zstrlst_c   = format_z_ratio(zthev_c,method='C')
zstrlst_dc  = format_z_ratio(zthev_dc,method='DC')
for b,zstr, zstr_c, zstr_dc in zip(buses,zstrlst_bas,zstrlst_c,zstrlst_dc):
    foutobj.write('  %d    %s       %s       %s' % (b, zstr, zstr_c, zstr_dc))
    foutobj.write('\n')


hdr ="""
 METHOD        BUS    I"k       K ip(50)     ip(50)     K ip(20)     ip(20)      Ib dc"""
foutobj.write(hdr)
foutobj.write('\n')

for b1,ik,kb,ipb,kc,ipc,idc,ik_t,kb_t,ipb_t,kc_t,ipc_t,ik_e,ipb_e,ipc_e,idc_e in zip(buses, ik_bas, k_b, ip_b, k_c, ip_c, idc_cal,
                                                            ik_tbl12, k_b_tbl12, ip_b_tbl12, k_c_tbl12, ip_c_tbl12,
                                                            ik_psse, ipb_psse, ipc_psse, idc_psse):
    ikabs = abs(ik)
    s1    = ' '
    lin1 = " CALCULATED   %(b1)3d   %(ikabs)-10.4f   %(kb)-10.4f %(ipb)-10.4f   %(kc)-10.4f %(ipc)-10.4f   %(idc)-10.4f" % vars()
    lin2 = " PSS(R)E      %(s1)3s   %(ik_e)-10.4f   %(s1)10s %(ipb_e)-10.4f   %(s1)10s %(ipc_e)-10.4f   %(idc_e)-10.4f" % vars()
    lin3 = " STANDARD     %(s1)3s   %(ik_t)-10.4f   %(kb_t)-10.4f %(ipb_t)-10.4f   %(kc_t)-10.4f %(ipc_t)-10.4f" % vars()
    foutobj.write(lin1)
    foutobj.write('\n')

    foutobj.write(lin2)
    foutobj.write('\n')

    foutobj.write(lin3)
    foutobj.write('\n\n')

foutobj.close()    

msg = " Results saved in file: %s" % fnamout
print(msg)
# =================================================================================
#[iecs_demo.py]   Fault Calculations using IECS
# =====================================================================================================
'''There are three different ways to calculate faults using IECS.
1) Using activity IECS (psspy.iecs_4)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.iecs.iecs_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run IECS fault calculations using either of these methods.

---------------------------------------------------------------------------------
How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psseXX
    [Here XX is PSSE major version number.]

B) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.
    run_iecs_4(..)
    run_iecs_currents_txtrpt(..)
    run_iecs_currents_xls(..)
    run_fault_summary_iecs(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
# ========================================================================================
#
"""
Use any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default   Description
                    # STATUS array
flt3ph   = 0        # 1 0=>omit, 1=>include
fltlg    = 0        # 2 0=>omit, 1=>include
fltllg   = 0        # 3 0=>omit, 1=>include
fltll    = 0        # 4 0=>omit, 1=>include
rptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl   = 0        # 6  number of contribution levels
fltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,
                    #    2=>AUX.XMER (connected to power station unit) LV bus
linout   = 0        # 8  0=>omit, 1=>include
linend   = 0        # 9  0=>omit, 1=>include
tpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,
                    #    3=>N unchanged and phi=0
lnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,
                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
dcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
cfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,
                    #    2=>User specified, maximum current, 3=>User specified, minimum current
loadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
genxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs
                    # VALUES array
brktime  = 0.1      # 0.1 seconds, breaker contact parting time
ucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)
                    # File args
iecfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""

# ========================================================================================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

# ========================================================================================

def set_prg_rpt(prgfile='', rptfile=''):
    import psspy
    psspy.lines_per_page_one_device(1,10000000)
    if prgfile: psspy.progress_output(2,prgfile,[0,0])
    if rptfile: psspy.report_output(2,rptfile,[0,0])

# ========================================================================================

def reset_prg_rpt():
    import psspy
    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,'',[0,0])
    psspy.report_output(1,'',[0,0])

# ========================================================================================

class IECS_DEMO:
    """ Run PSSE IECS Calculations"""

    def __init__(self):
        import psspy
        self.ierr = psspy.psseinit(buses=150000)

    # ------------------------------------------------------------------------------------
    def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    # ------------------------------------------------------------------------------------
    def _frmted_z_xbyr(self, cnum):

        zstr = self._frmted_z(cnum)

        r=cnum.real
        x=abs(cnum.imag)
        if r==0:
            xbyr=''
        else:
            xbyr="%9.6f" % (x/r)

        cstr="%(zstr)s, %(xbyr)s" % vars()

        return cstr

    # ------------------------------------------------------------------------------------

    def _crnt_mag(self, fmt, cval):
        if fmt=='rectangular':
            return abs(cval)
        else:
            return cval.real

    # ------------------------------------------------------------------------------------

    def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    # ------------------------------------------------------------------------------------
    def run_iecs_api(self, sid, allbus, **kwds):
        import psspy
        ierr = psspy.iecs_4(sid, allbus, **kwds)

    # ------------------------------------------------------------------------------------
    def run_iecs_currents(self, sid, allbus, **kwds):
        import psspy, arrbox.iecs

        rlst = arrbox.iecs.iecs_currents(sid, allbus, **kwds)

        if rlst.ierr!=0:
            raise Exception("arrbox.iecs.iecs_currents error= {}\n".format(rlst.ierr))

        return rlst

    # ------------------------------------------------------------------------------------
    def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    # ------------------------------------------------------------------------------------
    def report_iecs_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E IECS SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        # ------------------------------------------------------------------------------------------------
        if rptfile:
            rptfile_h.close()
            print('\n Done .... IECS FAULT Report saved to file %s' % rptfile)

    # ------------------------------------------------------------------------------------
    def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using IECS"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

# ========================================================================================
def _get_exam_path():
    import psspy
    vrsn_pydir = os.path.dirname(psspy.__file__)
    vrsn_rootdir, jnk = os.path.split(vrsn_pydir)
    examdir = os.path.join(vrsn_rootdir, "EXAMPLE")
    
    return examdir

# ========================================================================================
def _get_outpath():
    import psspy
    
    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()
    s_mjr = "{}".format(mjr)
    s_mnr = "{}".format(mnr)
    s_pch = "{}".format(pch)
    vnam = "v{}{}{}".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))
    outnam = "output_iecs_demo_{}".format(vnam)
    
    outpath = os.path.join(os.getcwd(), outnam)
    if not os.path.exists(outpath): os.makedirs(outpath)
    
    return outpath
    
# ========================================================================================
def _get_iec60909_network_files():
    savfile = 'iec60909_testnetwork_50Hz.sav'
    iecfile = 'iec60909_testnetwork.iec'
    
    if not os.path.exists(savfile):
        examdir = _get_exam_path()
        savfile = os.path.join(examdir, savfile)
        iecfile = os.path.join(examdir, iecfile)
        if not os.path.exists(savfile):
            msg = " IEC 60909 Network case not found.\n    {}".format(savfile)
            print(msg)
            raise Exception(" Case File not found")

    return savfile, iecfile

# ========================================================================================
def run_iecs_4(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    iecsobj.run_iecs_api(sid, allbus, **kwds)

    reset_prg_rpt()

# ========================================================================================
def run_iecs_currents_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_currents_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.report_iecs_currents(rlst, rptfile)

# ========================================================================================
def run_iecs_currents_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_iecs_currents_{}".format(nam_unt[unt])
    outpath = _get_outpath()
    xlsfile = os.path.join(outpath, xlsfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.excel_iecs_currents(rlst, xlsfile)

# ========================================================================================
def run_fault_summary_iecs(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_fault_summary_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

##    kwds = {
##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,
##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,
##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,
##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,
##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

# ========================================================================================
# IEC 60909 Test Network - Compare PSSE Results  
def run_iec60909_test_network():
    # Results output of following run_iecs_4(..)
    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)
    
# ========================================================================================
def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

    run_iec60909_test_network()

# ========================================================================================
if __name__=='__main__':
    pass
#[iecs_demo.py]   Fault Calculations using IECS
# =====================================================================================================
'''There are three different ways to calculate faults using IECS.
1) Using activity IECS (psspy.iecs_4)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.iecs.iecs_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run IECS fault calculations using either of these methods.

---------------------------------------------------------------------------------
How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psseXX
    [Here XX is PSSE major version number.]

B) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.
    run_iecs_4(..)
    run_iecs_currents_txtrpt(..)
    run_iecs_currents_xls(..)
    run_fault_summary_iecs(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
# ========================================================================================
#
"""
Use any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default   Description
                    # STATUS array
flt3ph   = 0        # 1 0=>omit, 1=>include
fltlg    = 0        # 2 0=>omit, 1=>include
fltllg   = 0        # 3 0=>omit, 1=>include
fltll    = 0        # 4 0=>omit, 1=>include
rptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl   = 0        # 6  number of contribution levels
fltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,
                    #    2=>AUX.XMER (connected to power station unit) LV bus
linout   = 0        # 8  0=>omit, 1=>include
linend   = 0        # 9  0=>omit, 1=>include
tpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,
                    #    3=>N unchanged and phi=0
lnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,
                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
dcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
cfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,
                    #    2=>User specified, maximum current, 3=>User specified, minimum current
loadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
genxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs
                    # VALUES array
brktime  = 0.1      # 0.1 seconds, breaker contact parting time
ucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)
                    # File args
iecfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""

# ========================================================================================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

# ========================================================================================

def set_prg_rpt(prgfile='', rptfile=''):
    import psspy
    psspy.lines_per_page_one_device(1,10000000)
    if prgfile: psspy.progress_output(2,prgfile,[0,0])
    if rptfile: psspy.report_output(2,rptfile,[0,0])

# ========================================================================================

def reset_prg_rpt():
    import psspy
    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,'',[0,0])
    psspy.report_output(1,'',[0,0])

# ========================================================================================

class IECS_DEMO:
    """ Run PSSE IECS Calculations"""

    def __init__(self):
        import psspy
        self.ierr = psspy.psseinit(buses=150000)

    # ------------------------------------------------------------------------------------
    def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    # ------------------------------------------------------------------------------------
    def _frmted_z_xbyr(self, cnum):

        zstr = self._frmted_z(cnum)

        r=cnum.real
        x=abs(cnum.imag)
        if r==0:
            xbyr=''
        else:
            xbyr="%9.6f" % (x/r)

        cstr="%(zstr)s, %(xbyr)s" % vars()

        return cstr

    # ------------------------------------------------------------------------------------

    def _crnt_mag(self, fmt, cval):
        if fmt=='rectangular':
            return abs(cval)
        else:
            return cval.real

    # ------------------------------------------------------------------------------------

    def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    # ------------------------------------------------------------------------------------
    def run_iecs_api(self, sid, allbus, **kwds):
        import psspy
        ierr = psspy.iecs_4(sid, allbus, **kwds)

    # ------------------------------------------------------------------------------------
    def run_iecs_currents(self, sid, allbus, **kwds):
        import psspy, arrbox.iecs

        rlst = arrbox.iecs.iecs_currents(sid, allbus, **kwds)

        if rlst.ierr!=0:
            raise Exception("arrbox.iecs.iecs_currents error= {}\n".format(rlst.ierr))

        return rlst

    # ------------------------------------------------------------------------------------
    def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    # ------------------------------------------------------------------------------------
    def report_iecs_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E IECS SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        # ------------------------------------------------------------------------------------------------
        if rptfile:
            rptfile_h.close()
            print('\n Done .... IECS FAULT Report saved to file %s' % rptfile)

    # ------------------------------------------------------------------------------------
    def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using IECS"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

# ========================================================================================
def _get_exam_path():
    import psspy
    vrsn_pydir = os.path.dirname(psspy.__file__)
    vrsn_rootdir, jnk = os.path.split(vrsn_pydir)
    examdir = os.path.join(vrsn_rootdir, "EXAMPLE")
    
    return examdir

# ========================================================================================
def _get_outpath():
    import psspy
    
    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()
    s_mjr = "{}".format(mjr)
    s_mnr = "{}".format(mnr)
    s_pch = "{}".format(pch)
    vnam = "v{}{}{}".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))
    outnam = "output_iecs_demo_{}".format(vnam)
    
    outpath = os.path.join(os.getcwd(), outnam)
    if not os.path.exists(outpath): os.makedirs(outpath)
    
    return outpath
    
# ========================================================================================
def _get_iec60909_network_files():
    savfile = 'iec60909_testnetwork_50Hz.sav'
    iecfile = 'iec60909_testnetwork.iec'
    
    if not os.path.exists(savfile):
        examdir = _get_exam_path()
        savfile = os.path.join(examdir, savfile)
        iecfile = os.path.join(examdir, iecfile)
        if not os.path.exists(savfile):
            msg = " IEC 60909 Network case not found.\n    {}".format(savfile)
            print(msg)
            raise Exception(" Case File not found")

    return savfile, iecfile

# ========================================================================================
def run_iecs_4(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    iecsobj.run_iecs_api(sid, allbus, **kwds)

    reset_prg_rpt()

# ========================================================================================
def run_iecs_currents_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_currents_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.report_iecs_currents(rlst, rptfile)

# ========================================================================================
def run_iecs_currents_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_iecs_currents_{}".format(nam_unt[unt])
    outpath = _get_outpath()
    xlsfile = os.path.join(outpath, xlsfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.excel_iecs_currents(rlst, xlsfile)

# ========================================================================================
def run_fault_summary_iecs(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_fault_summary_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

##    kwds = {
##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,
##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,
##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,
##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,
##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

# ========================================================================================
# IEC 60909 Test Network - Compare PSSE Results  
def run_iec60909_test_network():
    # Results output of following run_iecs_4(..)
    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)
    
# ========================================================================================
def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

    run_iec60909_test_network()

# ========================================================================================
if __name__=='__main__':
    pass
#[iecs_report.py]    Get IEC fault currents in arrays and create custom report
# =====================================================================================================
'''
This is an example file showing how to use "iecs_currents" function from pssarrays module.

IECS_CURRENTS function returns IEC 60909 standard fault currents for each faulted bus and
each type of fault applied. They are:
    ia1   = Positive Sequence Current
    ia2   = Negative Sequence Current
    ia0   = Zero Sequence Current
    ia    = Phase A current
    ib    = Phase B current
    ic    = Phase C current
    ipb   = peak Current - Method B, ip(B)
    ipc   = peak Current - Method C, ip(C)
    idc   = DC component of asymmetrical breaking current, idc
    ibsym = symmetrical breaking current (r.m.s.), ib(sym)
    ibuns = asymmetrical breaking current (r.m.s.), ib(uns)

The APIs used in this program are part of python "pssarrays" module.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    run_iecs_report()

    You may want to change inputs specified in this function.
    run_iecs_report(savfile, iecfile, fltbuses, rptfile)
    Defaults:
        savfile  = 'iec60909_testnetwork_50Hz.sav'
        iecfile  = 'iec60909_testnetwork.iec'
        fltbuses = [1,2,3,4,5,6,7,8]
        rptfile  = 'iecs_report_iec60909_testnetwork_50Hz.txt'
                   When this script is called from PSSE's Example Folder,
                   report is created in subfolder 'Output_Pyscript'
'''

# =====================================================================================================

import os, time

# =====================================================================================================

def encode_complex_number_xbyr(cnum):
    r=cnum.real
    x=cnum.imag
    csign='+j'
    if x<0:
        csign='-j'
        x=abs(x)

    if r==0:
        rstr=''
        xbyr=''
    else:
        rstr="%9.6f" % r
        xbyr="%9.6f" % (x/r)

    if x==0:
        xstr=''
        csign=''
    else:
        xstr="%9.6f" % x

    cstr="%(rstr)s%(csign)s%(xstr)s, %(xbyr)s" % vars()

    return cstr

# =====================================================================================================

def current_magnitude(fmt,cmplxvalue):
    if fmt == 'rectangular':
        return abs(cmplxvalue)
    else:
        return cmplxvalue.real

# =====================================================================================================

def create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,
                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,
                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):

    import psspy, arrbox.iecs

    # open case
    if savfile: psspy.case(savfile)

    # set sc units and format
    psspy.short_circuit_units(units)
    psspy.short_circuit_coordinates(fmt)

    sid = 3
    if fltbuses:
        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])
        busall = 0
    else:
        busall = 1

    # call pssarrays routine
    rlst=arrbox.iecs.iecs_currents(sid=sid, all=busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,
            fltll=fltll, linout=linout, linend=linend, tpunty=tpunty, lnchrg=lnchrg,
            shntop=shntop, dcload=dcload, zcorec= zcorec, optnftrc=optnftrc, loadop=loadop,
            genxop=genxop, brktime=brktime, vfactorc=vfactorc,
            iecfile=iecfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)
    if rlst.ierr!=0:
        raise Exception("arrbox.iecs.iecs_currents error= %d\n" % rlst.ierr)

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)
        rptfile_h = open(rptfile,'w')
        report    = rptfile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    nfbus=len(rlst.fltbus)

    ttlstr="PSS(R)E IEC 60909 SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
    ln1str,ln2str=psspy.titldt()
    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
    report(ttlstr.center(maxlen))
    report("\n")
    report(ln1str.center(maxlen))
    report("\n")
    report(ln2str.center(maxlen))
    report("\n\n")

    scunit = rlst.scunit
    scfmt  = rlst.scfmt
    if scunit == 'pu':
        units = 'PU'
    else:
        units = 'AMP'
    unitstr   = units.center(10)
    clnhdr    = "   BUS     " + 6*unitstr + "\n"

    for i in range(nfbus):
        report("           <-i''k--> <-ip(B)-> <-ip(C)-> <--idc--> <ib(sym)> <ib(uns)>\n")
        report(clnhdr)
        fbus   = rlst.fltbus[i]
        if flt3ph:
            ttxt   = "%6d" % fbus
            spc    = '3PH'
            ia1    = current_magnitude(scfmt,rlst.flt3ph[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.flt3ph[i].ia2)
            ia0    = current_magnitude(scfmt,rlst.flt3ph[i].ia0)
            ia     = current_magnitude(scfmt,rlst.flt3ph[i].ia)
            ib     = current_magnitude(scfmt,rlst.flt3ph[i].ib)
            ic     = current_magnitude(scfmt,rlst.flt3ph[i].ic)
            ipb    = current_magnitude(scfmt,rlst.flt3ph[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.flt3ph[i].ipc)
            idc    = current_magnitude(scfmt,rlst.flt3ph[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.flt3ph[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.flt3ph[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltlg:
            if flt3ph:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = ' LG'
            ia1    = current_magnitude(scfmt,rlst.fltlg[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltlg[i].ia2)
            ia0    = current_magnitude(scfmt,3*rlst.fltlg[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltlg[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltlg[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltlg[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltlg[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltlg[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltlg[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltlg[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltlg[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltllg:
            if flt3ph or fltlg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = 'LLG'
            ia1    = current_magnitude(scfmt,rlst.fltllg[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltllg[i].ia2)
            ia0    = current_magnitude(scfmt,3*rlst.fltllg[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltllg[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltllg[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltllg[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltllg[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltllg[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltllg[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltllg[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltllg[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltll:
            if flt3ph or fltlg or fltllg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc     = ' LL'
            ia1    = current_magnitude(scfmt,rlst.fltll[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltll[i].ia2)
            ia0    = current_magnitude(scfmt,rlst.fltll[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltll[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltll[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltll[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltll[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltll[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltll[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltll[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltll[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ib)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        report("\nTHEVENIN IMPEDANCE (pu), X/R\n")
        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)
        z1str ="Z1: " + z1str
        if fltlg or fltllg or fltll:
            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)
            z2str ="Z2: " + z2str
            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)
            z0str ="Z0: " + z0str
            tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
        else:
            tmptxt="%(z1str)s\n" % vars()
        report(tmptxt)

        if scunit != 'pu':
            report("\nTHEVENIN IMPEDANCE (ohms), X/R\n")
            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)
                z2str ="Z2: " + z2str
                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
            else:
                tmptxt="%(z1str)s\n" % vars()
            report(tmptxt)

        tmptxt=110*'-'
        report(tmptxt)
        report("\n")

    # Maximum Fault Currents
    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
    unitstr   = units.center(11)
    unitstr = ''
    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
        t = each+'('+units+')'
        t = ' ' + t.center(9) + ' '
        unitstr += t

    clnhdr    = "   BUS  " + unitstr + "  Description\n"
    report("\nBREAKER DUTY CURRENTS\n")
    report(clnhdr)
    for i in range(nfbus):
        fbus   = rlst.fltbus[i]
        ia1    = current_magnitude(scfmt,rlst.maxflt[i].ia1)
        ia2    = current_magnitude(scfmt,rlst.maxflt[i].ia2)
        ia0    = current_magnitude(scfmt,rlst.maxflt[i].ia0)
        ia     = current_magnitude(scfmt,rlst.maxflt[i].ia)
        ib     = current_magnitude(scfmt,rlst.maxflt[i].ib)
        ic     = current_magnitude(scfmt,rlst.maxflt[i].ic)
        dsc    = rlst.maxfltdsc[i]
        tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\n" % vars()
        report(tmptxt)

    # ------------------------------------------------------------------------------------------------
    if rptfile:
        rptfile_h.close()
        print('\n Done .... IECS FAULT Report saved to file %s' % rptfile)
    else:
        print('\n Done .... IECS FAULT Report created in Report window.')

# =====================================================================================================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

# =====================================================================================================

def run_iecs_report(savfile='iec60909_testnetwork_50Hz.sav', iecfile='iec60909_testnetwork.iec',
                    fltbuses=[1,2,3,4,5,6,7,8], rptfile='iecs_report_iec60909_testnetwork_50Hz.txt'):

    import psspy

    psspy.psseinit()

    # Inputs, change as required

    units    = 1       # 0=per unit,    1=physical
    fmt      = 0       # 0=rectangular, 1=polar coordinates

    flt3ph   = 1       #
    fltlg    = 1       #
    fltllg   = 1       #
    fltll    = 1       #
    linout   = 0       #
    linend   = 0       #
    tpunty   = 0       #
    lnchrg   = 1       #
    shntop   = 1       #
    dcload   = 0       #
    zcorec   = 0       #
    optnftrc = 0       #
    loadop   = 1       #
    genxop   = 0       # 0=X", 1=X', 2=Xs (generator reactance)

    brktime  = 0.1     # 0.1 seconds
    vfactorc = 1.0     #

    rptfile  = check_psse_example_folder(rptfile)

    fcdfile  = ""
    scfile   = ""

    rprtyp   = -1      # no report
    rprlvl   = 0       # number of contribution levels

    create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,
                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,
                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)

# ====================================================================================================
if __name__ == '__main__':

    import psse35
    run_iecs_report()

# ====================================================================================================
#[nlevel_buses.py]   Get N level buses from Home Bus
# =====================================================================================================
'''This script returns a dictionary of N level buses from Home (starting) Bus.
The next level bus is found from its branch and transformer connections [and not its electrical length].

---------------------------------------------------------------------------------
How to use this file?
    Refer "test_me()" function.
'''

# ========================================================================================

def get_nlevel_buses(homebus, nlevels):
    """
    Python Syntax:
        lvl_busdict = get_nlevel_buses(savfile, homebus, nlevels)

    Arguments:
        homebus(integer) : Home (starting) bus number to start finding next buses
        nlevels(integer) : Number of levels of buses from Home Bus
    """
    import psspy
    psspy.psseinit()

    lvl_list = [n+1 for n in range(nlevels)]

    lvl_busdict = {}
    lvl_busdict[0] = [homebus]

    do_buslist = [homebus]
    done_busdict = {}

    for lvl in lvl_list:
        if not do_buslist: break
        tmp_busdict = {}

        # Search for branches and two winding transformers
        for ibus in do_buslist:
            ierr = psspy.inibrn(ibus, single=2)
            #print("0 inibrn: ierr={}, ibus={}".format(ierr, ibus))
            if ierr == 0:
                while True:
                    ierr,jbus,ickt = psspy.nxtbrn(ibus)
                    #print("1 nxtbrn: ierr={}, jbus={}".format(ierr, jbus))
                    if ierr: break
                    tmp_busdict[jbus] = 1

        # Search for three winding transformers
        for ibus in do_buslist:
            ierr = psspy.inibrn(ibus, single=2)
            if ierr == 0:
                while True:
                    ierr,jbus,kbus,ickt = psspy.nxtbrn3(ibus)
                    #print("2 nxtbrn3: ierr={}, jbus={}, kbus={}".format(ierr, jbus, kbus))
                    if ierr: break
                    tmp_busdict[jbus] = 1
                    if (kbus>0): tmp_busdict[kbus] = 1

        tmp_buslist = list(tmp_busdict.keys())
        tmp_buslist.sort()

        for ibus in do_buslist:
            done_busdict[ibus] = 1

        do_buslist = []
        for ibus in tmp_buslist:
            if ibus not in done_busdict:
                do_buslist.append(ibus)

        lvl_busdict[lvl] = do_buslist[:]

    # all done
    return lvl_busdict

# ========================================================================================
def test_me():
    import psse3502
    import psspy
    psspy.psseinit()
    savfile = "sample.sav"
    psspy.case(savfile)
    lvl_busdict = get_nlevel_buses(151, 3)
    #lvl_busdict = get_nlevel_buses(206, 10)
    #lvl_busdict = get_nlevel_buses(101, 10)
    print("N Level Buses")
    for lvl, buslist in lvl_busdict.items():
        print("Level={}, Buses={}".format(lvl, buslist))

# ========================================================================================

if __name__=="__main__":
    pass
# Generated on TUE, JUN 08 2004  11:37
psspy.case(r"""savnw.sav""")
psspy.opendiagfile(r"""savnw.sld""")
#[otdffactors_excel.py]  OTDF FACTORS Exported to Excel Spreadsheet
# ====================================================================================================
'''
This is an example file showing how to use DFAX_PP object's method "otdf_factors" from
PSSARRAYS module to export OTDF factors to excel spreadsheet.

You need to have Win32 extensions for Python installed.
(http://sourceforge.net/projects/pywin32)

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    otdf_excel(savfile, dfxfile, outpath, show)
    or
    otdf_excel()  <-- savnw.sav and savnw.dfx must exist in working folder.
'''
# ----------------------------------------------------------------------------------------------------

import sys, os

# -----------------------------------------------------------------------------------------------------

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# -----------------------------------------------------------------------------------------------------

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ----------------------------------------------------------------------------------------------------

def otdf_excel(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None, show=True):

    import psspy, arrbox.dfax_pp

    import excelpy

    if not os.path.exists(savfile):
        print("\n SAV file '%s' not found." % savfile)
        return

    if not os.path.exists(dfxfile):
        print("\n DFAX file '%s' not found." % dfxfile)
        return

    p, nx = os.path.split(dfxfile)
    n, x  = os.path.splitext(nx)
    xlfile = get_output_filename(outpath, 'otdffactors_'+n)

    psspy.psseinit()

    psspy.case(savfile)

    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)

    otdfobj = dfxobj.otdf_factors()
    if otdfobj.ierr != 0: return

    otdfxls = excelpy.workbook(xlfile, 'OTDF FACTORS', overwritesheet=True)
    if show: otdfxls.show()
    otdfxls.show_alerts(0) # do not show pop-up alerts

    otdfxls.page_format(orientation="landscape",left=1.0,right=1.0,
                       top=0.5,bottom=0.5,header=0.25,footer=0.25)
    otdfxls.page_footer(left='page number of page total', right='date, time')
    otdfxls.page_header(center='file name:sheet name')
    otdfxls.font_sheet()

    # Report Title
    col = 1
    row = 1
    tmplst = (["OTDF Factors Report"],[dfxfile])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.font((1,1),fontColor='red',fontSize=14)
    otdfxls.font_color((2,1),'blue')

    row = bottomRow + 1

    tmplst = [
        otdfobj.casetitle.line1,                                       #
        otdfobj.casetitle.line2,                                       #
        ''
        'Saved Case file              = %s' % otdfobj.file.sav,         #
        'DFAX file                    = %s' % otdfobj.file.dfx,         #
        'Subsystem file               = %s' % otdfobj.file.sub,         #
        'Monitored Element file       = %s' % otdfobj.file.mon,         #
        'Contingency Description file = %s' % otdfobj.file.con,         #
        ]

    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst,transpose=True)
    row = bottomRow + 2 # one blank row

    txt = "'*** OTDF Contingency Description ***"
    otdfxls.set_cell((row,col),txt,fontStyle="Bold",fontSize=12, fontColor="red")
    row = row + 1

    tmplst=[]
    for i in range(otdfobj.size.ncase):
        lbl  = otdfobj.colabel[i]
        desc = otdfobj.codesc[i]
        tmplst.append([lbl,desc])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,col),'right')
    otdfxls.font_color((row,col,bottomRow,col),'dgreen')

    row = bottomRow + 2 # one blank row

    txt = "'*** OTDF Factors ***"
    otdfxls.set_cell((row,col),txt,fontStyle="Bold",fontSize=12, fontColor="red")
    row = row + 1

    tmplst=['<---------- Monitored Branch/Interface ------------->']
    for each in otdfobj.colabel:
        tmplst.append(each.strip())
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,rightCol),'right')
    otdfxls.font_color((row,col,bottomRow,rightCol),'blue')

    row = bottomRow + 1

    tmplst=[]
    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):
        tmplst.append([otdfobj.melement[i].strip()])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,col),'right')
    otdfxls.font_color((row,col,bottomRow,col),'dgreen')

    col = rightCol + 1
    bottomRow,rightCol = otdfxls.set_range(row,col,otdfobj.factor,transpose=True,numberFormat='0.0000')

    otdfxls.width((1,1),53)
    otdfxls.width((1,2,1,rightCol),12)

    # ------------------------------------------------------------------------------------------------
    # Save the workbook and close the Excel application
    xlfile = otdfxls.save(xlfile)

    if not show:
        otdfxls.close()
        txt = '\n OTDF Factors saved to file %s\n' % xlfile
        sys.stdout.write(txt)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':

    import psse35
    otdf_excel()
    # OR
    #otdf_excel(savfile, dfxfile, outpath, show)


# ====================================================================================================
#[otdffactors_report.py]  OTDF FACTORS REPORT
# ====================================================================================================
'''
This is an example file showing how to use DFAX_PP object's method "otdf_factors" from
PSSARRAYS module to generate OTDF factors report.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    otdf_report(savfile, dfxfile, outpath, show)
    or
    otdf_report()  <-- savnw.sav and savnw.dfx must exist in working folder.
'''

# ----------------------------------------------------------------------------------------------------

import sys, os, time

# -----------------------------------------------------------------------------------------------------

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# -----------------------------------------------------------------------------------------------------

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ----------------------------------------------------------------------------------------------------

def otdf_report(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):

    import psspy, arrbox.dfax_pp

    if not os.path.exists(savfile):
        print("\n SAV file '%s' not found." % savfile)
        return

    if not os.path.exists(dfxfile):
        print("\n DFAX file '%s' not found." % dfxfile)
        return

    p, nx = os.path.split(dfxfile)
    n, x  = os.path.splitext(nx)
    rptfile = get_output_filename(outpath, 'otdffactors_'+n+'.txt')

    psspy.psseinit()

    psspy.case(savfile)

    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)
    otdfobj = dfxobj.otdf_factors()
    if otdfobj.ierr != 0: return

    rptfile_h = open(rptfile,'w')
    report    = rptfile_h.write

    # (0) Report title
    ttl_hline = '*' + 46* ' *' + '\n\n'
    ttl       = 30*' ' + "OTDF Factors Report" + "\n"
    ttl_file  = 30*' ' + otdfobj.file.dfx + "\n"
    ttl_time  = 30*' ' + time.ctime() + "\n\n"
    report(ttl_hline)
    report(ttl)
    report(ttl_file)
    report(ttl_time)
    report(ttl_hline)

    report('%s\n' % otdfobj.casetitle.line1)
    report('%s\n' % otdfobj.casetitle.line2)
    report('\n')

    report('Saved Case file              = %s\n' % otdfobj.file.sav)
    report('DFAX file                    = %s\n' % otdfobj.file.dfx)
    report('Subsystem file               = %s\n' % otdfobj.file.sub)
    report('Monitored Element file       = %s\n' % otdfobj.file.mon)
    report('Contingency Description file = %s\n' % otdfobj.file.con)
    report('\n')

    report('*** OTDF Contingency Description ***\n')
    for i in range(otdfobj.size.ncase):
        lbl  = otdfobj.colabel[i]
        desc = otdfobj.codesc[i]
        report("  %(lbl)12s  %(desc)s\n" %vars())

    report("\n")
    report('*** OTDF Factors ***\n')
    report('  <---------- Monitored Branch/Interface ------------->  ')
    for each in otdfobj.colabel:
        report("%12s  " %each.strip())
    report("\n")
    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):
        report("  %52s  " % otdfobj.melement[i].strip())
        for j in range(otdfobj.size.ncase):
            report("%12.6f  " % otdfobj.factor[j][i])
        report("\n")

    # ------------------------------------------------------------------------------------------------
    rptfile_h.close()
    txt = '\n OTDF Factors saved to file %s\n' % rptfile
    sys.stdout.write(txt)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':

    import psse35
    otdf_report()
    # OR
    #otdf_report(savfile, dfxfile, outpath)

# ====================================================================================================
# [preparer_transfomers_iec_data.py] 04/08/2009 Preparer Two and Three Winding Transformers IEC Data
# ==================================================================================================
'''
In some PSSE Saved Cases, especially some old sav files, all transformer data is provided on
System MVA base (SBASE). When this network data is to be used to calculate fault currents
according to "IEC 60909" standard, in order to calculate correct IEC impedance correction factors,
nameplate transformer winding MVA data is required.

This file is used to:
(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and
    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.
    Refer function: change_winding_mva(rating='')
    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),
    then this files can be used to change transformer winding MVA with selected Rating. 

(2) Create transformers IEC data file.
    Refer function: create_iecdata(wdgmva='',rptfile='')
    Create a text file with all transformer branches and then use this file to provide
    nameplate transformer winding MVA as part of transformer nameplate IEC data records.
    
---------------------------------------------------------------------------------
Functions:

(1) change_winding_mva(rating='')
    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.

(2) create_iecdata(wdgmva='',rptfile='')
    Create IEC data file for all Transformers Winding MVA.
    Each IEC data record for a transformer has following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1

    Transformers IEC data records created here need to put in complete IEC data file.
        Refer POM Volume 1, API IECS for format of IEC data file.
        
    This function creates output file depending on the wndmva input provided.
    (1) If wndmva is not provided, it creates records in the following format.
    IBUS, JBUS, KBUS, CKT
    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.

    (2) If wndmva="SBASE", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

    (3) If wndmva="RATEA" or "RATEB" or "RATEC", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)
          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)
          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)
          If any of the winding MVA is zero, it is ignored.
    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

---------------------------------------------------------------------------------
How to use this file?

(1) Open the Saved Case using PSS(R)E GUI

(2) Without PROMPT for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    change_winding_mva(rating)
    or
    create_iecdata(wndmva, rptfile)

(3) With PROMPTS for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    dochng()
    or
    docreate()
'''

import psspy, os


# ===========================================================================================

def _splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

# ===========================================================================================

def _check_wdgmva(instr):
    '''check for valid wdgmva string.'''

    if type(instr) != str: instr = str(instr)
    instr0 = instr
    
    instr = instr.strip().lower()
    if not instr:
        retv = ''
    elif instr =='ratea':
        retv = "RATEA"
    elif instr =='rateb':
        retv = "RATEB"
    elif instr =='ratec':
        retv = "RATEC"
    elif instr =='sbase':
        retv = "SBASE"
    else:
        print(' Input value "%s" not recognized.\n' % str(instr0))
        retv = ''

    return retv

# ===========================================================================================

def _min_rate(r1,r2):
    if not r1:
        retv = r2
    elif not r2:
        retv = r1
    else:
        retv = min(r1,r2)

    return retv

# ===========================================================================================

def _get_xmer_data(wdgmva=''):

    '''
    wdgmva = 0 or ''    # return just transfomrer buses and ckt id
           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE
           
           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from
           = 'rateb'    # winding rating A or B or C
           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)
    '''
    
    sid   = -1       # all buses
    owner = 1        # ignored
    ties  = 1        # ignored

    # Get Two Winding Transformer Specified Rating
    flag  = 2        # =1 in-service transformers, =2 all
    entry = 1        # each branch once only

    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])
    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        if wdgmva == "SBASE":
            strval = "SBASE1"
        else:
            strval = wdgmva
        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])

    two_wdg_xmers = {}
    for i in range(len(tmplist1[0])):
        busi  = tmplist1[0][i]
        busj  = tmplist1[1][i]
        cktid = tmplist2[0][i]
        if wdgmva:
            val = tmplist3[0][i]
        else:
            val = ''
        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}

    # Three Winding Transformer Specified Rating
    flag  = 3        # =2 all windings of in-service transformers
                     # =3 all transformers
    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)
                     # need to be done differently when entry = 1

    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])
    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])

    three_wdg_xmers = {}
    nwdgs = len(tmplist1[0])
    for i in range(0,nwdgs,3):
        busi     = tmplist1[0][i]
        busj     = tmplist1[1][i]
        busk     = tmplist1[2][i]
        cktid    = tmplist2[0][i]
        if wdgmva == 'SBASE':
            val1 = tmplist3[0][i]
            val2 = tmplist3[0][i+1]
            val3 = tmplist3[0][i+2]
        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:
            ratea_w1 = tmplist3[0][i]
            ratea_w2 = tmplist3[0][i+1]
            ratea_w3 = tmplist3[0][i+2]
            val1 = _min_rate(ratea_w1,ratea_w2)
            val2 = _min_rate(ratea_w2,ratea_w3)
            val3 = _min_rate(ratea_w3,ratea_w1)
        else:
            val1 = ''
            val2 = ''
            val3 = ''
            
        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}
   
    return two_wdg_xmers, three_wdg_xmers

# ===========================================================================================

def change_winding_mva(rating=''):
    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''

    wdgmva = _check_wdgmva(rating)
    
    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:
        print(" No need to update working case.")
        return
    
    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()

    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        ckt  = brn[2]
        sbase12 = two_wdg_xmers[brn]['sbase12']
        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3]
        sbase12 = three_wdg_xmers[brn]['sbase12']
        sbase23 = three_wdg_xmers[brn]['sbase23']
        sbase31 = three_wdg_xmers[brn]['sbase31']    
        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,
                                                      realari8=sbase23, realari9=sbase31)
    
# ===========================================================================================

def create_iecdata(wdgmva='',rptfile=''):
    '''Create IEC data file for all Transformers Winding MVA.'''

    wdgmva = _check_wdgmva(wdgmva)

    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    if rptfile:     # open report file to write
        p,nx = os.path.split(rptfile)
        if not p: p = os.getcwd()
        n,x = os.path.splitext(nx)
        if not x or x.lower() != '.txt': x = '.txt'
        nx = n + x
        rptfile = os.path.join(p,nx)
        rptfile_h = open(rptfile,'w')
        report       = rptfile_h.write
    else:           # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    # printing
    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\n')

    # Two Winding Transformers
    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()
    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = 0
        ckt  = brn[2].strip()
        sbase12 = two_wdg_xmers[brn]['sbase12']
        if sbase12:
            sbase12 = "%8.2f" % sbase12
        else:
            sbase12 = ''
        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\n' % vars())

    # Three Winding Transformers
    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3].strip()
        sbase12  = three_wdg_xmers[brn]['sbase12']
        sbase23  = three_wdg_xmers[brn]['sbase23']
        sbase31  = three_wdg_xmers[brn]['sbase31']    
        if sbase12:
            sbase12 = "%8.2f" % sbase12
            sbase23 = "%8.2f" % sbase23
            sbase31 = "%8.2f" % sbase31
        else:
            sbase12 = ''
            sbase23 = ''
            sbase31 = ''

        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\n' % vars())

    if rptfile:
        print(" Transformers IEC Data records saved in file %s." % rptfile)

# ====================================================================================================

def dochng():
    psspy.prompt("PROVIDE RATING TO SELECT:\n\n\
        - TYPE ratea for RATE A or\n\
        - TYPE rateb for RATE B or\n\
        - TYPE ratec for RATE C")
    
    ierr, rating = psspy.userin()

    change_winding_mva(rating)
    
# ====================================================================================================

def docreate():
    psspy.prompt("PROVIDE WINDING MVA selection string and IEC DATA output text file name:\n\n\
        - ALLOWED WINDING MVA selection string\n\
             sbase, ratea, rateb, ratec or ''(empty string) \n")
    psspy.prompt("        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\n")
    psspy.prompt("TYPE inputs separated either by comma or space.")
    
    ierr, instr = psspy.userin()
    wndmva  = ''
    rptfile = ''

    if instr:
        instrlst = _splitstring_commaspace(instr)
        wndmva = instrlst[0]
        try:
            rptfile = instrlst[1]
        except:
            pass

    create_iecdata(wndmva, rptfile)
    
# ====================================================================================================

if __name__ == '__main__':
    #dochng()
    docreate()

# ====================================================================================================
   

# [preparer_transfomers_iec_data.py] 04/08/2009 Preparer Two and Three Winding Transformers IEC Data
# ==================================================================================================
'''
In some PSSE Saved Cases, especially some old sav files, all transformer data is provided on
System MVA base (SBASE). When this network data is to be used to calculate fault currents
according to "IEC 60909" standard, in order to calculate correct IEC impedance correction factors,
nameplate transformer winding MVA data is required.

This file is used to:
(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and
    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.
    Refer function: change_winding_mva(rating='')
    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),
    then this files can be used to change transformer winding MVA with selected Rating. 

(2) Create transformers IEC data file.
    Refer function: create_iecdata(wdgmva='',rptfile='')
    Create a text file with all transformer branches and then use this file to provide
    nameplate transformer winding MVA as part of transformer nameplate IEC data records.
    
---------------------------------------------------------------------------------
Functions:

(1) change_winding_mva(rating='')
    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.

(2) create_iecdata(wdgmva='',rptfile='')
    Create IEC data file for all Transformers Winding MVA.
    Each IEC data record for a transformer has following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1

    Transformers IEC data records created here need to put in complete IEC data file.
        Refer POM Volume 1, API IECS for format of IEC data file.
        
    This function creates output file depending on the wndmva input provided.
    (1) If wndmva is not provided, it creates records in the following format.
    IBUS, JBUS, KBUS, CKT
    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.

    (2) If wndmva="SBASE", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

    (3) If wndmva="RATEA" or "RATEB" or "RATEC", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)
          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)
          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)
          If any of the winding MVA is zero, it is ignored.
    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

---------------------------------------------------------------------------------
How to use this file?

(1) Open the Saved Case using PSS(R)E GUI

(2) Without PROMPT for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    change_winding_mva(rating)
    or
    create_iecdata(wndmva, rptfile)

(3) With PROMPTS for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    dochng()
    or
    docreate()
'''

import psspy, os


# ===========================================================================================

def _splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

# ===========================================================================================

def _check_wdgmva(instr):
    '''check for valid wdgmva string.'''

    if type(instr) != str: instr = str(instr)
    instr0 = instr
    
    instr = instr.strip().lower()
    if not instr:
        retv = ''
    elif instr =='ratea':
        retv = "RATEA"
    elif instr =='rateb':
        retv = "RATEB"
    elif instr =='ratec':
        retv = "RATEC"
    elif instr =='sbase':
        retv = "SBASE"
    else:
        print(' Input value "%s" not recognized.\n' % str(instr0))
        retv = ''

    return retv

# ===========================================================================================

def _min_rate(r1,r2):
    if not r1:
        retv = r2
    elif not r2:
        retv = r1
    else:
        retv = min(r1,r2)

    return retv

# ===========================================================================================

def _get_xmer_data(wdgmva=''):

    '''
    wdgmva = 0 or ''    # return just transfomrer buses and ckt id
           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE
           
           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from
           = 'rateb'    # winding rating A or B or C
           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)
    '''
    
    sid   = -1       # all buses
    owner = 1        # ignored
    ties  = 1        # ignored

    # Get Two Winding Transformer Specified Rating
    flag  = 2        # =1 in-service transformers, =2 all
    entry = 1        # each branch once only

    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])
    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        if wdgmva == "SBASE":
            strval = "SBASE1"
        else:
            strval = wdgmva
        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])

    two_wdg_xmers = {}
    for i in range(len(tmplist1[0])):
        busi  = tmplist1[0][i]
        busj  = tmplist1[1][i]
        cktid = tmplist2[0][i]
        if wdgmva:
            val = tmplist3[0][i]
        else:
            val = ''
        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}

    # Three Winding Transformer Specified Rating
    flag  = 3        # =2 all windings of in-service transformers
                     # =3 all transformers
    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)
                     # need to be done differently when entry = 1

    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])
    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])

    three_wdg_xmers = {}
    nwdgs = len(tmplist1[0])
    for i in range(0,nwdgs,3):
        busi     = tmplist1[0][i]
        busj     = tmplist1[1][i]
        busk     = tmplist1[2][i]
        cktid    = tmplist2[0][i]
        if wdgmva == 'SBASE':
            val1 = tmplist3[0][i]
            val2 = tmplist3[0][i+1]
            val3 = tmplist3[0][i+2]
        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:
            ratea_w1 = tmplist3[0][i]
            ratea_w2 = tmplist3[0][i+1]
            ratea_w3 = tmplist3[0][i+2]
            val1 = _min_rate(ratea_w1,ratea_w2)
            val2 = _min_rate(ratea_w2,ratea_w3)
            val3 = _min_rate(ratea_w3,ratea_w1)
        else:
            val1 = ''
            val2 = ''
            val3 = ''
            
        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}
   
    return two_wdg_xmers, three_wdg_xmers

# ===========================================================================================

def change_winding_mva(rating=''):
    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''

    wdgmva = _check_wdgmva(rating)
    
    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:
        print(" No need to update working case.")
        return
    
    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()

    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        ckt  = brn[2]
        sbase12 = two_wdg_xmers[brn]['sbase12']
        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3]
        sbase12 = three_wdg_xmers[brn]['sbase12']
        sbase23 = three_wdg_xmers[brn]['sbase23']
        sbase31 = three_wdg_xmers[brn]['sbase31']    
        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,
                                                      realari8=sbase23, realari9=sbase31)
    
# ===========================================================================================

def create_iecdata(wdgmva='',rptfile=''):
    '''Create IEC data file for all Transformers Winding MVA.'''

    wdgmva = _check_wdgmva(wdgmva)

    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    if rptfile:     # open report file to write
        p,nx = os.path.split(rptfile)
        if not p: p = os.getcwd()
        n,x = os.path.splitext(nx)
        if not x or x.lower() != '.txt': x = '.txt'
        nx = n + x
        rptfile = os.path.join(p,nx)
        rptfile_h = open(rptfile,'w')
        report       = rptfile_h.write
    else:           # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    # printing
    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\n')

    # Two Winding Transformers
    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()
    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = 0
        ckt  = brn[2].strip()
        sbase12 = two_wdg_xmers[brn]['sbase12']
        if sbase12:
            sbase12 = "%8.2f" % sbase12
        else:
            sbase12 = ''
        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\n' % vars())

    # Three Winding Transformers
    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3].strip()
        sbase12  = three_wdg_xmers[brn]['sbase12']
        sbase23  = three_wdg_xmers[brn]['sbase23']
        sbase31  = three_wdg_xmers[brn]['sbase31']    
        if sbase12:
            sbase12 = "%8.2f" % sbase12
            sbase23 = "%8.2f" % sbase23
            sbase31 = "%8.2f" % sbase31
        else:
            sbase12 = ''
            sbase23 = ''
            sbase31 = ''

        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\n' % vars())

    if rptfile:
        print(" Transformers IEC Data records saved in file %s." % rptfile)

# ====================================================================================================

def dochng():
    psspy.prompt("PROVIDE RATING TO SELECT:\n\n\
        - TYPE ratea for RATE A or\n\
        - TYPE rateb for RATE B or\n\
        - TYPE ratec for RATE C")
    
    ierr, rating = psspy.userin()

    change_winding_mva(rating)
    
# ====================================================================================================

def docreate():
    psspy.prompt("PROVIDE WINDING MVA selection string and IEC DATA output text file name:\n\n\
        - ALLOWED WINDING MVA selection string\n\
             sbase, ratea, rateb, ratec or ''(empty string) \n")
    psspy.prompt("        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\n")
    psspy.prompt("TYPE inputs separated either by comma or space.")
    
    ierr, instr = psspy.userin()
    wndmva  = ''
    rptfile = ''

    if instr:
        instrlst = _splitstring_commaspace(instr)
        wndmva = instrlst[0]
        try:
            rptfile = instrlst[1]
        except:
            pass

    create_iecdata(wndmva, rptfile)
    
# ====================================================================================================

if __name__ == '__main__':
    #dochng()
    docreate()

# ====================================================================================================
   
# pssexcel_demo.py  Use of pssexcel to export ACCC, PV and QV
# ====================================================================================================
'''
This is an example file showing how to use Python module "pssexcel"
to export ACCC, PV and QV solution results to excel spreadsheets.

Refer help(pssexcel) for details.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example, where XX could be 33 or 34:
    import psseXX

- call any of the function as below
    accc()
    accc(accfile='savnw.acc', show=True, cosep=True)

    pv()
    pv(pvfile='savnw.pv', show=True)

    qv()
    qv(qvfile='savnw.qv', show=True)

---------------------------------------------------------------------------------
Alternatively, use either of the following menu items.
- from Start>Programs>PSSExx>Export Results to Excel OR
- from Power Flow>Reports>Export Results to Excel

'''
# ====================================================================================================
import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# ====================================================================================================

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ====================================================================================================

def accc(accfile='savnw.acc', outpath=None, show=True, cosep=True):
    import pssexcel

    if not os.path.exists(accfile):
        prgmsg = " Error: Input accfile '{0}' does not exist".format(accfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','e','b','i','v','l','g','p','a']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(accfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_accc_' + n)

    sheet = n + '_accc'
    overwritesheet = True

    baseflowvio = False
    basevoltvio = False
    flowlimit   = 0.0
    flowchange  = 0.0
    voltchange  = 0.0
    branchanglediff = True
    angdifmin=0.05

    pssexcel.accc(accfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show,
                  baseflowvio=baseflowvio, basevoltvio=basevoltvio, flowlimit=flowlimit,
                  flowchange=flowchange, voltchange=voltchange, angdifmin=angdifmin, cosep=cosep, branchanglediff=branchanglediff)

# ====================================================================================================

def pv(pvfile='savnw.pv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g','l','b','i']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_pv_' + n)

    sheet = n + '_pv'
    overwritesheet = True

    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

# ====================================================================================================

def qv(qvfile='savnw.qv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_qv_' + n)

    sheet = n + '_qv'
    overwritesheet = True

    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':
    pass
    # change XX to 33, 34 or 35.
    #import psseXX

    #accc(accfile)
    #pv(pvfile)
    #qv(qvfile)

# ====================================================================================================


# pv_export.py  Exporting PV Solution Results to Excel Spreadsheet
# ====================================================================================================
'''
This is an example file showing how to export PV solution results to excel spreadsheets.

Refer help(arrbox.pv_pp) for details.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    excel_report()
    excel_report(pvfile='savnw.pv', show=True)

    text_report()
    text_report(pvfile='savnw.pv')

---------------------------------------------------------------------------------
Alternatively, use either of the following menu items.
- from Start>Programs>PSSExx>Export Results to Excel OR
- from Power Flow>Reports>Export Results to Excel

'''
# ====================================================================================================
import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# ====================================================================================================

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ====================================================================================================

def excel_report(pvfile='savnw.pv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g','l','b','i']
    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pv_export_' + n)

    sheet = n + '_pv'
    overwritesheet = True

    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

# ====================================================================================================

def text_report(pvfile='savnw.pv', outpath=None):

    import arrbox.pv_pp

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    pvobj = arrbox.pv_pp.PV_PP(pvfile)

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    smryfile = get_output_filename(outpath, 'pv_export_' + n +'_summary.txt')
    solnfile = get_output_filename(outpath, 'pv_export_' + n +'_solution.txt')

    ierr = pvobj.summary_report(smryfile)

    ierr = pvobj.solution_report(colabels=None,rptfile=solnfile)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':

    import psse35

    #excel_report()
    #text_report()
    #excel_report(pvfile='savnw.pv', show=True)
    #text_report(pvfile='savnw.pv')

# ====================================================================================================
# qv_export.py  Exporting QV Solution Results to Excel Spreadsheet
# ====================================================================================================
'''
This is an example file showing how to export PV solution results to excel spreadsheets.

Refer help(arrbox.qv_pp) for details.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    excel_report()
    excel_report(qvfile='savnw.qv', show=True)

    text_report()
    text_report(qvfile='savnw.qv')

---------------------------------------------------------------------------------
Alternatively, use either of the following menu items.
- from Start>Programs>PSSExx>Export Results to Excel OR
- from Power Flow>Reports>Export Results to Excel

'''
# ====================================================================================================
import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# ====================================================================================================

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ====================================================================================================

def excel_report(qvfile='savnw.qv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g']
    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'qv_export_' + n)

    sheet = n + '_qv'
    overwritesheet = True

    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

# ====================================================================================================

def text_report(qvfile='savnw.qv', outpath=None):

    import arrbox.qv_pp

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    qvobj = arrbox.qv_pp.QV_PP(qvfile)

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    smryfile = get_output_filename(outpath, 'qv_export_' + n +'_summary.txt')
    solnfile = get_output_filename(outpath, 'qv_export_' + n +'_solution.txt')

    ierr = qvobj.summary_report(smryfile)

    ierr = qvobj.solution_report(colabels=None,rptfile=solnfile)

# ====================================================================================================
# ====================================================================================================
if __name__ == '__main__':

    import psse35

    #excel_report()
    #text_report()
    #excel_report(qvfile='savnw.qv', show=True)
    #text_report(qvfile='savnw.qv')

# ====================================================================================================
'run_idle.py - This script starts up the IDLE interpreter (for Python 2.3).'

import sys

# Import IDLE's PyShell and run its main()
sys.argv=['','-n','-t','PSS/E-Python Shell'] #Arguments for IDLE
import idlelib.PyShell                       #Import the PyShell module
idlelib.PyShell.main()                       #Start IDLE

#[sample_add_substations.py]    Create sample_zils case with various Node Breaker Substation Configurations
# =====================================================================================================
'''This file shows example of adding one or more substation configurations.
Uses sample.raw and sample.seq files.

This example uses substations data [latitude, longitude, RG] from sample_fv4.gic, but applies
different Substation Configurations.
'''
ss_config = {
    1: 'SB',        #'Single Bus',
    2: 'RB',        #'Ring Bus',
    3: 'DBDB',      #'Double Bus double breaker',
    4: 'BH',        #'Breaker and a half',
    5: 'DBSB',      #'Double Bus Single breaker',
    6: 'MBTB',      #'Main Bus Transfer Bus',
    }

sub_dict = {
     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211      ]},
     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022   ]},
     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154                    ]},
     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202              ]},
     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204]},
     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                ]},
     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002      ]},
     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005           ]},
     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018       ]},
    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                          ]},
    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                          ]},
    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212                          ]},
    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                          ]},
    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                          ]},
    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                          ]},
    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                 ]},
    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                         ]},
    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                         ]},
    }

rawfnam           = r"sample.raw"
seqfnam           = r"sample.seq"
rawoutfnam        = r"sample"
rawoutfnam_nb     = r"sample_nb"
rawoutfnam_nb_sec = r"sample_nb_sec"
prgfnam           = r"sample_nb_progress.txt"

import os

# ==================================================================================================
def solve_pf():
    import psspy
    pf_options = [1,0,0,1,1,0,99,0]
    psspy.fdns(pf_options)
    psspy.fdns(pf_options)
    ival = psspy.solved()
    return ival

def save_case(rawfile, seqfile, savfnam, outpath):
    import psspy
    psspy.read(0, rawfile)
    psspy.resq(seqfile)
    ival = solve_pf()
    if ival==0:
        savfile = "{}.sav".format(savfnam)
        savfile = os.path.join(outpath, savfile)
        psspy.save(savfile)

# ==================================================================================================

def run(datapath=None, outpath=None):
    import psspy

    if datapath is None:        # use Example folder
        psspy_dir = os.path.dirname(psspy.__file__)
        psse_dir, jnk = os.path.split(psspy_dir)
        datapath = os.path.join(psse_dir, 'Example')

    rawfile = os.path.join(datapath, rawfnam)
    seqfile = os.path.join(datapath, seqfnam)

    if not os.path.exists(rawfile):
        msg = "\n Error- RAW file not found, terminated:\n    {}".format(rawfile)
        print(msg)
        return

    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ file not found, terminated:\n    {}".format(seqfile)
        print(msg)
        return

    if outpath is None:
        outpath = os.path.dirname(__file__)
        outpath = os.path.join(outpath, 'output_sample_nb')
    if not os.path.exists(outpath): os.makedirs(outpath)

    psspy.psseinit()

    prgfile = os.path.join(outpath, prgfnam)

    psspy.progress_output(2,prgfile,[0,0])

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()
    _s = psspy.getdefaultchar()

    psspy.read(0, rawfile)
    psspy.resq(seqfile)

    ival_raw = solve_pf()
    if ival_raw>0:
        msg = "\n Error - Power flow non converged. RAW file:\n    {}".format(rawfile)
        print(msg)
        return

    sslst = list(sub_dict.keys())
    sslst.sort()

    for ss in sslst:
        vdict = sub_dict[ss]
        name  = sub_dict[ss]['name']
        lat   = sub_dict[ss]['lat']
        lon   = sub_dict[ss]['long']
        rg    = sub_dict[ss]['rg']
        config= sub_dict[ss]['config']
        buses = sub_dict[ss]['buses']

        s_ss = "{:{fill}2d}".format(ss, fill='0')
        s_config = ss_config[config]

        ss_name  = "SS{}_{}_TYP_{}_{}".format(s_ss, name, config, s_config)

        for b in buses:
            psspy.station_build_config(b,ss,_s,config)

        psspy.station_data(ss, [lat, lon, rg], ss_name)

    # Update/Change Node and Switching Device Names
    sid = -1
    flag = 1
    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])
    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])

    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'NODE', str(node)]
        newnam = '_'.join(newlst)
        psspy.station_node_chng(ss,node,[_i,_i],newnam)

    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])
    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])

    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]
        newnam = '_'.join(newlst)
        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)

    # --------------------------------------------------
    # Save un-solved raw file
##    rawfileout = "{}_pf_no.raw".format(rawoutfnam_nb)
##    rawfileout = os.path.join(outpath, rawfileout)
##    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout)

    # --------------------------------------------------
    # Solve power flow and save raw file
    ival_raw_nb = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, NO ZILS')
    rawfileout_nb = "{}.raw".format(rawoutfnam_nb)
    rawfileout_nb = os.path.join(outpath, rawfileout_nb)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)

    seqfileout_nb = "{}.seq".format(rawoutfnam_nb)
    seqfileout_nb = os.path.join(outpath, seqfileout_nb)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)

    if ival_raw_nb>0:
        msg = "\n Error - Power flow non converged after adding substations, SAV file not created."
        print(msg)

    # --------------------------------------------------
    # Create substation sections
    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)

    # --------------------------------------------------
    # Solve power flow and save raw file
    ival_raw_nb_sec = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, NO ZILS')
    rawfileout_nb_sec = "{}.raw".format(rawoutfnam_nb_sec)
    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)

    seqfileout_nb_sec = "{}.seq".format(rawoutfnam_nb_sec)
    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)

    if ival_raw_nb_sec>0:
        msg = "\n Error - Power flow non converged after adding substation sections, SAV file not created."
        print(msg)
        return

    # --------------------------------------------------
    # Create .sav files
    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ sile not found:\n    {}".format(seqfile)
        print(msg)
        return

    # base case
    save_case(rawfile, seqfile, rawoutfnam, outpath)

    # base+NB case
    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)

    # base+NB+sections case
    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)

    # --------------------------------------------------
    # all done

    psspy.progress_output(1,"",[0,0])

    msg = "\n Progress saved in file: {}".format(prgfile)
    print(msg)

# ==================================================================================================
def test1():
    # Run from outside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

# --------------------------------------------------
def test2():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

# --------------------------------------------------
def test3():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from Example folder.
    # Create output RAW/SEQ files in folder Example/output_sample_nb.
    run()

# ==================================================================================================
if __name__=='__main__':
    pass
#[sample_zils_add_substations.py]    Create sample case with various Node Breaker Substation Configurations
# =====================================================================================================
'''This file shows example of adding one or more substation configurations.
Uses sample_zils.raw and sample_zils.seq files.

This example uses substations data [latitude, longitude, RG] from sample_zils_fv4.gic, but applies
different Substation Configurations.
'''
ss_config = {
    1: 'SB',        #'Single Bus',
    2: 'RB',        #'Ring Bus',
    3: 'DBDB',      #'Double Bus double breaker',
    4: 'BH',        #'Breaker and a half',
    5: 'DBSB',      #'Double Bus Single breaker',
    6: 'MBTB',      #'Main Bus Transfer Bus',
    }

sub_dict = {
     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211, 80102, 80151 ]},
     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022, 803022    ]},
     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154, 809154                     ]},
     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202, 80203                ]},
     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204         ]},
     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                         ]},
     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002, 803002       ]},
     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005                    ]},
     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018, 803008, 803010, 803018]},
    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                                   ]},
    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                                   ]},
    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212, 80212                            ]},
    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                                   ]},
    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                                   ]},
    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                                   ]},
    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                          ]},
    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                                  ]},
    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                                  ]},
    19: {'name': 'DC2TERM',     'lat': 31.7104,  'long': -84.5694 ,  'rg':0.30, 'config':1, 'buses': [301, 80301                            ]},
    20: {'name': 'DCMTERM',     'lat': 33.9163,  'long': -81.9163 ,  'rg':0.31, 'config':1, 'buses': [401, 402, 80402                       ]},
    }

rawfnam           = r"sample_zils.raw"
seqfnam           = r"sample_zils.seq"
rawoutfnam        = r"sample_zils"
rawoutfnam_nb     = r"sample_zils_nb"
rawoutfnam_nb_sec = r"sample_zils_nb_sec"
prgfnam           = r"sample_zils_nb_progress.txt"

import os

# ==================================================================================================
def solve_pf():
    import psspy
    pf_options = [1,0,0,1,1,0,99,0]
    psspy.fdns(pf_options)
    psspy.fdns(pf_options)
    ival = psspy.solved()
    return ival

def save_case(rawfile, seqfile, savfnam, outpath):
    import psspy
    psspy.read(0, rawfile)
    psspy.resq(seqfile)
    ival = solve_pf()
    if ival==0:
        savfile = "{}.sav".format(savfnam)
        savfile = os.path.join(outpath, savfile)
        psspy.save(savfile)

# ==================================================================================================

def run(datapath=None, outpath=None):
    import psspy

    if datapath is None:        # use Example folder
        psspy_dir = os.path.dirname(psspy.__file__)
        psse_dir, jnk = os.path.split(psspy_dir)
        datapath = os.path.join(psse_dir, 'Example')

    rawfile = os.path.join(datapath, rawfnam)
    seqfile = os.path.join(datapath, seqfnam)

    if not os.path.exists(rawfile):
        msg = "\n Error- RAW file not found, terminated:\n    {}".format(rawfile)
        print(msg)
        return

    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ file not found, terminated:\n    {}".format(seqfile)
        print(msg)
        return

    if outpath is None:
        outpath = os.path.dirname(__file__)
        outpath = os.path.join(outpath, 'output_sample_nb')
    if not os.path.exists(outpath): os.makedirs(outpath)

    psspy.psseinit()

    prgfile = os.path.join(outpath, prgfnam)

    psspy.progress_output(2,prgfile,[0,0])

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()
    _s = psspy.getdefaultchar()

    psspy.read(0, rawfile)
    psspy.resq(seqfile)

    ival_raw = solve_pf()
    if ival_raw>0:
        msg = "\n Error - Power flow non converged. RAW file:\n    {}".format(rawfile)
        print(msg)
        return

    sslst = list(sub_dict.keys())
    sslst.sort()

    for ss in sslst:
        vdict = sub_dict[ss]
        name  = sub_dict[ss]['name']
        lat   = sub_dict[ss]['lat']
        lon   = sub_dict[ss]['long']
        rg    = sub_dict[ss]['rg']
        config= sub_dict[ss]['config']
        buses = sub_dict[ss]['buses']

        s_ss = "{:{fill}2d}".format(ss, fill='0')
        s_config = ss_config[config]

        ss_name  = "SS{}_{}_TYP_{}_{}".format(s_ss, name, config, s_config)

        for b in buses:
            psspy.station_build_config(b,ss,_s,config)

        psspy.station_data(ss, [lat, lon, rg], ss_name)

    # Update/Change Node and Switching Device Names
    sid = -1
    flag = 1
    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])
    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])

    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'NODE', str(node)]
        newnam = '_'.join(newlst)
        psspy.station_node_chng(ss,node,[_i,_i],newnam)

    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])
    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])

    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]
        newnam = '_'.join(newlst)
        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)

    # --------------------------------------------------
    # Save un-solved raw file
##    rawfileout = "{}_pf_no.raw".format(rawoutfnam_nb)
##    rawfileout = os.path.join(outpath, rawfileout)
##    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout)

    # --------------------------------------------------
    # Solve power flow and save raw file
    ival_raw_nb = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, CONTAINS ZILS')
    rawfileout_nb = "{}.raw".format(rawoutfnam_nb)
    rawfileout_nb = os.path.join(outpath, rawfileout_nb)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)

    seqfileout_nb = "{}.seq".format(rawoutfnam_nb)
    seqfileout_nb = os.path.join(outpath, seqfileout_nb)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)

    if ival_raw_nb>0:
        msg = "\n Error - Power flow non converged after adding substations, SAV file not created."
        print(msg)

    # --------------------------------------------------
    # Create substation sections
    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)

    # --------------------------------------------------
    # Solve power flow and save raw file
    ival_raw_nb_sec = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, CONTAINS ZILS')
    rawfileout_nb_sec = "{}.raw".format(rawoutfnam_nb_sec)
    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)

    seqfileout_nb_sec = "{}.seq".format(rawoutfnam_nb_sec)
    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)

    if ival_raw_nb_sec>0:
        msg = "\n Error - Power flow non converged after adding substation sections, SAV file not created."
        print(msg)
        return

    # --------------------------------------------------
    # Create .sav files
    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ sile not found:\n    {}".format(seqfile)
        print(msg)
        return

    # base case
    save_case(rawfile, seqfile, rawoutfnam, outpath)

    # base+NB case
    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)

    # base+NB+sections case
    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)

    # --------------------------------------------------
    # all done
    psspy.progress_output(1,"",[0,0])

    msg = "\n Progress saved in file: {}".format(prgfile)
    print(msg)

# ==================================================================================================
def test1():
    # Run from outside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

# --------------------------------------------------
def test2():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

# --------------------------------------------------
def test3():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from Example folder.
    # Create output RAW/SEQ files in folder Example/output_sample_nb.
    run()

# ==================================================================================================
if __name__=='__main__':
    pass
#[sensitivity_factors.py]  Sensitivity Analysis Report and Accesing them in Python Script
# ====================================================================================================
'''Sensitivity Factors of a branch flow to MW power at generator and load buses:
This is an example file showing how to generate sensitivity factors report or
access those factor values in Python script.

# ----------------------------------------------------------------------------------------------------

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    run_demo()  OR
    run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None)
    You could modify various inputs in run)demo() as desired.
'''

# ====================================================================================================
import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# ====================================================================================================

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ====================================================================================================

def create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile):
    # Create Report
    import arrbox.sensitivity_flow_to_mw

    flow2mw = arrbox.sensitivity_flow_to_mw()

    ierr = flow2mw.sensitivity_flow_to_mw_report(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',
        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='',rptfile=rptfile)

# ====================================================================================================

def demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys):
    # Access factor results in Python script
    import arrbox.sensitivity_flow_to_mw

    flow2mw = arrbox.sensitivity_flow_to_mw()

    robj = flow2mw.sensitivity_flow_to_mw(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',
        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='')

    print("\n Returned dictionary object as is:")
    print(robj)
    print('\n')

    print("  Getting 'ngenbuses' value by different ways:")
    print("     robj.ngenbuses    = {0:d}".format(robj.ngenbuses))
    print("     robj.ngenBuses    = {0:d}".format(robj.ngenBuses))
    print("     robj['ngenbuses'] = {0:d}".format(robj['ngenbuses']))
    print("     robj['NGENbuses'] = {0:d}".format(robj['NGENbuses']))
    print('\n')

    print("  Bus names for which generator factors are calculated:")
    print(list(robj.genvalues.keys()))
    print('\n')

    print("  Generator factors:")
    for bus, vdict in list(robj.genvalues.items()):
        tdct = {'bus':bus, 'pmax':vdict.pmax, 'pmin':vdict.pmin, 'pgen':vdict.pgen, 'sftr':vdict.factor}
        print("{bus:s}  {pmax:8.2f}  {pmin:8.2f} {pgen:8.2f}  {sftr:8.5f}".format(**tdct))

# ====================================================================================================

def run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):
    import psspy

    ibus        = 151
    jbus        = 152
    kbus        = 0
    ckt         = '1'
    mainsys     = 'STUDY'
    netmod      = 'dc'
    brnflowtyp  = 'mw'
    transfertyp = 'import'
    oppsystyp   = 'slack bus'
    dispmod     = 1
    toln        = None
    oppsys      = ''

    if not os.path.exists(savfile):
        prgmsg = " Error: Input savfile '{0}' does not exist".format(savfile)
        print(prgmsg)
        return

    if not os.path.exists(dfxfile):
        prgmsg = " Error: Input dfxfile '{0}' does not exist".format(dfxfile)
        print(prgmsg)
        return

    p, nx = os.path.split(dfxfile)
    n, x = os.path.splitext(nx)

    rptfile = get_output_filename(outpath, 'sensitivity_factors_' + n +'_report.txt')

    psspy.psseinit()

    psspy.case(savfile)

    create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile)

    demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys)

# ====================================================================================================
# ====================================================================================================

if __name__ == '__main__':

    import psse35
    run_demo()

# ====================================================================================================
# [pssgrpg.py]     04/23/20     Python Functions to emulate GRPG
#
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#  *                                                                     *
#  *  THIS PROGRAM AND ITS DOCUMENTATION ARE TRADE SECRETS OF POWER      *
#  *  TECHNOLOGIES, INC. (PTI).  THEY HAVE BEEN LEASED TO                *
#  *                   client full name (clabr)                          *
#  *  SUBJECT TO TERMS WHICH PROHIBIT clabr FROM DISCLOSING OR TRANS-    *
#  *  FERRING THE PROGRAM OR ITS DOCUMENTATION, WHETHER IN ITS ORIGINAL  *
#  *  OR MODIFIED FORM, TO A THIRD PARTY, OR FROM USING THE PROGRAM FOR  *
#  *  ANY PURPOSE OTHER THAN COMPUTATION RELATING TO clabr'S OWN SYSTEM. *
#  *  ANY SUCH TRANSFER OR USE BY clabr OR ITS EMPLOYEES WILL CONSTI-    *
#  *  TUTE A BREACH OF CONFIDENCE AND OF THE CONTRACT UNDER WHICH        *
#  *  RIGHTS OF USE HAVE BEEN GRANTED.                                   *
#  *                                                                     *
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'''The functions in this Python module return:
    - formatted text which can be used to put annotation on slider diagrams.
    - values which are used to generate formatted text above.
Example: function 'area_summary' returns formatted text and
         function 'area_summary_v' returns values used by 'area_summary'
         i.e, functions with name ending with "_v" return values
'''

import psspy

#========================================================================================

def area_summary_v(arnum):
    '''Returns desired and net interchange, loads, generation and losses for
    area 'arnum'.
pdes,pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.area_summary_v(arnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.asys(sid, flag, [arnum])
    ierr, rdata = psspy.aareareal(sid,flag,
        ['PDES','PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])
    psspy.asysdef(sid, 0)
    if ierr==0:
        (pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata
        if len(pdes)>0:
           return pdes[0],pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]
    return None,None,None,None,None,None,None,None,None

def area_summary(arnum):
    '''Returns formatted text showing desired and net interchange, loads, generation
     and losses for area 'arnum'.
txt = pssgrpg.area_summary(arnum)
'''
    pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = area_summary_v(arnum)
    if pdes:
        txt = '''Area %(arnum)d Summary:
  Desired Interchange: %(pdes)9.2f MW
  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR
  Area loads         : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR
  Area generation    : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Area losses        : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    else:
        txt = '''Area %(arnum)d Summary:
  Desired Interchange: None
  Net Interchange    : None
  Area loads         : None
  Area generation    : None
  Area losses        : None''' % vars()
    return txt

def area_interchange_net_v(arnum):
    '''Returns desired and net interchange for area 'arnum'.
pdes,pint,qint = pssgrpg.area_interchange_net_v(arnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.asys(sid, flag, [arnum])
    ierr, rdata = psspy.aareareal(sid,flag,['PDES','PINT','QINT'])
    psspy.asysdef(sid, 0)
    if ierr==0:
        (pdes,pint,qint) = rdata
        if len(pdes)>0:
           return pdes[0],pint[0],qint[0]
    return None,None,None

def area_interchange_net(arnum):
    '''Returns formatted text showing desired and net interchange for area 'arnum'.
txt = pssgrpg.area_interchange_net(arnum)
'''
    pdes,pint,qint = area_interchange_net_v(arnum)
    if pdes:
        txt = '''Area %(arnum)d Interchange:
  Desired Interchange: %(pdes)9.2f MW
  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Area %(arnum)d Interchange:
  Desired Interchange: None
  Net Interchange    : None''' % vars()
    return txt

def area_interchange_ij_v(iar,jar):
    '''Returns interchange from area 'iar' to area 'jar'.
p,q = pssgrpg.area_interchange_ij_v(iar,jar)
'''
    ierr, cmpval = psspy.aritoj(iar,jar)
    if ierr==0:
        return cmpval.real, cmpval.imag
    return None,None

def area_interchange_ij(iar,jar):
    '''Returns formatted text showing interchange from area 'iar' to area 'jar'.
txt = pssgrpg.area_interchange_ij(iar,jar)
'''
    pint,qint = area_interchange_ij_v(iar,jar)
    if pint:
        txt = '''Interchange from Area %(iar)d to Area %(jar)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Interchange from Area %(iar)d to Area %(jar)d: None''' % vars()
    return txt

#========================================================================================

def zone_summary_v(znnum):
    '''Returns net interchange, loads, generation and losses for zone 'znnum'.
pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.zone_summary_v(znnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.zsys(sid, flag, [znnum])
    ierr, rdata = psspy.azonereal(sid,flag,
        ['PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])
    psspy.zsysdef(sid, 0)
    if ierr==0:
        (pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata
        if len(pint)>0:
           return pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]
    return None,None,None,None,None,None,None,None,None

def zone_summary(znnum):
    '''Returns formatted text showing net interchange, loads, generation and losses
    for zone 'znnum'.
txt = pssgrpg.zone_summary(znnum)
'''
    pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = zone_summary_v(znnum)
    if pint:
        txt = '''Zone %(znnum)d Summary:
  Net Interchange : %(pint)9.2f MW, %(qint)9.2f MVAR
  Zone loads      : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR
  Zone generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Zone losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    else:
        txt = '''Zone %(znnum)d Summary:
  Net Interchange : None
  Zone loads      : None
  Zone generation : None
  Zone losses     : None''' % vars()
    return txt

def zone_interchange_ij_v(izn,jzn):
    '''Returns interchange from zone 'izn' to zone 'jzn'.
p,q = pssgrpg.zone_interchange_ij_v(izn,jzn)
'''
    ierr, cmpval = psspy.znitoj(izn,jzn)
    if ierr==0:
        return cmpval.real, cmpval.imag
    return None,None

def zone_interchange_ij(izn,jzn):
    '''Returns formatted text showing interchange from zone 'izn' to zone 'jzn'.
txt = pssgrpg.zone_interchange_ij(izn,jzn)
'''
    pint,qint = zone_interchange_ij_v(izn,jzn)
    if pint:
        txt = '''Interchange from Zone %(izn)d to Area %(jzn)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Interchange from Zone %(izn)d to Zone %(jzn)d: None''' % vars()
    return txt

#========================================================================================

def system_summary_v():
    '''Returns working case loads, generation and losses.
pload,qload,pgen,qgen,ploss,qloss = pssgrpg.system_summary_v()
'''
    ierr, syslod = psspy.systot('LOAD')
    ierr, sysgen = psspy.systot('GEN')
    ierr, syslos = psspy.systot('LOSS')
    return syslod.real, syslod.imag, sysgen.real, sysgen.imag, syslos.real, syslos.imag

def system_summary():
    '''Returns formatted text showing working case loads, generation and losses.
txt = pssgrpg.system_summary()
'''
    pload,qload,pgen,qgen,ploss,qloss = system_summary_v()
    txt = '''Case Summary:
  Total loads      : %(pload)9.2f MW, %(qload)9.2f MVAR
  Total generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Total losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    return txt

#========================================================================================
#[wecclf_demo.py]  Demo for running WECCLF Converter from Python Scripts
# ====================================================================================================
'''
WECCLF converter is used to convert PSLF Power Flow (.epc) and Sequence (.seq) Data
to PSSE Power Flow (.raw) and Sequence (.seq) Data.

Additionally it also compares PSSE and PSLF Power Flow Solutions.

WECCLF converter can be run from its own GUI:
>>> import wecclf_gui
>>> wecclf_gui.main()

This scripts shows different ways to run WECCLF Converter from Python Scripts.
'''

import os, sys

# ====================================================================================================

def run_wecclf(pslf_version, pslf_epcfile, psse_version, workdir=os.getcwd(), testnum=2):

    import ndppslf

    if not os.path.exists(pslf_epcfile):
        msgtxt = " EPC file does not exist, WECCLF converter not run.\n    {}".format(pslf_epcfile)
        print(msgtxt)
        return

    p, nx = os.path.split(pslf_epcfile)
    nam, ext  = os.path.splitext(nx)

    outdir = 'wecclf_demo_output_v{}'.format(psse_version)
    workdir = os.path.join(workdir, outdir)
    if not os.path.exists(workdir): os.makedirs(workdir)

    rawfnam  = "{}_v{}.raw".format(nam, psse_version)
    rawfile  = os.path.join(workdir, rawfnam)

    prgsplit = False
    prgfull  = True

    if testnum==1:
        #(1) Convert and compare power flow solutions using all default options
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, ratea=1, rateb=2, ratec=3,
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull)

    elif testnum==2:
        #(2) Convert only
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, do_psse_pfsoln=False,
            workdir=workdir, compare_pfsoln=False, prgfull=prgfull, prgsplit=prgsplit)

    elif testnum==3:
        #(3) Convert and compare power flow solutions using options from epcfile and options as specified
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile,
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,
            pfmethod='RSOL', use_epcoptns=False, itmxn=100, flat=0, varlmt=99, nondiv=0,
            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,
            compare_pfsoln=True, show_ntop=-1, toler_vpu=-0.001,
            toler_pgen=-1.0, toler_qgen=-1.0, toler_bact=-0.01, toler_pitf=-1.0, toler_qitf=-1.0)

    elif testnum==4:
        #(4) Convert and compare power flow solutions using options as specified
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, psse_autofile='',
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,
            pfmethod='RSOL', use_epcoptns=False, itmxn=100, toln=0.1, thrshz=0.0001, tap=0,
            area=0, phshft=0, dctap=1, swsh=1,flat=0, varlmt=99, nondiv=0,
            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,
            compare_pfsoln=True, show_ntop=100, toler_vpu=0.02, toler_pgen=1.0,
            toler_qgen=-1.0, toler_bact=0.01, toler_pitf=1.0, toler_qitf=-1.0)

# ====================================================================================================

def _run_how():
    pass
##    # EPC file version=18
##    epcfile18 = r"sample18.epc"
##    run_wecclf(18, epcfile18, psse_version=34, workdir=os.getcwd(), testnum=3)
##
##    # EPC file version=19
##    epcfile19 = r"sample19.epc"
##    run_wecclf(19, epcfile19, psse_version=34, workdir=os.getcwd(), testnum=3)
##
##    # EPC file version=21
##    epcfile21 = r"sample21.epc"
##    run_wecclf(21, epcfile21, psse_version=34, workdir=os.getcwd(), testnum=3)

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if __name__ == '__main__':
    pass
    # Here "import psse34" or "import psse35" as appropriate.
    # Then run required test. See _run_how() above for reference.
#[wordpy_demo.py]  Demo for using functions from wordpy module
# ====================================================================================================
'''
'wordpy' module provides Pythonic Interface to Miscrosoft Word.
This module has functions to create new or update existing Microsoft Word document by:
- adding text into Word document
- inserting pictures/plots into Word document

This is an example file showing how to use various functions available in wordpy module.

---------------------------------------------------------------------------------
How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    run()  OR
    run(pssplt_eps_files, pict_files, docfile, outpath, show)
    You could modify various inputs in run)demo() as desired.

'''

# ====================================================================================================
import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

# ====================================================================================================

def get_output_filename(outpath, fnam):

    p, nx = os.path.split(fnam)
    if p:
        retvfile = fnam
    else:
        outdir = get_output_dir(outpath)
        retvfile = os.path.join(outdir, fnam)

    return retvfile

# ====================================================================================================

def run(pssplt_eps_files=[], pict_files=[], docfile='', outpath=None, show=True):
    """
Inputs:
pssplt_eps_files --> List of Multi-page 'eps' plot files created by PSSPLT
pict_files       --> List of any word compatible picture files (.eps, .wmf, .png, .bmp etc.)
docfile          --> Word file name
outpath          --> Outpath where Word file created/saved
Show             --> = True, Show Word
                     = False, Create and Save Word file but do not show
"""
    import wordpy

    pssplt_eps_files_lst = []
    for fnam in pssplt_eps_files:
        if not os.path.exists(fnam): continue
        pssplt_eps_files_lst.append(fnam)

    pict_files_lst   = []
    pict_caption_lst = []
    for fnam in pict_files:
        if not os.path.exists(fnam): continue
        p, nx = os.path.split(fnam)
        caption, x = os.path.splitext(nx)
        pict_files_lst.append(fnam)
        pict_caption_lst.append(caption)

    if  docfile:
        p, nx = os.path.split(docfile)
        docfnam, x = os.path.splitext(nx)
    else:
        docfnam = r'wordpy_demo_created'
        p = outpath

    # doc file
    docfile = get_output_filename(p, docfnam)

    docoverwrite = True

    # Picture Insert Options (see help(wordpy) for explaination)
    align      = 'center'
    captionpos = 'below'
    height     = None
    width      = None
    rotate     = None

    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    # Put-it-together
    wdobj = wordpy.workdoc(docfile=docfile, overwrite=docoverwrite)
    if show:
        wdobj.show()

    wdobj.page_format(orientation="portrait",left=0.75,right=0.75,top=0.5,bottom=0.5,
                      header=0.25,footer=0.25)

    wdobj.add_styled_para('Use of Python and Word','Title')

    txt = "This file is produced by Python script, by inserting picture files into word document. \
    It uses python module 'wordpy'.\n\n\
    This module is mainly created to add plot files (.eps, .png, .wmf etc.) \
    created by PSSPLT/PSSPLOT to existing or new Word files.\n\n\
    Use PSSPLT to create .eps files, and PSSPLOT to create .wmf files. Then use \
    'wordpy' module to create Word document from those files.\n\n\
    How to use it?\n\n\
    Use 'workdoc' function to create Miscrosoft Word object and use 'add_picture(...)' or \
    'add_pictures(...)' methods to insert pictures into the doc file.\n\n"
    wdobj.add_text(txt)

    txt = """Use either of the following to create Word object:
    (1) When file does not exist, create new file.
        wdobj = wordpy.workdoc()
    (2) When file exists, do not remove the content and add data at the end.
        wdobj = wordpy.workdoc(r"c:\working dir\ex1.doc", overwrite=False)
    (3) When file exists, remove the content and create new file.
        wdobj = wordpy.workdoc(r"c:\working dir\ex1.doc", overwrite=True)
    """
    wdobj.add_text(txt)


    if pssplt_eps_files_lst:
        wdobj.insert_page_break()
        wdobj.add_styled_para('Inserting multi-page PSSPLT EPS Files - add_pssplt_eps(...)','Heading 1')
        for fnam in pssplt_eps_files_lst:
            wdobj.add_pssplt_eps(fnam, captionlst=True, align=align, captionpos=captionpos,
                                 height=height, width=width, rotate=rotate)
            wdobj.insert_page_break()

    if pict_files_lst:
        wdobj.add_styled_para('Inserting One Picture File - add_picture(...)','Heading 1')
        wdobj.add_picture(pictfile=pict_files_lst[0], caption=pict_caption_lst[0], align=align,
                          captionpos=captionpos, height=None, width=None, rotate=0.0)
        wdobj.insert_page_break()

    if pict_files_lst:
        wdobj.add_styled_para('Inserting Many Picture Files - add_pictures(...)','Heading 1')
        wdobj.add_pictures(pictfilelst=pict_files_lst, captionlst=pict_caption_lst, align=align,
                           captionpos=captionpos, height=height, width=width, rotate=0.0)

    wdobj.save()

    if not show:
        txt = "\n Word file created:\n     {0}".format(wdobj.DOCFNAM)
        wdobj.close()
        print(txt)

# ====================================================================================================
# ====================================================================================================

if __name__ == '__main__':

    import psse35
    run()

# ====================================================================================================


