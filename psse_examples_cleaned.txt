--- Area Data — .txt ---

Area Data — 

Area Data¶

aareachar

 return an array of character values for subsystem areas.

aareacount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the area data family.

aareacplx

 return an array of complex values for subsystem areas.

aareaint

 return an array of integer values for subsystem areas.

aareareal

 return an array of real values for subsystem areas.

aareatypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the area data family (aAreaInt, aAreaReal, aAreaCplx and aAreaChar).

--- Area Subsystems — .txt ---

Area Subsystems — 

Area Subsystems¶

asys

 define an area subsystem.

asysdef

 set the definition of an area subsystem.

asysinit

 initialize or re-initialize an area subsystem.

--- Assign Branch Quantities To Output Channels — .txt ---

Assign Branch Quantities To Output Channels — 

Assign Branch Quantities To Output Channels¶

branch_app_r_x_channel

 add a pair of output channels containing the apparent impedance, as seen at the from bus of a specified branch, along with a corresponding call to the RELAY2 monitoring model.

branch_mva_channel

 add an output channel containing the MVA flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.

branch_p_and_q_channel

 add a pair of output channels containing the active and reactive power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.

branch_p_channel

 add an output channel containing the active power flow at the from bus of a specified branch, along with a corresponding call to the FLOW1 monitoring model.

three_wnd_app_r_x_channel

 add a pair of output channels containing the apparent impedance as seen at the from bus of a specified three-winding transformer, along with a corresponding call to the RELAY3 monitoring model.

three_wnd_mva_channel

 add an output channel containing the MVA flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.

three_wnd_p_and_q_channel

 add a pair of output channels containing the active and reactive power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.

three_wnd_p_channel

 add an output channel containing the active power flow at the from bus of a specified three-winding transformer, along with a corresponding call to the FLOW3 monitoring model.

--- Assign Machine Quantities To Output Channels — .txt ---

Assign Machine Quantities To Output Channels — 

Assign Machine Quantities To Output Channels¶

machine_app_r_x_channel

 add a pair of output channels containing the apparent impedance of the system, as seen from the terminals of a specified machine, along with a corresponding call to the GENTMZ monitoring model.

machine_array_channel

 add an output channel containing a plant related model variable of a designated type for a specified machine.

machine_iterm_channel

 add an output channel containing the terminal current of a specified machine, along with a corresponding call to the GENTMC monitoring model.

--- Assign Other Quantities To Output Channels — .txt ---

Assign Other Quantities To Output Channels — 

Assign Other Quantities To Output Channels¶

bus_frequency_channel

 add an output channel containing the per unit frequency deviation at a specified bus.

state_channel

 add an output channel containing the value of a specified STATE.

var_channel

 add an output channel containing the value of a specified VAR.

voltage_and_angle_channel

 add a pair of output channels containing the voltage magnitude in per unit and phase angle in degrees of a specified bus, along with a corresponding call to the VOLMAG monitoring model.

voltage_channel

 add an output channel containing the voltage magnitude in per unit of a specified bus, along with a corresponding call to the VOLMAG monitoring model.

--- Auxiliary Signal Models — .txt ---

Auxiliary Signal Models — 

Auxiliary Signal Models¶

add_fctsauxsignal_model

 add a FACTS device auxiliary signal model at the specified injection point of the designated FACTS device.

add_mtdcauxsignal_model

 add a multi-terminal dc line auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.

add_ttdcauxsignal_model

 add a two-terminal dc line auxiliary signal model at the specified injection point of the designated two-terminal dc line.

add_vsdcauxsignal_model

 add a VSC dc line auxiliary signal model at the specified injection point of the designated VSC dc line.

auxmod_pack

 remove entries that are marked as unused from the auxiliary signal model connection tables and the auxiliary signal array allocation tables.

auxmod_unconnected

 list or remove from dynamics working memory those auxiliary signal models that are assigned to dc lines or FACTS devices that are not present in the current power flow working case (unconnected).

auxmod_user

 list user-written auxiliary signal model definitions or to remove user-written auxiliary signal model definitions that are not assigned to any dc lines or FACTS devices (unused) from the user model definition tables.

change_fctsauxmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified FACTS device.

change_fctsauxmod_con

 change the value of a CON of an auxiliary signal model of a specified FACTS device.

change_fctsauxmod_data

change_fctsauxmod_icon

 change the value of an integer ICON of an auxiliary signal model of a specified FACTS device.

change_fctsauxmod_var

 change the value of a VAR of an auxiliary signal model of a specified FACTS device.

change_mtdcauxmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified multi-terminal dc line.

change_mtdcauxmod_con

 change the value of a CON of an auxiliary signal model of a specified multi- terminal dc line.

change_mtdcauxmod_data

change_mtdcauxmod_icon

 change the value of an integer ICON of an auxiliary signal model of a specified multi-terminal dc line.

change_mtdcauxmod_var

 change the value of a VAR of an auxiliary signal model of a specified multi- terminal dc line.

change_ttdcauxmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified two-terminal dc line.

change_ttdcauxmod_con

 change the value of a CON of an auxiliary signal model of a specified two- terminal dc line.

change_ttdcauxmod_data

change_ttdcauxmod_icon

 change the value of an integer ICON of an auxiliary signal model of a specified two-terminal dc line.

change_ttdcauxmod_var

 change the value of a VAR of an auxiliary signal model of a specified two- terminal dc line.

change_vsdcauxmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of an auxiliary signal model of a specified VSC dc line.

change_vsdcauxmod_con

 change the value of a CON of an auxiliary signal model of a specified VSC dc line.

change_vsdcauxmod_data

change_vsdcauxmod_icon

 change the value of an integer ICON of an auxiliary signal model of a specified VSC dc line.

change_vsdcauxmod_var

 change the value of a VAR of an auxiliary signal model of a specified VSC dc line.

fctsauxmod_remove

 remove an auxiliary signal model from the specified injection point of a designated FACTS device.

fctsauxmod_status

 change the status of the auxiliary signal model at the specified injection point of a designated FACTS device.

mtdcauxmod_remove

 remove an auxiliary signal model from the specified auxiliary signal index of the designated multi-terminal dc line.

mtdcauxmod_status

 change the status of the auxiliary signal model at the specified auxiliary signal index of the designated multi-terminal dc line.

ttdcauxmod_remove

 remove an auxiliary signal model from the specified injection point of the designated two-terminal dc line.

ttdcauxmod_status

 change the status of the auxiliary signal model at the specified injection point of the designated two-terminal dc line.

vsdcauxmod_remove

 remove an auxiliary signal model from the specified injection point of the designated VSC dc line.

vsdcauxmod_status

 change the status of the auxiliary signal model at the specified injection point of the designated VSC dc line.

--- Branch Data — .txt ---

Branch Data — 

Branch Data¶

abrnchar

 return an array of character values for subsystem branches.

abrncount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the branch data family.

abrncplx

 return an array of complex values for subsystem branches.

abrnint

 return an array of integer values for subsystem branches.

abrnreal

 return an array of real values for subsystem branches.

abrntypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch data family (aBrnInt, aBrnReal, aBrnCplx and aBrnChar).

--- Branch Flow Data — .txt ---

Branch Flow Data — 

Branch Flow Data¶

aflowchar

 return an array of character values for subsystem branches.

aflowcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the branch flow data family.

aflowcplx

 return an array of complex values for subsystem branches.

aflowint

 return an array of integer values for subsystem branches.

aflowreal

 return an array of real values for subsystem branches.

aflowtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch flow data family (aFlowInt, aFlowReal, aFlowCplx and aFlowChar).

--- Bus Data — .txt ---

Bus Data — 

Bus Data¶

abuschar

 return an array of character values for subsystem buses.

abuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the bus data family.

abuscplx

 return an array of complex values for subsystem buses.

abusint

 return an array of integer values for subsystem buses.

abusreal

 return an array of real values for subsystem buses.

abustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the bus data family (aBusInt, aBusReal, aBusCplx and aBusChar).

--- Bus Subsystems — .txt ---

Bus Subsystems — 

Bus Subsystems¶

bsys

 define a bus subsystem.

bsysadd

 add elements to an existing bus subsystem.

bsysdef

 set the definition of a bus subsystem.

bsysdelo

 delete a single bus from a bus subsystem.

bsysinit

 initialize or re-initialize a bus subsystem.

bsysmem

 replicate the specified bus subsystem in a bus subsystem file.

bsyso

 build a bus subsystem one bus at a time.

bsysrcl

 recall a specified bus subsystem saved in a bus subsystem file.

--- Cct Models — .txt ---

Cct Models — 

Cct Models¶

add_cct2dco_model

 add an “other” type model attached to a 2-terminal dc line.

add_cct2wtd_model

 add a 2-winding transformer device model to the specified 2-winding transformer.

add_cct3wtd_model

 add a 3-winding transformer device model to the specified 3-winding transformer.

add_cctbrnd_model

 add a branch device model to the specified branch.

add_cctbrno_model

 add a branch “other” model to the specified branch.

add_cctbuso_model

 add an “other” type model attached to a bus.

add_cctmcno_model

 add a machine other model to the specified machine.

add_cctmcnp_model

 add a machine protection model to the specified machine.

add_cctmsco_model

 add a miscellaneous “other” type model with the specified model instance.

add_cctswso_model

add_cctswso_model_2

 add a switched shunt “other” model to the specified bus.

cct2dco_list

 list “other” type models attached to 2-terminal dc lines.

cct2dcomod_remove

 remove an “other” type model attached to a 2-terminal dc line.

cct2dcomod_status

 change status of an “other” type model attached to a 2-terminal dc line.

cct2wtd_list

 list “other” type models attached to 2-winding transformers.

cct2wtdmod_remove

 remove a 2-winding transformer device model attached to the specified 2-winding transformer.

cct2wtdmod_status

 change the status of a 2-winding transformer device model attached to the specified 2-winding transformer.

cct3wtd_list

 list “other” type models attached to 3-winding transformers.

cct3wtdmod_remove

 remove a 3-winding transformer device model attached to the specified 3-winding transformer.

cct3wtdmod_status

 change the status of a 3-winding transformer device model attached to the specified 3-winding transformer.

cctbrnd_list

 list device type models attached to branches.

cctbrndmod_remove

 remove a branch device model attached to the specified branch.

cctbrndmod_status

 change the status of a branch device model attached to the specified branch.

cctbrno_list

 list “other” type models attached to branches.

cctbrnomod_remove

 remove a branch “other” model attached to the specified branch.

cctbrnomod_status

 change the status of a branch “other” model attached to the specified branch.

cctbuso_list

 list “other” type models attached to buses.

cctbusomod_remove

 remove an “other” type model attached to a bus.

cctbusomod_status

 change status of an “other” type model attached to a bus.

cctmcno_list

 list “other” type models attached to machines.

cctmcnomod_remove

 remove a machine “other” model attached to the specified machine.

cctmcnomod_status

 change status of a machine “other” model attached to the specified machine.

cctmcnp_list

 list protection models attached to machines.

cctmcnpmod_remove

 remove a machine protection model attached to the specified machine.

cctmcnpmod_status

 change status of a machine protection model attached to the specified machine.

cctmod_pack

 pack CCT model definition tables.

cctmod_user

 list or remove user-written CCT model definitions.

cctmsco_list

 list miscellaneous “other” type models.

cctmscomod_remove

 remove a miscellaneous “other” type model with the specified model instance.

cctmscomod_status

 change status of a miscellaneous “other” type model with the specified model instance.

cctswso_list

 list “other” type models attached to switched shunts.

cctswsomod_remove

cctswsomod_remove_2

 remove an “other” type model attached to a switched shunt.

cctswsomod_status

cctswsomod_status_2

 change status of an “other” type model attached to a switched shunt.

change_cct2dcomod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the “other” type model attached to a specified 2-terminal dc line.

change_cct2dcomod_con

 change the value of a real constant (CON) of the “other” type model attached to a specified 2-terminal dc line.

change_cct2dcomod_icon

 change the value of an integer ICON of the “other” type model attached to a specified 2-terminal dc line.

change_cct2dcomod_var

 change the value of VAR of the “other” type model attached to a specified 2-terminal dc line.

change_cct2wtdmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the 2-winding transformer device model of a specified branch.

change_cct2wtdmod_con

 change the value of a real constant (CON) of the 2-winding transformer device model of a specified branch.

change_cct2wtdmod_icon

 change the value of an integer ICON of the 2-winding transformer device model of a specified branch.

change_cct2wtdmod_var

 change the value of VAR of the 2-winding transformer device model of a specified branch.

change_cct3wtdmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the 3-winding transformer device model of a specified branch.

change_cct3wtdmod_con

 change the value of a real constant (CON) of the 3-winding transformer device model of a specified branch.

change_cct3wtdmod_icon

 change the value of an integer ICON of the 3-winding transformer device model of a specified branch.

change_cct3wtdmod_var

 change the value of VAR of the 3-winding transformer device model of a specified branch.

change_cctbrndmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the branch device model of a specified branch.

change_cctbrndmod_con

 change the value of a real constant (CON) of the branch device model of a specified branch.

change_cctbrndmod_icon

 change the value of an integer ICON of the branch device model of a specified branch.

change_cctbrndmod_var

 change the value of VAR of the branch device model of a specified branch.

change_cctbrnomod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the branch “other” model of a specified branch.

change_cctbrnomod_con

 change the value of a real constant (CON) of the branch “other” model of a specified branch.

change_cctbrnomod_icon

 change the value of an integer ICON of the branch “other” model of a specified branch.

change_cctbrnomod_var

 change the value of VAR of the branch “other” model of a specified branch.

change_cctbusomod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the “other” type model attached to a specified bus.

change_cctbusomod_con

 change the value of a real constant (CON) of the “other” type model attached to a specified bus.

change_cctbusomod_icon

 change the value of an integer ICON of the “other” type model attached to a specified bus.

change_cctbusomod_var

 change the value of VAR of the “other” type model attached to a specified bus.

change_cctmcnomod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the machine “other” model for a specified machine.

change_cctmcnomod_con

 change the value of a real constant (CON) of the machine “other” model for a specified machine.

change_cctmcnomod_icon

 change the value of an integer ICON of the machine “other” model for a specified machine.

change_cctmcnomod_var

 change the value of VAR of the machine “other” model for a specified machine.

change_cctmcnpmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the machine protection model of a specified machine.

change_cctmcnpmod_con

 change the value of a real constant (CON) of the machine protection model of a specified machine.

change_cctmcnpmod_icon

 change the value of an integer ICON of the machine protection model of a specified machine.

change_cctmcnpmod_var

 change the value of VAR of the machine protection model of a specified machine.

change_cctmscomod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the miscellaneous “other” type model with the specified model instance.

change_cctmscomod_con

 change the value of a real constant (CON) of the miscellaneous “other” type model with the specified model instance.

change_cctmscomod_icon

 change the value of an integer ICON of the miscellaneous “other” type model with the specified model instance.

change_cctmscomod_var

 change the value of VAR of the miscellaneous “other” type model with the specified model instance.

change_cctswsomod_chricn

change_cctswsomod_chricn_2

 change the value of a character ICON (i.e., an element of the CHRICN array) of the “other” type model attached to a specified switched shunt.

change_cctswsomod_con

change_cctswsomod_con_2

 change the value of a real constant (CON) of the “other” type model attached to a specified switched shunt.

change_cctswsomod_icon

change_cctswsomod_icon_2

 change the value of an integer ICON of the “other” type model attached to a specified switched shunt.

change_cctswsomod_var

change_cctswsomod_var_2

 change the value of VAR of the “other” type model attached to a specified switched shunt.

--- Character Data — .txt ---

Character Data — 

Character Data¶

get_char_length

 return the number of characters required to accommodate the data corresponding to the specified STRING entries, which can be for any of the a*Char data retrieval functions.

--- Dc Line Related Models — .txt ---

Dc Line Related Models — 

Dc Line Related Models¶

add_mtdcline_model

 add a multi-terminal dc line model to the specified multi-terminal dc line.

add_ttdcline_model

 add a two-terminal dc line model to the specified two-terminal dc line.

add_vsdcline_model

 add a VSC dc line model to the specified VSC dc line.

change_mtdclmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the multi-terminal dc line model of a specified multi-terminal dc line.

change_mtdclmod_con

 change the value of a CON of the multi-terminal dc line model of a specified multi-terminal dc line.

change_mtdclmod_data

change_mtdclmod_icon

 change the value of an integer ICON of the multi-terminal dc line model of a specified multi-terminal dc line.

change_mtdclmod_var

 change the value of a VAR of the multi-terminal dc line model of a specified multi-terminal dc line.

change_ttdclmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the two-terminal dc line model of a specified two-terminal dc line.

change_ttdclmod_con

 change the value of a CON of the two-terminal dc line model of a specified two- terminal dc line.

change_ttdclmod_data

change_ttdclmod_icon

 change the value of an integer ICON of the two-terminal dc line model of a specified two-terminal dc line.

change_ttdclmod_var

 change the value of a VAR of the two-terminal dc line model of a specified two- terminal dc line.

change_vsdclmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the VSC dc line model of a specified VSC dc line.

change_vsdclmod_con

 change the value of a CON of the VSC dc line model of a specified VSC dc line.

change_vsdclmod_data

change_vsdclmod_icon

 change the value of an integer ICON of the VSC dc line model of a specified VSC dc line.

change_vsdclmod_var

 change the value of a VAR of the VSC dc line model of a specified VSC dc line.

dclmod_pack

 remove entries that are marked as unused from the dc line model connection tables and the dc line array allocation tables.

dclmod_unconnected

 list or remove from dynamics working memory those dc line models that are assigned to dc lines that are not present in the current power flow working case (unconnected).

dclmod_user

 list user-written dc line model definitions or to remove user-written dc line model definitions that are not assigned to any dc lines (unused) from the user model definition tables.

mtdclmod_remove

 remove the multi-terminal dc line model from a specified multi-terminal dc line.

mtdclmod_status

 change the status of the multi-terminal dc line model at a specified multi- terminal dc line.

ttdclmod_remove

 remove the two-terminal dc line model from a specified two-terminal dc line.

ttdclmod_status

 change the status of the two-terminal dc line model at a specified two-terminal end line.

vsdclmod_remove

 remove the VSC dc line model from a specified VSC dc line.

vsdclmod_status

 change the status of the VSC dc line model at a specified VSC dc line.

--- Diagram View — .txt ---

Diagram View — 

Diagram View¶

changediagcontour

 change the contour parameters for the contour in the active Slider diagram in the GUI.

checkdiagfile

 check the active Slider Diagram in the GUI against the current network case.

closediagfile

 close the active Slider Diagram in the GUI without prompting to save the Diagram.

deletediagcontour

 delete the contour from the active Slider Diagram in the GUI.

enablediagcontour

 specify the contour parameters and display a contour in the active Slider Diagram in the GUI.

exportbuslocfile

exportbuslocfile_2

 export the bus location from the active Slider Diagram in the GUI to a file.

exportimagefile

exportimagefile_2

 export an image of the active Slider Diagram in the GUI to a file.

gexmbus

 create a GEXM/GOUT display of a bus in an active Slider diagram in the GUI.

growbus

 GROW a bus in an active Slider diagram in the GUI.

growbuslevels

 GROW a bus and all the connected buses up to the specified number of levels away in an active Slider diagram in the GUI.

growdiagram

growdiagram_2

 GROW a bus and all the connected buses in an active Slider diagram in the GUI.

growstation

This API routine was first introduced in release 34.

grpg

 produce a GRPG report in the active Slider diagram in the GUI.

importdrawfile

 import a Draw Data File into an active Slider diagram in the GUI.

importimagefile

 import an image into the background layer of the active Slider diagram in the GUI.

newdiagfile

 open a new Slider diagram in the GUI.

nextdiagfiledataset

This API is used to display the next element in the active data set on the active Slider diagram.

openaccfile

openaccfile_2

This API is used to open an existing ACC results file for displaying results on diagram.

openbuslocfile

 open an existing bus location file in the GUI.

opendiagfile

 open an existing Slider diagram in the GUI.

prevdiagfiledataset

This API is used to display the previous element in the active data set on the active Slider diagram.

printdiagfile

printdiagfile_2

 print the active Slider diagram in the GUI.

refreshdiagcontour

 refresh the contour in the active Slider diagram in the GUI.

refreshdiagfile

 refresh the results and styles in the active Slider diagram in the GUI.

renumdiagfile

 renumber buses in the active Slider diagram in the GUI.

savediagfile

 save the active Slider diagram in the GUI.

setdiagautofile

 specify an automation file that is run each time results are updated on the active Slider diagram.

setdiagfont

 specify the default text font in the active Slider diagram.

setdiagprec

setdiagprec_2

 specify the precision of results displayed in Slider Diagrams.

setdiagprop

setdiagprop_2

setdiagprop_3

setdiagprop_4

setdiagprop_5

 specify basic properties in the active Slider diagram.

setdiagresaccc

setdiagresaccc_2

setdiagresaccc_3

 set the ACCC analysis annotation options in the active Slider diagram.

setdiagresascc

setdiagresascc_2

setdiagresascc_3

This API is used to set the ASCC short circuit analysis annotation options in the active Slider diagram.

setdiagresdata

setdiagresdata_2

setdiagresdata_3

 specify the basic Power Flow annotation options in the active Slider Diagram.

setdiagresdyn

setdiagresdyn_2

This API is used to set the dynamic simulation annotation options in the active Slider diagram.

setdiagresgdif

 specify the case comparison voltage and range checking annotation options in the active Slider diagram.

setdiagresiec

setdiagresiec_2

setdiagresiec_3

 specify the IEC annotation options in the active Slider diagram.

setdiagresmust

This API is used to set the MUST simulation annotation options in the active Slider diagram.

setdiagresopf

setdiagresopf_2

setdiagresopf_3

 specify the OPF annotation options in the active Slider diagram.

setdiagrespflowcheck

setdiagrespflowcheck_2

setdiagrespflowcheck_3

 specify the Power Flow voltage and range checking annotation options in the active Slider Diagram.

setdiagrespflowoptions

setdiagrespflowoptions_2

setdiagrespflowoptions_3

 specify the basic Power Flow annotation options in the active Slider diagram.

setdiagresrel

setdiagresrel_2

setdiagresrel_3

 specify the reliability annotation options in the active Slider diagram.

setdiagresscgr

 specify the short circuit analysis voltage and range checking annotation options in the active Slider diagram.

setdiagrestypeacc

 set the type of results displayed in the active Slider diagram to ACCC results.

setdiagrestypeascc

 set the type of results displayed in the active Slider diagram to ASCC fault calculation results.

setdiagrestypedata

 set the type of results displayed in the active Slider diagram to impedance data values.

setdiagrestypedyn

 set the type of results displayed in the active Slider diagram to Dynamics data results.

setdiagrestypegdif

 set the type of results displayed in the active Slider diagram to the differences in values between the current network case and a supplied comparison case.

setdiagrestypegic

 set the type of results displayed in the active Slider diagram to GIC solution results.

setdiagrestypeharm

 set the type of results displayed in the active Slider diagram to Harmonics solution results.

setdiagrestypeiec

 set the type of results displayed in the active Slider diagram to IEC Fault calculation results.

setdiagrestypemust

 set the type of results displayed in the active Slider diagram to MUST solution results.

setdiagrestypeopf

 set the type of results displayed in the active Slider diagram to OPF solution results.

setdiagrestypepflow

 set the type of results displayed in the active Slider diagram to Power Flow results.

setdiagrestyperel

 set the type of results displayed in the active Slider diagram to reliability analysis results.

setdiagrestypescgr

 set the type of results displayed in the active Slider diagram to the results of a short circuit analysis.

setdiagrestypetspf

 set the type of results displayed in the active Slider diagram to TSPF solution results.

setdiagresvrcs

setdiagresvrcs_2

 specify the system diagram defaults for Voltage coloring and style, Out of Service coloring and style etc.

setdiagtitle

 set the title of the active Slider diagram.

switchdiagfiledataset

This API is used to rotate through values for the current element in the active data set on the active Slider diagram.

updatebuslocdiagfile

 update bus locations in the active Slider diagram in the GUI using the positions found in the current bus location file.

--- Dynamic Simulation Operation — .txt ---

Dynamic Simulation Operation — 

Dynamic Simulation Operation¶

addmodellibrary

 add a library to the list to be searched for library models.

astr

 calculate and replicates the state variable system matrices in the form required by the Linear Dynamic Analysis Program, LSYSAN (activity ASTR).

aulist

 list auxiliary signal models that inject signals into dc lines or FACTS devices connected to subsystem buses, along with their storage locations in the dynamics data arrays.

change_channel_out_file

 modify the dynamic simulation channel output filename in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).

change_chricn

 change the value of an element of the CHRICN array (a character ICON).

change_con

 change the value of an element of the CON array.

change_gref

 change the value of the element of the GREF (governor reference) array associated with a specified machine.

change_icon

 change the value of an element of the ICON array (an integer ICON).

change_state

 change the value of an element of the STATE array, as well as the values of the corresponding time derivative (DSTATE) and the associated memory cell used in the integration algorithm (STORE).

change_swsref

change_swsref_2

 change the value of the element of the SWREF array associated with a specified switched shunt.

change_var

 change the value of an element of the VAR array.

change_vref

 change the value of the element of the VREF array associated with a specified machine.

crctrun

 run critical clearing time calculation in dynamic simulations.

dclist

 list dc line models connected to subsystem buses along with their storage locations in the dynamics data arrays.

dlst

 tabulate specified portions of one or more of the PSSE dynamics data storage arrays.

docu

 tabulate the data associated with equipment models referenced in the user’s simulation setup.

dropmodellibrary

 remove a library from the list being searched for library models.

dropmodelprogram

 remove a model from the list of known library models; library models are added to this list the first time that they are called.

dyda

 replicate dynamics model data in the form of a Dynamics Data Input file.

dynamics_solution_param_2

 modify the dynamic simulation solution parameters (except the channel output filename) in dynamics working memory (see PSSE Program Operation Manual, activity ALTR).

dynamics_solution_params

dynamicsmode

 return PSSE to dynamics mode following the use of the POWERFLOWMODE API while in dynamics mode.

dynexportcsv

 export dynamics engine and dynamics model messages that are displayed after running a dynamics simulation to CSV file format.

dyre_add

 read a Dynamics Model Raw Data File and append the model references specified in its data records to the simulation data already contained in dynamics working memory (activity DYRE,ADD).

dyre_new

 clear dynamics working memory, read a Dynamics Data File, and place the model references specified on its data records into dynamics working memory.

erun

 calculate PSSE state-space dynamic simulations of excitation system response tests.

estr_open_circuit_test

 initialize a PSSE dynamic simulation for excitation system open circuit response simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.

estr_response_ratio_test

 initialize a PSSE dynamic simulation for excitation system response ratio test simulations (i.e., in preparation for activity ERUN) and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.

fclist

 list FACTS device models connected to subsystem buses along with their storage locations in the dynamics data arrays.

grun

 calculate PSSE state-space dynamic simulations of turbine-governor response tests.

gstr

 initialize a PSSE dynamic simulation for governor response simulations and to specify the Channel Output File into which the output channel values are to be recorded during the simulation.

increment_gref

 add a specified value to the value of the element of the GREF (governor reference) array associated with a specified machine.

increment_swsref

increment_swsref_2

 add a specified value to the value of the element of the SWREF (switched shunt reference) array associated with a specified switched shunt.

increment_vref

 add a specified value to the value of the element of the VREF (voltage reference) array associated with a specified machine.

ldclist

 list load models connected to subsystem loads along with their storage locations in the dynamics data arrays.

ldlist

 list load models connected to subsystem loads along with their storage locations in the dynamics data arrays.

load_array_channel

 add an output channel containing the active or reactive component of a designated load.

mlst

 list plant models connected to subsystem machines along with their storage locations in the dynamics data arrays.

mrun

 calculate PSSE extended term dynamic simulations.

mstr

 initialize a PSSE dynamic simulation for extended term simulations and to specify the Channel Output File into which the output channel values are to be recorded during the dynamic simulation.

powerflowmode

 switch PSSE from dynamics mode to power flow mode.

psas

 convert a PSAS Command File into a PSSE Response File.

rllist

 list line relay models connected to subsystem buses along with their storage locations in the dynamics data arrays.

rstr

 read a dynamics Snapshot File into PSSE working memory.

run

 calculate PSSE state-space dynamic simulations.

rwdy

 replicate portions of dynamics model data in the form of either a breaker duty data file, unit inertia and governor data file, or PSSPLT relay characteristic data file.

set_chnfil_type

 set/Get the channel output file type (extended type or not).

set_disable_run

 enable or disable the simulation option setting that precludes dynamic simulation runs in the event there are fatal errors in the model data.

set_freq_relay_v_thresh

This API is used to set voltage threshold for use in frequency relay models.

set_genang

set_genang_2

set_genang_3

 enable or disable the simulation option setting that scans for generators for which the angle differs from the angular average by more than a specified threshold.

set_genang_subsys_flag

Use this API api for get/set the flag that is used for the subsystem defintion for performing scan for generators exceeding angle threshold.

set_genpwr

 enable or disable the simulation option setting that scans for generators for which the mechanical power differs from its electrical power by more than a specified threshold.

set_genspdev

 enable or disable the simulation option setting that scans for generators for which the speed deviation is more than a specified threshold.

set_genspdev_subsys_flag

Use this API api for get/set the flag that is used for the subsystem defintion for performing scans for generators for which the speed deviation is more than a specified threshold.

set_load_model_thresh

This API is used to set the MW, P over Q, and load bus voltage thresholds for load models.

set_model_debug_output_flag

 enable or disable the simulation option setting for dynamic model debug output.

set_netfrq

 enable or disable the simulation option setting that models the frequency dependence of network parameters.

set_next_channel

 assign the next available channel index value.

set_next_icon

 assign the next available ICON index value.

set_next_var

 assign the next available VAR index value.

set_osscan

 enable or disable the simulation option setting that scans for out-of-step conditions using a generic relay.

set_osscan_2

set_osscan_subsys_flag

Use this API api for get/set the flag that is used for the subsystem defintion for performing scans for out-of-step conditions using a generic relay.

set_relang

 enable or disable the simulation option setting that expresses the ANGLE array relative to a designated reference angle.

set_relscn

 enable or disable the simulation option setting that scans branches using a generic branch relay.

set_relscn_subsys_flag

Use this API api for get/set the flag that is used for the subsystem defintion for performing scans of branches using a generic branch relay.

set_vltscn

 enable or disable the simulation option setting that scans buses for high or low values of voltage magnitude.

set_vltscn_subsys_flag

Use this API api for get/set the flag that is used for the subsystem definition for performing scans of buses for high or low voltage magnitudes.

set_volt_viol_subsys_flag

This API is used to set the flag to denote the bus subsystem to be used for voltage violation (voltage recovery and voltage dip) checks.

set_voltage_dip_check

This API is used to enable or disable the simulation option setting which scans buses for voltage dip (back-swing).

set_voltage_rec_check

This API is used to enable or disable the simulation option setting which scans buses for voltage recovery (primary and secondary recovery).

set_zsorce_reconcile_flag

 enable or disable the simulation option setting for automatic ZSORCE reconciliation.

size_ds

 obtain a summary of utilization in the general purpose dynamics data storage arrays as well as in the various model connection and allocation tables contained in dynamics working memory.

snap

 save PSSE dynamics working memory into a Snapshot file.

strt

strt_2

This API routine is the second release of the dynamic simulation initialization function.

swslist

 list switched shunt models connected to subsystem buses along with their storage locations in the dynamics data arrays.

trig_volt_violation_check

This API is used to trigger voltage violation (voltage recovery, voltage dip) checks.

wnlist

 list wind models connected to subsystem buses along with their storage locations in the dynamics data arrays.

--- Dynamic Simulation Output Channel Operation — .txt ---

Dynamic Simulation Output Channel Operation — 

Dynamic Simulation Output Channel Operation¶

change_channel

 change the channel address and the channel identifier of a specified output channel.

chsb

 specify, on a subsystem basis, the simulation variables to monitor during dynamic simulation runs (activity CHSB).

crt_plot_channel

  assign one of the main simulation output channels to a designated CRT plot channel.

delete_all_plot_channels

 delete all the plot channels in the working case.

dmpc

 replicate the output channel specifications from dynamics working memory in the form of a response file suitable for transferring them to another snapshot that models essentially the same system.

list_channel_models

 tabulate the output channel monitoring models referenced in the dynamic model.

remove_unused_chan_models

 delete from the output channel monitoring model table those model references indicating equipment that is not present in the power flow working case.

--- Event Studies — .txt ---

Event Studies — 

Event Studies¶

closeeventstudyfile

 close an open Event Study file.

openeventstudyfile

 open a new or existing event study file in the GUI.

rundynamiceventstudy

 run a dynamic study using the active event study in the open event study file.

runpowerfloweventstudy

 run a power flow study using the active event study in the open event study file.

saveeventstudyfile

 save existing event studies in an event study file.

setactiveeventstudy

 select an Event Study in an Event file as the active Event Study for running dynamic or power flow event studies.

--- Extension Data Access — .txt ---

Extension Data Access — 

Extension Data Access¶

get_ext_acline_char

 get ac line character extension data.

get_ext_acline_int

 get ac line integer extension data.

get_ext_acline_logical

 get ac line logical extension data.

get_ext_acline_real

 get ac line real extension data.

get_ext_area_char

 get area character extension data.

get_ext_area_int

 get area integer extension data.

get_ext_area_logical

 get area logical extension data.

get_ext_area_real

 get area real extension data.

get_ext_bus_char

 get bus character extension data.

get_ext_bus_int

 get bus integer extension data.

get_ext_bus_logical

 get bus logical extension data.

get_ext_bus_real

 get bus real extension data.

get_ext_char

 get character extension data.

get_ext_facts_char

 get facts device character extension data.

get_ext_facts_int

 get facts device integer extension data.

get_ext_facts_logical

 get facts device logical extension data.

get_ext_facts_real

 get facts device real extension data.

get_ext_fixshunt_char

 get fixed shunt character extension data.

get_ext_fixshunt_int

 get fixed shunt integer extension data.

get_ext_fixshunt_logical

 get fixed shunt logical extension data.

get_ext_fixshunt_real

 get fixed shunt real extension data.

get_ext_generator_char

 get generator character extension data.

get_ext_generator_int

 get generator integer extension data.

get_ext_generator_logical

 get generator logical extension data.

get_ext_generator_real

 get generator real extension data.

get_ext_gne_char

 get general network element device character extension data.

get_ext_gne_int

 get general network element device integer extension data.

get_ext_gne_logical

 get general network element device logical extension data.

get_ext_gne_real

 get general network element device real extension data.

get_ext_iatrans_char

 get inter-area transfer character extension data.

get_ext_iatrans_int

 get inter-area transfer integer extension data.

get_ext_iatrans_logical

 get inter-area transfer logical extension data.

get_ext_iatrans_real

 get inter-area transfer real extension data.

get_ext_indmach_char

 get induction machine character extension data.

get_ext_indmach_int

 get induction machine integer extension data.

get_ext_indmach_logical

 get induction machine logical extension data.

get_ext_indmach_real

 get induction machine real extension data.

get_ext_int

 get integer extension data.

get_ext_load_char

 get load character extension data.

get_ext_load_int

 get load integer extension data.

get_ext_load_logical

 get load logical extension data.

get_ext_load_real

 get load real extension data.

get_ext_logical

 get logical extension data.

get_ext_msline_char

 get multi-section line character extension data.

get_ext_msline_int

 get multi-section line integer extension data.

get_ext_msline_logical

 get multi-section line logical extension data.

get_ext_msline_real

 get multi-section line real extension data.

get_ext_ntermdc_char

 get multi-terminal dc line character extension data.

get_ext_ntermdc_int

 get multi-terminal dc line integer extension data.

get_ext_ntermdc_logical

 get multi-terminal dc line logical extension data.

get_ext_ntermdc_real

 get multi-terminal dc line real extension data.

get_ext_owner_char

 get owner character extension data.

get_ext_owner_int

 get owner integer extension data.

get_ext_owner_logical

 get owner logical extension data.

get_ext_owner_real

 get owner real extension data.

get_ext_rating_char

 get rating character extension data.

get_ext_rating_int

 get rating integer extension data.

get_ext_rating_logical

 get rating logical extension data.

get_ext_rating_real

 get rating real extension data.

get_ext_real

 get real extension data.

get_ext_rowcount

 get extension data table row count.

get_ext_sub_char

 get substation character extension data.

get_ext_sub_int

 get substation integer extension data.

get_ext_sub_logical

 get substation logical extension data.

get_ext_sub_real

 get substation real extension data.

get_ext_subnode_char

 get substation node character extension data.

get_ext_subnode_int

 get substation node integer extension data.

get_ext_subnode_logical

 get substation node logical extension data.

get_ext_subnode_real

 get substation node real extension data.

get_ext_subswd_char

 get substation switching device character extension data.

get_ext_subswd_int

 get substation switching device integer extension data.

get_ext_subswd_logical

 get substation switching device logical extension data.

get_ext_subswd_real

 get substation switching device real extension data.

get_ext_swshunt_char

 get switched shunt character extension data.

get_ext_swshunt_int

 get switched shunt integer extension data.

get_ext_swshunt_logical

 get switched shunt logical extension data.

get_ext_swshunt_real

 get switched shunt real extension data.

get_ext_sysswd_char

 get system switching device character extension data.

get_ext_sysswd_int

 get system switching device integer extension data.

get_ext_sysswd_logical

 get system switching device logical extension data.

get_ext_sysswd_real

 get system switching device real extension data.

get_ext_transformer_char

 get transformer character extension data.

get_ext_transformer_int

 get transformer integer extension data.

get_ext_transformer_logical

 get transformer logical extension data.

get_ext_transformer_real

 get transformer real extension data.

get_ext_twotermdc_char

 get two-terminal dc line character extension data.

get_ext_twotermdc_int

 get two-terminal dc line integer extension data.

get_ext_twotermdc_logical

 get two-terminal dc line logical extension data.

get_ext_twotermdc_real

 get two-terminal dc line real extension data.

get_ext_vscdc_char

 get voltage source converter dc line character extension data.

get_ext_vscdc_int

 get voltage source converter dc line integer extension data.

get_ext_vscdc_logical

 get voltage source converter dc line logical extension data.

get_ext_vscdc_real

 get voltage source converter dc line real extension data.

get_ext_zone_char

 get zone character extension data.

get_ext_zone_int

 get zone integer extension data.

get_ext_zone_logical

 get zone logical extension data.

get_ext_zone_real

 get zone real extension data.

set_ext_acline_char

 set ac line character extension data.

set_ext_acline_int

 set ac line integer extension data.

set_ext_acline_logical

 set ac line logical extension data.

set_ext_acline_real

 set ac line real extension data.

set_ext_area_char

 set area character extension data.

set_ext_area_int

 set area integer extension data.

set_ext_area_logical

 set area logical extension data.

set_ext_area_real

 set area real extension data.

set_ext_bus_char

 set bus character extension data.

set_ext_bus_int

 set bus integer extension data.

set_ext_bus_logical

 set bus logical extension data.

set_ext_bus_real

 set bus real extension data.

set_ext_char

 set character extension data.

set_ext_facts_char

 set facts device character extension data.

set_ext_facts_int

 set facts device integer extension data.

set_ext_facts_logical

 set facts device logical extension data.

set_ext_facts_real

 set facts device real extension data.

set_ext_fixshunt_char

 set fixed shunt character extension data.

set_ext_fixshunt_int

 set fixed shunt integer extension data.

set_ext_fixshunt_logical

 set fixed shunt logical extension data.

set_ext_fixshunt_real

 set fixed shunt real extension data.

set_ext_generator_char

 set generator character extension data.

set_ext_generator_int

 set generator integer extension data.

set_ext_generator_logical

 set generator logical extension data.

set_ext_generator_real

 set generator real extension data.

set_ext_gne_char

 set general network element device character extension data.

set_ext_gne_int

 set general network element device integer extension data.

set_ext_gne_logical

 set general network element device logical extension data.

set_ext_gne_real

 set general network element device real extension data.

set_ext_iatrans_char

 set inter-area transfer character extension data.

set_ext_iatrans_int

 set inter-area transfer integer extension data.

set_ext_iatrans_logical

 set inter-area transfer logical extension data.

set_ext_iatrans_real

 set inter-area transfer real extension data.

set_ext_indmach_char

 set induction machine character extension data.

set_ext_indmach_int

 set induction machine integer extension data.

set_ext_indmach_logical

 set induction machine logical extension data.

set_ext_indmach_real

 set induction machine real extension data.

set_ext_int

 set integer extension data.

set_ext_load_char

 set load character extension data.

set_ext_load_int

 set load integer extension data.

set_ext_load_logical

 set load logical extension data.

set_ext_load_real

 set load real extension data.

set_ext_logical

 set logical extension data.

set_ext_msline_char

 set multi-section line character extension data.

set_ext_msline_int

 set multi-section line integer extension data.

set_ext_msline_logical

 set multi-section line logical extension data.

set_ext_msline_real

 set multi-section line real extension data.

set_ext_ntermdc_char

 set multi-terminal dc line character extension data.

set_ext_ntermdc_int

 set multi-terminal dc line integer extension data.

set_ext_ntermdc_logical

 set multi-terminal dc line logical extension data.

set_ext_ntermdc_real

 set multi-terminal dc line real extension data.

set_ext_owner_char

 set owner character extension data.

set_ext_owner_int

 set owner integer extension data.

set_ext_owner_logical

 set owner logical extension data.

set_ext_owner_real

 set owner real extension data.

set_ext_rating_char

 set rating character extension data.

set_ext_rating_int

 set rating integer extension data.

set_ext_rating_logical

 set rating logical extension data.

set_ext_rating_real

 set rating real extension data.

set_ext_real

 set real extension data.

set_ext_sub_char

 set substation character extension data.

set_ext_sub_int

 set substation integer extension data.

set_ext_sub_logical

 set substation logical extension data.

set_ext_sub_real

 set substation real extension data.

set_ext_subnode_char

 set substation node character extension data.

set_ext_subnode_int

 set substation node integer extension data.

set_ext_subnode_logical

 set substation node logical extension data.

set_ext_subnode_real

 set substation node real extension data.

set_ext_subswd_char

 set substation switching device character extension data.

set_ext_subswd_int

 set substation switching device integer extension data.

set_ext_subswd_logical

 set substation switching device logical extension data.

set_ext_subswd_real

 set substation switching device real extension data.

set_ext_swshunt_char

 set switched shunt character extension data.

set_ext_swshunt_int

 set switched shunt integer extension data.

set_ext_swshunt_logical

 set switched shunt logical extension data.

set_ext_swshunt_real

 set switched shunt real extension data.

set_ext_sysswd_char

 set system switching device character extension data.

set_ext_sysswd_int

 set system switching device integer extension data.

set_ext_sysswd_logical

 set system switching device logical extension data.

set_ext_sysswd_real

 set system switching device real extension data.

set_ext_transformer_char

 set transformer character extension data.

set_ext_transformer_int

 set transformer integer extension data.

set_ext_transformer_logical

 set transformer logical extension data.

set_ext_transformer_real

 set transformer real extension data.

set_ext_twotermdc_char

 set two-terminal dc line character extension data.

set_ext_twotermdc_int

 set two-terminal dc line integer extension data.

set_ext_twotermdc_logical

 set two-terminal dc line logical extension data.

set_ext_twotermdc_real

 set two-terminal dc line real extension data.

set_ext_vscdc_char

 set voltage source converter dc line character extension data.

set_ext_vscdc_int

 set voltage source converter dc line integer extension data.

set_ext_vscdc_logical

 set voltage source converter dc line logical extension data.

set_ext_vscdc_real

 set voltage source converter dc line real extension data.

set_ext_zone_char

 set zone character extension data.

set_ext_zone_int

 set zone integer extension data.

set_ext_zone_logical

 set zone logical extension data.

set_ext_zone_real

 set zone real extension data.

--- Facts Device Bus Data — .txt ---

Facts Device Bus Data — 

Facts Device Bus Data¶

afactsbuschar

 return an array of character values for subsystem FACTS device buses.

afactsbuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device bus data family.

afactsbuscplx

 return an array of complex values for subsystem FACTS device buses.

afactsbusint

 return an array of integer values for subsystem FACTS device buses.

afactsbusreal

 return an array of real values for subsystem FACTS device buses.

afactsbustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device bus data family (aFactsBusInt, aFactsBusReal, aFactsBusCplx and aFactsBusChar).

--- Facts Device Data — .txt ---

Facts Device Data — 

Facts Device Data¶

afactschar

 return an array of character values for subsystem FACTS devices.

afactscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the FACTS device data family.

afactscplx

 return an array of complex values for subsystem FACTS devices.

afactsint

 return an array of integer values for subsystem FACTS devices.

afactsreal

 return an array of real values for subsystem FACTS devices.

afactstypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the FACTS device data family (aFactsInt, aFactsReal, aFactsCplx and aFactsChar).

--- Facts Device Models — .txt ---

Facts Device Models — 

Facts Device Models¶

add_facts_device_model

 add a FACTS device model to the specified FACTS device.

change_fctmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the FACTS device model of a specified FACTS device.

change_fctmod_con

 change the value of a CON of the FACTS device model of a specified FACTS device.

change_fctmod_data

change_fctmod_icon

 change the value of an integer ICON of the FACTS device model of a specified FACTS device.

change_fctmod_var

 change the value of a VAR of the FACTS device model of a specified FACTS device.

fctmod_pack

 remove entries that are marked as unused from the FACTS device model connection tables and the FACTS device model array allocation tables.

fctmod_remove

 remove the FACTS device model from a specified FACTS device.

fctmod_status

 change the status of the FACTS device model at a specified FACTS device.

fctmod_unconnected

 list or remove from dynamics working memory those FACTS device models that are assigned to FACTS device that are not present in the current power flow working case (unconnected).

fctmod_user

 list user-written FACTS device model definitions or to remove user-written FACTS device model definitions that are not assigned to any FACTS devices (unused) from the user model definition tables.

gmb_add_facts_dev_model

 add a GMB FACTS device model to the specified FACTS device.

--- Fault Analysis Data — .txt ---

Fault Analysis Data — 

Fault Analysis Data¶

mbidncs

 change the table name of the specified non-conventional source fault contribution table in the working case.

seq_3_wind_grounding_data

 modify the zero sequence grounding data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).

seq_3_wind_winding_data

 modify the zero sequence impedance data of one winding of an existing three- winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).

seq_branch_data

seq_branch_data_3

 modify the zero sequence data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Zero Sequence Non-Transformer Branch Data).

seq_bus_data

Bus load sequence data is now accessible as load sequence data.

seq_fixed_shunt_data

 modify the zero sequence data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Fixed Shunt Data).

seq_induction_mach_data

seq_induction_mach_data_2

Use this API routine to modify the sequence data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Impedance Data).

seq_load_data

Use this API routine to modify the sequence data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).

seq_machine_data

seq_machine_data_3

seq_machine_data_4

Use this API routine to modify the sequence data of an existing machine in the working case (see PSSE Program Operation Manual, Positive Sequence Generator Impedance Data, Negative Sequence Generator Impedance Data and Zero Sequence Generator Impedance Data).

seq_machine_ncs_data

Use this API routine to modify a machine’s existing non-conventional source fault current contribution (NCSFCC) data or to add NCSFCC data to an existing machine in the working case.

seq_machine_ncs_data_purg

Use this API routine to delete a machine’s existing non-conventional source fault current contribution (NCSFCC) data.

seq_mutual_data

 modify existing zero sequence mutual impedance data in the working case or to add a new zero sequence mutual coupling to the working case (see PSSE Program Operation Manual, Zero Sequence Mutual Impedance Data).

seq_ncs_flt_cntrb_chng

This API routine was first introduced in release 34.

seq_ncs_flt_cntrb_data

seq_ncs_flt_cntrb_purg

seq_ncs_table_data

 modify the data of an existing non-conventional source fault contribution table in the working case or to add a new non-conventional source fault contribution table to the working case.

seq_ncs_table_onept

 modify the one data point of an existing non-conventional source fault contribution table in the working case or to add a new one data point to non-conventional source fault contribution table to the working case.

seq_ncs_table_purg

 delete an existing non-conventional source fault contribution table from the working case.

seq_ncs_table_purg_onept

 delete specified data point in an existing non-conventional source fault contribution table.

seq_ncs_table_type

 get NCS table type.

seq_switched_shunt_data

seq_switched_shunt_data_3

 modify the zero sequence data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Zero Sequence Switched Shunt Data).

seq_three_winding_data

seq_three_winding_data_3

 modify the zero sequence data of an existing three-winding transformer in the working case.

seq_two_winding_data

seq_two_winding_data_3

 modify the zero sequence data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Zero Sequence Transformer Data).

--- Fault Analysis Operation — .txt ---

Fault Analysis Operation — 

Fault Analysis Operation¶

ansi

ansi_2

ansi_3

This API routine executes the third release of the ANSI fault calculation function.

ascc

ascc_1a

ascc_2

ascc_3

This API is used to apply a series of faults at various locations in the working case.

ascc_scfile

This API reads ASCC short circuit results from SCFILE and produces same ASCC output report that was generated when SCFILE was created.

bkdy

 calculate and report circuit breaker interrupting duty for 3-phase faults at all buses in a specified subsystem of the working case (activity BKDY).

check_sequence_data

Use this API routine to perform data checks on the selected categories of sequence data for all buses in the working case or for all buses in a specified subsystem.

flat

flat_2

This API routine is the second release of the flat conditions function.

iecs

iecs_2

iecs_3

iecs_4

This API executes the fourth release of the IEC short circuit calculations function.

iecs_scfile

This API reads IECS short circuit results from SCFILE and produces same IECS output report that was generated when SCFILE was created.

newseq

 initialize the fault analysis data arrays, set them to default values, and set the flag indicating that sequence data is present in the working case.

sceq

 construct network equivalents of the positive and zero sequence networks and calculates source impedances at equivalent source nodes for all three sequences in preparation for the unbalanced fault analysis activities of PSSE.

scgr

scmu

scmu_2

 calculate simultaneous unbalances.

scop

 tabulate unbalanced fault solution output.

seqd

seqd_2

Use this API routine to factorize the sequence matrices in preparation for unbalanced fault calculations SCMU and SPCB.

sequence_network_setup

 specify or return the option to enable or disable automatic fault analysis sequence network setup.

sqex

 tabulate all fault analysis data pertaining to a specified bus.

--- Fixed Shunt Bus Data — .txt ---

Fixed Shunt Bus Data — 

Fixed Shunt Bus Data¶

afxshntbuschar

 return an array of character values for subsystem buses.

afxshntbuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt bus data family.

afxshntbuscplx

 return an array of complex values for subsystem buses.

afxshntbusint

 return an array of integer values for subsystem buses.

afxshntbusreal

 return an array of real values for subsystem buses.

afxshntbustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt bus data family (aFxShntBusInt, aFxShntBusReal, aFxShntBusCplx and aFxShntBusChar).

--- Fixed Shunt Data — .txt ---

Fixed Shunt Data — 

Fixed Shunt Data¶

afxshuntchar

 return an array of character values for subsystem fixed shunts.

afxshuntcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the fixed shunt data family.

afxshuntcplx

 return an array of complex values for subsystem fixed shunts.

afxshuntint

 return an array of integer values for subsystem fixed shunts.

afxshuntreal

 return an array of real values for subsystem fixed shunts.

afxshunttypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the fixed shunt data family (aFxShuntInt, aFxShuntReal, aFxShuntCplx and aFxShuntChar).

--- Gic Data — .txt ---

Gic Data — 

Gic Data¶

gic_2tdc

 modify or add new two terminal dc GIC shunt data to the working case.

gic_2tdc_chng

 modify new two terminal dc GIC shunt data from the working case.

gic_2tdc_purg

 purge new two terminal dc GIC shunt data from the working case.

gic_brn

 modify or add new GIC branch data to the working case.

gic_brn_chng

 modify new GIC branch data from the working case.

gic_brn_purg

 purge GIC branch data from the working case.

gic_earth1d_usr

 modify or add new GIC User 1D Earth Model data to the working case.

gic_earth1d_usr_chng

 modify GIC User 1D Earth Model data from the working case.

gic_facts

 modify or add new FACTS device GIC shunt data to the working case.

gic_facts_chng

 modify new FACTS device GIC shunt data from the working case.

gic_facts_purg

 purge new FACTS device GIC shunt data from the working case.

gic_fxsh

 modify or add new fixed shunt GIC shunt data to the working case.

gic_fxsh_chng

 modify fixed shunt GIC shunt data from the working case.

gic_fxsh_purg

 purge fixed shunt GIC shunt data from the working case.

gic_load

 modify or add new load GIC shunt data to the working case.

gic_load_chng

 modify load GIC shunt data from the working case.

gic_load_purg

 purge load GIC shunt data from the working case.

gic_mtdc

 modify or add new multi terminal dc GIC shunt data to the working case.

gic_mtdc_chng

 modify new multi terminal dc GIC shunt data from the working case.

gic_mtdc_purg

 purge new multi terminal dc GIC shunt data from the working case.

gic_substn

 modify or add new GIC sub station data to the working case.

gic_substn_chng

 modify GIC sub station data to the working case.

gic_substn_purg

 purge GIC sub station data to the working case.

gic_swsh

 modify or add new GIC switched shunt data to the working case.

gic_swsh_chng

 modify GIC switched shunt data from the working case.

gic_swsh_purg

 purge GIC switched shunt data from the working case.

gic_trn

 modify or add new GIC transformer data to the working case.

gic_trn_chng

 modify GIC transformer data to the working case.

gic_trn_purg

 purge GIC transformer data from the working case.

gic_vscdc

 modify or add new vscdc GIC shunt data to the working case.

gic_vscdc_chng

 modify new vscdc GIC shunt data from the working case.

gic_vscdc_purg

 purge new vscdc GIC shunt data from the working case.

--- Gic Operation — .txt ---

Gic Operation — 

Gic Operation¶

gic

gic_2

gic_3

gic_4

gic_5

gic_6

gic_7

gic_8

 calculate Geomagnetically Induced Currents (GIC) in electric power system network as a result of Geomagnetic Disturbance (GMD).

gic_branch_efield_nn

 calculate geoelectric efield induced in the network branches from specified geoelectric efield grid data using nearest neigbor (NN) alogorithm.

gic_earth1d_usr_purg

 purge GIC User 1D Earth Model data from the working case.

gic_efield_waveshape

For Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as provided in EFLDFILE.

gic_efield_waveshape_ref

For Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 benhcmark event.

gic_efield_waveshape_supp

For Transformer Thermal Impact assessement due to geomagnetic disturbance event, set the geoelectric field waveshape as NERC TPL-007-2 supplemental event.

gic_mvarloss_scaling_factors

Specify KFACTORS to determine transformer reactive power losses due to geomagnetic currents (GICs) flow.

gic_new

 initialize all data records required for GIC analysis.

gic_pf_options

 specify the Newton-Raphson power flow solution options used in GIC.

gic_purg

 purge all GIC data from the working case.

gic_read

 read GIC Data Text (.gic) File into the working case memory.

gic_read_efield_grid

 read Geoelectric Efield Grid Data File into the working case memory.

gic_thermal_impact

gic_thermal_impact_1

 calculate Transformer Thermal Impact assessement GIC(t) curve using specified effective Eastward GIC(E) and Nortward GIC(N) for one specific transformer.

gic_write

 write working case GIC Data to text (.gic) file.

gic_write_stn

 write working case GIC Data to text (.gic) file version 4 that has substation data.

--- Graphical Analysis Output — .txt ---

Graphical Analysis Output — 

Graphical Analysis Output¶

poly_print

 print the results of activity POLY from a .pol results file.

pv_print

 print the results of PV analysis from the .pv results file

qv_print

 print the results of QV analysis from a .qv resultsfile.

setfullviewgrapharea

 specify the parameters of the scales used for plotting the results of PV and QV analysis.

setfullviewscale

 specify the parameters of the scales used for plotting the results of PV and QV analysis.

--- Harmonics Data — .txt ---

Harmonics Data — 

Harmonics Data¶

har_2tdc

 modify or add new harmonics Two Terminal DC data to the working case.

har_2tdc_chng

 modify harmonics Two Terminal DC data in the working case.

har_2tdc_purg

 purge specified harmonics Two Terminal DC data from the working case.

har_brn

 modify or add new harmonics branch data to the working case.

har_brn_chng

 modify harmonics branch data to the working case.

har_brn_purg

 purge specified harmonics branch data from the working case.

har_cursrc

 modify or add new harmonics current source table data to the working case.

har_cursrc_chng

 change harmonics current source table data in the working case.

har_cursrc_chng_name

 change harmonics current source table name in the working case.

har_cursrc_chng_onept

 modify one data point to harmonics current source table in the working case.

har_cursrc_name

 add or change harmonics current source table name in the working case.

har_cursrc_onept

 modify or add new one data point to harmonics current source table in the working case.

har_cursrc_purg

 purge specified harmonics current source table data from the working case.

har_cursrc_purg_onept

 purge specified data point in harmonics current source table.

har_facts

 modify or add new harmonics FACTS device data to the working case.

har_facts_chng

 modify harmonics FACTS device data in the working case.

har_facts_purg

 purge specified harmonics FACTS device data from the working case.

har_impchar

 modify or add new harmonics impedance characteristics table data to the working case.

har_impchar_chng

 change harmonics impedance characteristics table data in the working case.

har_impchar_chng_name

 change harmonics impedance characteristics table name in the working case.

har_impchar_chng_onept

 modify one data point to harmonics impedance characteristics table in the working case.

har_impchar_name

 add or change harmonics impedance characteristics table name in the working case.

har_impchar_onept

 modify or add new one data point to harmonics impedance characteristics table in the working case.

har_impchar_purg

 purge specified harmonics impedance characteristics table data from the working case.

har_impchar_purg_onept

 purge specified data point in harmonics impedance characteristics table.

har_indmc

 modify or add new harmonics induction machine data to the working case.

har_indmc_chng

 modify harmonics induction machine data to the working case.

har_indmc_purg

 purge specified harmonics induction machine data from the working case.

har_load

 modify or add new harmonics load data to the working case.

har_load_chng

 modify harmonics load data to the working case.

har_load_purg

 purge specified harmonics load data from the working case.

har_mach

 modify or add new harmonics machine data to the working case.

har_mach_chng

 modify harmonics machine data to the working case.

har_mach_purg

 purge specified harmonics machine data from the working case.

har_mtdc

 modify or add new harmonics Multi Terminal DC data to the working case.

har_mtdc_chng

 modify harmonics Multi Terminal DC data in the working case.

har_mtdc_purg

 purge specified harmonics Multi Terminal DC data from the working case.

har_passive_filter

 modify or add new harmonics passive filter data to the working case.

har_passive_filter_chng

 modify harmonics passive filter data in the working case.

har_passive_filter_purg

 purge specified harmonics passive filter data from the working case.

har_set_par_lodmdl_cigre_measurement

 set parameters for harmonics load data user model CIGRE_MEASUREMENT.

har_set_par_lodmdl_cigre_motive

 set parameters for harmonics load data user model CIGRE_MOTIVE.

har_set_par_lodmdl_cigre_passive

 set parameters for harmonics load data user model CIGRE_PASSIVE.

har_set_par_lodmdl_ieee_2rl_parallel

 set parameters for harmonics load data user model IEEE_2RL_PARALLEL.

har_set_par_lodmdl_ieee_im

 set parameters for harmonics load data user model IEEE_IM.

har_set_par_lodmdl_ieee_measurement

 set parameters for harmonics load data user model IEEE_MEASUREMENT.

har_set_par_lodmdl_ieee_skin

 set parameters for harmonics load data user model IEEE_SKIN.

har_set_par_lodmdl_large_async_motor

 set parameters for harmonics load data user model LARGE_ASYNC_MOTOR.

har_trn

 modify or add new harmonics transformer data to the working case.

har_trn_chng

 modify harmonics transformer data to the working case.

har_trn_purg

 purge specified harmonics transformer data from the working case.

har_vltsrc

 modify or add new harmonics voltage source table data to the working case.

har_vltsrc_chng

 change harmonics voltage source table data in the working case.

har_vltsrc_chng_name

 change harmonics voltage source table name in the working case.

har_vltsrc_chng_onept

 modify one data point to harmonics voltage source table in the working case.

har_vltsrc_name

 add or change harmonics voltage source table name in the working case.

har_vltsrc_onept

 modify or add new one data point to harmonics voltage source table in the working case.

har_vltsrc_purg

 purge specified harmonics voltage source table data from the working case.

har_vltsrc_purg_onept

 purge specified data point in harmonics voltage source table.

har_vscdc

 modify or add new harmonics VSCDC data to the working case.

har_vscdc_chng

 modify harmonics VSCDC data in the working case.

har_vscdc_purg

 purge specified harmonics VSCDC data from the working case.

--- Harmonics Operation — .txt ---

Harmonics Operation — 

Harmonics Operation¶

har_analysis

har_analysis_2

 run harmonics analysis.

har_create_pfcase

 save working case updated for harmonic frequency and passive filters added as fixed shunts.

har_exists_dstn_results

Check if Harmonics Distortion Calculation results available in PSSE working memory from previously run harmonic analysis activity.

har_exists_fscan_results

Check if Harmonics Frequency Scan results available in PSSE working memory from previously run harmonic analysis activity.

har_export_dstn

 export harmonics distortion calculation results to comma separated (.csv) file.

har_export_fscan

 export harmonics frequency scan results to comma separated (.csv) file.

har_new

 initialize all data records required for Harmonics analysis.

har_purg

 purge all harmonics data from the working case.

har_set_resn_thresholds

 set parameters to filter resonances from harmonic analysis frequency scan response.

har_set_resn_thresholds_default

 set default parameters to filter resonances from harmonic analysis frequency scan response.

--- Induction Machine Bus Data — .txt ---

Induction Machine Bus Data — 

Induction Machine Bus Data¶

aindmacbuschar

Use this API routine to return an array of character values for subsystem buses.

aindmacbuscount

Use this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine bus data family.

aindmacbuscplx

Use this API routine to return an array of complex values for subsystem buses.

aindmacbusint

Use this API routine to return an array of integer values for subsystem buses.

aindmacbusreal

Use this API routine to return an array of real values for subsystem buses.

aindmacbustypes

Use this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine bus data family (aIndMacBusInt, aIndMacBusReal, aIndMacBusCplx and aIndMacBusChar).

--- Induction Machine Data — .txt ---

Induction Machine Data — 

Induction Machine Data¶

aindmacchar

Use this API routine to return an array of character values for subsystem induction machines.

aindmaccount

Use this API routine to obtain the number of array entries required to accommodate the data to be returned by the remaining members of the induction machine data family.

aindmaccplx

Use this API routine to return an array of complex values for subsystem induction machines.

aindmacint

Use this API routine to return an array of integer values for subsystem induction machines.

aindmacreal

Use this API routine to return an array of real values for subsystem induction machines.

aindmactypes

Use this API routine to return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the induction machine data family (aIndMacInt, aIndMacReal, aIndMacCplx and aIndMacChar).

--- Induction Machine Models — .txt ---

Induction Machine Models — 

Induction Machine Models¶

add_indmac_model

 add an induction machine model to a specified machine.

change_immod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of an induction machine model at a specified machine.

change_immod_con

 change the value of a CON of a designated induction machine model at a specified machine.

change_immod_icon

 change the value of an integer ICON of a designated induction machine model at a specified machine.

change_immod_var

 change the value of a VAR of a designated induction machine model at a specified machine.

immod_pack

 remove entries that are marked as unused from the induction machine model contables.

immod_remove

 remove an induction machine model of a designated type from a specified machine.

immod_status

 change the status of an induction machine model at a specified machine.

immod_unconnected

 list or remove from dynamics working memory those induction machine models that are assigned to machines that are not present in the current power flow working case (unconnected).

immod_user

 list user-written induction machine model definitions or to remove user-written induction machine model definitions that are not assigned to any machines (unused) from the user model definition tables.

--- Line Relay Models — .txt ---

Line Relay Models — 

Line Relay Models¶

add_relay_model

 add a line relay model in the designated relay slot of the from bus end of a specified branch.

change_rlmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of the line relay model in the designated relay slot of the from bus end of a specified branch.

change_rlmod_con

 change the value of a CON of the line relay model in the designated relay slot of the from bus end of a specified branch.

change_rlmod_data

change_rlmod_icon

 change the value of an integer ICON of the line relay model in the designated relay slot of the from bus end of a specified branch.

change_rlmod_var

 change the value of a VAR of the line relay model in the designated relay slot of the from bus end of a specified branch.

rlmod_pack

 remove entries that are marked as unused from the line relay model connection tables and the line relay model array allocation tables.

rlmod_remove

 remove the line relay model in the designated relay slot of the from bus end of a specified branch.

rlmod_status

 change the status of the line relay model in the designated relay slot of the from bus end of a specified branch.

rlmod_unconnected

 list or remove from dynamics working memory those line relay models that are assigned to branches that are not present in the current power flow working case (unconnected).

rlmod_user

 list user-written line relay model definitions or to remove user-written line relay model definitions that are not assigned to any branches (unused) from the user model definition tables.

--- Load Bus Data — .txt ---

Load Bus Data — 

Load Bus Data¶

alodbuschar

 return an array of character values for subsystem buses.

alodbuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the load bus data family.

alodbuscplx

 return an array of complex values for subsystem buses.

alodbusint

 return an array of integer values for subsystem buses.

alodbusreal

 return an array of real values for subsystem buses.

alodbustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load bus data family (aLodBusInt, aLodBusReal, aLodBusCplx and aLodBusChar).

--- Load Component Models — .txt ---

Load Component Models — 

Load Component Models¶

add_loadc_model

 add a load component model of a designated type to a specified load or subsystem.

change_ldmodc_cdesc

 change the value of a Model Description of a load component model at a specified load or subsystem).

change_ldmodc_chricn

 change the value of a CHRICN of a load component model at a specified load or subsystem).

change_ldmodc_con

 change the value of a CON of a load component model at a specified load or subsystem.

change_ldmodc_icon

 change the value of a ICON of a load component model at a specified load or subsystem.

change_ldmodc_var

 change the value of a VAR of a load component model at a specified load or subsystem.

--- Load Data — .txt ---

Load Data — 

Load Data¶

aloadchar

 return an array of character values for subsystem loads.

aloadcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the load data family.

aloadcplx

 return an array of complex values for subsystem loads.

aloadint

 return an array of integer values for subsystem loads.

aloadreal

 return an array of real values for subsystem loads.

aloadtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the load data family (aLoadInt, aLoadReal, aLoadCplx and aLoadChar).

--- Load Related Models — .txt ---

Load Related Models — 

Load Related Models¶

add_load_model

 add a load related model of a designated type to a specified load or subsystem.

change_ldmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of a load related model at a specified load or subsystem.

change_ldmod_con

 change the value of a CON of a load related model at a specified load or subsystem.

change_ldmod_data

change_ldmod_icon

 change the value of an integer ICON of a load related model at a specified load or subsystem.

change_ldmod_var

 change the value of a VAR of a load related model at a specified load or subsystem.

ldmod_pack

 remove entries that are marked as unused from the load model connection tables and the load model array allocation tables.

ldmod_remove

 remove a load related model of a designated type from a specified load or subsystem.

ldmod_status

 change the status of a load related model of a designated type for all subsystem loads at which it is applied.

ldmod_status2

 change the status of a load related model of a designated type at a specified load.

ldmod_unconnected

 list or remove from dynamics working memory those load related models that are assigned to loads that are not present in the current power flow working case (unconnected).

ldmod_user

 list user-written load model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables.

ldmodc_pack

 remove entries that are marked as unused from the load component model connection tables.

ldmodc_remove

 remove a load component related model of a designated type from a specified load or subsystem.

ldmodc_status

 change the status of a load related model of a designated type for all subsystem loads at which it is applied.

ldmodc_unconnected

 list or remove from dynamics working memory those load Component models that are assigned to loads that are not present in the current power flow working case (unconnected).

ldmodc_user

 list user-written load component model definitions or to remove user-written load model definitions that are not assigned to any loads (unused) from the user model definition tables.

--- Machine Data — .txt ---

Machine Data — 

Machine Data¶

amachchar

 return an array of character values for subsystem machines.

amachcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the machine data family.

amachcplx

 return an array of complex values for subsystem machines.

amachint

 return an array of integer values for subsystem machines.

amachreal

 return an array of real values for subsystem machines.

amachtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the machine data family (aMachInt, aMachReal, aMachCplx and aMachChar).

--- Multi-Terminal Dc Line Converter Data — .txt ---

Multi-Terminal Dc Line Converter Data — 

Multi-Terminal Dc Line Converter Data¶

amultitrmdcconvchar

 return an array of character values for subsystem multi-terminal dc line converters.

amultitrmdcconvcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line converter data family.

amultitrmdcconvcplx

 return an array of complex values for subsystem multi-terminal dc line converters.

amultitrmdcconvint

 return an array of integer values for subsystem multi-terminal dc line converters.

amultitrmdcconvreal

 return an array of real values for subsystem multi-terminal dc line converters.

amultitrmdcconvtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (aMultiTrmDcConvInt, aMultiTrmDcConvReal, aMultiTrmDcConvCplx and aMultiTrmDcConvChar).

--- Multi-Terminal Dc Line Data — .txt ---

Multi-Terminal Dc Line Data — 

Multi-Terminal Dc Line Data¶

amultitrmdcchar

 return an array of character values for subsystem multi-terminal dc lines.

amultitrmdccount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the multi-terminal dc line data family.

amultitrmdccplx

 return an array of complex values for subsystem multi-terminal dc lines.

amultitrmdcint

 return an array of integer values for subsystem multi-terminal dc lines.

amultitrmdcreal

 return an array of real values for subsystem multi-terminal dc lines.

amultitrmdctypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the multi-terminal dc line data family (aMultiTrmDcInt, aMultiTrmDcReal, aMultiTrmDcCplx and aMultiTrmDcChar).

--- Multiple Element Data — .txt ---

Multiple Element Data — 

Multiple Element Data¶

avoltagedroopchar

 return an array of character values for the voltage droop controls.

avoltagedroopcount

 return the number of voltage droop controls.

avoltagedroopint

 return an array of real values for the voltage droop controls.

avoltagedroopreal

 return an array of real values for the voltage droop controls.

getmodellibraries

Return the list of libraries that are searched for dynamically (i.e.

getmodelprograms

Return the list dynamically (i.e.

gettspfprofilebyelement

 return an array of character values for the Time Series Power Flow profiles by element name.

gettspfprofilecountbyelement

 return the number of Time Series Power Flow profile by element name.

gettspfprofiledata

 return an array of real values for Time Series Power Flow profile data.

gettspfprofiledatabyset

 return an array of real values for Time Series Power Flow profile data for given curve set id.

gettspfprofiledatacolumncount

 return the number of Time Series Power Flow profile data column count for a curve set.

gettspfprofiledatacount

 return the number of Time Series Power Flow profile data count.

last_pf

Return last attempted network solution data.

rxpath

 return buses from starting bus to ending bus with shortest electricity distance in terms of one of two options, impedance and number of buses.

treedat

 return Swing Bus and Island Data of Working Case Network.

--- Node Breaker Data — .txt ---

Node Breaker Data — 

Node Breaker Data¶

fetch_adjvar_term_node

 obtain the terminal node to which an OPF adjustable bus shunt is connected to.

fetch_indmachine_term_node

 obtain the terminal node to which a machine is connected to.

fetch_load_term_node

 obtain the terminal node to which a load is connected to.

fetch_machine_term_node

 obtain the terminal node to which a machine is connected to.

fetch_shunt_term_node

 obtain the terminal node to which a shunt is connected to.

fetch_sws_shunt_term_node

fetch_sws_shunt_term_node_2

 obtain the terminal node to which a switched shunt is connected to.

plant_bus_section_chng

station_2dc_bus_term_chng

 change the station two-term dc rectifier or inverter node terminal connection in the working case.

station_2dc_conv_term_chng

This API changes both node terminal connections of an existing two-term dc rectifier and inverter terminal data in the working case.

station_adjvar_term_chng

 change a substation OPF adjustable bus shunt node terminal connection in the working case.

station_branch_term_chng

 access existing station branch terminal data in the working case.

station_branch_term_move

 move one terminal node connection of a branch in the working case.

station_bus_purg

This API routine was first introduced in release 34.2.

station_chng

 modify the data of an existing substation data in the working case.

station_data

 modify the data of an existing substation data in the working case, or to add a new substation to the working case.

station_facts_bus_term_chng

 change the station FACTS device node terminal data connection in the working case.

station_facts_term_chng

This API changes the FACTS device sending and terminal end node terminal connections.

station_indmachine_term_chng

 change a substation induction machine node terminal connection in the working case.

station_load_term_chng

 access existing station load terminal data in the working case.

station_machine_term_chng

 change a substation machine terminal connection in the working case.

station_mtdc_bus_term_chng

 change the station multi-terminal converter node terminal connection in the working case.

station_mtdc_term_chng

This API changes both node terminal connections of an existing multi-terminal converter in the working case.

station_node_chng

 modify the data of an existing substation node in the working case.

station_node_data

 modify the data of an existing substation node in the working case, or to add a new substation node to the working case.

station_node_number

 change a node number in an existing substation.

station_node_purg

 delete a node in an existing substation.

station_number

 change a substation number for an existing substation.

station_purg

 delete a substation and all node-breaker components within that substation from the working case.

station_shunt_term_chng

 change a substation fixed shunt terminal connection in the working case.

station_swd_chng

 modify the data of an existing station switching device in the working case.

station_swd_data

 modify the data of an existing substation switching device in the working case, or to add a new substation switching device to the working case.

station_swd_mbid

 modify the circuit identifier of an existing station switching device in the working case.

station_swd_move

 move the “to” node of an existing substation switching device in the working case.

station_swd_purg

 delete an existing substation switching device in the working case.

station_sws_shunt_term_chng

station_sws_shunt_term_chng_2

 change a substation switched shunt node terminal connection in the working case.

station_three_wnd_term_chng

 access existing substation three-winding transformer terminal data in the working case.

station_three_wnd_term_move

 move one terminal node connection of a three-winding transformer in the working case.

station_vscdc_bus_term_chng

 change the vsc dc converter node terminal connection in the working case.

station_vscdc_conv_term_chng

This API changes both node terminal connections of an existing vsc dc converter in the working case.

system_swd_chng

 modify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.

system_swd_data

 add or modify the data of an existing system switching device in the working case, or to add a new system switching device to the working case.

--- Node Breaker Operation — .txt ---

Node Breaker Operation — 

Node Breaker Operation¶

convert_section_to_bus

Use this API routine to convert a bus section, one that had been automatically created within a substation due to open substation switching devices, into a main network bus.

isolate2dclinebybreaker

 isolate a two-terminal DC line using system or substation breakers.

isolate3wtbybreaker

 isolate a three-winding transformer using system or substation breakers.

isolatebusbybreaker

 isolate a bus using system or substation breakers.

isolatefactsbybreaker

 isolate a FACTS device using system or substation breakers.

isolateindmachinebybreaker

 isolate an induction machine using system or substation breakers.

isolatelinebybreaker

 isolate a two-winding transformer or non-transformer line using system or substation breakers.

isolateloadbybreaker

 isolate a load using system or substation breakers.

isolatemachinebybreaker

 isolate a machine using system or substation breakers.

isolatemslinebybreaker

 isolate a multi-section line using system or substation breakers.

isolatemtdclinebybreaker

 isolate a multi-terminal dc line using system or substation breakers.

isolatenodebybreaker

 isolate a substation node using system or substation breakers.

isolateshuntbybreaker

 isolate a fixed shunt using system or substation breakers.

isolateswdbybreaker

 isolate a substation switching device using system or substation breakers.

isolateswshuntbybreaker

isolateswshuntbybreaker_2

 isolate a switched shunt using system or substation breakers.

isolatevscdclinebybreaker

 isolate a VSC DC line using system or substation breakers.

restorestatesfromisolate

 restore the network working case back to its original state; the state prior to all “Isolate By Breaker” actions that have been taken.

station_ampout

 print current within a substation.

station_build_config

 automatically build a general layout configuration for a bus being built within a substation.

station_list

 list components in a substation.

station_pout

station_pout_2

 print power flows within a substation.

station_tree

Use this API routine to check the node breaker model and the consistency between node breaker and bus branch models.

--- Non-Engineering — .txt ---

Non-Engineering — 

Non-Engineering¶

alert

 send output to the alert device.

appendrecording

Start recording program operation at end of specified file.

beginreport

 create a new report tab in the GUI.

clearalertoutput

Clear the Alerts/Warnings tab of the output bar in the GUI

clearprogressoutput

Clear the Progress tab of the output bar in the GUI

filein

Get input from file (Fortran unit number).

getbatdefaults

Retrieve “no input” value for integers and reals.

getdefaultchar

Retrieve “no input” value for characters (i.e., strings) other than filenames.

getdefaultint

Retrieve “no input” value for integers.

getdefaultreal

Retrieve “no input” value for reals (floats).

getloadedmodules

get list of all modules currently loaded

getmodfunclist

Get list if external callable methods given a module name.

ioflush

Force all files in PSSE to flush buffers to disk, if possible.

launch_program

This API routine was first introduced in release 34.1.

pagereport

 place a report separator on the active report tab of the GUI.

pauserecording

Pause or resume recording program operation.

progress

Send output to progress device.

prompt

Send output to prompt device.

psseinit

Initialize PSSE.

psseversion

Get PSSE version information.

refreshgui

Refresh the graphical user interface.

report

Send output to report device.

runiplanfile

Execute an IPLAN program.

runrspnsfile

Run a response file.

showloadedlibraries

showloadedmodules

startrecording

Start recording program operation.

stoprecording

Stop recording program operation.

t_alert_output

 specify a “T“‘d alert device, i.e. a destination for a copy of everything sent to the alert device.

t_progress_output

 specify a “T“‘d progress device, i.e. a destination for a copy of everything sent to the progress device.

t_prompt_output

 specify a “T“‘d prompt device, i.e. a destination for a copy of everything sent to the prompt device.

t_report_output

 specify a “T“‘d report device, i.e. a destination for a copy of everything sent to the report device.

userin

Get input from interactive device.

--- Optimal Power Flow Data — .txt ---

Optimal Power Flow Data — 

Optimal Power Flow Data¶

newopf

 initialize the working case with default OPF data for all bus oriented data records.

opf_adjbrx_indv

 add an individual adjustable branch reactance data record to the working case.

opf_adjbrx_subsys

 add or modify all OPF branch reactance data records in a specified subsystem of the working case.

opf_adjload_tbl

 add an individual adjustable bus load table record to the working case.

opf_adjvar_indv

opf_adjvar_indv_2

 add an individual OPF adjustable bus shunt data record to the working case.

opf_adjvar_subsys

 add or modify all OPF adjustable bus shunt records in a specified subsystem of the working case.

opf_apdsp_tbl

 add an individual active power dispatch table record to the working case.

opf_brflw_3wt_indv

 add a flow constraint record for an individual winding of a three-winding transformer in the working case.

opf_brflw_brn_indv

 add an individual branch or two-winding transformer flow constraint record to the working case.

opf_brflw_subsys

 add or modify all branch flow data records in a specified subsystem of the working case.

opf_bus_indv

opf_bus_indv_2

 add OPF bus voltage magnitude data to the working case.

opf_bus_subsys

 add OPF bus attribute data for all records in a specified subsystem of the working case.

opf_change_3wt_flow_id

 change the identifier of a flow constraint record for an individual winding of a three-winding transformer in the working case.

opf_change_adjvar_id

opf_change_brn_flow_id

 change the identifier of a branch or two-winding transformer OPF flow constraint record in the working case.

opf_csttbl_lin

 add a linear cost curve table record to the working case.

opf_csttbl_poly

 add a polynomial and exponential cost curve table record to the working case.

opf_csttbl_quad

 add a quadratic cost curve table record to the working case.

opf_gen_rcap_indv

 add an individual generation reactive capability data record to the working case.

opf_gen_rcap_subsys

 add or modify all OPF generator reactive capability records in a specified subsystem of the working case.

opf_gendsp_indv

 add generator dispatch data to an individual record in the working case.

opf_gendsp_subsys

 add OPF generator dispatch data to all records in a specified subsystem of the working case.

opf_genrsv_indv

 add an individual generator reserve data record to the working case.

opf_genrsv_subsys

 add or modify all OPF generator reserve records in a specified subsystem of the working case.

opf_intflw_3wt

 add a participating three-winding transformer winding to a specified interface flow constraint in the working case.

opf_intflw_brn

 add a participating branch to a specified interface flow constraint in the working case.

opf_intflw_main

 add an interface flow constraint record to the working case.

opf_intflw_reset

 remove all interface branches associated with a particular interface flow constraint in the working case.

opf_lnceqn_adjload

 add a participating adjustable bus load variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_adjvar

 add a participating adjustable bus shunt variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_brflow

 add a participating branch flow variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_intflow

 add a participating interface flow constraint variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_main

 add a linear constraint dependency record to the working case.

opf_lnceqn_pgen

 add a participating active power dispatch variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_qgen

 add a participating reactive power dispatch variable of a specified linear constraint dependency equation in the working case.

opf_lnceqn_reset

 remove all participating variables from a particular OPF linear constraint dependency equation in the working case.

opf_lnceqn_swshunt

opf_lnceqn_swshunt_2

 add a participating switched shunt variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_tran

 add a participating transformer control variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_vang

opf_lnceqn_vang_2

 add a participating bus voltage angle variable to a specified linear constraint dependency equation in the working case.

opf_lnceqn_vmag

opf_lnceqn_vmag_2

 add a participating bus voltage magnitude variable to a specified linear constraint dependency equation in the working case.

opf_load_indv

 add an individual OPF bus load data record to the working case.

opf_load_subsys

 add or modify all OPF bus load data records in a specified subsystem of the working case.

opf_perrsv_gen

 add a participating generation reserve unit to a previously defined period reserve constraint in the working case.

opf_perrsv_main

 add a period reserve constraint record to the working case.

opf_perrsv_reset

 remove all generation reserve units associated with a particular period reserve constraint in the working case.

purge_all_opf_data

 purge and re-initialize all OPF data records in the working case.

purge_opf_adjbrx_indv

 purge an individual adjustable branch reactance data record from the working case.

purge_opf_adjbrx_subsys

 purge all OPF branch reactance data records from a specified subsystem of the working case.

purge_opf_adjload_tbl

 purge an individual adjustable bus load table from the working case.

purge_opf_adjvar_indv

purge_opf_adjvar_indv_3

 purge an individual OPF adjustable bus shunt data record from the working case.

purge_opf_adjvar_subsys

 purge all OPF adjustable bus shunt records from a specified subsystem of the working case.

purge_opf_apdsp_tbl

 purge an individual active power dispatch table record from the working case.

purge_opf_brflw_3wt

 purge an individual flow constraint record of a three-winding transformer from the working case.

purge_opf_brflw_brn

 purge an individual branch or two-winding transformer flow constraint record from the working case.

purge_opf_brflw_subsys

 purge all branch flow data records in a specified subsystem in the working case.

purge_opf_bus_indv

purge_opf_bus_indv_3

 purge (re-initialize) OPF bus voltage magnitude data for an individual bus or bus section record in the working case.

purge_opf_bus_subsys

 purge (re-initialize) OPF bus attribute data for all records in a specified subsystem of the working case.

purge_opf_csttbl_lin

 purge an optimal power flow linear cost curve record from the working case.

purge_opf_csttbl_poly

 purge an optimal power flow polynomial and exponential cost curve record from the working case.

purge_opf_csttbl_quad

 purge an optimal power flow quadratic cost curve record from the working case.

purge_opf_gen_rcap_indv

 purge an individual OPF generation reactive capability data record from the working case.

purge_opf_gen_rcap_subsys

 purge all OPF generator reactive capability records in a specified subsystem from the working case.

purge_opf_gendsp_indv

 purge generator dispatch data for an individual record from the working case.

purge_opf_gendsp_subsys

 purge generator dispatch data for all records from a specified subsystem of the working case.

purge_opf_genrsv_indv

 purge an individual optimal power flow generator reserve data record from the working case.

purge_opf_genrsv_subsys

 purge all OPF generator reserve records in a specified subsystem from the working case.

purge_opf_intflw

 purge an OPF interface flow constraint record, including all of its participating branches, from the working case.

purge_opf_intflw_3wt

 remove a participating three-winding transformer winding from a specified OPF interface flow constraint in the working case.

purge_opf_intflw_brn

 remove a participating branch from a specified OPF interface flow constraint in the working case.

purge_opf_lnceqn

 purge an OPF linear constraint dependency record, including all of its participating variables, from the working case.

purge_opf_lnceqn_adjload

 remove a participating adjustable bus load variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_adjvar

 remove a participating adjustable bus shunt variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_brflow

 remove a participating branch flow variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_intflow

 remove a participating interface flow constraint variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_pgen

 remove a participating active power dispatch variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_qgen

 remove a participating reactive power dispatch variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_swshunt

purge_opf_lnceqn_swshunt_2

 remove a participating switched shunt variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_tran

 remove a participating transformer control variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_vang

purge_opf_lnceqn_vang_2

 remove a participating bus voltage angle variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_lnceqn_vmag

purge_opf_lnceqn_vmag_2

 remove a participating bus voltage magnitude variable from a specified OPF linear constraint dependency equation in the working case.

purge_opf_load_indv

 purge (re-initialize) an individual OPF bus load data record from the working case.

purge_opf_load_subsys

 purge (re-initialize) all OPF bus load data records in a specified subsystem of the working case.

purge_opf_perrsv

 purge an OPF period reserve constraint record and its association with participating reserve units from the working case.

purge_opf_perrsv_gen

 remove a participating period reserve unit from a specified OPF period reserve constraint.

--- Optimal Power Flow Operation — .txt ---

Optimal Power Flow Operation — 

Optimal Power Flow Operation¶

add_details_to_opf_log

 specify or return the value of the OPF solution option to add details of the sensitivity values and Lagrange multipliers to the OPF Output Log file.

apply_alternate_step_size

 specify or return the value of the OPF solution option for applying an alternate lambda mismatch step size.

apply_automatic_scaling

 specify or return the value of the OPF solution option to apply automatic scaling of the objective coefficients and derivatives to improve convergence of the OPF solution.

bad_iter_coarse_limit

 specify or return the number of bad iterations allowed when the barrier coefficient is greater than 011 (mu greater then -2) before the solution progress is terminated as being infeasible.

bad_iter_fine_limit

 specify or return the the bad iteration limit when the barrier coefficient is less than, or equal to 011 (mu less than or equal to -2) before the solution progress is terminated as being infeasible.

clamp_nonoptimized_gens

 specify or return the value of the OPF solution option to apply the clamp equation to non-optimized generators.

constrain_interface_flows

 specify or return the value of the OPF option to constrain interface flows.

final_opf_barrier_coeff

 specify or return the value of the final coefficient value that the barrier function is attempting to attain.

import_ecdi

 import data from an Economics Dispatch Data File, as prepared for use in activity ECDI, into the OPF working data.

initial_opf_barrier_coeff

 specify or return the value of the initial OPF barrier coefficient.

interface_flow_cost_coeff

 specify or return the value of the coefficient for the interface flow objective.

lsto

 list OPF working case data in a form suitable for data documentation.

minimize_adj_bus_shunts

 specify or return the value of the OPF minimize adjustable bus shunts (var compensation) objective function option.

minimize_fuel_cost

 specify or return the value of the OPF minimize fuel cost objective option.

minimize_interface_flows

 specify or return the value of the OPF minimize interface flows objective option.

minimize_load_adjustments

 specify or return the value of the OPF minimize adjustable bus load objective option.

minimize_p_losses

 specify or return the value of the OPF minimize active power loss objective option.

minimize_p_slack

 specify or return the value of the OPF minimize active power slack objective option.

minimize_q_losses

 specify or return the value of the OPF minimize reactive power loss objective option.

minimize_q_slack

 specify or return the value of the OPF minimize reactive power slack objective option.

minimize_reactive_reserve

 specify or return the value of the OPF minimize reactive reserve objective option.

minimize_series_comp

 specify or return the value of the OPF minimize series compensation (adjustable branch reactance) objective option.

nopf

 run the Optimal Power Flow solution.

open_bus_voltage_limits

 specify or return the value of the OPF solution option to automatically adjust bus voltage limits, making them more open for initial feasibility.

opf_barrier_step_length

 specify or return the value of the barrier function step length setting.

opf_clamp_decay_factor

 specify or return the value of the clamp equation decay factor.

opf_final_clamp_tol

 specify or return the value of the final clamp tolerance.

opf_fix_all_generators

 specify or return the value of the OPF option to treat all generators as nonoptimized (fixed).

opf_fix_phase_shifters

 specify or return the value of the OPF option to fix transformer phase shift angle settings.

opf_fix_switched_shunts

 specify or return the value of the OPF option to fix switched shunt settings.

opf_fix_tap_ratios

 specify or return the value of the OPF option to fix transformer tap ratio settings.

opf_fixed_voltage_penalty

 specify or return the value of the penalty for fixed voltage excursions.

opf_initial_clamp_tol

 specify or return the value of the initial clamp tolerance.

opf_interior_shift_factor

 specify or return the value of the interior shift factor multiplier.

opf_lambda_tolerance

 specify or return the value of the Lagrange multiplier blow-up tolerance during an optimal power flow solution.

opf_lf_control_penalty

 specify or return the value of the quadratic penalty for loadflow controls.

opf_max_tap_ratio_step

 specify or return the value of the maximum transformer tap ratio step.

opf_min_tap_ratio_step

 set or return the value of the minimum transformer tap ratio step.

opf_regulate_area_int

 set or return the value of the OPF option to regulate area interchange.

opf_round_switched_shunts

 set or return the value of the OPF solution option to discretize switched shunts.

opf_round_tap_ratios

 set or return the value of the OPF solution option to round transformer tap ratio settings.

opf_scale_qgen_limits

 set or return the value of the OPF option to scale reactive generation limits in the clamped constraint equation.

opf_step_length_tolerance

 set or return the value of the OPF minimum barrier step length tolerance.

opf_use_generator_vsched

 set or return the value of the OPF option to employ the generator scheduled voltage.

opto

Please use the individual OPF option setting API’s described in this section.

p_losses_cost_coeff

 set or return the value of the coefficient for the active power loss objective (OPF Solution Options).

produce_opf_log_file

 set or return the value of the OPF solution option to produce an OPF solution log file, and if so, the name of the log file.

q_losses_cost_coeff

 set or return the value of the coefficient for the reactive power loss objective.

reactive_resv_cost_coeff

 set or return the value of the coefficient for the reactive reserve objective.

ropf

 read an Optimal Power Flow Raw Data File.

rwop

 replicate the OPF data contained in the working case in the form of an Optimal Power Flow Data File.

set_opf_report_subsystem

 define the subsystem to be used when producing the opf output report.

use_dual_criteria

 set or return the value of the OPF solution option to apply the power flow mismatch tolerance to the dual variable problem.

use_emergency_flow_limits

 set or return the value of the OPF solution option to impose the emergency flow limits instead of the normal flow limits.

use_emergency_volt_limits

 set or return the value of the OPF solution option to impose the emergency bus voltage limits instead of the normal bus voltage limits.

write_opf_options_file

 save the PSSE OPF solution option settings to the PSSOPF.OPT file.

--- Owner Data — .txt ---

Owner Data — 

Owner Data¶

aownerchar

 return an array of character values for subsystem owners.

aownercount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the owner data family.

aownercplx

 return an array of complex values for subsystem owners.

aownerint

 return an array of integer values for subsystem owners.

aownerreal

 return an array of real values for subsystem owners.

aownertypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the owner data family (aOwnerInt, aOwnerReal, aOwnerCplx and aOwnerChar).

--- Owner Subsystems — .txt ---

Owner Subsystems — 

Owner Subsystems¶

osys

 define an owner subsystem.

osysdef

 set the definition of an owner subsystem.

osysinit

 initialize or re-initialize an owner subsystem.

--- Plant Bus Data — .txt ---

Plant Bus Data — 

Plant Bus Data¶

agenbuschar

 return an array of character values for subsystem buses.

agenbuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the plant bus data family.

agenbuscplx

 return an array of complex values for subsystem buses.

agenbusint

 return an array of integer values for subsystem buses.

agenbusreal

 return an array of real values for subsystem buses.

agenbustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the plant bus data family (aGenBusInt, aGenBusReal, aGenBusCplx and aGenBusChar).

--- Plant Related Models — .txt ---

Plant Related Models — 

Plant Related Models¶

add_plant_model

 add a plant related model of a designated type to a specified machine.

change_plmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of a designated plant related model at a specified machine.

change_plmod_con

 change the value of a CON of a designated plant related model at a specified machine.

change_plmod_data

change_plmod_icon

 change the value of an integer ICON of a designated plant related model at a specified machine.

change_plmod_var

 change the value of a VAR of a designated plant related model at a specified machine.

gmb_add_plant_model

 add a plant related GMB model to a specified machine.

plmod_consistency

 check consistency among the plant related models referenced at each machine.

plmod_pack

 remove entries that are marked as unused from the plant model connection tables and the plant model array allocation tables.

plmod_remove

 remove a plant related model of a designated type from a specified machine.

plmod_status

 change the status of a plant related model of a designated type at a specified machine.

plmod_unconnected

 list or remove from dynamics working memory those plant related models that are assigned to machines that are not present in the current power flow working case (unconnected).

plmod_user

 list user-written plant model definitions or to remove user-written plant model definitions that are not assigned to any machines (unused) from the user model definition tables.

--- Power Flow Data — .txt ---

Power Flow Data — 

Power Flow Data¶

area_data

 modify area data in the working case (see PSSE Program Operation Manual, Areas, Zones and Owners).

branch_chng

branch_chng_3

Use this API routine to modify the data of an existing non-transformer branch in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).

branch_data

branch_data_3

 modify the data of an existing non-transformer branch in the working case or to add a new non-transformer branch to the working case (see PSSE Program Operation Manual, Non- Transformer Branch Data).

bus_chng_3

Use this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).

bus_chng_4

Use this API routine to modify the data of an existing bus in the working case (see PSSE Program Operation Manual, Bus Data).

bus_data

bus_data_2

bus_data_3

bus_data_4

Use this API routine to modify the data of an existing bus in the working case, or to add a new bus to the working case (see PSSE Program Operation Manual, Bus Data).

bus_number

 change the bus number of an existing bus in the working case.

case_title_data

 change the two line case title in the working case (see PSSE Program Operation Manual, Case Identification Data).

casolution_parameters

 modify the contingency analysis solution parameters.

casolution_parameters_2

 modify the contingency analysis solution parameters.

casolution_parameters_3

 modify the contingency analysis solution parameters.

extr

 purge specified buses and all branches connected to them from the working case (activity EXTR).

facts_chng_2

facts_chng_3

Use this API routine to modify the data of an existing FACTS device in the working case (see PSSE Program Operation Manual, FACTS Device Data).

facts_data

facts_data_2

facts_data_3

 modify the data of an existing FACTS device in the working case, or to add a new FACTS device to the working case (see PSSE Program Operation Manual, FACTS Device Data).

gne_chng

Use this API routine to modify the data of an existing GNE device in the working case (see PSSE Program Operation Manual, GNE Device Data).

gne_data

Use this API routine to run the GNE device data specification function.

impedance_correction_data

impedance_correction_data_3

 modify the data of an existing transformer impedance correction table in the working case or to add a new transformer impedance correction table to the working case (see PSSE Program Operation Manual, Transformer Impedance Correction Table Data).

induction_machine_chng

Use this API routine to modify the data of an existing induction machine in the working case (see PSSE Program Operation Manual, Induction Machine Data).

induction_machine_data

Use this API routine to modify the data of an existing induction machine in the working case, or to add a new induction machine to the working case (see PSSE Program Operation Manual, Induction Machine Data).

load_chng_4

load_chng_5

load_chng_6

Use this API routine to modify the data of an existing load in the working case (see PSSE Program Operation Manual, Load Data).

load_data

load_data_3

load_data_4

load_data_5

load_data_6

Use this API routine to modify the data of an existing load in the working case, or to add a new load to the working case (see PSSE Program Operation Manual, Load Data).

long_title_data

 change the sixteen line long title in the working case (see PSSE Program Operation Manual, activity CHTI).

machine_cap_curve_chng

Use this API routine to modify the capability curve data of an existing machine in the working case.

machine_cap_curve_data

Use this API routine to specify or modify the capability curve data of an existing machine in the working case.

machine_chng_2

machine_chng_3

Use this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).

machine_chng_4

Use this API routine to modify the data of an existing machine in the working case (see PSSE Program Operation Manual, Plant Data).

machine_data

machine_data_2

machine_data_3

 modify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).

machine_data_4

 modify the data of an existing machine in the working case, or to add a new machine to a plant bus in the working case (see PSSE Program Operation Manual, Plant Data).

mbid2dc

 change the name of the specified two-terminal dc line.

mbid3wnd

 change the identifier of the specified three-winding transformer.

mbidatrn

 change the identifier of the specified inter-area transfer.

mbidbrn

 change the identifier of the specified non-transformer branch or two-winding transformer.

mbidfacts

 change the name of the specified FACTS device.

mbidgne

Use this API routine to change the GNE device name of the specified GNE device.

mbidindmac

Use this API routine to change the identifier of the specified induction machine.

mbidload

 change the identifier of the specified load.

mbidmac

 change the identifier of the specified machine.

mbidmdc

 change the name of the specified multi-terminal dc line.

mbidmsl

 change the identifier of the specified multi-section line.

mbidshunt

 change the identifier of the specified fixed bus shunt.

mbidswshunt

 change the identifier of the specified switched bus shunt.

mbidvd

 change the voltage droop control name of the specified voltage droop control in the working case.

mbidvsc

 change the VSC dc line name of the specified VSC dc line.

multi_section_line_data

 modify the definition of an existing multi-section line grouping in the working case or to add a new multi-section line grouping to the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).

multi_section_line_edit

 modify the status and/or metered end designation of an existing multi-section line grouping in the working case (see PSSE Program Operation Manual, Multi-Section Line Grouping Data).

multi_term_dc_bus_data

 modify the data of a dc bus of an existing multi-terminal dc line in the working case or to add a new dc bus to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).

multi_term_dc_convr_data

 modify the data of a dc converter of an existing multi-terminal dc line in the working case or to add a new converter to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).

multi_term_dc_line_chng

Use this API routine to modify the control mode and mode switch voltage of an existing multi- terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).

multi_term_dc_line_data

 modify the control mode and mode switch voltage of an existing multi-terminal dc line in the working case or to add a new multi-terminal dc line to the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).

multi_term_dc_link_data

 modify the data of a dc link of an existing multi-terminal dc line in the working case or to add a new dc link to a multi-terminal dc line in the working case (see PSSE Program Operation Manual, Multi-Terminal DC Transmission Line Data).

owner_data

 modify owner data in the working case (see PSSE Program Operation Manual, Interarea Transfer Data).

pbus_add_mod

 add or modify transaction event participating bus data.

pbus_delete

 remove a bus from the set of buses that are participating in a transaction event.

plant_chng

plant_chng_3

plant_chng_4

Use this API routine to modify the data of an existing plant that is part of a substation in the working case.

plant_data

plant_data_3

plant_data_4

 modify the data of an existing plant in the working case, or to add a new plant to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).

purg

Use this API routine to delete specified outaged equipment items from the working case.

purg2dc

 delete the specified two-terminal dc line from the working case.

purg3wnd

 delete the specified three-winding transformer from the working case.

purg_voltage_droop

 delete an existing voltage droop control from the working case.

purgarea

 delete areas with no equipment assigned to them from the working case.

purgatrn

 delete the specified inter-area transfer from the working case.

purgbrn

 delete the specified non-transformer branch or two-winding transformer from the working case.

purgcapcurve

 delete the specified machine’s capability curve from the working case.

purge_multi_term_dc_bus

 delete the specified dc bus from the specified multi-terminal dc line in the working case.

purge_multi_term_dc_convr

 delete the specified converter from the specified multi-terminal dc line in the working case.

purge_multi_term_dc_link

 delete the specified dc link from the specified multi-terminal dc line in the working case.

purgfacts

 delete the specified FACTS device from the working case.

purggne

Use this API routine to delete the specified GNE device from the working case.

purgindmac

Use this API routine to delete the specified induction machine from the working case.

purgindmacs

Use this API routine to delete all induction machines from the specified bus in the working case.

purgload

 delete the specified load from the working case.

purgloads

 delete all loads from the specified bus in the working case.

purgmac

 delete the specified machine from the working case.

purgmdc

 delete the specified multi-terminal dc line from the working case.

purgmsl

 delete the specified multi-section line grouping from the working case.

purgmut

 delete the specified zero sequence mutual coupling from the working case.

purgowner

 delete owners with no equipment assigned to them from the working case.

purgplnt

 delete the plant and machine data at the specified bus from the working case.

purgshunt

 delete the specified fixed bus shunt from the working case.

purgshunts

 delete all fixed shunts from the specified bus in the working case.

purgsws

 delete all switched shunts from the specified bus in the working case.

purgswshunt

 delete the specified switched bus shunt from the working case.

purgvsc

 delete the specified VSC dc line from the working case.

purgzone

 delete zones with no equipment assigned to them from the working case.

ratingsettextdata

 change the column and descriptions for a particular rating set used in reporting.

shunt_chng

Use this API routine to modify the data of an existing fixed bus shunt in the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).

shunt_data

 modify the data of an existing fixed bus shunt in the working case or to add a new fixed bus shunt to the working case (see PSSE Program Operation Manual, Fixed Bus Shunt Data).

solution_parameters

solution_parameters_2

solution_parameters_3

solution_parameters_4

solution_parameters_5

 modify the power flow solution parameters in the working case (see PSSE Program Operation Manual, Sections 6.3.13, 6.3.18, 6.5.1 and 11.7).

switched_shunt_chng_3

switched_shunt_chng_4

switched_shunt_chng_5

Use this API routine to modify the data of an existing switched shunt in the working case (see PSSE Program Operation Manual, Switched Shunt Data).

switched_shunt_data

switched_shunt_data_3

switched_shunt_data_4

switched_shunt_data_5

 modify the data of an existing switched shunt in the working case or to add a new switched shunt to the working case (see PSSE Program Operation Manual, Switched Shunt Data).

three_winding_data

three_wnd_imped_chng_3

three_wnd_imped_chng_4

Use this API routine to modify the impedance data of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).

three_wnd_imped_data_3

three_wnd_imped_data_4

Use this API routine to modify the impedance data of an existing three-winding transformer in the working case, or to add a new three-winding transformer to the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).

three_wnd_impedance_data

three_wnd_winding_data

three_wnd_winding_data_3

three_wnd_winding_data_4

three_wnd_winding_data_5

 modify the data of one winding of an existing three-winding transformer in the working case (see PSSE Program Operation Manual, Non-Transformer Branch Data).

transaction_add_mod

 add or modify transaction event data in PSSE working memory.

transaction_delete

 delete a transaction event from PSSE working memory.

transfer_chng

Use this API routine to modify the data of an inter-area transfer in the working case (see PSSE Program Operation Manual, Zone Data).

transfer_data

Use this API routine to modify the data of an inter-area transfer in the working case, or to add a new inter-area transfer to the working case (see PSSE Program Operation Manual, Zone Data).

two_term_dc_converter_data_3

 modify the data of a dc converter of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).

two_term_dc_convr_data

two_terminal_dc_line_chng

Use this API routine to modify the link data of an existing two-terminal dc line in the working case (see PSSE Program Operation Manual, Area Interchange Data).

two_terminal_dc_line_data

Use this API routine to modify the link data of an existing two-terminal dc line in the working case, or to add a new two-terminal dc line and its link data to the working case (see PSSE Program Operation Manual, Area Interchange Data).

two_winding_chng_4

two_winding_chng_5

two_winding_chng_6

Use this API routine to modify the data of an existing two-winding transformer in the working case (see PSSE Program Operation Manual, Owner Data).

two_winding_data

two_winding_data_3

two_winding_data_4

two_winding_data_5

two_winding_data_6

 modify the data of an existing two-winding transformer in the working case, or to add a new two-winding transformer to the working case (see PSSE Program Operation Manual, Owner Data).

voltage_droop_chng

Use this API routine to modify the voltage droop control in the working case(see PSSE Program Operation Manual.

voltage_droop_data

Use this API routine to modify the voltage droop control in the working case, or to add a new voltage droop control to the working case (see PSSE Program Operation Manual.

vsc_dc_converter_data

vsc_dc_converter_data_3

 modify the data of a dc converter of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).

vsc_dc_line_chng

Use this API routine to modify the link data of an existing VSC dc line in the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).

vsc_dc_line_data

Use this API routine to modify the link data of an existing VSC dc line in the working case, or to add a new VSC dc line to the working case (see PSSE Program Operation Manual, Voltage Source Converter (VSC) DC Transmission Line Data).

zone_data

 modify zone data in the working case (see PSSE Program Operation Manual, Zone Data).

--- Power Flow Operation — .txt ---

Power Flow Operation — 

Power Flow Operation¶

accc

accc_2

accc_multiple_merge

 merge a number of AC contingency solution files (acc files) into one acc file.

accc_multiple_run_report

accc_multiple_run_report_2

 report the results of up to twenty two executions of the AC Contingency Calculation function.

accc_parallel

accc_parallel_2

Use this API routine to run the second release of the parallel implementation of the AC contingency calculation function (use ACCC_WITH_DSP_3 to run AC contingency calculation function serially).

accc_single_run_report

accc_single_run_report_2

accc_single_run_report_3

accc_single_run_report_4

accc_single_run_report_5

accc_single_run_report_6

This API is the sixth release of the AC Contingency Report function.

accc_trip_cor

accc_trip_cor_2

accc_trip_cor_3

This API is the third release of the function to run AC contingency analysis with tripping simulation and corrective actions.

accc_with_cor

accc_with_cor_2

accc_with_cor_3

This API is the third release of function to run AC contingency analysis with corrective actions.

accc_with_dsp

accc_with_dsp_2

accc_with_dsp_3

 run the second release of AC contingency calculation function (ACCC, ACCC_WITH_DSP).

accc_with_trip

accc_with_trip_2

 run the second version of AC contingency calculation function with a post- contingency tripping function.

accc_with_trip_parallel

 run the parallel version of AC contingency calculation function with a post- contingency tripping function (use ACCC_WITH_TRIP_2 to run the function sequentially).

accor

accor_2

accor_3

This API is the third release of corrective action function.

alert_output

 specify the alert device.

allow_pssuserpf

 specify or return the option to allow or disallow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf).

alph

 print an alphabetically sorted table of all buses in a specified subsystem of the working case (activity ALPH).

append_accc

 replicate system conditions of a contingency case solution, as contained in a designated Saved Case File, in the form of a Contingency Solution Output File.

apply_var_limits

 specify or return the option for the default VAR limits setting; either apply automatically, apply immediately, ignore, or apply on a specific iteration

area

area_2

 tabulate area totals by area, as well as the desired area net interchange (activity AREA).

area_zone

 tabulate area totals by area, along with subtotals by zone.

arnm

arnm_2

This API routine is the second release of the area renumbering function.

base_frequency

 specify or return the value of the base frequency option setting.

bgen

 convert the mismatch at boundary buses to equivalent load and/or generation (activity BGEN).

brch

brch_2

 tabulate those branches where impedances or other characteristics are such that they may be detrimental to the rate of convergence of one or more of the power flow solution activities.

bsnm

 change the bus numbers of specified network buses in the working case and retain a tabulation, in file form, of bus number changes made (activity BSNM).

bus_input

 specify or return the bus input option setting, for either numbers or names.

bus_output

 specify or return the bus output option setting, for either numbers or names.

bus_size_level

 specify or return the value of the PSSE size level option setting to a multiple of 1,000 between 1,000 and 200,000.

busn

 tabulate unused bus numbers within a specified bus number range (activity BUSN).

ca_iterations

 specify or return the contingency iterations limit setting.

case

 open a PSSE Saved Case file and transfers its data into the PSSE working case.

check_powerflow_data

Use this API routine to perform data checks on the selected categories of powerflow data for all buses in the working case or for all buses in a specified subsystem.

checkvoltagelimits

 tabulate those buses where voltage magnitude is beyond their normal or emergency voltage limits.

chkcntduplicon

Check duplicate labels in Contingengy (CON) file.

chkcntduplidfx

Check duplicate labels in DFAX file.

close_powerflow

Removes the current powerflow working case from PSSE’s working memory.

close_report

Sets the report output device to the standard output and sets the command line to request device selection for individual reporting activities (Activity CLOS).

cmpr

 tabulate certain case totals, as contained in the working case, with those of a designated Saved Case (activity CMPR).

cntb

 tabulate the voltage setpoints and desired voltage bands of voltage-controlling equipment in the working case (activity CNTB).

cong

 convert generators from their power flow representation in preparation for switching studies and dynamic simulations (activity CONG).

conl

 convert the constant MVA load for a specified grouping of network loads to a specified mixture of the constant MVA, constant current, and constant admittance load characteristics (activity CONL).

connectivity_check

 specify or return the option to enable or disable the solution connectivity checking option setting.

control_area_interchange

 to specify or return the area interchange control option setting to disabled, or enabled with tie lines only, or enabled with tie lines and loads.

csv_to_rawx

 import a rawx (extended raw data) data table from a CSV (comma-separated values) file.

csv_to_rawx_with_metamodel

 import a rawx (extended raw data) data table from a CSV (comma-separated values) file with metamodel.

dc_tap_adjustment

 specify or return the option to enable or disable the dc tap adjustment option setting.

dccc

dccc_2

 run contingency case solutions using a linear network (dc) model (activity DCCC).

dccor

 apply corrective actions to the base case using linear programming methods.

dccor_2

 apply corrective actions to the base case using linear programming methods.

dclf

dclf_2

Use this API routine to apply the dc analogy network solution algorithm to the network modeled in the working case (activity DCLF).

dcpscopf

This API is the DC based Preventive Security Constrained Optimal Power Flow solution (DCPSCOPF).

deltmpfiles

Delete closed temporary files.

dfax

dfax_2

 construct a Distribution Factor Data File (activity DFAX).

dfax_contingency

 combine one contingency in the first Distribution Factor file with one contingency in the second Distribution Factor file and so on, till specified contingency level is reached, to create multiple event contingencies and then export resulting contingencies to user defined report device.

dfti

 compare tie lines, as contained in the working case, with those of a designated Saved Case (activity DFTI).

diff

 compare specified power flow data and solution results, as contained in the working case, with those of a designated Saved Case (activity DIFF).

dscn

 electrically disconnect a bus (activity DSCN).

duplicate_cntlabel_check

 specify or return the option to enable or disable the duplicated contingency labels check     when Distribution Factor Data File (.dfx) or Contingency Description Data File (.con) files are used.

ecdi

 place machines in a specified subsystem on- or off-line to satisfy a given subsystem minimum capacity; the in-service machines in the subsystem are then dispatched on the basis of incremental cost to meet a specified total subsystem generation (activity ECDI).

echo

 enable or disable response echoing (activity ECHO).

eeqv

 construct an electrical equivalent of a specified subsystem of the working case (activity EEQV).

eqrd

 build an electrical equivalent of radial and, optionally, two-point Type 1 buses in a specified subsystem of the working case (activity EQRD).

exam

 tabulate all power flow data pertaining to a specified bus (activity EXAM).

fact

 factorize the network admittance matrix in preparation for switching studies and dynamic simulations (activity FACT).

fdns

 apply the fixed slope decoupled Newton-Raphson power flow calculation (activity FDNS).

file_overwrite

 specify or return the option to set the file overwrite option setting to either ask first or overwrite.

find

 tabulate a list of buses matching a partial extended bus name (activity FIND).

flat_start

 specify or return the option to enable or disable the voltage flat start option setting.

fnsl

 apply the Newton-Raphson power flow calculation (activity FNSL).

gcap

gcap_2

 print a report of machine loading and reactive power limit data (activity GCAP).

gdif

 calculate differences between the working case and a designated Saved Case (activity GDIF).

gendsp

 impose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.

gendsp_2

 impose a contingency specified in the Distribution Factor Data file and apply the generation dispatch algorithm used in contingency analysis on the working case.

gens

 tabulate the loading and voltage conditions at plant buses (activity GENS).

geol

 tabulate the loading and voltage conditions at the generator terminals for online machines at Type 2 and 3 buses in the working case (activity GEOL).

getcontingencysavedcase

Use this API routine to place the working case in the form of a specified system condition as calculated during a previous run of one of the members of the the AC contingency calculation family.

gic_pf

Add activity GIC calculated Mvar Qloss in scaled manner to the working case to arrive at the converged power flow solution.

gnestatus

 specify or return the status of a GNE device.

gnet

 change in-service generation to negative MVA load at all Type 2 and 3 buses in the subsystem specified by the user.

imnet

Use this API routine to change the status of induction machines that are in-service to out-of- service, and to replace the power flowing from the network into the machine with constant power load.

imoutage

Use this API routine to change the status of induction machines that are in-service, but that have been set to the “stalled” (for motors) or “tripped” (for generators) state by the power flow solution, to out-of-service.

impc

 calculate the impact of transaction events on MW flows using a linear network (dc) model.

implement_transfer

implement_transfer_2

Use this API routine to apply a specified transfer using the same transfer dispatch methods that are available in the PV analysis calculation engine.

inlf

inlf_2

Use this API routine to run the second release of the inertial and governor response power flow calculation.

inta

 summarize tie flows between an interchange area and all other areas in the working case.

intz

 summarize tie flows between each zone and all other zones in the working case.

isolate_levels

 specify or return the maximum number of levels to go outward when isolating an element by breaker.

join

The API combines two buses into a single bus.

lamp

 print power flow solution output, including loadings in amps, in a traditional power flow report format.

line_shunt_reporting

 specify or return the option to enable or disable the line shunt reporting.

lines_per_page

 specify or return the page length limits for the four output devices; also retrieve device names.

lines_per_page_one_device

 specify or return the page length limit and device name for one of the four output devices.

list

Use this API routine to tabulate the power flow working case in a form suitable for problem data documentation.

listcontingencysavedcases

Use this API routine to obtain a report listing some or all of the system conditions preserved in a ZIP Archive Output File that was created during a previous run of one of the members of the the AC contingency calculation family.

llrf

 apply the line loading relief calculation using a linear network (dc) model.

load_reduction

 tabulate the amount of load reduction in a specified subsystem due to the voltage at the bus to which the load is connected being below PQBRAK (for constant MVA load) or 0.5 (for constant current load.

lout

 print the power flow solution results in a traditional power flow report format.

ltap

 insert a bus at a designated location along a line.

maccc

maccc_2

 run the second release of multiple level contingency analysis.

maccc_3

 run the third release of multiple level contingency analysis.

maccc_parallel

 run the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.

maccc_parallel_2

 run the multiple level contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.

maccc_trip_cor

maccc_trip_cor_2

maccc_trip_cor_3

This API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.

maccc_trip_cor_4

This API is the third release of function to run multiple AC contingency analysis with tripping simulations and corrective actions.

maccc_with_cor

maccc_with_cor_2

maccc_with_cor_3

This API is the third release of function to run multiple AC contingency analysis with corrective actions.

maccc_with_cor_4

This API is the third release of function to run multiple AC contingency analysis with corrective actions.

maccc_with_trip

maccc_with_trip_2

 run the second version of multiple level contingency analysis with tripping simulation.

maccc_with_trip_3

 run the second version of multiple level contingency analysis with tripping simulation.

maccc_with_trip_parallel

 run the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.

maccc_with_trip_parallel_2

 run the multiple level contingency analysis with tripping simulation in parallel when the number of contingency processors in Program Settings is greater than 1.

matrix_growth_factor

 specify or return the value of the matrix growth factor option setting.

mcre

 read a Machine Impedance Data File and add the data specified in it to the working case.

modr

 uniformly increase or decrease the line resistances of in-service nontransformer branches.

mov_alpha

 specify or return the value of the MOV iteration ALPHA option setting.

mov_iterations

 specify or return the value of the maximum MOV iterations option setting.

mov_tolerance

 specify or return the value of the MOV iteration tolerance option setting.

move3wnd

 disconnect the third bus of a specified three-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.

movebrn

 disconnect the to bus of a specified non-transformer branch or two-winding transformer from the bus to which it is currently connected, and reconnect it to a designated bus.

moveindmac

Use this API routine to disconnect the specified induction machine from the bus to which it is currently connected, and reconnect it to a designated bus.

moveindmacs

Use this API routine to disconnect all of the induction machines at the specified bus, and reconnect them to a designated bus.

moveload

 disconnect the specified load from the bus to which it is currently connected, and reconnect it to a designated bus.

moveloads

 disconnect all of the load from the specified bus, and reconnect it to a designated bus.

movemac

 disconnect the specified machine from the bus to which it is currently connected, and reconnect it to a designated bus.

moveplnt

 disconnect all of the machines from the specified bus, and reconnect it to a designated bus.

moveshunt

 disconnect the specified fixed shunt from the bus to which it is currently connected, and reconnect it to a designated bus.

moveshunts

 disconnect all of the fixed shunts from the specified bus and reconnect them to a designated bus.

movesws

moveswshunt

 disconnect the specified switched shunt from the bus to which it is currently connected, and reconnect it to a designated bus.

moveswshunts

 disconnect all of the switched shunts from the specified bus and reconnect them to a designated bus.

mslv

 apply the modified Gauss-Seidel power flow calculation.

msum

 print a summary of mileage by owner.

mtdc

 produce a report of bus voltages and flows for each in-service multi-terminal dc line.

multisection_reporting

 specify or return the option to enable or disable multi-section line reporting.

mwmi

 apply the MAPP MW-mile calculation .

mwomwmsf

 tabulate generation (MW) on MW-mile shift factors for a specified transaction event.

mwomwosf

 tabulate generation (MW) on MW-ohm shift factors for a specified transaction event.

n11_accc

n11_accc_2

This API is the second release of N-1-1 contingency analysis solution.

n11_accc_3

This API is the second release of N-1-1 contingency analysis solution.

n11_accc_parallel

 run the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.

n11_accc_parallel_2

 run the N-1-1 contingency analysis in parallel when the number of contingency processors in Program Settings is greater than 1.

n11_accc_pscopf

n11_accc_pscopf_2

The API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).

n11_accc_pscopf_3

The API is the second release of N-1-1 contingency analysis solution in either corrective mode or security constrained optimal power flow mode (SCOPF).

netg

 change the in-service generation to negative MVA load at all Type 2 and 3 buses except those in the subsystem specified by the user.

new_dimension

 reset PSSE to an increased bus size level.

newcas

newcase_2

This API is the second release of the function used to initialize a new power flow case.

newton_tolerance

 specify or return the value of the default Newton-Raphson convergence tolerance.

non_divergent

 specify or return the option to specify or return the option to enable or disable the non-divergent Newton power flow solution.

non_trans_percent_units

 set the non-transformer branch percent units option setting to either MVA or current expressed as MVA.

nsol

 apply the decoupled Newton-Raphson power flow calculation.

number_threads

 specify or return the number of processors available for parallel operations.

ordr

 calculate a sparsity preserving ordering of buses in preparation for the processing of network matrices.

otdf

 tabulate vectors of distribution factors using a linear network (dc) model.

output_y_matrix

 display the network admittance matrix for a subsystem of the working case in the form of a list of matrix terms.

outs

 tabulate those components in the working case that are removed from service.

ownm

ownm_2

ownm_3

This API routine is the third release of the owner renumbering function.

ownr

 tabulate owner totals by owner.

path

 specify a directory pathname.

phase_shift_adjustment

 specify or return the option to enable or disable the phase shift adjustment.

poly

 calculate interchange limits of a study system against two opposing systems using a linear network (dc) model.

pout

 print the power flow solution results with boundary condition and flow information on the left side of the report and other information on the right side.

power_output

 specify or return the option to display power output in either MVA or kVA.

pp_accc

 report the results of the AC contingency calculation function.

pp_accc_multi_case

print_outaged_branches

 specify or return the option to enable or disable whether to print out-of- service branches.

print_winding_buses

 specify or return the option to enable or disable whether to print winding “to” buses of three-winding transformers.

progress_output

 specify the progress output device.

prompt_output

 specify the prompt output device.

prti

 print the 16 line long title.

pscopf

pscopf_2

This API is the second release of Preventive Security Constrained Optimal Power Flow solution (PSCOPF).

pseb

 convert a PSEB command file into a PSSE response file.

pssehalt

pssehalt_2

 end the operation of PSSE, closes all associated files and returns to the calling application.

pv_engine

pv_engine_1a

pv_engine_2

pv_engine_3

pv_engine_4

pv_engine_5

pv_engine_6

Use this API routine to run the PV analysis calculation engine.

qv_engine

qv_engine_2

qv_engine_3

qv_engine_4

Use this API routine to run the QV analysis calculation engine.

rank

 estimate the severity of designated single branch outage contingencies and builds a contingency solution output file with contingencies specified in decreasing order of their estimated severities.

rank_brn_and_mac

 estimate the severity of designated single element outage contingencies and builds a contingency description data file with contingencies specified in decreasing order of their estimated severities.

rate

rate_2

 check branch loadings.

rating_set

 specify or return the current rating set, from 1 to 12.

rawd

rawd_2

 replicate the working case in the form of a power flow raw data file.

rawdx

rawx_to_csv

 export rawx (extended raw data) table to a CSV (comma-separated values) file.

rdch

 read power flow change data into the working case.

rdchrawversion

 read a Power Flow Change Raw Data File into the working case.

rdeq

 build an electrical equivalent of radial and, optionally, two-point Type 1 buses outside of a specified subsystem of the working case.

read

 read a power flow raw data file and add all the data specified in it to the working case.

readcapcurves

 read data contained in a Machine Capability Curve Data File into the working case.

readrawversion

 read a power flow raw data file and add all the data specified in it to the working case.

readrawx

 read an extended raw data file and add all the data specified to the working case.

readsub

 read a power flow raw data file and add subsystem data specified in it to the working case.

readsubrawversion

 read a power flow raw data file and add subsystem data specified in it to the working case.

readx

recn

 electrically reconnect a bus.

regb

 tabulate those buses where voltages are controlled by generation, switched shunts, and/or other voltage controlling equipment.

relind

relind_2

 run probabilistic reliability assessment for transmission systems.

remm

 read transaction event data from a transactions raw data file and add it to PSSE working memory.

report_output

 specify the report output device.

resq

 read sequence data from a sequence data file and add it to the working case.

resqversion

 read a network sequence data file and add all the data specified in it to the working case.

result_table_output

 get and set the default tabular output.

reti

 read the long title from an input file into the working case.

retry_pssuserpf

 allow the loading or use of the Powerflow Customization Interface (PCI) implementation module (pssuserpf) after a failure.

rev29_names

 set the extended bus name input format to either the PSSE-29 or PSSE-30 format.

rnfi

 reproduce the results of a working case bus renumbering operation in auxiliary data input files.

rsol

 perform a robust power flow solution (activity RSOL).

runlastsolution

 run the last known power flow solution.

rwcm

 replicate the working case in IEEE common tape format.

rwma

 replicate machine parametric data from the working case in the form of a machine impedance data file.

rwmm

 replicate transaction event data in the form of a transactions data file.

rwsq

rwsq_2

 replicate the sequence data contained in the working case in the form of a sequence data file.

save

 save the PSSE working case in a saved case file.

scal

scal_2

scal_3

scal_4

Use this API routine to uniformly increase or decrease any or all specified bus quantities for a specified group of buses.

sensitivity_flow

This API is used to calculate sensitivity factors of a branch flow to MW power at buses, MW power at generator buses, MW at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts:

sensitivity_flows

This API is used to calculate sensitivity factors of flows on the branches in a subsystem to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.

sensitivity_interface

This API is used to calculate sensitivity factors of  an interface flow to MW power at buses, MW power at generator buses, MW power at load buses, phase angle of phase shifters, tap position of tap changing transformers as well as admittance of switched shunts.

sensitivity_voltage

This API is used to calculate sensitivity factors of a bus voltage to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.

sensitivity_voltages

This API is used to calculate sensitivity factors of  bus voltages in a subsystem to MW and MVar power at buses, MW power at generator buses, MW and MVar at load buses, phase angle of phase shifters, tap postion of tap changing transformers as well as admittance of switched shunts.

set_input_dev

 set the terminal input device to a file.

set_progress_verbose

 to set the option progress message verbose value.

shnt

 tabulate fixed and/or switched bus shunts contained in the working case.

short_circuit_coordinates

 specify or return the option to set the fault analysis voltage and current output coordinates to either rectangular or polar coordinates.

short_circuit_modeling

 specify or return the option for the fault analysis modeling setting; either normal three-phase or center tapped two-phase.

short_circuit_units

 specify or return the option to set the fault analysis voltage and current output units to either per unit or physical units.

short_circuit_warning

 specify or return the option to enable or disable the fault analysis warning option setting.

short_circuit_z_coordinates

 specify or return the option to set the fault analysis output impedance coordinates to either rectangular or polar coordinates.

short_circuit_z_units

 specify or return the option to set the fault analysis output impedance units to either per unit or ohms.

show

 tabulate summaries of Saved Case and/or Snapshot Files.

showtable

Directs a report table to output console.

showtablebyindex

This API routine was first introduced in release 35.

size

 obtain a summary of the number of components in the working case (activity SIZE).

solv

 apply the Gauss-Seidel power flow calculation.

spcb

 calculate positive sequence equivalents of branch unbalances.

spil

 calculate transmission interchange limits using a linear network (dc) model.

splt

 add a bus to the working case and place a zero impedance line between bus BUS and the new bus.

sqli

 tabulate the sequence data in a form suitable for problem data documentation.

sraind

 run the substation reliability analysis.

stop

stop_2

 end the operation of PSSE.

subs

 summarize conditions in the working case by tabulating the conditions at each swing system bus, conditions at each area slack area bus, number of components, generation/ load/shunt totals, and loss/line shunt/charging totals by voltage levels.

switched_shunt_adjustment

 specify or return the option to enable or disable switched shunt adjustment.

tap_adjustment

 specify or return the option for the default tap adjustment setting; either disabled, stepping or direct.

text

This API does nothing.

tflg

 set or reset the adjustment control mode flags for all automatically adjustable transformers contained in the specified subsystem.

ties

 tabulate the flows on all area tie lines, with tie flows grouped by area.

tiez

 tabulate the flows on all zone tie lines, with tie flows grouped by zone.

time

 tabulate timing statistics.

tlst

 tabulate those transformers in the working case where off-nominal turns ratio or phase shift angle may be adjusted by the power flow solution activities.

tltg

 calculate transmission interchange limits using a linear network (dc) model.

tpch

 check the adjustment data associated with voltage or flow controlling transformers.

transformer_percent_units

 specify or return the option to set the transformer percent units to either MVA or current expressed as MVA.

transmission_line_units

 to specify or return the option set the transmission line units to either per unit or ohms.

tree

 check for the existence of in-service ac islands that do not contain a Type 3 (swing) bus.

tspfprofilecurvevalue

 return real parameters of Time Series Power Flow profile data.

tysl

 run switching study network solutions.

user

 run the user-written activity, subroutine USERAC.

vamm

 tabulate the vector absolute MW-mile report.

vamo

 tabulate the vector absolute MW-ohm report.

vchk

 tabulate those buses where voltage magnitude is outside a specified range.

voltage_input

 specify or return the voltage input option setting; either per unit or kV.

voltage_output

 specify or return the voltage output option setting; either per unit or kV.

vsmo

 tabulate the vector MW-ohm report.

write_options_file

 save the present values of the PSSE-25 program option settings to the file psse.opt.

writecapcurves

 write the capability curve data in the working case in the form of a Capability Curve Raw Data File.

writerawversion

 replicate the working case in the form of power flow raw data file compatible with PSSE 15 or later.

writerawx

 write an extended raw data file from data in the current working case.

writerawxsubsys

 write an extended raw data file from data in the current working case, specifying a subsystem.

writeseqversion

writeseqversion_2

 replicate the working case in the form of a network sequence data file compatible with PSSE 27 or later.

xeqv

 build an electrical equivalent of the portion of the working case outside of a specified subsystem of the working case.

zone

zone_2

 tabulate zone totals by zone.

zone_area

 tabulate zone totals by zone, along with subtotals by area.

zonm

zonm_2

Use this API routine to reassign the buses, loads and/or induction machines in a specified subsystem of the working case from their original zone to a designated zone.

--- Scenarios — .txt ---

Scenarios — 

Scenarios¶

closescenariofile

newscenariofile

openscenariofile

savescenariofile

scenarioclose

 close the currently open Scenario.

scenariocopyfile

 copy a file from one group to another group.

scenariofileadd

 add a file to the specified group.

scenariofilecount

 retrieve the number of files in a specified group in the Scenario.

scenariofilegetattrs

 retrieve the attributes of the specified file.

scenariofilegetcomments

 retrieve the comments for the specified file.

scenariofilelengthcomments

 determine the buffer size needed to hold the comments for the specified file.

scenariofilelist

 retrieve the list of files in the specified group.

scenariofileremove

 remove a file from the specified group.

scenariofilerename

 rename one of the files in the Scenario.

scenariofilesetattrs

 modify the attributes of the specified file.

scenariofilesetcomments

 define or modify the comments for the specified file.

scenariogetattrs

 retrieve the attributes of the Scenario.

scenariogetcomments

 retrieve the Scenario comments.

scenariogetopt

 retrieve the Scenario options.

scenariogroupadd

 add a group to the Scenario.

scenariogroupcount

 retrieve the number of groups in the Scenario.

scenariogroupgetcomments

 retrieve the comments for the specified group.

scenariogrouplengthcomments

 determine the buffer size needed to hold the comments for the specified group.

scenariogrouplist

 retrieve the list of groups in the Scenario.

scenariogroupopen

 add a group to the Scenario.

scenariogroupremove

 remove a group from the Scenario.

scenariogrouprename

 rename one of the groups in the Scenario.

scenariogroupsetcomments

 define or modify the comments for the specified group.

scenarioisdirty

 determine if there are any unsaved changes in the current Scenario.

scenarioisvalid

 determine if there is a valid Scenario in memory.

scenariolengthcomments

 determine the buffer size needed to hold the current Scenario comments.

scenariomodelgroup

 create a new group that is identical to another group.

scenariomovefile

 move a file from one group to another group.

scenarionew

 create a new Scenario.

scenarioopen

 open a previously created Scenario.

scenariosave

 save the currently open Scenario.

scenariosetattrs

 modify the root path and startup group attributes of the Scenario.

scenariosetcomments

 define or modify the Scenario comments.

scenariosetopt

 modify the Scenario options.

scenariotrackfileadd

 add the files currently being tracked.

scenariotrackfilelist

 retrieve the list of files being tracked.

scenariotrackfilenum

 retrieve the current number of files being tracked.

scenariounzip

 unzip a zipped Scenario.

scenariounzipproblems

 retrieve the problems that occurred during the last unzip attempt.

scenariounzipsolutions

 submit potential solutions to the problems that occurred during the last unzip attempt.

scenariozip

 zip up the current Scenario.

scenariozipactive

 determine if the Scenario is currently in Zip Mode.

scenariozipopen

 open a zipped Scenario.

scenariozipsave

This API routine was first introduced in release 33.2.

--- Set Disturbance Definition — .txt ---

Set Disturbance Definition — 

Set Disturbance Definition¶

dist_def_3phase_bus_fault

 define a three phase fault at a bus in dynamic simulations.

dist_def_3wind_fault

 define a fault at the IBUS end of a three-winding transformer in dynamic simulations.

dist_def_branch_fault

 define a fault at the IBUS end of a non-transformer branch or a two-winding transformer in dynamic simulations.

dist_def_scmu_fault_3

 define an unbalanced fault at a bus in dynamic simulations.

dist_def_spcb_fault_2

Use this API routine to define a branch unbalance in dynamic simulations.

--- Set Disturbance — .txt ---

Set Disturbance — 

Set Disturbance¶

dist_3phase_bus_fault

 apply a three phase fault at a bus during dynamic simulations.

dist_3wind_close

 set a three-winding transformer to in-service during dynamic simulations.

dist_3wind_fault

 apply a fault at the IBUS end of a three-winding transformer during dynamic simulations.

dist_3wind_trip

 set a three-winding transformer to out-of-service during dynamic simulations.

dist_branch_close

 set a non-transformer branch or a two-winding transformer to in-service during dynamic simulations.

dist_branch_fault

 apply a fault at the IBUS end of a non-transformer branch or a two-winding transformer during dynamic simulations.

dist_branch_trip

 set a non-transformer branch or a two-winding transformer to out-of-service during dynamic simulations.

dist_bus_fault

dist_bus_fault_2

dist_bus_fault_3

 apply an unbalanced fault at a bus during dynamic simulations.

dist_bus_trip

 disconnect a bus during dynamic simulations.

dist_clear_fault

 clear a fault during dynamic simulations.

dist_machine_trip

 set a machine to out-of-service during dynamic simulations.

dist_scmu_fault

dist_scmu_fault_2

dist_scmu_fault_3

 calculate an unbalanced fault and apply the equivalent positive sequence fault admittance at a bus during dynamic simulations.

dist_spcb_fault

dist_spcb_fault_2

Use this API routine to run the second release of the dynamics branch unbalance function.

--- Single Element Data — .txt ---

Single Element Data — 

Single Element Data¶

apierrstr

 return the message string associated with a specific error code returned from a recordable PSSE API routine.

ardat

 return area totals.

aredat

 return real area data items.

areint

 return integer area data items.

arenam

 return the area name.

arenum

 return the area number.

areuse

 indicate if an area is in use.

aritoj

 return the interchange between two areas.

brncur

brndat

 return real branch parameters.

brndt2

 return complex positive and zero sequence parameters for non-transformer branches, and complex positive sequence parameters for transformer branches.

brnflo

 return the complex branch flow (P+jQ) as calculated at IBUS.

brnint

 return integer branch parameters.

brnmsc

 return real branch flow values.

brnmva

brnnam

 return the name of an AC branch.

brnstt

bsysisdef

 check whether a bus subsystem has been defined for a given subsystem ID.

busdat

 return real bus values.

busdt1

 return complex bus parameters as MVA.

busdt2

 return complex bus parameters.

busexs

 check for the existence of a specified bus.

busint

 return integer bus parameters.

busmsm

 return complex bus mismatch.

busordpos

 return the ordinal position of the specified bus or bus section in the numerically ordered list of non-star point buses (i.e., star point buses are excluded).

bussectdat

Use this API routine to return real bus section values.

bussectdt1

Use this API routine to return complex bus section parameters as MVA.

bussectdt2

Use this API routine to return complex bus section parameters.

bussectexs

Use this API routine to check for the existence of a specified bus section.

bussectint

Use this API routine to return real bus section values.

cctmdlnam_2dco

 return model name of CCT 2-terminal dc line other models.

cctmdlnam_2wtd

 return model name of the CCT 2-winding transformer device model.

cctmdlnam_3wtd

 return model name of the CCT 3-winding transformer device model.

cctmdlnam_brnd

 return model name of the CCT branch device model.

cctmdlnam_brno

 return model name of the CCT branch other model.

cctmdlnam_buso

 return model name of CCT Bus other models.

cctmdlnam_mcno

 return model name of the CCT machine other models.

cctmdlnam_mcnp

 return model name of the CCT machine protection models.

cctmdlnam_msco

 return model name of the CCT Miscellaneous other model.

cctmdlnam_swso_2

 return model name of the CCT switched shunt other type models.

cctmind_2dco

 return starting array indices and status of CCT 2-terminal dc line other models.

cctmind_2wtd

 return starting array indices and status of CCT 2-winding transformer device models.

cctmind_3wtd

 return starting array indices and status of CCT 3-winding transformer device models.

cctmind_brnd

 return starting array indices and status of CCT branch device models.

cctmind_brno

 return starting array indices and status of CCT branch other models.

cctmind_buso

 return starting array indices and status of CCT Bus other models.

cctmind_mcno

 return starting array indices and status of CCT machine other models.

cctmind_mcnp

 return starting array indices and status of CCT machine protection models.

cctmind_msco

 return starting array indices and status of CCT Miscellaneous other models.

cctmind_swso

cctmind_swso_2

 return starting array indices and status of CCT Switched Shunt other models.

chktre

 check for Type 4 (or greater) buses with in-service branches connected to them.

chnval

 return the present value of the simulation variable assigned to a specified output channel.

dc2auxmind

 return the starting array indices and status of auxiliary signal model associated with 2-terminal dc line for the specified signal index.

dc2auxmnam

 return the auxiliary signal model name associated with a 2-terminal dc line for the specified auxiliary signal index.

dc2dat

dc2dat_2

This API is the second release of the API that returns real two-terminal dc line quantities.

dc2int

dc2int_2

This API is the second release of the API that returns integer two-terminal dc line quantities.

dc2mind

 return 2-terminal dc line model starting array indices and status.

dc2mnam

 return 2-terminal dc line model name.

dcnauxmind

 return the starting array indices and status of auxiliary signal model associated with N-terminal dc line for the specified signal index.

dcnauxmnam

 return the auxiliary signal model name associated with a N-terminal dc line for the specified auxiliary signal index.

dcncin

dcncin_2

This API is the second release of the API that returns integer multi-terminal dc line converter quantities.

dcndat

dcndat_2

This API is the second release of the API that returns real multi-terminal dc line quantities.

dcnint

dcnint_2

This API is the second release of the API that returns integer multi-terminal dc line quantities.

dcnmind

 return N-terminal dc line model starting array indices and status.

dcnmnam

 return N-terminal dc line model name.

dscval

 return dynamics character array values.

dsival

 return dynamics integer array values.

dsrval

 return dynamics real values.

fcdauxmind

 return the starting array indices and status of auxiliary signal model associated with FACTS device for the specified signal index.

fcdauxmnam

 return the auxiliary signal model name associated with a FACTS device for the specified auxiliary signal index.

fcddat

fcddat_2

This API is the second release of the API that returns FACTS device real quantities.

fcdint

fcdint_2

This API is the second release of the API that returns FACTS device integer quantities.

fcdmind

 return FACTS device model starting array indices and status.

fcdmnam

 return FACTS device model name.

fxsdt1

 return the magnitude of a specified fixed bus shunt.

fxsdt2

 return complex fixed bus shunt.

fxsint

 return integer quantities of the specified fixed bus shunt.

gencnv

 return a flag indicating whether generators are converted.

gendat

 return plant total power output.

gendt1

Returns total plant power output in MVA.

gensectdat

Use this API routine to return a bus section’s plant total power output.

gensectdt1

Use this API routine to return a bus section’s total plant power output in MVA.

get_mstate

 return the MSTATE value.

gethomepath

 retrieve a user’s HOMEPATH directory.

gnechr

Use this API routine to return character quantities of a specified GNE device.

gnedat

Use this API routine to return real quantities of a specified GNE device.

gneint

Use this API routine to return integer quantities of a specified GNE device.

inddt1

Use this API routine to return real induction machine quantities.

inddt2

Use this API routine to return complex induction machine quantities.

indint

Use this API routine to return integer induction machine quantities.

ini2dc

Initializes the two-terminal dc line fetching routine ‘NXT2DC’ for retrieving two-terminal dc lines in dc line name alphabetical order.

inibrn

Initializes the branch fetching routine ‘NXTBRN’ or ‘NXTBRN3’ for returning branches connected to IBUS.

inibrn_2

Initializes the branch fetching routine ‘NXTBRN_2’ or ‘NXTBRN3_2’ for returning branches connected to bus sections described by IBUS and INODE.

inibrx

Initializes the branch fetching routine, ‘NXTBRN’ or ‘NXTBRN3’ for returning branches connected to IBUS.

inibrx_2

Initializes the branch fetching routine, ‘NXTBRN_2’ or ‘NXTBRN3_2’ for returning branches connected to IBUS.

inibus

Initializes the bus fetching routine ‘NXTBUS’ for retrieving buses in ascending numerical order.

inibus_2

Initializes the bus fetching routine ‘NXTBUS_2’ for retrieving buses in ascending numerical order.

inibux

Initializes the bus fetching routine ‘NXTBUS’ for retrieving buses in ascending numerical order.

inifax

Initializes the FACTS device fetching routine ‘NXTFAX’ for retrieving FACTS devices in FACTS device name alphabetical order.

inifxs

Initializes the fixed bus shunt fetching routine ‘NXTFXS’ for returning fixed shunts attached to bus IBUS.

iniind

Initializes induction machine fetching routine ‘NXTIND’ for returning induction machines attached to IBUS.

inilod

Initializes load fetching routine ‘NXTLOD’ for returning loads attached to IBUS.

inimac

Initializes machine fetching routine ‘NXTMAC’ for returning machines attached to IBUS.

inimdc

Initializes the multi-terminal dc line fetching routine ‘NXTMDC’ for retrieving multi-terminal dc lines in dc line name alphabetical order.

inimsl

Initializes the multi-section line member fetching routine ‘NXTMSL’ for retrieving lines that are sections of the specified multi-section line from IBUS to JBUS.

ininam

Initializes the bus fetching routine ‘NXTBUS’ for retrieving buses in ascending alphabetical order.

ininam_2

Initializes the bus fetching routine ‘NXTBUS_2’ for retrieving buses in ascending alphabetical order.

ininax

Initializes the bus fetching routine ‘NXTBUS’ for retrieving buses in ascending alphabetical order.

inistabussect

Use this API routine to initialize the bus section fetching routine ‘NXTSTABUSSECT’ for retrieving the bus sections in a substation.

inistanode

Use this API routine to initialize the node fetching routine ‘NXTSTANODE’ for retrieving the nodes in a sub-station.

inistaswdev

Use this API routine to initialize the switching device fetching routine ‘NXTSTASWDEV’ for retrieving the switching devices in a substation.

inisws

Initializes the switched shunt fetching routine ‘NXTSWS’ for returning switched shunts attached to bus IBUS.

initie

Initializes the tie branch fetching routine ‘NXTTIE’ or ‘NXTTIE3’ for returning tie branches from area IAR.

initix

Initializes the tie branch fetching routine ‘NXTTIE’ or ‘NXTTIE3’ for returning tie branches from area IAR.

inivsc

Initializes the VSC dc line fetching routine ‘NXTVSC’ for retrieving VSC dc lines in dc line name alphabetical order.

island

Trips in-service branches connected to Type 4 (or greater) buses, and disconnects islands not containing a swing bus.

iterat

 return the number of iterations used in the last solution attempt.

lmodind

Returns load-related model starting array indices and status.

lmodnam

Returns load-related model name.

lodcnv

This obsolete API always returns a 0.

loddt1

Returns load quantities in MVA.

loddt2

 return complex load quantities.

lodind

 return the load array index.

lodint

 return integer load quantities.

lodtype

 return the load type character string.

macchr

 return character machine quantities.

macdat

 return real machine quantities.

macdt2

 return complex machine quantities.

macind

 return the machine array index.

macint

 return integer machine quantities.

macstt

 return the machine status value.

maxmsm

 return the complex bus mismatch at the bus with the largest MVA mismatch.

mdlind

 return plant-related model starting array indices and status.

mdllibcnt

 return the number of libraries in the list to be searched for dynamics library models.

mdlnam

 return plant-related model name.

mdlpgmcnt

 returns the number of model programs loaded from dynamics model libraries.

natono

 return the bus number for a specified 18-character extended bus name.

notona

 return the bus 18-character extended bus name for a specified bus number.

notonasect

 return the bus 18-character extended bus name for a specified bus section.

nxt2dc

Returns the next two-terminal dc line in dc line name alphabetical order.

nxtbrn

Returns the next branch connected to a bus, excluding three-winding transformers.

nxtbrn3

Returns the next branch connected to a bus, including three-winding transformers.

nxtbrn3_2

Returns the next branch connected to a bus section, including three-winding transformers.

nxtbrn_2

Returns the next branch connected to a bus, excluding three-winding transformers.

nxtbus

Returns the next bus in ordered sequence.

nxtbus_2

Returns the next bus in ordered sequence.

nxtfax

Returns the next FACTS device in FACTS device name alphabetical order.

nxtfxs

 return the identifier of the next fixed shunt connected to a bus.

nxtind

Use this API routine to return the identifier of the next induction machine connected to a bus.

nxtlod

 return the identifier of the next load connected to a bus.

nxtmac

 return the identifier of the next machine connected to a bus.

nxtmdc

Returns the next multi-terminal dc line in dc line name alphabetical order.

nxtmsl

 return the next multi-section line member branch.

nxtstabussect

Use this API routine to retrieve the next bus section in the specified substation.

nxtstanode

Use this API routine to retrieve the next node in the specified substation.

nxtstaswdev

Use this API routine to retrieve the next switching device in the specified substation.

nxtsws

 return the identifier of the next switched shunt connected to a bus.

nxttie

 return the next tie branch from an area, excluding three-winding transformers.

nxttie3

 return the next tie branch from an area, including three-winding transformers.

nxtvsc

Returns the next VSC dc line in dc line name alphabetical order.

okstrt

Routine which may be called after activity STRT or MSTR to indicate the presence of INITIAL CONDITIONS SUSPECT errors (for activity STRT) or at least one MODEL NOT AVAILABLE IN MSTR/MRUN message (for MSTR).

openun

Connects an IPLAN unit number to the Fortran unit used by activity OPEN and returns that IPLAN unit number.

ordbus

This API routine returns the bus number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-hidden buses (i.e., star point buses and topological buses are excluded).

ordbussect

This API routine returns the bus number and section number corresponding to the specified position in the ordered list (numeric or alphabetic) of non-star point buses (i.e., star point buses are excluded).

owndat

Returns the data associated with an owner (‘LOAD’ gets loads at buses of owner ‘IAR’, ‘LOADLD’ gets loads assigned to owner ‘IAR’).

ownnam

Returns the owner name for a specified owner number.

ownnum

Returns the owner number for a specified owner name.

ownuse

 indicate whether an owner is in use.

prmdat

Use this API routine to return real-valued solution parameters.

prmint

Use this API routine to return integer-valued solution parameters.

ratchr

 get rating set parameters.

rmodind

Returns the branch relay model starting array indices and status.

rmodnam

Returns the branch relay model name.

sbsgtbkv

 get previously defined bus subsystem voltage limits.

sc3wnd

Returns the three-winding transformer short circuit currents arriving at IBUS following activity SCMU.

scbrn2

Returns the branch short circuit currents arriving at IBUS following activity SCMU.

scbus2

Returns complex bus voltages and currents following activity SCMU.

scdone

 restore the working case after ‘SCINIT’.

scinit

 initialize the short-circuit data retrieval APIs.

scmac2

 return the machine short circuit currents following activity SCMU.

selctr

 return the activity selector indicator.

sethomepath

 set a user’s HOMEPATH directory.

sfiles

 return the current Saved Case and Snapshot filenames.

slmodind

 return the subsystem load-related model starting array indices and status.

slmodnam

 return the subsystem load-related model name.

solstr

 return a string indicating the result of the last solution attempt.

solved

 check whether the last solution attempt reached tolerance.

solved_ca

 check whether the last corrective action solution attempt reached tolerance.

stadat

Use this API routine to return real substation values.

staint

Use this API routine to return integer substation values.

staname

Use this API routine to return a substation’s name.

stanodeint

Use this API routine to return integer substation values.

stanodename

Use this API routine to return the name of a substation node.

starea

 restrict ‘NXTBUS’ to a single area.

staswdevdat

Use this API routine to return real substation switching device values.

staswdevint

Use this API routine to return integer substation switching device values.

staswdevname

Use this API routine to return the name of a substation switching device.

stbskv

 restrict ‘NXTBUS’ to a single base voltage level.

stzone

 restrict ‘NXTBUS’ to a single zone.

swsblk

swsblk_2

 return data for a specified block of a specified switched shunt.

swsblz

swsblz2

swsdat

swsdat_2

 return switched shunt real data.

swsdt1

swsint

swsint_2

 return switched shunt integer parameters.

swsmind

swsmind_2

 return switched shunt model starting array indices and status.

swsmnam

swsmnam_2

 return switched shunt model name.

sysmsm

 return the total system MVA mismatch.

sysmva

 return the system base MVA.

systot

 return complex system-wide values.

titldt

 return the two line case title.

totbus

 return the total number of buses in the working case.

tr3dat

 return three-winding transformer real values.

tr3dt2

 return three-winding transformer complex values.

tr3int

 return three-winding transformer integer values.

tr3nam

 return three-winding transformer name.

trndat

trxdat

 return the inter-area transfer MW.

tspfprofilechr

 return string parameters of Time Series Power Flow profile.

tspfprofilecurvechr

 return string parameters of Time Series Power Flow profile curve.

tspfprofilecurveint

 return integer parameters of Time Series Power Flow profile curve.

tspfprofilecurvereal

 return real parameters of Time Series Power Flow profile curve.

tspfprofileint

 return integer parameters of Time Series Power Flow profile.

tspfprofilereal

 return real parameters of Time Series Power Flow profile.

voltagedroopdata

 return voltage droop control real parameters.

voltagedroopint

 return voltage droop control integer parameters.

vscauxmind

 return the starting array indices and status of auxiliary signal model associated with VSC dc line for the specified signal index.

vscauxmnam

 return the auxiliary signal model name associated with a VSC dc line for the specified auxiliary signal index.

vsccdt

 return VSC dc line real parameters.

vsccin

 return VSC dc line converter integer parameters.

vscint

 return VSC dc line integer parameters.

vscmind

 return VSC dc line model starting array indices and status.

vscmnam

 return VSC dc line model name.

windmind

 return wind model starting array indices and status.

windmnam

 return wind model name.

wnddat

 return three-winding transformer real values for winding connected to bus IBUS.

wnddt2

 return three-winding transformer complex values for winding connected to bus IBUS.

wndint

 return three-winding transformer integer values for winding connected to bus IBUS.

xfrdat

 return two-winding transformer real parameters.

xfrint

 return two-winding transformer integer parameters.

xfrnam

 return two-winding transformer name.

zndat

 return zone totals.

znitoj

 return the interchange between two zones.

zonnam

 return the zone name.

zonnum

 return the zone number.

zonuse

 indicate whether a zone is in use.

--- Substation Data — .txt ---

Substation Data — 

Substation Data¶

astationchar

 return an array of character values for subsystem substations.

astationcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the substation data family.

astationint

 return an array of integer values for subsystem substations.

astationreal

 return an array of real values for subsystem substations.

astationtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation data family (aStationInt, aStationReal and aStationChar).

--- Substation Node Data — .txt ---

Substation Node Data — 

Substation Node Data¶

anodechar

 return an array of character values for subsystem substation nodes.

anodecount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the substation node data family.

anodeint

 return an array of integer values for subsystem substation nodes.

anodereal

 return an array of real values for subsystem substation nodes.

anodetypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation node data family (aNodeInt and aNodeChar).

--- Substation Switching Device Data — .txt ---

Substation Switching Device Data — 

Substation Switching Device Data¶

astaswdevchar

 return an array of character values for subsystem substation switching devices.

astaswdevcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the substation switching device data family.

astaswdevcplx

 return an array of complex values for subsystem substation switching devices.

astaswdevint

 return an array of integer values for subsystem substation switching devices.

astaswdevreal

 return an array of real values for subsystem substation switching devices.

astaswdevtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation switching device data family (aStaSwDevInt, aStaSwDevReal, aStaSwDevCplx and aStaSwDevChar).

--- Substation Terminal Data — .txt ---

Substation Terminal Data — 

Substation Terminal Data¶

aterminalchar

 return an array of integer values for subsystem substation terminals.

aterminalcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the substation terminal data family.

aterminalint

 return an array of integer values for subsystem substation terminals.

aterminaltypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the substation terminal data family (aTerminalInt and aTerminalChar).

--- Switched Shunt Bus Data — .txt ---

Switched Shunt Bus Data — 

Switched Shunt Bus Data¶

aswshuntbuschar

 return an array of character values for subsystem buses.

aswshuntbuscount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt bus data family.

aswshuntbuscplx

 return an array of complex values for subsystem buses.

aswshuntbusint

 return an array of integer values for subsystem buses.

aswshuntbusreal

 return an array of real values for subsystem buses.

aswshuntbustypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt bus data family (aSwShntBusInt, aSwShntBusReal, aSwShntBusCplx and aSwShntBusChar).

--- Switched Shunt Data — .txt ---

Switched Shunt Data — 

Switched Shunt Data¶

aswshchar

 return an array of character values for subsystem switched shunts.

aswshcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the switched shunt data family.

aswshcplx

 return an array of complex values for subsystem switched shunts.

aswshint

 return an array of integer values for subsystem switched shunts.

aswshreal

 return an array of real values for subsystem switched shunts.

aswshtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the switched shunt data family (aSwshInt, aSwshReal, aSwshCplx and aSwshChar).

--- Switched Shunt Models — .txt ---

Switched Shunt Models — 

Switched Shunt Models¶

add_swshunt_model

add_swshunt_model_2

 add a switched shunt model to the specified switched shunt device.

change_swsmod_chricn

change_swsmod_chricn_2

 change the value of a character ICON (i.e., an element of the CHRICN array) of the switched shunt model of a specified switched shunt device.

change_swsmod_con

change_swsmod_con_2

 change the value of a CON of the switched shunt model of a specified switched shunt device.

change_swsmod_icon

change_swsmod_icon_2

 change the value of an integer ICON (i.e., an element of the ICON array) of the switched shunt model of a specified switched shunt device.

change_swsmod_var

change_swsmod_var_2

 change the value of a VAR of the switched shunt model of a specified switched shunt device.

gmb_add_swshunt_model

gmb_add_swshunt_model_2

 add a GMB switched shunt model to the specified switched shunt device.

swsmod_pack

 remove entries that are marked as unused from the switched shunt model connection tables and the switched shunt model array allocation tables.

swsmod_remove

swsmod_remove_2

 remove the switched shunt model from a specified switched shunt.

swsmod_status

swsmod_status_2

 change the status of the switched shunt model at a specified switched shunt device.

swsmod_unconnected

 list or remove from dynamics working memory those switched shunt models that are assigned to switched shunt that are not present in the current power flow working case (unconnected).

swsmod_user

 list user-written switched shunt model definitions or to remove user-written switched shunt model definitions that are not assigned to any switched shunt devices (unused) from the user model definition tables.

--- Three-Winding Transformer Data — .txt ---

Three-Winding Transformer Data — 

Three-Winding Transformer Data¶

atr3char

 return an array of character values for subsystem three-winding transformers.

atr3count

 return the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer data family.

atr3cplx

 return an array of complex values for subsystem three-winding transformers.

atr3int

 return an array of integer values for subsystem three-winding transformers.

atr3real

 return an array of real values for subsystem three-winding transformers.

atr3types

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer data family (aTr3Int, aTr3Real, aTr3Cplx and aTr3Char).

--- Three-Winding Transformer Winding Data — .txt ---

Three-Winding Transformer Winding Data — 

Three-Winding Transformer Winding Data¶

awndchar

 return an array of character values for subsystem three-winding transformer windings.

awndcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the three-winding transformer winding data family.

awndcplx

 return an array of complex values for subsystem three-winding transformer windings.

awndint

 return an array of integer values for subsystem three-winding transformer windings.

awndreal

 return an array of real values for subsystem three-winding transformer windings.

awndtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the three-winding transformer winding data family (aWndInt, aWndReal, aWndCplx and aWndChar).

--- Time Series Power Flow Data — .txt ---

Time Series Power Flow Data — 

Time Series Power Flow Data¶

purge_tspf_channel

 delete all Time Series Power Flow profiles for an element.

purge_tspf_channel_all

 remover all time series power flow channels for a selected element.

purge_tspf_profile

 delete Time Series Power Flow profile by profile name.

purge_tspf_profilecurve

 delete Time Series Power Flow profile curve by curvesetid and curvecol and index.

purge_tspf_profilecurveset

 delete Time Series Power Flow profile curve set by profile curvesetid.

purge_tspf_profiledata

 delete Time Series Power Flow profile data by curvesetid and curvecol and index.

tspf_channel_chng

 select time series power flow Cchannels.

tspf_channel_data

 select time series power flow Cchannels.

tspf_profile_chng

Use this API routine to modify the data of an existing Time Series Power Flow profile.

tspf_profile_data

Use this API routine to modify the data of an existing Time Series Power Flow profile, or to add a new Time Series Power Flow profile.

tspf_profilecurveset_chng

Use this API routine to modify the data of an existing Time Series Power Flow profile curve set.

tspf_profilecurveset_data

Use this API routine to modify the data of an existing Time Series Power Flow profile curve set, or to add a new Time Series Power Flow profile curve set.

tspf_profiledata_chng

Use this API routine to modify the data of an existing Time Series Power Flow profile curve value.

tspf_profiledata_data

Use this API routine to modify the data of an existing Time Series Power Flow profile curve value, or to add a new Time Series Power Flow profile curve value.

--- Time Series Power Flow Operation — .txt ---

Time Series Power Flow Operation — 

Time Series Power Flow Operation¶

imposeprofile

 impose generation/load at the given time point on profile curves.

tspf

 run the time series power flow solution.

tspf_output_pmatrix

 output the profile curves within one profile set in the matrix format.

tspf_output_pmatrix_2

 output the profile curves within one profile set in the matrix format.

--- Two-Terminal Dc Line Converter Data — .txt ---

Two-Terminal Dc Line Converter Data — 

Two-Terminal Dc Line Converter Data¶

a2trmdcconvchar

 return an array of character values for subsystem two-terminal dc line converters.

a2trmdcconvcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line converter data family.

a2trmdcconvcplx

 return an array of complex values for subsystem two-terminal dc line converters.

a2trmdcconvint

 return an array of integer values for subsystem two-terminal dc line converters.

a2trmdcconvreal

 return an array of real values for subsystem two-terminal dc line converters.

a2trmdcconvtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line converter data family (a2TrmDcConvInt, a2TrmDcConvReal, a2TrmDcConvCplx and a2TrmDcConvChar).

--- Two-Terminal Dc Line Data — .txt ---

Two-Terminal Dc Line Data — 

Two-Terminal Dc Line Data¶

a2trmdcchar

 return an array of character values for subsystem two-terminal dc lines.

a2trmdccount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the two-terminal dc line data family.

a2trmdccplx

 return an array of complex values for subsystem two-terminal dc lines.

a2trmdcint

 return an array of integer values for subsystem two-terminal dc lines.

a2trmdcreal

 return an array of real values for subsystem two-terminal dc lines.

a2trmdctypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-terminal dc line data family (a2TrmDcInt, a2TrmDcReal, a2TrmDcCplx and a2TrmDcChar).

--- Two-Winding Transformer Data — .txt ---

Two-Winding Transformer Data — 

Two-Winding Transformer Data¶

atrnchar

 return an array of character values for subsystem two-winding transformers.

atrncount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the two-winding transformer data family.

atrncplx

 return an array of complex values for subsystem two-winding transformers.

atrnint

 return an array of integer values for subsystem two-winding transformers.

atrnreal

 return an array of real values for subsystem two-winding transformers.

atrntypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the two-winding transformer data family (aTrnInt, aTrnReal, aTrnCplx and aTrnChar).

--- Using The Vendor Neutral Contingency And Ras Auxiliary File — .txt ---

Using The Vendor Neutral Contingency And Ras Auxiliary File — 

Using The Vendor Neutral Contingency And Ras Auxiliary File¶

accc_ras

accc_ras_2

 run AC contingency calculation function with RAS model.

add2windingconditionelement

Add 2WindingConditionElement to RAS memory model

add2windingcontingencyelement

Add 2WindingContingencyElement to RAS memory model

add2windingremedialactionelement

Add 2WindingRemedialActionElement to RAS memory model

add3windingconditionelement

Add 3WindingConditionElement to RAS memory model

add3windingcontingencyelement

Add 3WindingContingencyElement to RAS memory model

add3windingremedialactionelement

Add 3WindingRemedialActionElement to RAS memory model

addaclineconditionelement

Add AclineConditionElement to RAS memory model

addaclinecontingencyelement

Add AclineContingencyElement to RAS memory model

addaclineremedialactionelement

Add AclineRemedialActionElement to RAS memory model

addbusconditionelement

Add BusConditionElement to RAS memory model

addbuscontingencyelement

Add BusContingencyElement to RAS memory model

addbusremedialactionelement

Add BusRemedialActionElement to RAS memory model

addcondition

Add Condition to RAS memory model

addconditionelement

Add ConditionElement to RAS memory model

addcontingency

Add Contingency to RAS memory model

addcontingencyelement

Add ContingencyElement to RAS memory model

adddcconvconditionelement

Add DcconvConditionElement to RAS memory model

adddcconvcontingencyelement

Add DcconvContingencyElement to RAS memory model

adddcconvremedialactionelement

Add DcconvRemedialActionElement to RAS memory model

adddclineconditionelement

Add DclineConditionElement to RAS memory model

adddclinecontingencyelement

Add DclineContingencyElement to RAS memory model

adddclineremedialactionelement

Add DclineRemedialActionElement to RAS memory model

addfixshuntconditionelement

Add FixshuntConditionElement to RAS memory model

addfixshuntcontingencyelement

Add FixshuntContingencyElement to RAS memory model

addfixshuntremedialactionelement

Add FixshuntRemedialActionElement to RAS memory model

addgenconditionelement

Add GenConditionElement to RAS memory model

addgencontingencyelement

Add GenContingencyElement to RAS memory model

addgenremedialactionelement

Add GenRemedialActionElement to RAS memory model

addloadconditionelement

Add LoadConditionElement to RAS memory model

addloadcontingencyelement

Add LoadContingencyElement to RAS memory model

addloadremedialactionelement

Add LoadRemedialActionElement to RAS memory model

addnestedcondition

Add NestedCondition to RAS memory model

addpythonconditionelement

Add PythonConditionElement to RAS memory model

addpythoncontingencyelement

Add PythonContingencyElement to RAS memory model

addpythonremedialactionelement

Add PythonRemedialActionElement to RAS memory model

addremedialaction

Add RemedialAction to RAS memory model

addremedialactionelement

Add RemedialActionElement to RAS memory model

addsubconditionelement

Add SubConditionElement to RAS memory model

addsubcontingencyelement

Add SubContingencyElement to RAS memory model

addsubremedialactionelement

Add SubRemedialActionElement to RAS memory model

addvscdcconditionelement

Add VscdcConditionElement to RAS memory model

addvscdccontingencyelement

Add VscdcContingencyElement to RAS memory model

addvscdcremedialactionelement

Add VscdcRemedialActionElement to RAS memory model

append_ras

 read a Contingency Definition and Remedial Actions auxiliary file, adding to definitions in memory, if present.

read_ras

 read a Contingency Definition and Remedial Actions auxiliary file into memory.

validate_ras

 validate Contingency and Remedial Actions definitions in memory.

write_ras

 write a Contingency Definition and Remedial Actions auxiliary file from memory.

--- Vsc Dc Line Converter Data — .txt ---

Vsc Dc Line Converter Data — 

Vsc Dc Line Converter Data¶

avscdcconvchar

 return an array of character values for subsystem VSC dc line converters.

avscdcconvcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line converter data family.

avscdcconvcplx

 return an array of complex values for subsystem VSC dc line converters.

avscdcconvint

 return an array of integer values for subsystem VSC dc line converters.

avscdcconvreal

 return an array of real values for subsystem VSC dc line converters.

avscdcconvtypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line converter data family (aVscDcConvInt, aVscDcConvReal, aVscDcConvCplx and aVscDcConvChar).

--- Vsc Dc Line Data — .txt ---

Vsc Dc Line Data — 

Vsc Dc Line Data¶

avscdcchar

 return an array of character values for subsystem VSC dc lines.

avscdccount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the VSC dc line data family.

avscdccplx

 return an array of complex values for subsystem VSC dc lines.

avscdcint

 return an array of integer values for subsystem VSC dc lines.

avscdcreal

 return an array of real values for subsystem VSC dc lines.

avscdctypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the VSC dc line data family (aVscDcInt, aVscDcReal, aVscDcCplx and aVscDcChar).

--- Wind Related Models — .txt ---

Wind Related Models — 

Wind Related Models¶

add_wind_model

 add a renewable related model of a designated type to a specified renewable machine.

change_wnmod_chricn

 change the value of a character ICON (i.e., an element of the CHRICN array) of a designated renewable related model at a specified renewable machine.

change_wnmod_con

 change the value of a CON of a designated renewable machine related model at a specified renewable machine.

change_wnmod_icon

 change the value of an integer ICON of a designated renewable machine related model at a specified renewable machine.

change_wnmod_var

 change the value of a VAR of a designated renewable machine related model at a specified renewable machine.

wnmod_consistency

 check consistency among the renewable machine related models referenced at each machine.

wnmod_pack

 remove entries that are marked as unused from the wind model connection tables and the renewable machine model array allocation tables.

wnmod_remove

 remove a renewable machine related model of a designated type from a specified renewable machine.

wnmod_status

 change the status of a renewable machine related model of a designated type at a specified renewable machine.

wnmod_unconnected

 list or remove from dynamics working memory those renewable machine related models that are assigned to renewable machines that are not present in the current power flow working case (unconnected).

wnmod_user

 list user-written renewable machine model definitions or to remove user-written renewable machine model definitions that are not assigned to any renewable machines (unused) from the user model definition tables.

--- Zero Sequence Mutuals Data — .txt ---

Zero Sequence Mutuals Data — 

Zero Sequence Mutuals Data¶

azmutchar

 return an array of character values for subsystem zero sequence mutual branches.

azmutcount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the branch zero sequence mutual data family.

azmutcplx

 return an array of complex values for subsystem zero sequence mutual branches.

azmutint

 return an array of integer values for subsystem zero sequence mutual branches.

azmutreal

 return an array of real values for subsystem zero sequence mutual branches.

azmuttypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the branch zero sequence mutual data family (aZmutInt, aZmutReal, aZmutCplx and aZmutChar).

--- Zone Data — .txt ---

Zone Data — 

Zone Data¶

azonechar

 return an array of character values for subsystem zones.

azonecount

 return the number of array entries required to accommodate the data to be returned by the remaining members of the zone data family.

azonecplx

 return an array of complex values for subsystem zones.

azoneint

 return an array of integer values for subsystem zones.

azonereal

 return an array of real values for subsystem zones.

azonetypes

 return an array of character values indicating the data types corresponding to a set of specified STRING values that are valid input values to any of the data retrieval routines of the zone data family (aZoneInt, aZoneReal, aZoneCplx and aZoneChar).

--- Zone Subsystems — .txt ---

Zone Subsystems — 

Zone Subsystems¶

zsys

 define a zone subsystem.

zsysdef

 set the definition of an zone subsystem.

zsysinit

 initialize or re-initialize a zone subsystem.
#[accc_reports.py]  GET ACCC SOLUTION IN ARRAYS and CREATE CUSTOM REPORTS
#

# =====================

'''
This is an example file showing how to use ACCC Solution Array fetch APIs
from Python to generate custom accc solution reports.

Following ACCC solutions can be retrieved:
    - post-contingency solution,
    - post-tripping solution, or
    - post-corrective action solution

These ACCC solutions can be obtained in Python lists for:
    - single contingency,
    - multiple contingencies, or
    - all contingencies

The APIs used in this program are part of python "arrbox.accc_pp" module.
    accobj = arrbox.accc_pp.CONTINGENCY_PP(accfile)
    Following methods are defined for accobj.
    - accobj.summary and accobj.solution methods return ACCC solution
      in python object, which can be used to create custom reports, or
    - accobj.summary_report, accobj.solution_report or accobj.violations_report
      methods can be used to get pre-defined reports.

Get more info on as:
    help(arrbox.accc_pp.CONTINGENCY_PP)

# =====================

def create_accc_reports(accfile, rptfile):

    import psspy, arrbox.accc_pp

    if not os.path.exists(accfile):
        prgmsg = " Error: Input accfile '{0}' does not exist".format(accfile)
        print(prgmsg)
        return

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)

        rptfpath, rptext = os.path.splitext(rptfile)

    #

# =====================

# (3) ACCC post contingency solution report
    accobj.solution_options(stype=stype_cnt,busmsm=busmsm,sysmsm=sysmsm,rating=rating,flowlimit=flowlimit)
    cntsolnfile = None
    if rptfile:  cntsolnfile = rptfpath + '_solution_cnt' + rptext
    accobj.solution_report(colabels=None,rptfile=cntsolnfile)

    #

# =====================

# (4) ACCC post tripping solution report
    trpsolnfile = None
    if rptfile:  trpsolnfile = rptfpath + '_solution_trp' + rptext
    accobj.solution_options(stype=stype_trp)    # changed only solution type, other options remain same
    accobj.solution_report(colabels=None,rptfile=trpsolnfile)

    #

# =====================

# (5) ACCC post corrective action solution report
    cactsolnfile = None
    if rptfile:  cactsolnfile = rptfpath + '_solution_cact' + rptext
    accobj.solution_options(stype=stype_cact)    # changed only solution type, other options remain same
    accobj.solution_report(colabels=None,rptfile=cactsolnfile)

    #

# =====================

# (9) Getting summary arrays and printing contingency lables in PSS(R)E progress window
    smryobj = accobj.summary()
        # note: returned "smryobj" is used in the following (10) to (16) examples of this program.
    psspy.progress('\n Contingency Labels:\n')
    for each in smryobj.colabel:
        psspy.progress('    '+each+'\n')

    #

# =====================

# (10) Getting solution arrays for one contingency and printing monitored element MVA and AMP flows
    #      in PSS(R)E progress window
    idx   = random.sample(list(range(len(smryobj.colabel))),1)   # select one contingency randomly
    colbl = smryobj.colabel[idx[0]]
    accobj.solution_options(stype=stype_cnt)
    solnobj  = accobj.solution(colabel=colbl)
    if solnobj!=None:        # contingency solution found/error, proceed
        rating = rating.strip().lower()
        try:
            rate = smryobj.rating.rating
        except:
            rate = smryobj.rating.a

        psspy.progress("\n Monitored Element Flows for contingency '%12s':\n" % colbl)
        psspy.progress("<

# =====================

> <RATING> <MVAFLOW> \
    <AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]
            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '

            txtstr = "%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars()
            psspy.progress(txtstr)

    #

# =====================

# (11) Getting solution arrays for three contingency and printing monitored element MVA and AMP flows
    #      in PSS(R)E progress window for converged contingencies

    # select upto maximum of 3 contingencies randomly
    idx    = random.sample(list(range(len(smryobj.colabel))),min(len(smryobj.colabel),3))
    colbls = [smryobj.colabel[x] for x in idx]

    rating = rating.strip().lower()
    try:
        rate = smryobj.rating.rating
    except:
        rate = smryobj.rating.a

    for lbl in colbls:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue          # contingency solution not found, move to next
        if not solnobj.cnvflag: continue    # contingency solution not converged, move to next
        psspy.progress("\n Monitored Element Flows for contingency '%12s':\n" % lbl)
        psspy.progress("<

# =====================

> <RATING> <MVAFLOW> \
<AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]

            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '

            txtstr = "%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars()
            psspy.progress(txtstr)
        psspy.progress('\n')

    #

# =====================

# (12) Creating Overload report (similar to PSS(R)E ACCC Spreadsheet Overload Report) in
    #      PSS(R)E progress window

    rating = rating.strip().lower()
    try:
        rate = smryobj.rating.rating
    except:
        rate = smryobj.rating.a

    psspy.progress("\n OVERLOAD Report\n")
    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue         # contingency solution not found, move to next
        if not solnobj.cnvflag: continue   # contingency solution not converged, move to next
        psspy.progress(" Monitored Element Flows above %g%% for contingency '%12s':\n" % (flowlimit,lbl))
        psspy.progress("<

# =====================

> <RATING> <MVAFLOW> \
<AMPFLOW> <PCTFLOW>\n")
        for i in range(len(solnobj.mvaflow)):
            elmt    = "%54s" % smryobj.melement[i]
            mvaflow = "%9.2f" % solnobj.mvaflow[i]

            if i < smryobj.acccsize.nmline:
                ampflow = "%9.2f" % solnobj.ampflow[i] # AMP flow exists for nmlines only.
                pctflow = abs(solnobj.ampflow[i])
            else:
                ampflow = 9*' '                 # for interfaces, no AMP flow
                pctflow = abs(solnobj.mvaflow[i])  # for interfaces, MVA rating to be considered

            if rate[i]:
                elmt_rate = "%8.2f" % rate[i]
                pctflow_v = pctflow*100.0/rate[i]
                pctflow   = "%9.2f" % (pctflow*100.0/rate[i])
            else:   # if rating is not provided, don't calculate %flow
                elmt_rate = 8*' '
                pctflow   = 9*' '
                pctflow_v = 0

            if pctflow_v >= flowlimit:
                psspy.progress("%(elmt)s %(elmt_rate)s %(mvaflow)s %(ampflow)s %(pctflow)s \n" %vars())
        psspy.progress('\n')

    #

# =====================

# (13) Creating Voltage Violations report in Text file, if provided

    if rptfile:  sumfile = rptfpath + '_summary' + rptext
    if rptfile:
        vviofpath, vviofext = os.path.splitext(rptfile)
        if not vviofext: vviofext = '.txt'
        vviofile   = vviofpath + '_vvio' + vviofext
        vviofile_h = open(vviofile,'w')
        report     = vviofile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    report("\n Post Contingency VOLTAGE VIOLATIONS Report\n")

    # get base case solution
    solnobj_basecase = accobj.solution(colabel="BASE CASE")

    if solnobj_basecase==None or not solnobj_basecase.cnvflag:
        report("    BASE CASE not converged\n")
    else:
        # remaining contingencies
        for lbl in smryobj.colabel[1:]:   # skipped "BASE CASE"
            solnobj  = accobj.solution(colabel=lbl)
            if solnobj==None: continue          # contingency solution not found, move to next
            if not solnobj.cnvflag: continue    # contingency solution not converged, move to next
            vvio_exists = False
            for r in range(len(solnobj.volts)):
                if solnobj.volts[r] == 0.0: continue # disconnected bus, move to next
                if smryobj.mvrectype[r]=='RANGE':
                    if smryobj.mvrecmin[r] and solnobj.volts[r] < smryobj.mvrecmin[r]:
                        vvio = solnobj.volts[r] - smryobj.mvrecmin[r]
                    elif smryobj.mvrecmax[r] and solnobj.volts[r] > smryobj.mvrecmax[r]:
                        vvio = solnobj.volts[r] - smryobj.mvrecmax[r]
                    else:
                        vvio = 0
                else: # DEVIATION
                    delta = solnobj.volts[r] - solnobj_basecase.volts[r]
                    if delta < 0:
                        if smryobj.mvrecmin[r] and abs(delta) > smryobj.mvrecmin[r]:
                            vvio =  delta + smryobj.mvrecmin[r]
                        else:
                            vvio = 0
                    else:
                        if smryobj.mvrecmax[r] and delta > smryobj.mvrecmax[r]:
                            vvio = delta - smryobj.mvrecmax[r]
                        else:
                            vvio = 0
                if vvio:
                    if not vvio_exists:
                        report(" Voltage Violations for contingency '%12s':\n" % (lbl))
                        report("<-----MONITORED BUS-----> <--MONITOR LABEL---> <--TYPE-> <-VMIN-> <-VMAX-> <-VINIT-> \
<-VOLT--> <-VVIO-->\n")
                        vvio_exists = True
                    mvbuslabel     = smryobj.mvbuslabel[r]
                    mvreclabel     = smryobj.mvreclabel[r]
                    mvrectype      = smryobj.mvrectype[r]
                    if smryobj.mvrecmin[r]:
                        mvrecmin   = "%8.5f" % smryobj.mvrecmin[r]
                    else:
                        mvrecmin   = '   --   '
                    if smryobj.mvrecmax[r]:
                        mvrecmax   = "%8.5f" % smryobj.mvrecmax[r]
                    else:
                        mvrecmax   = '   --   '
                    mvrecvolts_init= solnobj_basecase.volts[r]
                    mvrecvolts     = solnobj.volts[r]
                    report("%(mvbuslabel)25s %(mvreclabel)20s %(mvrectype)9s %(mvrecmin)s \
%(mvrecmax)s %(mvrecvolts_init)9.5f %(mvrecvolts)9.5f %(vvio)9.5f \n" %  vars())

            if vvio_exists: report('\n')

    if rptfile:
        vviofile_h.close()
        print('\n Voltage Violations Report saved to file %s' % vviofile)
    else:
        print('\n Voltage Violations Report created in Report window.')

    #

# =====================

# (14) Creating Post-Contingency Solution Load Shedding report in progress

    report = psspy.progress
    load_curtailment_exists = False
    report('\n Post-Contingency LOAD CURTAILMENTS Report\n')
    stype = stype_cnt
    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.lshedbus): continue  # no load shedding, move to next
        report("\n Load Curtailments for contingency '%12s':\n" % (lbl))
        if not load_curtailment_exists:
            if stype=='contingency' or stype=='tripping':
                report("<

# =====================

> <INITLD(MW)>  <LDSHED(MW)> <CONTINGENCY>\n")
            load_curtailment_exists = True

        for c in range(len(solnobj.lshedbus)):
            if stype=='contingency' or stype=='tripping':
                report("%25s %12.2f %-12s\n" % (solnobj.lshedbus[c],solnobj.loadshed[c],lbl))
            else:
                report("%25s %12.2f %12.2f %-12s\n" % (solnobj.lshedbus[c],solnobj.loadshed[0][c],
                                                       solnobj.loadshed[1][c],lbl))
    if not load_curtailment_exists:
        report('    None\n')

    #

# =====================

# (15) Creating Corrective Action Solution Generation Dispatch report in progress

    accobj.solution_options(stype=stype_cact)

    report = psspy.progress
    gen_disp_exists = False
    report('\n Corrective Action GENERATION DISPATCH  Report\n')

    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.gdispbus): continue  # no generation dispatch, move to next
        if not gen_disp_exists:
            report("<

# =====================

> <INITGEN(MW)>  <GENDISP(MW)> <CONTINGENCY>\n")
            gen_disp_exists = True
        for c in range(len(solnobj.gdispbus)):
            report("%25s %9.2f %s %9.2f %s %-12s\n" % (solnobj.gdispbus[c],solnobj.gendisp[0][c],4*' ',
                                                      solnobj.gendisp[1][c],3*' ',lbl))

    if not gen_disp_exists:
        report('    None\n')

    #

# =====================

# (16) Creating Corrective Action Solution Phase Shifter Angle report in progress

    accobj.solution_options(stype=stype_cact)

    report = psspy.progress
    phsftr_exists = False
    report('\n Corrective Action PHASE SHIFTER ANGLE Report\n')

    for lbl in smryobj.colabel:
        solnobj  = accobj.solution(colabel=lbl)
        if solnobj==None: continue              # contingency solution not found, move to next
        if not solnobj.cnvflag: continue        # contingency solution not converged, move to next
        if not len(solnobj.phsftr): continue    # no generation dispatch, move to next
        if not phsftr_exists:
            report("<-------FROM BUS

# =====================

ID> <INITANG(deg)> <NEWANG(deg)> \
<CONTINGENCY>\n")
            phsftr_exists = True
        for c in range(len(solnobj.phsftr)):
            report("%54s %9.2f %s %9.2f %s %-12s\n" % (solnobj.phsftr[c],solnobj.phsftrang[0][c],5*' ',
                                                       solnobj.phsftrang[1][c],3*' ',lbl))
    if not phsftr_exists:
        report('    None\n')

#

# =====================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

#

# =====================

'''There are three different ways to calculate faults using ASCC.
1) Using activity ASCC (psspy.ascc_3)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.ascc.ascc_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run ASCC fault calculations using either of these methods.

# =====================

How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psse35

B) This file contain following functions that uses savnw.sav file run ASCC calculations.
    run_ascc_3_savnw(..)
    run_ascc_currents_savnw_txtrpt(..)
    run_ascc_currents_savnw_xls(..)
    run_fault_summary_ascc_savnw(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
#

# =====================

#
"""
Use any of these keywords to run psspy.ascc or arrbox.ascc.ascc_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default      Description
                       # STATUS array
fltlg     = 0          # 1  0=>omit, 1=>include
linout    = 0          # 2  0=>omit, 1=>include
linend    = 0          # 3  0=>omit, 1=>include
voltop    = 0          # 4  0=>from PF, 1=>at specified for all buses, 2=>at specified faulted bus
genxop    = 0          # 5  0=>X'' 1=>X', 2=>Xs
rptop     = -1         # 6  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl    = 0          # 7  number of contribution levels
tpunty    = 0          # 8  0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged, 3=>N unchanged and phi=0
dcload    = 1          # 9  0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec    = 1          # 10 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
flt3ph    = 0          # 11 0=>omit, 1=>include
fltllg    = 0          # 12 0=>omit, 1=>include
fltll     = 0          # 13 0=>omit, 1=>include
lnchrg    = 0          # 14 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop    = 0          # 15 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
loadop    = 0          # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
machpq    = 0          # 17 0=>from PF, 1=>0.0 (generator/motor PQ output)
                       # VALUES array
volts     = 1.0        # 1  specified bus voltage, used when voltop=1 or 2
                       # File args
relfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""
#

# =====================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

#

# =====================

def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    #

# =====================

def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    #

# =====================

def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('ASCC', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    #

# =====================

def report_ascc_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E ASCC SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        #

# =====================

def excel_ascc_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using ASCC"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

#

# =====================

def run_ascc_3_savnw(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]
    rptfile = ''

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_3_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    asccobj.run_ascc_api(sid, allbus, **kwds)

    reset_prg_rpt()

#

# =====================

def run_ascc_currents_savnw_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_currents_{}.txt".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)
    asccobj.report_ascc_currents(rlst, rptfile)

#

# =====================

def run_ascc_currents_savnw_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_savnw_ascc_currents_{}".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    rlst = asccobj.run_ascc_currents(sid, allbus, **kwds)
    asccobj.excel_ascc_currents(rlst, xlsfile)

#

# =====================

def run_fault_summary_ascc_savnw(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile = 'savnw.sav'
    sid, allbus = 3, 0
    buses = [153, 154]

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_savnw_ascc_fault_summary_{}.txt".format(nam_unt[unt])

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)      # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)  # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)      # 0= disable, printing of of RESQ/TRSQ/solution warnings

    asccobj = ASCC_DEMO()
    fltobj = asccobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

#

# =====================

def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_ascc_3_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_ascc_currents_savnw_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1)
    run_ascc_currents_savnw_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=1, fltll=1)
    run_fault_summary_ascc_savnw(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

#

# =====================

'''
This is an example file showing how to use "ascc_currents" function from pssarrays module.

ASCC_CURRENTS function returns ASCC short circuit currents for each faulted bus and
each type of fault applied. They are:
    ia1   = Positive Sequence Current
    ia2   = Negative Sequence Current
    ia0   = Zero Sequence Current
    ia    = Phase A current
    ib    = Phase B current
    ic    = Phase C current

The APIs used in this program are part of python "pssarrays" module.

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call function
    run_ascc_report()

    You may want to change inputs specified in this function.
    run_ascc_report(savfile, fltbuses, rptfile)
    Defaults:
        savfile  = 'savnw.sav'
        fltbuses = [151,154]
        rptfile  = 'ascc_report_savnw.txt'
                   When this script is called from PSSE's Example Folder,
                   report is created in subfolder 'Output_Pyscript'
'''

#

# =====================

def encode_complex_number_xbyr(cnum):
    r=cnum.real
    x=cnum.imag
    csign='+j'
    if x<0:
        csign='-j'
        x=abs(x)

    if r==0:
        rstr=''
        xbyr=''
    else:
        rstr="%9.6f" % r
        xbyr="%9.6f" % (x/r)

    if x==0:
        xstr=''
        csign=''
    else:
        xstr="%9.6f" % x

    cstr="%(rstr)s%(csign)s%(xstr)s, %(xbyr)s" % vars()

    return cstr

#

# =====================

def create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,
                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,
                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):

    import psspy, arrbox.ascc

    # open case
    if savfile: psspy.case(savfile)

    # Save pre-fault voltages
    sid  = -1
    flag = 2
    ierr, (buslst,)           = psspy.abusint(sid,  flag, ['NUMBER'])
    ierr, (busvltlst_preflt,) = psspy.abuscplx(sid, flag, ['VOLTAGE'])
    ierr, (busvltlst_base,)   = psspy.abusreal(sid, flag, ['BASE'])
    busdata_dict = {}
    for n, vpf, vnm in zip(buslst, busvltlst_preflt, busvltlst_base):
        busdata_dict[n] = {'prefltv': vpf, 'basekv': vnm}

    # set sc units and format
    psspy.short_circuit_units(1)         # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(0)   # 0=rectangular, 1=polar

    sid = 3
    if fltbuses:
        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])
        busall = 0
    else:
        busall = 1

    # call pssarrays routine
    rlst = arrbox.ascc.ascc_currents(sid, busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,
           fltll=fltll, linout=linout, linend=linend, voltop=voltop, genxop=genxop, tpunty=tpunty,
           dcload=dcload, zcorec= zcorec, lnchrg=lnchrg, shntop=shntop, loadop=loadop, machpq=machpq,
           volts=volts, relfile=relfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)

    if rlst.ierr!=0:
        raise Exception("arrbox.ascc.ascc_currents error= %d\n" % rlst.ierr)

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)
        rptfile_h = open(rptfile,'w')
        report    = rptfile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    nfbus=len(rlst.fltbus)

    ttlstr="PSS(R)E ASCC SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
    ln1str,ln2str=psspy.titldt()
    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
    report(ttlstr.center(maxlen))
    report("\n")
    report(ln1str.center(maxlen))
    report("\n")
    report(ln2str.center(maxlen))
    report("\n\n")

    sbase  = psspy.sysmva()

    scunit = rlst.scunit
    scfmt  = rlst.scfmt

    if scunit == 'pu':
        units = 'PU'
    else:
        units = 'AMP'
    unitstr   = units.center(10)
    clnhdr    = "   BUS     " + 6*unitstr + "\n"

    for i in range(nfbus):
        report("           <-SCMVA-> <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->\n")
        report(clnhdr)
        fbus   = rlst.fltbus[i]
        basekv = busdata_dict[fbus]['basekv']
        baseamp = (1000.0 * sbase) / (math.sqrt(3.0) * basekv)

        if flt3ph:
            ttxt   = "%6d" % fbus
            spc    = '3PH'

            ia1    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia2)
            ia0    = get_cplx_mag(scfmt,rlst.flt3ph[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.flt3ph[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.flt3ph[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.flt3ph[i].ic)

            scmva  = math.sqrt(3.0) * basekv * rlst.flt3ph[i].ia1 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltlg:
            if flt3ph:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = ' LG'
            ia1    = get_cplx_mag(scfmt,rlst.fltlg[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltlg[i].ia2)
            ia0    = get_cplx_mag(scfmt,3*rlst.fltlg[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltlg[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltlg[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltlg[i].ic)

            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltlg[i].ia0 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltllg:
            if flt3ph or fltlg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = 'LLG'
            ia1    = get_cplx_mag(scfmt,rlst.fltllg[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltllg[i].ia2)
            ia0    = get_cplx_mag(scfmt,3*rlst.fltllg[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltllg[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltllg[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltllg[i].ic)

            scmva  = math.sqrt(3.0) * basekv * 3 * rlst.fltllg[i].ia0 / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        if fltll:
            if flt3ph or fltlg or fltllg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc     = ' LL'
            ia1    = get_cplx_mag(scfmt,rlst.fltll[i].ia1)
            ia2    = get_cplx_mag(scfmt,rlst.fltll[i].ia2)
            ia0    = get_cplx_mag(scfmt,rlst.fltll[i].ia0)
            ia     = get_cplx_mag(scfmt,rlst.fltll[i].ia)
            ib     = get_cplx_mag(scfmt,rlst.fltll[i].ib)
            ic     = get_cplx_mag(scfmt,rlst.fltll[i].ic)

            scmva  = math.sqrt(3.0) * basekv * rlst.fltll[i].ib / 1000.0
            if scunit == 'pu': scmva = scmva*baseamp
            scmva  = get_cplx_mag(scfmt,scmva)

            tmptxt = "%(ttxt)s %(spc)s %(scmva)9.2f %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f \n" % vars()
            report(tmptxt)

        report("\nTHEVENIN IMPEDANCE (pu), X/R\n")
        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)
        z1str ="Z1: " + z1str
        if fltlg or fltllg or fltll:
            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)
            z2str ="Z2: " + z2str
            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)
            z0str ="Z0: " + z0str
            tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
        else:
            tmptxt="%(z1str)s\n" % vars()
        report(tmptxt)

        if scunit != 'pu':
            report("\nTHEVENIN IMPEDANCE (ohms), X/R\n")
            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)
                z2str ="Z2: " + z2str
                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
            else:
                tmptxt="%(z1str)s\n" % vars()
            report(tmptxt)

        tmptxt=110*'-'
        report(tmptxt)
        report("\n")

    # Maximum Fault Currents
    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
    unitstr   = units.center(11)
    unitstr = ''
    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
        t = each+'('+units+')'
        t = ' ' + t.center(9) + ' '
        unitstr += t

    clnhdr    = "   BUS  " + unitstr + "  Description\n"
    report("\nBREAKER DUTY CURRENTS\n")
    report(clnhdr)
    for i in range(nfbus):
        fbus   = rlst.fltbus[i]
        ia1    = get_cplx_mag(scfmt,rlst.maxflt[i].ia1)
        ia2    = get_cplx_mag(scfmt,rlst.maxflt[i].ia2)
        ia0    = get_cplx_mag(scfmt,rlst.maxflt[i].ia0)
        ia     = get_cplx_mag(scfmt,rlst.maxflt[i].ia)
        ib     = get_cplx_mag(scfmt,rlst.maxflt[i].ib)
        ic     = get_cplx_mag(scfmt,rlst.maxflt[i].ic)
        dsc    = rlst.maxfltdsc[i]
        tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\n" % vars()
        report(tmptxt)

    #

# =====================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

#

# =====================

def run_ascc_report(savfile="savnw.sav", fltbuses=[151,154], rptfile='ascc_report_savnw.txt'):

    import psspy

    psspy.psseinit()

    # Inputs, change as required

    flt3ph  = 1       #
    fltlg   = 1       #
    fltllg  = 1       #
    fltll   = 1       #
    linout  = 0       #
    linend  = 0       #
    voltop  = 0       #
    genxop  = 0       #
    tpunty  = 0       #
    dcload  = 1       #
    zcorec  = 1       #
    lnchrg  = 0       #
    shntop  = 0       #
    loadop  = 0       #
    machpq  = 0       #

    volts   = 1.0     #

    rptfile = check_psse_example_folder(rptfile)

    relfile = ""
    fcdfile = ""
    scfile  = ""

    rprtyp  = -1      # no report
    rprlvl  = 0       # number of contribution levels

    create_report(fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,voltop,genxop,
                  tpunty,dcload,zcorec,lnchrg,shntop,loadop,machpq,volts,
                  savfile,relfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)

#

# =====================

def OpenFile():
    """Opens the BPA file specified in prompt."""

    psspy.prompt("Enter the BPA file path, followed by its name:\n")
    ierr, fnamestr = psspy.userin()		#User types in the path name

    if ierr != 0: return

    fpath, fext = os.path.splitext(fnamestr)
    if not fext: fnamestr = fpath + '.dat'	#To add the extension if left blank

    if os.path.isfile(fnamestr) == False:
        psspy.alert("The specified path or file name is invalid\n")
        return

    bpa_file = open(fnamestr, 'r')		#Opens the file in read mode

    return bpa_file

#

# =====================

def GetMVA(bpa_file, bpa_str):
    """Gets the base MVA in the BPA file."""

    pos = string.find(bpa_str, "MVA_BASE")

    if pos != -1:
        bpa_file.seek(pos)
        bpa_file.readline()			#Just to position on to the next line
        mva_base_str = bpa_file.readline()
        mva_base_str = mva_base_str.replace(' ', '')	#To delete any spaces
        mva_base_str = mva_base_str.strip()	#To remove trailing and leading whitespaces
        mva_base_str = mva_base_str[10:]	#To remove the "/MVA_BASE=" part
        basemva = float(mva_base_str[:-1])

    else:
        basemva = 100.0				#The default base MVA in BPA is 100 MVA

    return basemva

#

# =====================

def GetTitles(bpa_file, bpa_str):
    """Gets the titles from the BPA file."""

    pos = string.find(bpa_str, "CASEID")	#To find title1

    if pos != -1:
        bpa_file.seek(pos)
        title_data = bpa_file.readline()
        pos1 = string.find(title_data, '=')
        pos2 = string.find(title_data, ',')
        case_id = title_data[pos1 + 1 : pos2]
        case_id = case_id.strip()		#To remove trailing and leading whitespaces

    else:
        case_id = ""				#Title1 is blank by default

    pos = string.find(bpa_str, "PROJECT")	#To find title2

    if pos != -1:
        bpa_file.seek(pos)
        title_data = bpa_file.readline()
        pos1 = string.find(title_data, '=')
        pos2 = string.find(title_data, ',')	
        if pos2 == -1:				#If there are no other parameters, the line finishes with ')'
            pos2 = string.find(title_data, ')')

        project_id = title_data[pos1 + 1 : pos2]
        project_id = project_id.strip()		#To remove trailing and leading whitespaces

    else:
        project_id = ""				#Title2 is blank by default

    return case_id, project_id

#

# =====================

def GetPCard(bpa_str_ar):
    """Gets the scale data from the BPA file."""

    scale_str = []

    for line in bpa_str_ar:			#Loop over every line of the BPA file
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#To continue if it is a blank line

        if line[0] == 'P' and line[2] == ' ':	#If the line is a P card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records
            scale_str.append(line)

    return scale_str				#Returns an array of P cards

#

# =====================

def GetScaleData(scale_str, owner_name, zone_name, type_code):
    """Gets the scale factors for each load and generator."""

    scale_ar = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]		#Default factors are unit factors

    for line in scale_str:					#For each P card
        if line[1] == 'O' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])	#Generation Q factor is generation P factor

        elif line[1] == 'Z' and line[3:5].strip() == zone_name or line[1] == 'N' and line[3:5].strip() == zone_name and type_code == 'N':
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
                if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
                elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
                if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
                elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])	#Generation Q factor is generation P factor

        elif line[1] == 'A':
            if isfloat(line[9:14]): scale_ar[0] = scale_ar[0] * float(line[9:14])		#Load P factor
            if isfloat(line[15:20]): scale_ar[1] = scale_ar[1] * float(line[15:20])		#Load Q factor
            elif isfloat(line[9:14]): scale_ar[1] = scale_ar[1] * float(line[9:14])		#Load Q factor is load P factor

            if isfloat(line[21:26]): scale_ar[6] = scale_ar[6] * float(line[21:26])		#Generation P factor
            if isfloat(line[27:32]): scale_ar[7] = scale_ar[7] * float(line[27:32])		#Generation Q factor
            elif isfloat(line[21:26]): scale_ar[7] = scale_ar[7] * float(line[21:26])		#Generation Q factor is generation P factor

        elif line[1] == 'B' and type_code == 'X' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])		#Constant current load P factor
                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])		#Constant current load Q factor
                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])		#Constant current load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'B' and type_code == 'Y' and line[3:6].strip() == owner_name:
            if zone_name == line[34:36].strip() or zone_name == line[37:39].strip() or zone_name == line[40:42].strip() or zone_name == line[43:45].strip()\
            or zone_name == line[46:48].strip() or zone_name == line[49:51].strip() or zone_name == line[52:54].strip() or zone_name == line[55:57].strip()\
            or zone_name == line[58:60].strip() or zone_name == line[61:63].strip() or zone_name == line[64:66].strip() or zone_name == line[67:69].strip()\
            or zone_name == line[70:72].strip() or zone_name == line[73:75].strip() or zone_name == line[76:78].strip() or line[34:80].strip() == "":

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'C' and type_code == 'X' and line[3:5].strip() == zone_name:
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[9:14]): scale_ar[2] = scale_ar[2] * float(line[9:14])		#Constant current load P factor
                if isfloat(line[15:20]): scale_ar[3] = scale_ar[3] * float(line[15:20])		#Constant current load Q factor
                elif isfloat(line[9:14]): scale_ar[3] = scale_ar[3] * float(line[9:14])		#Constant current load Q factor is load P factor

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

        elif line[1] == 'C' and type_code == 'Y' and line[3:5].strip() == zone_name:
            if owner_name == line[34:37].strip() or owner_name == line[38:41].strip() or owner_name == line[42:45].strip() or owner_name == line[46:49].strip()\
            or owner_name == line[50:53].strip() or owner_name == line[54:57].strip() or owner_name == line[58:61].strip() or owner_name == line[62:65].strip()\
            or owner_name == line[66:69].strip() or owner_name == line[70:73].strip() or owner_name == line[74:77].strip() or line[34:80].strip() == "":

                if isfloat(line[21:26]): scale_ar[4] = scale_ar[4] * float(line[21:26])		#Constant admittance load P factor
                if isfloat(line[27:32]): scale_ar[5] = scale_ar[5] * float(line[27:32])		#Constant admittance load Q factor
                elif isfloat(line[21:26]): scale_ar[5] = scale_ar[5] * float(line[21:26])	#Constant admittance load Q factor is load P factor

    return scale_ar		#Returns the scale factors
 
#

# =====================

def CheckICard(bpa_str_ar, area_name):
    """To check if there is an I card with the specified area name."""

    for line in bpa_str_ar:			#Loop over every line of the BPA file
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#To continue if it is a blank line
        
        if line[0] == 'I' and line[2] == ' ':	#If it is an I card
            line = line + ' '*(34-len(line))	#To pad each line with spaces up to 34 records
            if line[3:13].strip() == area_name or line[14:24].strip() == area_name: return True		#Returns true if the area is found in an I card

    return False			#Returns false if the area has not been found in I cards

#

# =====================

def GetXCard(bpa_str_ar, bus_name, Vmax, Vmin, remote_bus_name, RMPCT, remote_bus_nbr, bus_nbr):
    """Gets the switched shunts attached to the specified bus."""

    for line in bpa_str_ar:		#This loop is used to get the corresponding switched shunts
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#To continue if it is a blank line

# =====================

intgar = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
        realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]

        if isfloat(line[28:32]): remote_kv = float(line[28:32])	#The remote bus base voltage
        else: remote_kv = 0.0

        if line[0] == 'X' and bus_name == (line[6:14].strip() + str(float(line[14:18]))) and remote_bus_name == (line[20:28].strip() + str(remote_kv)):
            if line[2] == ' ':					#The modification code for a new record
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records

                if isint(line[32]): intgar[0] = int(line[32])	#Number of steps for block 1
                if isint(line[38]): intgar[1] = int(line[38])	#Number of steps for block 2
                if isint(line[44]): intgar[2] = int(line[44])	#Number of steps for block 3
                if isint(line[50]): intgar[3] = int(line[50])	#Number of steps for block 4
                if isint(line[56]): intgar[4] = int(line[56])	#Number of steps for block 5
                if isint(line[62]): intgar[5] = int(line[62])	#Number of steps for block 6
                if isint(line[68]): intgar[6] = int(line[68])	#Number of steps for block 7
                if isint(line[74]): intgar[7] = int(line[74])	#Number of steps for block 8

                if isfloat(line[33:38]): realar[0] = float(line[33:38])	#Admittance increment for block 1
                if isfloat(line[39:44]): realar[1] = float(line[39:44])	#Admittance increment for block 2
                if isfloat(line[45:50]): realar[2] = float(line[45:50])	#Admittance increment for block 3
                if isfloat(line[51:56]): realar[3] = float(line[51:56])	#Admittance increment for block 4
                if isfloat(line[57:62]): realar[4] = float(line[57:62])	#Admittance increment for block 5
                if isfloat(line[63:68]): realar[5] = float(line[63:68])	#Admittance increment for block 6
                if isfloat(line[69:74]): realar[6] = float(line[69:74])	#Admittance increment for block 7
                if isfloat(line[75:80]): realar[7] = float(line[75:80])	#Admittance increment for block 8

                if isfloat(Vmax): realar[8] = float(Vmax)	#Upper voltage limit
                if isfloat(Vmin): realar[9] = float(Vmin)	#Lower voltage limit
                if isfloat(RMPCT):
                    realar[11] = float(RMPCT)	#The RMPCT
                    if realar[11] > 1.0: realar[11] = realar[11] / 100.0	#To bring back the RMPCT from percent to unit

                intgar[9] = remote_bus_nbr

                count_nbr = -1
                for nbr in realar[0:8]:		#This loop is used to get the reactors first in the list for PSS/E to work
                    count_nbr = count_nbr + 1
                    if nbr < 0.0 and count_nbr != 0:	#If the admittance is negative (reactor) and it is not already first in the list
                        realar.insert(0, nbr)
                        realar.pop(count_nbr + 1)
                        intgar.insert(0, intgar[count_nbr])
                        intgar.pop(count_nbr + 1)

                ierr = psspy.switched_shunt_data(bus_nbr, intgar, realar, '')	#The API used to load switched shunts in PSS/E

#

# =====================

def GetACard(bpa_str_ar, zone_str, bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr):
    "Gets the area data from the BPA file."""

    if zone_str != "":			#Only look for area number if the zone is not blank
        for line in bpa_str_ar:		#This loop is used to get the corresponding area data
            line = line.lstrip()
            line = line.rstrip('\n')
            if line == "": continue	#To continue if the line is blank
            
            if line[0] == 'A' and line[1] != 'O':
                if line[2] == ' ':			#The modification code for a new record
                    line = line + ' '*(95-len(line))	#To pad each line with spaces up to 95 records
                    if zone_str == line[35:37].strip() or zone_str == line[38:40].strip() or zone_str == line[41:43].strip() or zone_str == line[44:46].strip()\
                    or zone_str == line[47:49].strip() or zone_str == line[50:52].strip() or zone_str == line[53:55].strip() or zone_str == line[56:58].strip()\
                    or zone_str == line[59:61].strip() or zone_str == line[62:64].strip() or zone_str == line[65:67].strip() or zone_str == line[68:70].strip()\
                    or zone_str == line[71:73].strip() or zone_str == line[74:76].strip() or zone_str == line[77:79].strip() or zone_str == line[80:82].strip()\
                    or zone_str == line[83:85].strip() or zone_str == line[86:88].strip() or zone_str == line[89:91].strip() or zone_str == line[92:94].strip():

                        if line[13:21].strip() + str(float(line[21:25])) not in bus_str:	#If the bus is not in the list, add it
                            bus_nbr = bus_nbr + 1
                            bus_str[line[13:21].strip() + str(float(line[21:25]))] = bus_nbr	#A new dictionnary entry
                            bus_flag = True							#True if the bus number has been incremented
                        else:
                            bus_nbr = bus_str[line[13:21].strip() + str(float(line[21:25]))]	#Get the bus number
                            bus_flag = False							#False if the bus number hasn't been incremented

                        if isfloat(line[26:34]):					#If the value of interchange is specified
                            if CheckICard(bpa_str_ar, line[3:13].strip()):		#If there is an I card, do not include interchange given
                                if (line[3:13].strip(), 0.0) not in area_str:	#If the area is not in the list, add it
                                    area_nbr = area_nbr + 1
                                    area_str[(line[3:13].strip(), 0.0)] = area_nbr
                                    area_slack_nbr.append(bus_nbr)			#An array with slack bus numbers for each area
                                else:
                                    area_nbr = area_str[(line[3:13].strip(), 0.0)]	#Get the area number
                            else:							#If there is no I card, include the interchange value given
                                if (line[3:13].strip(),float(line[26:34])) not in area_str:	#If the area is not in the list, add it
                                    area_nbr = area_nbr + 1
                                    area_str[(line[3:13].strip(), float(line[26:34]))] = area_nbr
                                    area_slack_nbr.append(bus_nbr)			#Add the corresponding slack bus number
                                else:
                                    area_nbr = area_str[(line[3:13].strip(),float(line[26:34]))]	#Get the area number

                        else:				#If there is no value of interchange specified
                            if (line[3:13].strip(), 0.0) not in area_str:		#If the area is not in the list, add it
                                area_nbr = area_nbr + 1
                                area_str[(line[3:13].strip(), 0.0)] = area_nbr
                                area_slack_nbr.append(bus_nbr)				#Add the corresponding slack bus number
                            else:
                                area_nbr = area_str[(line[3:13].strip(), 0.0)]		#Get the area number

                        area_flag = True		#True if the zone name has a corresponding area card

                        return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr

    area_flag = False		#The zone name has no corresponding area card
    bus_flag = False		#The bus number hasn't changed

    return area_flag, bus_flag, area_nbr, bus_nbr, bus_str, area_str, area_slack_nbr

#

# =====================

def GetBCard(bpa_str_ar, base_mva, scale_str):
    """Gets the AC bus data from the BPA file."""

    bus_data_str = []			#The array to contain all AC bus lines
    bus_str = {}			#A dictionnary with bus names and the corresponding bus numbers
    bus_owner_nbr = [0]			#An array with the owner number for each bus
    bus_zone_str = ["0"]		#An array with the zone of each bus
    load_id_ar = [0]			#An array used to determine the load CKT for each bus
    machine_id_ar = [0]			#An array used to determine the machine CKT for each bus
    owner_str = {'DEFAULT': 1}		#The default owner
    zone_str = {'DEFAULT': 1}		#The default zone
    area_str = {("DEFAULT", 0.0): 1}	#The default area is used for zones without A cards or for data without zones
    area_slack_nbr = [0]		#An array with the slack bus of each area
    bus_nbr = 0				#The bus number
    owner_nbr = 1			#The owner number
    zone_nbr = 1			#The zone number
    area_nbr = 1			#The area number

    for line in bpa_str_ar:		#This loop is used to fill the bus data array with each line of bus data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'B':		#If it is a bus
            if line[1] != 'D' and line[1] != 'M':	#But not a DC bus
                bus_data_str.append(line)		#Add the line to the array

    for line in bus_data_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

bus_intgar = [1, 0, 1, 0]
        load_intgar = [1, 1, 1, 1]
        machine_intgar = [0, 0, 0, 0, 0]
        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]
        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        plant_realar = [1.0, 1.0]
        remote_bus_nbr = 0
        remote_kv = 0.0

        if line[2] == ' ':			#The modification code for a new record
            if line[1] == ' ' or line[1] == 'T' or line[1] == 'C' or line[1] == 'V' or line[1] == 'F' or line[1] == 'J' or line [1] == 'X':
                bus_intgar[0] = 1		#The bus type code for a PQ bus
            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G' or line[1] == 'K' or line[1] == 'L':
                bus_intgar[0] = 2		#The bus type code for a PV bus
            elif line[1] == 'S':
                bus_intgar[0] = 3		#The bus type code for a swing bus

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr
                bus_intgar[3] = owner_nbr			#The owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                bus_intgar[3] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                bus_intgar[3] = 1				#The default owner number

            bus_namear = line[6:14].strip()		#The bus name
            bus_realar[2] = float(line[14:18])		#The bus base voltage in kV

            if bus_namear + str(bus_realar[2]) not in bus_str:	#If the bus is not in the list, add it (the bus could be in the list if assigned as a remote for another bus)
                bus_nbr = bus_nbr + 1
                bus_str[bus_namear + str(bus_realar[2])] = bus_nbr	#A new dictionnary entry
            else:
                bus_nbr = bus_str[bus_namear + str(bus_realar[2])]	#Get the bus number

            bus_owner_nbr.insert(bus_nbr + 1, bus_intgar[3])		#Insert the corresponding owner of the bus

            load_id_ar.append(0)	#To initialize the load CKT number
            machine_id_ar.append(0)	#To initialize the machine CKT number

            if line[18:20] != "  ":	#If the zone is not blank
                if line[18:20].strip() not in zone_str:	#If the zone is not in the list, add it
                    zone_nbr = zone_nbr + 1
                    zone_str[line[18:20].strip()] = zone_nbr
                    bus_intgar[2] = zone_nbr		#The zone number
                else:
                    bus_intgar[2] =  zone_str[line[18:20].strip()]	#Get the zone number

            bus_zone_str.insert(bus_nbr + 1, line[18:20].strip())	#Insert the corresponding zone of the bus

            if isfloat(line[20:25]): load_realar[0] = float(line[20:25])	#Load P in MW
            if isfloat(line[25:30]): load_realar[1] = float(line[25:30])	#Load Q in Mvar

            if isfloat(line[30:34]): bus_realar[0] = float(line[30:34])		#Fixed bus shunt active load
            if isfloat(line[34:38]): bus_realar[1] = float(line[34:38])		#Fixed bus shunt reactive load

            if isfloat(line[38:42]): machine_realar[4] = float(line[38:42])	#Maximum active power generation
            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])	#Actual active power generation

            if line[1] != ' ' and line[1] != 'C' and line[1] != 'T' and line[1] != 'V':	#If not a PQ bus
                if isfloat(line[47:52]): machine_realar[2] = float(line[47:52])	#Machine reactive upper limit
                if isfloat(line[52:57]): machine_realar[3] = float(line[52:57])	#Machine reactive lower limit

            if line[1] == ' ' or line[1] == 'C' or line[1] == 'T' or line[1] == 'V':	#If it is a PQ bus
                if isfloat(line[47:52]): 
                    machine_realar[2] = float(line[47:52])	#Machine reactive upper limit
                    machine_realar[3] = machine_realar[2]	#Machine reactive lower limit
                    machine_realar[1] = machine_realar[2]	#Machine reactive power output

            elif line[1] == 'E' or line[1] == 'Q' or line[1] == 'G':		#If it is a PV bus
                if isfloat(line[57:61]): 
                    plant_realar[0] = float(line[57:61])			#Scheduled voltage
                    bus_realar[3] = float(line[57:61])				#Bus voltage magnitude

            elif line[1] == 'S':						#If it is a swing bus
                if isfloat(line[57:61]):
                    plant_realar[0] = float(line[57:61])			#Scheduled voltage
                    bus_realar[3] = float(line[57:61])				#Bus voltage magnitude
                if isfloat(line[61:65]): bus_realar[4] = float(line[61:65])	#The voltage phase angle

            if line[65:73] != "        ":					#If there is a remote bus
                remote_kv = float(line[73:77])					#The remote bus base voltage
                if line[65:73].strip() + str(remote_kv) not in bus_str:	#If the remote bus name is not in the list, add it
                    remote_bus_nbr = bus_nbr + 1
                    bus_str[line[65:73].strip() + str(remote_kv)] = remote_bus_nbr
                else:
                    remote_bus_nbr = bus_str[line[65:73].strip() + str(remote_kv)]	#Get the remote bus number

            if isfloat(line[77:80]):
                plant_realar[1] = float(line[77:80])	#The RMPCT
                if plant_realar[1] > 1.0: plant_realar[1] = plant_realar[1] / 100.0	#To bring back the RMPCT from percent to unit

            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)

            if bus_flag == True: bus_nbr = swing_bus_nbr	#To change the bus number if it has been incremented

            if area_flag == True:		#To assign the area number to the buses and loads
                bus_intgar[1] = area_nbr
                load_intgar[1] = area_nbr
            else:				#The default area number
                bus_intgar[1] = 1
                load_intgar[1] = 1
            
            ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)	#Loads the bus data in PSS/E

            if line[1] == 'X': GetXCard(bpa_str_ar, bus_namear + str(bus_realar[2]), line[57:61], line[61:65], line[65:73].strip() + str(remote_kv), line[77:80], remote_bus_nbr, bus_nbr)

            scale_ar = GetScaleData(scale_str, line[3:6].strip(), line[18:20].strip(), 'N')	#To get the scale factors

            load_realar[0] = load_realar[0] * scale_ar[0]		#To scale the load P
            load_realar[1] = load_realar[1] * scale_ar[1]		#To scale the load Q
            machine_realar[0] = machine_realar[0] * scale_ar[6]		#To scale the machine P
            machine_realar[1] = machine_realar[1] * scale_ar[7]		#To scale the machine Q

            if load_realar[0] != 0.0 or load_realar[1] != 0.0: 			#If there is a load
                load_intgar[2] = bus_intgar[2]		#The zone number
                load_intgar[3] = bus_intgar[3]		#The owner number
                load_id_ar[bus_nbr] = 1			#The load CKT number is now 1
                ierr = psspy.load_data(bus_nbr, '1', load_intgar, load_realar)	#Loads the load data in PSS/E

            if machine_realar[0] != 0.0:		#If there is a generator
                machine_intgar[0] = 1			#The machine status
                machine_intgar[1] = bus_intgar[3]	#The owner number
                machine_id_ar[bus_nbr] = 1		#The machine CKT number is now 1
                ierr = psspy.plant_data(bus_nbr, remote_bus_nbr, plant_realar)	#First load the plant data
                ierr = psspy.machine_data(bus_nbr, '1', machine_intgar, machine_realar)	#After add the generator data

            if remote_bus_nbr == bus_nbr + 1: bus_nbr = bus_nbr + 1	#To change the actual bus number

    return area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str

#

# =====================

#Only the returned values are useful
    intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
    realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'R' and line[1] != 'Z':	#If it is a R card but not RZ
            if line[2] == ' ' and from_bus == (line[6:14].strip() + str(float(line[14:18]))) and to_bus == (line[19:27].strip() + str(float(line[27:31]))):
                line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

                if line[33:41] != "        ": intgar[9] = bus_str[line[33:41].strip() + str(float(line[41:45]))]	#Controlled bus number
                if isfloat(line[45:50]): realari[17] = float(line[45:50])	#Winding one ratio/angle high limit
                if isfloat(line[50:55]): realari[18] = float(line[50:55])	#Winding one ratio/angle low limit
                if isint(line[55:57]): intgar[6] = int(line[55:57])		#Number of tap positions

                if line[1] == ' ':	#If it is a R card
                    intgar[11] = 1	#Control mode = 1
                elif line[1] == 'V':	#If it is a RV card
                    intgar[11] = 1	#Control mode = 1
 
                elif line[1] == 'Q':	#If it is a RQ card
                    intgar[11] = 2	#Control mode = 2
                elif line[1] == 'N':	#If it is a RN card
                    intgar[11] = 2	#Control mode = 2
                    if isfloat(line[57:62]): realari[19] = float(line[57:62])	#Voltage or flow upper limit
                    else: realari[19] = 0.0					#Default
                    if isfloat(line[62:67]): realari[20] = float(line[62:67])	#Voltage or flow lower limit
                    else: realari[20] = 0.0					#Default

                elif line[1] == 'P':	#If it is a RP card
                    intgar[11] = 3	#Control mode = 3
                elif line[1] == 'M':	#If it is a RM card
                    intgar[11] = 3	#Control mode = 3
                    if isfloat(line[57:62]): realari[19] = float(line[57:62])	#Voltage or flow upper limit
                    else: realari[19] = 0.0					#Default
                    if isfloat(line[62:67]): realari[20] = float(line[62:67])	#Voltage or flow lower limit
                    else: realari[19] = 0.0					#Default

                return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]

    return intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20]

#

# =====================

def GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva):
    """To get the multi-section line data from BPA.

    This function is recursive.
    """

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

# =====================

bus_intgar = [1, 1, 1, owner_nbr]
        bus_realar = [0.0, 0.0, 0.0, 1.0, 0.0]
        line_intgar = [1, 0, 1, 0, 0, 0]
        line_realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        trans_intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
        trans_realari = [0.0, 0.0, base_mva, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

        if line[0] == 'L' and line[1] == ' ' and line[2] == ' ' or line[0] == 'E' and line[1] == ' ' and line[2] == ' ':
            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records
                section_nbr = section_nbr + 1			#To increment the section number
                dummy_nbr = dummy_nbr + 1			#To increment the dummy bus number
                bus_nbr = bus_nbr + 1				#To increment the bus number
                bus_namear = "DUMMY #" + str(dummy_nbr)		#The name of the new dummy bus
                bus_str[bus_namear] = bus_nbr			#Add the bus to the dictionnary
                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)	#Insert the owner number of that bus
                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])	#The bus base voltage
                multi_intgar[section_nbr - 2] = bus_nbr		#The bus number of the dummy bus
                from_bus = bus_nbr				#To remember the value of the from bus before recalling this function

                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)		#Loads the bus data in PSS/E

                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)	#Recursive function

                if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                    owner_nbr = owner_nbr + 1
                    owner_str[line[3:6].strip()] = owner_nbr		#A new dictionnary entry
                    line_intgar[2] = owner_nbr				#The new owner number
                elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                    line_intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
                elif line[3:6] == "   ":
                    line_intgar[2] = 1			#The default owner

                line_intgar[1] = from_bus		#Every section of the line is set as metered from (default)

                if isfloat(line[33:37]) and isfloat(line[14:18]): line_realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0	#The Rate A in MVA

                if line[31] != ' ': ckt = line[31]		#The circuit identifier
                else: ckt = '1'			#If none is mentionned, the default is 1

                if isfloat(line[38:44]): line_realar[0] = float(line[38:44])			#Nominal branch resistance
                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: line_realar[1] = float(line[44:50])	#Nominal branch reactance

                if line[0] == 'L':		#If it is an L card
                    if isfloat(line[50:56]):
                        line_realar[6] = float(line[50:56])/2.0					#Real line shunt at bus IARG end
                        line_realar[8] = line_realar[6]						#Real line shunt at bus JARG end
                    if isfloat(line[56:62]): line_realar[2] = float(line[56:62])*2.0		#Total line charging
                    if isfloat(line[62:66]): line_realar[10] = float(line[62:66])		#Line's length in miles

                else:				#If it is an E card
                    if isfloat(line[50:56]): line_realar[6] = float(line[50:56])		#Real line shunt at bus IARG end
                    if isfloat(line[56:62]): line_realar[7] = float(line[56:62])		#Reactive line shunt at bus IARG end
                    if isfloat(line[62:68]): line_realar[8] = float(line[62:68])		#Real line shunt at bus JARG end
                    if isfloat(line[68:74]): line_realar[9] = float(line[68:74])		#Reactive line shunt at bus JARG end

                #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual
                #if line[77:80] != "   ": line_intgar[0] = 0		#If there is an out of service date, the status is offline

                ierr = psspy.branch_data(from_bus, to_bus, ckt, line_intgar, line_realar)	#The API to load branch data in PSS/E

                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

        if line[0] == 'T' and line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:
            if iarg == bus_str[line[6:14].strip() + str(float(line[14:18]))] and jarg == bus_str[line[19:27].strip() + str(float(line[27:31]))] and line[32] == str(section_nbr) and ckt_nbr == line[31]:
                line = line + ' '*(80-len(line))		#To pad each line with spaces up to 80 records
                section_nbr = section_nbr + 1			#To increment the section number
                dummy_nbr = dummy_nbr + 1			#To increment the dummy bus number
                bus_nbr = bus_nbr + 1				#To increment the bus number
                bus_namear = "DUMMY #" + str(dummy_nbr)		#The name of the dummy bus
                bus_str[bus_namear] = bus_nbr			#A new dictionnary entry
                bus_owner_nbr.insert(bus_nbr + 1, owner_nbr)	#Insert the owner of this bus
                if isfloat(line[14:18]): bus_realar[2] = float(line[14:18])	#The bus base voltage
                multi_intgar[section_nbr - 2] = bus_nbr		#The bus number of the dummy bus
                from_bus = bus_nbr

                ierr = psspy.bus_data(bus_nbr, bus_intgar, bus_realar, bus_namear)	#Loads the bus data in PSS/E

                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, ckt_nbr, base_mva)	#Recursive function

                if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                    owner_nbr = owner_nbr + 1
                    owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                    trans_intgar[2] = owner_nbr			#The new owner number
                elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                    trans_intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
                elif line[3:6] == "   ":
                    trans_intgar[2] = 1			#The default owner

                trans_intgar[1] = from_bus		#Every section of the line is set as metered from (default)

                trans_intgar[8] = from_bus		#The winding one side

                if isfloat(line[14:18]): trans_realari[4] = float(line[14:18])		#Winding one nominal voltage

                if isfloat(line[27:31]): trans_realari[7] = float(line[27:31])		#Winding two nominal voltage

                if isfloat(line[33:37]): trans_realari[8] = float(line[33:37])		#The Rate A in MVA

                if line[31] != ' ': ckt = line[31]	#The circuit identifier
                else: ckt = '1'				#If none is mentionned, the default is 1

                if isfloat(line[38:44]): trans_realari[0] = float(line[38:44])	#Nominal transformer resistance
                if isfloat(line[44:50]) and float(line[44:50]) != 0.0: trans_realari[1] = float(line[44:50])	#Nominal transformer reactance

                if isfloat(line[50:56]): trans_realari[15] = float(line[50:56])		#The magnetizing conductance

                if isfloat(line[56:62]): trans_realari[16] = float(line[56:62])		#The magnetization susceptance

                if line[1] == ' ':
                    if isfloat(line[62:67]): trans_realari[3] = float(line[62:67])		#The winding one ratio/voltage
                    if isfloat(line[67:72]): trans_realari[6] = float(line[67:72])		#The winding one ratio/voltage

                else:		#For the phase shifting transformer
                    if isfloat(line[62:67]): trans_realari[5] = float(line[62:67])		#The winding one phase shift angle
                    trans_realari[3] = trans_realari[4]
                    trans_realari[6] = trans_realari[7]

                #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual
                #if line[77:80] != "   ": trans_intgar[0] = 0		#If there is an out of service date, the status is offline

                trans_intgar[11], trans_intgar[9], trans_realari[17], trans_realari[18], trans_intgar[6], trans_realari[19], trans_realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)

                ierr, realaro  = psspy.two_winding_data(from_bus, to_bus, ckt, trans_intgar, trans_realari, "")	#The API to load transformer data in PSS/E

                return from_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

    return jarg, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar

#

# =====================

def GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, base_mva):
    """Gets the symmetrical and asymmetrical lines from BPA."""

    line_str = []	#An array to contain all AC line data
    dummy_nbr = 0	#The dummy bus number for multi-section lines

    for line in bpa_str_ar:		#This loop is used to fill the branch data array with each line of branch data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'L' and line[1] == ' ' or line[0] == 'E' and line[1] == ' ': line_str.append(line)

    for line in line_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

intgar = [1, 0, 1, 0, 0, 0]
        realar = [0.0, 0.0001, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]

        if line[2] == ' ':			#The modification code for a new record

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                intgar[2] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                intgar[2] = 1					#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]		#From bus
            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]		#To bus

            if line[18] == '1': intgar[1] = iarg	#The metered end is IARG
            elif line[18] == '2': intgar[1] = jarg	#The metered end is JARG
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg		#If both ends have the same owner, IARG is the metered end
                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg			#Else the end that has a different owner from the line is the metered end
                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg

            if isfloat(line[33:37]) and intgar[1] == iarg and isfloat(line[14:18]): realar[3] = sqrt(3)*float(line[33:37])*float(line[14:18])/1000.0	#The Rate A in MVA
            elif isfloat(line[33:37]) and intgar[1] == jarg and isfloat(line[27:31]): realar[3] = sqrt(3)*float(line[33:37])*float(line[27:31])/1000.0	#The Rate A in MVA

            if line[31] != ' ': ckt = line[31]		#The circuit identifier
            else: ckt = '1'				#If none is mentionned, the default is 1

            if isfloat(line[38:44]): realar[0] = float(line[38:44])			#Nominal branch resistance
            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realar[1] = float(line[44:50])	#Nominal branch reactance

            if line[0] == 'L':		#If it is an L card
                if isfloat(line[50:56]):
                    realar[6] = float(line[50:56])/2.0					#Real line shunt at bus IARG end
                    realar[8] = realar[6]						#Real line shunt at bus JARG end
                if isfloat(line[56:62]): realar[2] = float(line[56:62])*2.0		#Total line charging
                if isfloat(line[62:66]): realar[10] = float(line[62:66])		#Line's length in miles

            else:			#If it is an E card
                if isfloat(line[50:56]): realar[6] = float(line[50:56])		#Real line shunt at bus IARG end
                if isfloat(line[56:62]): realar[7] = float(line[56:62])		#Reactive line shunt at bus IARG end
                if isfloat(line[62:68]): realar[8] = float(line[62:68])		#Real line shunt at bus JARG end
                if isfloat(line[68:74]): realar[9] = float(line[68:74])		#Reactive line shunt at bus JARG end

            #It seems the format for the date in the file 2006eh-tmp-1.dat is not the same as in the user manual
            #if line[77:80] != "   ": intgar[0] = 0		#If there is an out of service date, the status is offline

            if line[32] == ' ': ierr = psspy.branch_data(iarg, jarg, ckt, intgar, realar)	#The API to load branch data in PSS/E

            elif line[32] == '1':	#If the branch is the section number 1
                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]
                section_nbr = 2		#To search for a section number 2
                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)

                intgar[1] = iarg	#The metered end is IARG
                ierr = psspy.branch_data(iarg, to_bus, ckt, intgar, realar)	#The API to load branch data in PSS/E
                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, "&" + ckt, multi_intgar)	#The API to load the multi-section line data in PSS/E	

    return owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr

#

# =====================

def GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, base_mva):
    """Gets the two-winding transformer data from BPA."""

    transformer_str = []	#An array to contain all lines with two-winding transformers connecting AC buses

    for line in bpa_str_ar:		#This loop is used to fill the transformer data array with each line of transformer data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank
        if line[0] == 'T' and line[1] == ' ' or line[0] == 'T' and line[1] == 'P': transformer_str.append(line)

    for line in transformer_str:
        line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

intgar = [1, 0, 1, 0, 0, 0, 33, 0, 0, 0, 0, 0, 2, 1, 1]
        realari = [0.0, 0.0, basemva, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.1, 0.9, 1.1, 0.9, 0.0, 0.0]

        if line[2] == ' ' and line[6:14].strip() + str(float(line[14:18])) in bus_str and line[19:27].strip() + str(float(line[27:31])) in bus_str:

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:		#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                intgar[2] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                intgar[2] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                intgar[2] = 1					#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]		#From bus
            jarg = bus_str[line[19:27].strip() + str(float(line[27:31]))]		#To bus

            intgar[8] = iarg						#The winding one side

            if isfloat(line[14:18]): realari[4] = float(line[14:18])	#Winding one nominal voltage

            if line[18] == '1': intgar[1] = iarg	#The metered end is IARG
            elif line[18] == '2': intgar[1] = jarg	#The metered end is JARG
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if bus_owner_nbr[iarg] == bus_owner_nbr[jarg]: intgar[1] = iarg		#If both ends have the same owner, IARG is the metered end
                elif bus_owner_nbr[iarg] == intgar[2]: intgar[1] = jarg			#Else the end that has a different owner from the line is the metered end
                elif bus_owner_nbr[jarg] == intgar[2]: intgar[1] = iarg

            if isfloat(line[27:31]): realari[7] = float(line[27:31])	#Winding two nominal voltage

            if isfloat(line[33:37]): realari[8] = float(line[33:37])	#The Rate A in MVA

            if line[31] != ' ': ckt = line[31]		#The circuit identifier
            else: ckt = '1'				#If none is mentionned, the default is 1

            if isfloat(line[38:44]): realari[0] = float(line[38:44])			#Nominal transformer resistance
            if isfloat(line[44:50]) and float(line[44:50]) != 0.0: realari[1] = float(line[44:50])	#Nominal transformer reactance

            if isfloat(line[50:56]): realari[15] = float(line[50:56])		#The magnetizing conductance

            if isfloat(line[56:62]): realari[16] = float(line[56:62])		#The magnetizing susceptance

            if line[1] == ' ':
                if isfloat(line[62:67]): realari[3] = float(line[62:67])	#The winding one ratio/voltage
                if isfloat(line[67:72]): realari[6] = float(line[67:72])	#The winding two ratio/voltage

            else:
                if isfloat(line[62:67]): realari[5] = float(line[62:67])	#The winding one phase shift angle
                realari[3] = realari[4]						#The winding one ratio/voltage
                realari[6] = realari[7]						#The winding two ratio/voltage

            #It seems the format for the date in the file 2006eh-tmp-1 is not the same as in the user manual
            #if line[77:80] != "   ": intgar[0] = 0		#If there is an out of service date, the status is offline

            intgar[11], intgar[9], realari[17], realari[18], intgar[6], realari[19], realari[20] = GetRCard(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), bus_str)

            if line[32] == ' ': ierr, realaro  = psspy.two_winding_data(iarg, jarg, ckt, intgar, realari, "")	#The API to load transformer data in PSS/E

            elif line[32] == '1':	#If the transformer is section number 1
                multi_intgar = [intgar[1], 0, 0, 0, 0, 0, 0, 0, 0, 0]
                section_nbr = 2		#To search for section number 2
                to_bus, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar = GetSectionLine(bpa_str_ar, iarg, jarg, section_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr, owner_nbr, multi_intgar, line[31], base_mva)

                intgar[1] = iarg	#The metered end is IARG
                ierr, realaro  = psspy.two_winding_data(iarg, to_bus, ckt, intgar, realari, "")		#The API used to load two-winding data in PSS/E
                if multi_intgar[1] != 0: ierr = psspy.multi_section_line_data(iarg, jarg, "&" + ckt, multi_intgar)	#The API used to load multi-section line in PSS/E

    return owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr

#

# =====================

def GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, base_mva, scale_str, bus_zone_str):
    """Gets the bus supplement data from BPA."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

# =====================

load_intgar = [1, 1, 1, 1]
        machine_intgar = [0, 0, 0, 0, 0]
        load_realar = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        machine_realar = [0.0, 0.0, 9999.0, -9999.0, 9999.0, -9999.0, base_mva, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0]
        plant_realar = [1.0, 1.0]

        if line[0] == '+' and line[2] == ' ':	#If it is a + card
            line = line + ' '*(77-len(line))	#To pad each line with spaces up to 77 records

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr	#A new dictionnary entry
                load_intgar[3] = owner_nbr			#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                load_intgar[3] =  owner_str[line[3:6].strip()]	#Get the owner number
            elif line[3:6] == "   ":
                load_intgar[3] = 1				#The default owner

            iarg = bus_str[line[6:14].strip() + str(float(line[14:18]))]	#The from bus number

            if line[18:20] == "*I" or line[18:20] == "01":			#If it is a constant current load
                if isfloat(line[20:25]): load_realar[2] = float(line[20:25])	#Constant current load P
                if isfloat(line[25:30]): load_realar[3] = float(line[25:30])	#Constant current load Q
            elif line[18:20] == "*P" or line[18:20] == "02":			#If it is a constant power load
                if isfloat(line[20:25]): load_realar[0] = float(line[20:25])	#Constant power load P
                if isfloat(line[25:30]): load_realar[1] = float(line[25:30])	#Constant power load Q

            if isfloat(line[30:34]): load_realar[4] = float(line[30:34])	#Constant impedance load P
            if isfloat(line[34:38]): load_realar[5] = float(line[34:38])	#Constant impedance load Q

            if isfloat(line[42:47]): machine_realar[0] = float(line[42:47])	#Generation P
            if isfloat(line[47:52]): machine_realar[1] = float(line[47:52])	#Generation Q

            if line[1] != 'A' and line[1] != 'F' and line[1] != 'I' and line[1] != 'P': type_code = 'N'	#Non-industrial load or generation
            elif line[1] == 'F' or line[1] == 'I' or line[1] == 'P': type_code = 'I'			#Industrial load
            elif line[1] == 'A' and line[18:20] == "*I" or line[18:20] == "01": type_code = 'X'		#If it is a +A card with constant current load
            elif line[1] == 'A' and line[18:20] == "*P" or line[18:20] == "02": type_code = 'Y'		#If is is a +A card with constant power load

            scale_ar = GetScaleData(scale_str, line[3:6].strip(), bus_zone_str[iarg], type_code)	#To get the scale factors

            load_realar[0] = load_realar[0] * scale_ar[0]		#To scale the constant power load P
            load_realar[1] = load_realar[1] * scale_ar[1]		#To scale the constant power load Q
            load_realar[2] = load_realar[2] * scale_ar[2]		#To scale the constant current load P
            load_realar[3] = load_realar[3] * scale_ar[3]		#To scale the constant current load Q
            load_realar[4] = load_realar[4] * scale_ar[4]		#To scale the constant impedance load P
            load_realar[5] = load_realar[5] * scale_ar[5]		#To scale the constant impedance load Q
            machine_realar[0] = machine_realar[0] * scale_ar[6]		#To scale the generation P
            machine_realar[1] = machine_realar[1] * scale_ar[7]		#To scale the generation Q

            if load_realar[0] != 0.0 or load_realar[1] != 0.0 or load_realar[2] != 0.0 or load_realar[3] != 0.0 or load_realar[4] != 0.0 or load_realar[5] != 0.0:
                load_id_ar[iarg] = load_id_ar[iarg] + 1		#To increment the load CKT
                ierr = psspy.load_data(iarg, str(load_id_ar[iarg]), load_intgar, load_realar)	#Loads the load data in PSS/E

            if machine_realar[0] != 0.0 or machine_realar[1] != 0.0:	#If there is a generator
                machine_id_ar[iarg] = machine_id_ar[iarg] + 1		#To increment the machine CKT
                machine_intgar[0] = 1					#The machine status
                machine_intgar[1] = owner_nbr				#The owner number
                if machine_id_ar[iarg] == 1:				#If it is the first generator on this bus
                    ierr = psspy.plant_data(iarg, 0, plant_realar)	#First load the plant data
                ierr = psspy.machine_data(iarg, str(machine_id_ar[iarg]), machine_intgar, machine_realar)	#After add the generator data

    return owner_str, owner_nbr

#

# =====================

def GetICard(bpa_str_ar, area_str, area_slack_nbr):
    """Gets the inter-area transfer data from BPA."""

    inter_nbr = 48			#In order to start to the character '1' in the transfer ID

    for line in bpa_str_ar:		#This loop is used to get the inter-area transfer data
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if it is a blank line

# =====================

ia = 1				#Default area number
        ja = 1				#Default area number
        realar = [0.0]			#Default transfer

        if line[0] == 'I' and line[2] == ' ':		#If it is an I card
            line = line + ' '*(34-len(line))		#To pad each line with spaces up to 34 records
            for (x,y), z in area_str.items():
                if x == line[3:13].strip(): ia = z	#The 'from' area number
                if x == line[14:24].strip(): ja = z	#The 'to' area number

            if isfloat(line[26:34]): realar[0] = float(line[26:34])	#The amount of MW in the transfer

            inter_nbr = inter_nbr + 1	#To increment the transfer ID

            if inter_nbr == 123:	#After the 'Z' character, PSS/E do not accept the other ASCII characters
                psspy.alert(" WARNING: MAXIMUM NUMBER OF INTER-AREA TRANSFERS REACHED\n")
                return

            ierr = psspy.transfer_data(1, ia, ja, chr(inter_nbr), realar[0])	#The transfer data API

#

# =====================

def GetRZCard(bpa_str_ar):
    """Gets the line series compensation from BPA."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'R' and line[1] == 'Z':	#If it is an RZ card
            line = line + ' '*(60-len(line))	#To pad each line with spaces up to 60 records

            #Found no equivalent way to model this series compensation device in PSS/E
            psspy.alert(" WARNING: THE RZ CARD GOING FROM BUS [" + line[6:18] + "] TO BUS [" + line[19:31] + "] CANNOT BE IMPORTED\n")

#

# =====================

def GetZCard(bpa_str_ar, zone_str):
    """Gets the renamed zone names from BPA."""

    zone_str_temp = {}		#A dictionnary containing the modified zone names

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue

        if line[0] == 'Z':
            line = line + ' '*(77-len(line))	#To pad each line with spaces up to 77 records

            for x, y in zone_str.items():
                if x == line[3:5].strip(): zone_str_temp[line[5:7].strip()] = y
                elif x == line[8:10].strip(): zone_str_temp[line[10:12].strip()] = y
                elif x == line[13:15].strip(): zone_str_temp[line[15:17].strip()] = y
                elif x == line[18:20].strip(): zone_str_temp[line[20:22].strip()] = y
                elif x == line[23:25].strip(): zone_str_temp[line[25:27].strip()] = y
                elif x == line[28:30].strip(): zone_str_temp[line[30:32].strip()] = y
                elif x == line[33:35].strip(): zone_str_temp[line[35:37].strip()] = y
                elif x == line[38:40].strip(): zone_str_temp[line[40:42].strip()] = y
                elif x == line[43:45].strip(): zone_str_temp[line[45:47].strip()] = y
                elif x == line[48:50].strip(): zone_str_temp[line[50:52].strip()] = y
                elif x == line[53:55].strip(): zone_str_temp[line[55:57].strip()] = y
                elif x == line[58:60].strip(): zone_str_temp[line[60:62].strip()] = y
                elif x == line[63:65].strip(): zone_str_temp[line[65:67].strip()] = y
                elif x == line[68:70].strip(): zone_str_temp[line[70:72].strip()] = y
                elif x == line[73:75].strip(): zone_str_temp[line[75:77].strip()] = y
                else: zone_str_temp[x] = y

            zone_str.clear()			#To clear the dictionnary
            zone_str.update(zone_str_temp)	#To copy the contents of the temporary dictionnary

    return zone_str

#

# =====================

def GetDZCard(bpa_str_ar, zone_str):
    """Gets the deleted zone names from BPA and remove connected buses and equipment."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'D' and line[1] == 'Z':	#If it is a DZ card
            line = line + ' '*(5-len(line))	#To pad each line with spaces up to 5 records
            if line[3:5].strip() in zone_str:
                ierr = psspy.bsys(0, 0, [0.0,0.0], 0, [], 0, [], 0, [], 1, [zone_str[line[3:5].strip()]])	#A bus subsystem of this zone
                ierr = psspy.extr(0, 0, [1, 0])						#To delete this subsystem
                ierr = psspy.bsys(0, 1, [0.0, 9999.], 0, [], 0, [], 0, [], 0, [])	#To bring back the original unfiltered view
                del zone_str[line[3:5].strip()]						#To delete the zone

            else: psspy.alert(" WARNING: THE ZONE [" +  line[3:5].strip() + "] SPECIFIED IN THE DZ CARD CANNOT BE FOUND\n")	#If the zone is not found

    return zone_str

#

# =====================

def GetDCOwners(bpa_str_ar, from_bus, to_bus):
    """Gets the owners of the DC buses for the two-terminal DC lines in BPA."""

    owner_1 = ""	#The owner of bus 'converter 1'
    owner_2 = ""	#The owner of bus 'converter 2'

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':	#If it is a BD card
            if from_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_1 = line[3:6].strip()
            elif to_bus == (line[6:14].strip() + str(float(line[14:18]))): owner_2 = line[3:6].strip()

    return owner_1, owner_2

#

# =====================

intgar_1 = [0, 0, 0, 0, 0]
    realari_1 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    intgar_2 = [0, 0, 0, 0, 0]
    realari_2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue			#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'D' and line[2] == ' ':	#If it is a BD card
            line = line + ' '*(62-len(line))	#To pad each line with spaces up to 62 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])):	#If the bus is converter 1
                if flow_flag: cnvflg_1 = 1	#If the flow is positive, the converter 1 is a rectifier
                else: cnvflg_1 = 2		#If the flow is negative, the converter 1 is an inverter

                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_1[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter 1 bus number

                if isint(line[23:25]): intgar_1[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[30:35]): realari_1[0] = float(line[30:35])	#Minimum firing angle
                if isfloat(line[35:40]): realari_1[1] = float(line[35:40])	#Maximum firing angle

            elif to_bus == line[6:14].strip() + str(float(line[14:18])):	#If the bus is converter 2
                if flow_flag: cnvflg_2 = 2	#If the flow is positive, the converter 2 is an inverter
                else: cnvflg_2 = 1		#If the flow is negative, the converter 2 is a rectifier

                if line[50:58].strip() + str(float(line[58:62])) in bus_str: intgar_2[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter 2 bus number

                if isint(line[23:25]): intgar_2[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[30:35]): realari_2[0] = float(line[30:35])	#Minimum firing angle
                if isfloat(line[35:40]): realari_2[1] = float(line[35:40])	#Maximum firing angle

        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':		#If it is a T card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[38:44]): realari_1[2] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): realari_1[3] = float(line[44:50])	#Commutating reactance

                realari_1[4] = float(line[14:18])				#Primary base voltage

                if isfloat(line[67:72]): realari_1[5] = float(line[67:72])	#Transformer ratio
                if isfloat(line[62:67]): realari_1[6] = float(line[62:67])	#Tap setting

            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[38:44]): realari_2[2] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): realari_2[3] = float(line[44:50])	#Commutating reactance

                realari_2[4] = float(line[14:18])				#Primary base voltage

                if isfloat(line[67:72]): realari_2[5] = float(line[67:72])	#Transformer ratio
                if isfloat(line[62:67]): realari_2[6] = float(line[62:67])	#Tap setting

        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':		#If it is a R card
            line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

            if from_bus == line[6:14].strip() + str(float(line[14:18])) or from_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): realari_1[7] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): realari_1[8] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: realari_1[9] = (realari_1[7] - realari_1[8])/int(line[55:57])	#Tap step

            elif to_bus == line[6:14].strip() + str(float(line[14:18])) or to_bus == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): realari_2[7] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): realari_2[8] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: realari_2[9] = (realari_2[7] - realari_2[8])/int(line[55:57])	#Tap step

    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_1, dc_line_nbr, intgar_1, realari_1, "")	#To load the converter 1 in PSS/E
    ierr,realaro = psspy.two_term_dc_convr_data(cnvflg_2, dc_line_nbr, intgar_2, realari_2, "")	#To load the converter 2 in PSS/E

#

# =====================

def GetTwoTermLine(bpa_str_ar, bus_str):
    """Gets the two-terminal DC line data from BPA."""

    dc_line_nbr = 0	#The two-terminal DC line number

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'D' and line[2] == ' ':	#If it is a LD card
            line = line + ' '*(78-len(line))	#To pad each line with spaces up to 78 records

# =====================

intgar = [1, 0]
            realari = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

            dc_line_nbr = dc_line_nbr + 1	#To increment the DC line number

            if isfloat(line[56:61]): realari[0] = float(line[56:61])	#Scheduled power demand
            if isfloat(line[61:66]): realari[1] = float(line[61:66])	#Scheduled DC voltage
            if isfloat(line[37:43]): realari[4] = float(line[37:43])	#DC line resistance

            if line[55] == 'I': realari[5] = 0			#Compounding resistance = 0 if Vdc is controlled at the inverter
            elif line[55] == 'R': realari[5] = realari[4]	#Compounding resistance = Rdc if Vdc is controlled at the rectifier

            if line[18] == '1':				#If the metered side is converter 1
                if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                else: metrar = 'I'			#The metered side is the inverter if the flow is negative

            elif line[18] == '2':			#If the metered side is converter 2
                if realari[0] >= 0.0: metrar = 'I'	#The metered side is the inverter if the flow is positive
                else: metrar = 'R'			#The metered side is the rectifier if the flow is negative

            elif line[18] == ' ':			#If the metered side is left blank, BPA chooses
                owner_1, owner_2 = GetDCOwners(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])))
                if owner_1 == owner_2:		#If both DC buses have the same owner
                    if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                    else: metrar = 'I'			#The metered side is the inverter if the flow is negative
                elif owner_1 == line[3:6].strip():  #If the owner of converter 1 is the same as the line
                    if realari[0] >= 0.0: metrar = 'I'	#The metered side is the inverter if the flow is positive
                    else: metrar = 'R'			#The metered side is the rectifier if the flow is negative
                elif owner_2 == line[3:6].strip():  #If the owner of converter 2 is the same as the line
                    if realari[0] >= 0.0: metrar = 'R'	#The metered side is the rectifier if the flow is positive
                    else: metrar = 'I'			#The metered side is the inverter if the flow is negative

            ierr, realaro = psspy.two_terminal_dc_line_data(dc_line_nbr, intgar, realari, metrar)	#The API to load two-terminal DC line in PSS/E

            GetTwoTermConv(bpa_str_ar, line[6:14].strip() + str(float(line[14:18])), line[19:27].strip() + str(float(line[27:31])), dc_line_nbr, realari[0] >= 0.0, bus_str)	#To get the 2 converters data

#

# =====================

def GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, bus_name):
    """Gets the T and R card corresponding to the converter bus specified."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'T' and line[1] == ' ' and line[2] == ' ':	#If it is a T card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[67:72]): conv_realari[3] = float(line[67:72])	#Transformer ratio
                if isfloat(line[38:44]): conv_realari[4] = float(line[38:44])	#Commutating resistance
                if isfloat(line[44:50]): conv_realari[5] = float(line[44:50])	#Commutating reactance

                conv_realari[6] = float(line[14:18])				#Winding one base voltage

                if isfloat(line[62:67]): conv_realari[7] = float(line[62:67])	#Tap setting

        if line[0] == 'R' and line[1] == ' ' and line[2] == ' ':		#If it is a R card
            line = line + ' '*(67-len(line))	#To pad each line with spaces up to 67 records

            if bus_name == line[6:14].strip() + str(float(line[14:18])) or bus_name == line[19:27].strip() + str(float(line[27:31])):
                if isfloat(line[45:50]): conv_realari[8] = float(line[45:50])	#Maximum tap setting
                if isfloat(line[50:55]): conv_realari[9] = float(line[50:55])	#Minimum tap setting
                if isint(line[55:57]) and int(line[55:57]) != 0: conv_realari[10] = (conv_realari[8] - conv_realari[9])/int(line[55:57])	#Tap step

    return conv_intgar, conv_realari

#

# =====================

def GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr):
    """Gets the converter data for multi-terminal lines and creates DC buses."""

    dc_bus_nbr = 0		#The DC bus number for multi-terminal lines
    dc_bus_str = {}		#The dictionnary to contain DC bus names and numbers
    dc_bus_owner = ["DEFAULT"]	#An array of the owners of each DC bus

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'B' and line[1] == 'M' and line[2] == ' ':	#If it is a BM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

conv_intgar = [0, 0, 0, 0]
            conv_realari = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.5, 0.51, 0.00625, 0.0, 1.0]
            bus_intgar = [0, 0, 0, 0, 0]
            bus_realari = 0.0

            if line[6:14].strip() + str(float(line[14:18])) not in dc_bus_str:		#If the bus is not in the list, add it
                dc_bus_nbr = dc_bus_nbr + 1
                dc_bus_str[line[6:14].strip() + str(float(line[14:18]))] = dc_bus_nbr		#A new dictionnary entry
            else:
                dc_bus_nbr = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]		#Get the bus number

            if line[3:6] != "   " and line[3:6].strip() not in owner_str:	#If the owner is not in the list, add it to the list with a new number
                owner_nbr = owner_nbr + 1
                owner_str[line[3:6].strip()] = owner_nbr		#A new dictionnary entry
                bus_intgar[3] = owner_nbr				#The new owner number
            elif line[3:6] != "   " and line[3:6].strip() in owner_str:
                bus_intgar[3] =  owner_str[line[3:6].strip()]		#Get the owner number
            elif line[3:6] == "   ":
                bus_intgar[3] = 1					#The default owner

            dc_bus_owner.insert(dc_bus_nbr + 1, line[3:6].strip())	#Insert the owner number of this bus

            if line[18:20] != "  ":
                if line[18:20].strip() not in zone_str:		#If the zone is not in the list, add it
                    zone_nbr = zone_nbr + 1
                    zone_str[line[18:20].strip()] = zone_nbr		#A new dictionnary entry
                    bus_intgar[2] = zone_nbr				#The new zone number
                else:
                    bus_intgar[2] =  zone_str[line[18:20].strip()]	#Get the zone number

            area_flag, bus_flag, area_nbr, swing_bus_nbr, bus_str, area_str, area_slack_nbr = GetACard(bpa_str_ar, line[18:20].strip(), bus_str, bus_nbr, area_str, area_slack_nbr, area_nbr)

            if area_flag == True:		#To assign the area number to the DC buses
                bus_intgar[1] = area_nbr
            else:				#The default area number
                bus_intgar[1] = 1

            if line[62] != ' ':			#If it is not a passive DC bus
                conv_intgar[0] = bus_str[line[50:58].strip() + str(float(line[58:62]))]	#Converter bus number
                bus_intgar[0] = conv_intgar[0]						#Converter bus number

                if isint(line[23:25]): conv_intgar[1] = int(line[23:25])		#Number of bridges in series
                if isfloat(line[69:75]):
                    if float(line[69:75]) != 0.0: conv_realari[0] = float(line[69:75])	#Scheduled power
                    elif isfloat(line[75:80]): conv_realari[0] = float(line[75:80])	#Scheduled voltage

                if line[62] == 'R' and isfloat(line[30:35]): conv_realari[1] = float(line[30:35])	#Minimum firing angle

                elif line[62] == 'I' and isfloat(line[66:69]) or line[62] == 'M' and isfloat(line[66:69]):
                    conv_realari[1] = float(line[66:69])			#Minimum extinction angle

                if isfloat(line[35:40]): conv_realari[2] = float(line[35:40])	#Maximum firing angle

                conv_intgar, conv_realari = GetConvTrans(bpa_str_ar, conv_intgar, conv_realari, line[6:14].strip() + str(float(line[14:18])))	#To get the corresponding T and R parameters

                ierr,realaro = psspy.multi_term_dc_convr_data(1, conv_intgar, conv_realari)	#The API to load multi-terminal DC line converter data in PSS/E

            ierr,realaro = psspy.multi_term_dc_bus_data(1, dc_bus_nbr, bus_intgar, bus_realari, line[6:14].strip())	#The API to load multi-terminal DC line bus data in PSS/E

    return dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr

#

# =====================

def GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner):
    """Gets the multi-terminal link data from the BPA file."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':	#If it is a LM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

intgar = 0
            realar = [0.0, 0.0]

            ibus = dc_bus_str[line[6:14].strip() + str(float(line[14:18]))]	#The from bus
            jbus = dc_bus_str[line[19:27].strip() + str(float(line[27:31]))]	#The to bus

            if line[18] == '1': intgar = ibus		#The metered end is IBUS
            elif line[18] == '2': intgar = jbus		#The metered end is JBUS
            elif line[18] == ' ':			#If the metered end is left blank, BPA chooses
                if dc_bus_owner[ibus] == dc_bus_owner[jbus]: intgar = ibus	#If both ends have the same owner, IBUS is the metered end
                elif dc_bus_owner[ibus] == line[3:6].strip(): intgar = jbus	#Else the end that has a different owner from the line is the metered end
                elif dc_bus_owner[jbus] == line[3:6].strip(): intgar = ibus

            if isfloat(line[37:43]): realar[0] = float(line[37:43])	#DC link resistance
            if isfloat(line[43:49]): realar[1] = float(line[43:49])	#DC link inductance

            ierr = psspy.multi_term_dc_link_data(1, ibus, jbus, '1', intgar, realar)	#The API used to load multi-terminal DC line link data in PSS/E

#

# =====================

def GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr):
    """Gets the multi-terminal lines from the BPA file."""

    for line in bpa_str_ar:
        line = line.lstrip()
        line = line.rstrip('\n')
        if line == "": continue		#Continue if the line is blank

        if line[0] == 'L' and line[1] == 'M' and line[2] == ' ':	#If it is a LM card
            line = line + ' '*(80-len(line))	#To pad each line with spaces up to 80 records

# =====================

intgari = 1
            realar = 0.0

            ierr, intgaro = psspy.multi_term_dc_line_data(1, intgari, realar)	#The API used to load multi-terminal DC line data in PSS/E

            #To get the converter, DC bus and DC link data
            dc_bus_str, dc_bus_owner, owner_str, owner_nbr, zone_str, zone_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermConv(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, bus_nbr, area_str, area_slack_nbr, area_nbr)
            GetMultiTermLink(bpa_str_ar, dc_bus_str, dc_bus_owner)

            return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr

    return zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr

#

# =====================

bpa_file = OpenFile()

if bpa_file:					#If the file opened successfully

    psspy.progress("\n\nFile opened successfully, starting the conversion:\n")

    bpa_str = bpa_file.read()			#The string containing the text file, to use the find() function
    bpa_file.seek(- bpa_file.tell(), 1)		#To position back at the beginning
    bpa_str_ar = bpa_file.readlines()		#The array that is containing all the lines of the BPA file

    basemva = GetMVA(bpa_file, bpa_str)		#To get the MVA base
    psspy.progress("\n-Base MVA: " + str(basemva))

    titl1, titl2 = GetTitles(bpa_file, bpa_str)	#To get the title data
    psspy.progress("\n-Title 1: " + titl1)
    psspy.progress("\n-Title 2: " + titl2 + "\n")

    ierr = psspy.newcas(basemva, titl1, titl2)	#To create the new case

    scale_str = GetPCard(bpa_str_ar)		#To get the P cards for scaling

    area_str, area_nbr, area_slack_nbr, owner_str, owner_nbr, bus_owner_nbr, bus_str, bus_nbr, zone_str, zone_nbr, load_id_ar, machine_id_ar, bus_zone_str = GetBCard(bpa_str_ar, basemva, scale_str)

    owner_str, owner_nbr, dummy_nbr, bus_nbr, bus_str, bus_owner_nbr = GetLCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, basemva)

    owner_str, owner_nbr, bus_nbr, bus_str, bus_owner_nbr = GetTCard(bpa_str_ar, owner_str, owner_nbr, bus_str, bus_nbr, bus_owner_nbr, dummy_nbr, basemva)

    owner_str, owner_nbr = GetPlusCard(bpa_str_ar, load_id_ar, machine_id_ar, bus_str, owner_str, owner_nbr, basemva, scale_str, bus_zone_str)

    GetTwoTermLine(bpa_str_ar, bus_str)
    zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr = GetMultiTermLine(bpa_str_ar, bus_str, zone_str, zone_nbr, owner_str, owner_nbr, area_str, area_slack_nbr, area_nbr)

    zone_str = GetZCard(bpa_str_ar, zone_str)	#To get Z cards
    zone_str = GetDZCard(bpa_str_ar, zone_str)	#To get DZ cards

    for x, y in zone_str.items():
        ierr = psspy.zone_data(y, x)	#The API used to load zone data in PSS/E

    for (x,y), z in area_str.items():
        ierr = psspy.area_data(z, area_slack_nbr[z - 1], [y, 0.0], x)	#The API used to load zone data in PSS/E

    GetICard(bpa_str_ar, area_str, area_slack_nbr)	#To get the I cards

    for x, y in owner_str.items():
        ierr = psspy.owner_data(y, x)	#The API used to load owner data in PSS/E

    GetRZCard(bpa_str_ar)	#To get RZ cards

    psspy.progress("\n\nConversion completed\n")

    bpa_file.close()	#To close the BPA file
#[brnflows_csv.py]  Export BRANCH FLOWS to COMMA SEPARATED FILE (CSV)
#

# =====================

'''
This is an example file showing how to use "subsystem data retrieval APIs
from Python to save branch flows to Comma Separated File.
    Input : Solved PSS(R)E saved case file name
    Output: CSV file name to save
    When 'savfile' is provided, FNSL with default options is used to solve the case.
    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.
    When 'csvfile' is provided, branch flows is saved in ASCII text file 'csvfile'.
    When 'csvfile' is not provided, it produces report in PSS(R)E report window.

The subsystem data retrieval APIs return values as List of Lists. For example:
When "abusint" API is called with "istrings" as defined below:
    istrings = ['number','type','area','zone','owner','dummy']
    ierr, idata = psspy.abusint(sid, flag_bus, istrings)
The returned list will have format:
    idata=[[list of 'number'],[list of 'type'],[],[],[],[list of 'dummy']]

This example is written such that, such returned lists are converted into dictionary with
keys as strings specified in "istrings". This makes it easier to refer and use these lists.
    ibuses = array2dict(istrings, idata)

So ibuses['number'] gives the bus numbers returned by "abusint".

# =====================

def busindexes(busnum, busnumlist):
    '''Find indexes of a bus in list of buses.
    Returns list with indexes of 'busnum' in 'busnumlist'.
    '''
    busidxes = []
    startidx = 0
    buscounts = busnumlist.count(busnum)
    if buscounts:
        for i in range(buscounts):
            tmpidx = busnumlist.index(busnum,startidx)
            busidxes.append(tmpidx)
            startidx = tmpidx+1
    return busidxes

#

# =====================

def splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

#

# =====================

def brnflows_csv(savfile,csvfile):
    '''Generates power flow result report.
    When 'savfile' is provided, FNSL with default options is used to solve the case.
    When 'savfile' is not provided, it uses solved Case from PSS(R)E memory.
    When 'csvfile' is provided, report is saved in ASCII text file 'csvfile'.
    When 'csvfile' is not provided, it produces report in PSS(R)E report window.
    '''

    import psspy
    psspy.psseinit()

    # Set Save and CSV files according to input file names
    if savfile:
        ierr = psspy.case(savfile)
        if ierr != 0: return
        fpath, fext = os.path.splitext(savfile)
        if not fext: savfile = fpath + '.sav'
    else:   # saved case file not provided, check if working case is in memory
        ierr, nbuses = psspy.abuscount(-1,2)
        if ierr != 0:
            print('\n No working case in memory.')
            print(' Either provide a Saved case file name or open Saved case in PSSE.')
            return
        savfile, snapfile = psspy.sfiles()

    if csvfile:  # open CSV file to write
        csvfile_h = open(csvfile,'w')
        report    = csvfile_h.write
    else:        # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    #

# =====================

# Branch Flow Data
    # Branch Flow Data - Integer
    istrings = ['fromnumber','tonumber','status','nmeternumber','owners','own1','own2','own3','own4']
    ierr, idata = psspy.aflowint(sid, owner_brflow, ties_brflow, flag_brflow, istrings)
    if ierr != 0: return
    iflow = array2dict(istrings, idata)
    # Branch Flow Data - Real
    rstrings = ['amps','pucur','pctrate','pctratea','pctrateb','pctratec','pctmvarate',
                'pctmvaratea','pctmvarateb',#'pctmvaratec','fract1','fract2','fract3',
                'fract4','rate','ratea','rateb','ratec',
                'p','q','mva','ploss','qloss',
                'o_p','o_q','o_mva','o_ploss','o_qloss'
                ]
    ierr, rdata = psspy.aflowreal(sid, owner_brflow, ties_brflow, flag_brflow, rstrings)
    if ierr != 0: return
    rflow = array2dict(rstrings, rdata)
    # Branch Flow Data - Complex
    xstrings = ['pq','pqloss','o_pq','o_pqloss']
    ierr, xdata = psspy.aflowcplx(sid, owner_brflow, ties_brflow, flag_brflow, xstrings)
    if ierr != 0: return
    xflow = array2dict(xstrings, xdata)
    # Branch Flow Data - Character
    cstrings = ['id','fromname','fromexname','toname','toexname','nmetername','nmeterexname']
    ierr, cdata = psspy.aflowchar(sid, owner_brflow, ties_brflow, flag_brflow, cstrings)
    if ierr != 0: return
    cflow = array2dict(cstrings, cdata)

    #

# =====================

report("Branch flows from Saved case: %s\n" %savfile)

    clnttls = "%6s,%18s,%6s,%18s,%3s,%3s,%9s,%9s,%9s,%6s,%8s,%8s\n" %('FRMBUS',
             'FROMBUSEXNAME','TOBUS','TOBUSEXNAME','CKT','STS','MW','MVAR','MVA','%I','MWLOSS','MVARLOSS')
    report(clnttls)
    for i in range(len(iflow['fromnumber'])):
        fromnum    = iflow['fromnumber'][i]
        fromexname = cflow['fromexname'][i]
        tonum      = iflow['tonumber'][i]
        toexname   = cflow['toexname'][i]
        ckt        = cflow['id'][i]
        status     = iflow['status'][i]
        p          = rflow['p'][i]
        q          = rflow['q'][i]
        mva        = rflow['mva'][i]
        ploss      = rflow['ploss'][i]
        qloss      = rflow['qloss'][i]
        pcti       = rflow['pctrate'][i]
        report("%(fromnum)6d,%(fromexname)18s,%(tonum)6d,%(toexname)18s,%(ckt)3s,%(status)3d,\
%(p)9.2F,%(q)9.2F,%(mva)9.2F,%(pcti)6.2F,%(ploss)8.2F,%(qloss)8.2F\n" %vars())
    #

# =====================

def check_psse_example_folder(csvfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(csvfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        csvfile  = os.path.join(outdir, rptfnam)

    return csvfile

#

# =====================

'''
'dyntools' module provide access to data in PSS(R)E Dynamic Simulation Channel Output file.
This module has functions:
- to get channel data in Python scripts for further processing
- to get channel information and their min/max range
- to export data to text files, excel spreadsheets
- to open multiple channel output files and post process their data using Python scripts
- to plot selected channels
- to plot and insert plots in word document

This is an example file showing how to use various functions available in dyntools module.

Other Python modules 'matplotlib', 'numpy' and 'python win32 extension' are required to be
able to use 'dyntools' module.
Self installation EXE files for these modules are available at:
   PSSE User Support Web Page and follow link 'Python Modules used by PSSE Python Utilities'.

- This version of the dyntools module is developed and tested using these open source modules.
  Python 3.7.3 [64 bit]
  matplotlib-3.1.1
  numpy-1.16.4
  pywin32-224

  Versions later than these may work.

# =====================

How to use this file?
- Open Python IDLE (or any Python Interpreter shell)
- Open this file
- run (F5)

Note: Do NOT run this file from PSS(R)E GUI. The 'xyplots' function from dyntools can
save plots to eps, png, pdf or ps files. However, creating only 'eps' files from inside
PSS(R)E GUI works. This is because different backends matplotlib uses to create different
plot types.
When run from any Python interpreter (outside PSS(R)E GUI) plots can be saved to any of
these four (eps, png, pdf or ps) file types.

Get information on functions available in dyntools as:
import dyntools
help(dyntools)

# =====================

How to use PSSE and Python modules like numpy, matplotlib together?
(a) In your python script, call following function before any of these modules are imported.
    psspy.set_fpcw_py()
(b) Call following function before exiting your python script.
    psspy.set_fpcw_psse()
To get details why this is needed, get help(..) on either of these functions.
Refer function test2_subplots_one_trace(..) in this script for usage of these functions.

'''

import os, sys, collections

#

# =====================

def get_demotest_file_names(outdir, outvrsn):

    if outvrsn==0:
        extn = '.out'
        prgfile  = os.path.join(outdir,'progress.txt')
    else:
        extn = '.outx'
        prgfile  = os.path.join(outdir,'progressX.txt')

    outfile1 = os.path.join(outdir,'bus154_fault{}'.format(extn))
    outfile2 = os.path.join(outdir,'bus3018_gentrip{}'.format(extn))
    outfile3 = os.path.join(outdir,'brn3005_3007_trip{}'.format(extn))

    return outfile1, outfile2, outfile3, prgfile

#

# =====================

# Run Dynamic simulation on SAVNW to generate .out files

def run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn):

    import psspy
    psspy.psseinit()

    examdir = get_example_folder()

    savfile = 'savcnv.sav'
    snpfile = 'savnw.snp'

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    snpfile = os.path.join(datapath, snpfile)

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])

    ierr = psspy.case(savfile)
    if ierr:
        psspy.progress_output(1,"",[0,0])
        print(" psspy.case Error")
        return
    ierr = psspy.rstr(snpfile)
    if ierr:
        psspy.progress_output(1,"",[0,0])
        print(" psspy.rstr Error")
        return

    psspy.set_chnfil_type(outvrsn)

    psspy.strt(0,outfile1)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_bus_fault(154,1, 230.0,[0.0,-0.2E+10])
    psspy.run(0, 1.05,1000,1,0)
    psspy.dist_clear_fault(1)
    psspy.run(0, 5.0,1000,1,0)

    psspy.case(savfile)
    psspy.rstr(snpfile)
    psspy.strt(0,outfile2)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_machine_trip(3018,'1')
    psspy.run(0, 5.0,1000,1,0)

    psspy.case(savfile)
    psspy.rstr(snpfile)
    psspy.strt(0,outfile3)
    psspy.run(0, 1.0,1000,1,0)
    psspy.dist_branch_trip(3005,3007,'1')
    psspy.run(0, 5.0,1000,1,0)

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])

#

# =====================

# 0. Run savnw dynamics simulation to create .out files

def test0_run_simulation(datapath=None, outpath=None, outvrsn=0):

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)
    run_savnw_simulation(datapath, outfile1, outfile2, outfile3, prgfile, outvrsn)

    print(" Test0:Done SAVNW dynamics simulation")

#

# =====================

# 1. Data extraction/information

def test1_data_extraction(outpath=None, show=True, outvrsn=0, prg2file=True):

    import psspy
    import dyntools

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    # create object
    chnfobj = dyntools.CHNF(outfile1, outvrsn=outvrsn)

    if chnfobj.ierr: return

    if prg2file:
        p, nx = os.path.split(outfile1)
        n, x  = os.path.split(nx)
        rptnam = "{}_test1_output.txt".format(n)
        if outpath:
            rptfile = os.path.join(outpath, rptnam)
        else:
            rptfile = os.path.join(p, rptnam)
        rptfile_h = open(rptfile,'w')
        report = rptfile_h.write
    else:
        report = sys.stdout.write

    report('\n Test1:Testing call to get_data\n')
    #sh_ttl, ch_id, ch_data = chnfobj.get_data()
    sh_ttl, ch_id, ch_data = chnfobj.get_data(['time', 4, 5, 55])
    #sh_ttl, ch_id, ch_data = chnfobj.get_data('')
    #sh_ttl, ch_id, ch_data = chnfobj.get_data([4, 5, 55])
    s_in = [str(ch) for ch in ch_data.keys()]
    s_ch = ', '.join(s_in)
    report(sh_ttl)
    report("{}".format(ch_id))
    report(" Test1:Data extracted for Channels = {}\n".format(s_ch))

    report('\n Test1:Testing call to get_id\n')
    sh_ttl, ch_id = chnfobj.get_id()
    report(sh_ttl)
    report("{}".format(ch_id))
    report('\n')

    report('\n Test1:Testing call to get_range\n')
    ch_range = chnfobj.get_range()
    report("{}".format(ch_range))
    report('\n')

    report('\n Test1:Testing call to get_scale\n')
    ch_scale = chnfobj.get_scale()
    report("{}".format(ch_scale))
    report('\n')

    if not prg2file:
        report('\n Test1:Testing call to print_scale\n')
        chnfobj.print_scale()
        report('\n')

    pn, x = os.path.splitext(outfile1)

    report('\n Test1:Testing call to txtout\n')
    chnfobj.txtout(channels=[1,4], txtfile=pn)
    report('\n')

    report('\n Test1:Testing call to csvout\n')
    chnfobj.csvout(channels=[1,4,41,5], csvfile=pn)
    report('\n')

    report('\n Test1:Testing call to xlsout\n')
    try:
        chnfobj.xlsout(channels=[2,3,4,7,8,10], show=show, xlsfile=pn)
    except:
        pass

    if prg2file:
        rptfile_h.close()
        txt = ' Test1_data_extraction report saved to file:\n    {}\n'.format(rptfile)
        print(txt)

#

# =====================

# 2. Multiple subplots in a figure, but one trace in each subplot
#    Channels specified with normal dictionary

# See how "set_plot_legend_options" method can be used to place and format legends

def test2_subplots_one_trace(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':True, 'showoutfnam':True, 'showlogo':True,
                'legendtype':1, 'addmarker':True}

    optnchn1 = {1:{'chns':6,                'title':'Ch#6,bus154_fault, P(pu)'},
                2:{'chns':[6, 'v*100'],     'title':'Ch#6,bus154_fault, P(MW)'},
                3:{'chns':11,               'title':'Ch#11,bus154_fault'},
                4:{'chns':40,               'title':'Ch#40,bus154_fault'},
                5:{'chns':26,               'title':'Ch#26,bus154_fault, Frequency (pu)'},
                6:{'chns':[26, '(1+v)*60'], 'title':'Ch#26,bus154_fault, Frequency (Hz)'},
                }
    pn,x     = os.path.splitext(outfile1)
    pltfile1 = pn+'.pdf'

    optnchn2 = {1:{'chns':{outfile2:6},                'title':'Channel 6 from bus3018_gentrip, P(pu)'},
                2:{'chns':{outfile2:[6, 'v*100']},     'title':'Channel 6 from bus3018_gentrip, P(MW)'},
                3:{'chns':{outfile2:11}},
                4:{'chns':{outfile2:16}},
                5:{'chns':{outfile2:26},               'title':'Ch#26,bus3018_gentrip, Frequency (pu)'},
                6:{'chns':{outfile2:[26, '(1+v)*60']}, 'title':'Ch#26,bus3018_gentrip, Frequency (Hz)'},
                }
    pn,x     = os.path.splitext(outfile2)
    pltfile2 = pn+'.png'

    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)

    chnfobj.set_plot_legend_options(loc='lower center', borderpad=0.2, labelspacing=0.5,
                                    handlelength=1.5, handletextpad=0.5, fontsize=8, frame=False)

    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':False}

    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)

    if figfiles1 or figfiles2:
        txt = ' Test2:Plot files saved:\n'
        if figfiles1: txt += "     {}\n".format(figfiles1[0])
        if figfiles2: txt += "     {}\n".format(figfiles2[0])
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

#

# =====================

# 3. Multiple subplots in a figure and more than one trace in each subplot
#    Channels specified with normal dictionary

def test3_subplots_mult_trace(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':2,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':True}

    optnchn1 = {1:{'chns':[1]},2:{'chns':[2]},3:{'chns':[3]},4:{'chns':[4]},5:{'chns':[5]}}
    pn,x     = os.path.splitext(outfile1)
    pltfile1 = pn+'.png'

    optnchn2 = {1:{'chns':{outfile2:1}},
                2:{'chns':{'v82_test1_bus_fault.out':3}},
                3:{'chns':4},
                4:{'chns':[5]}
               }
    pn,x     = os.path.splitext(outfile2)
    pltfile2 = pn+'.pdf'

    optnchn3 = {1:{'chns':{outfile1:1}},
                2:{'chns':{outfile2:[1,5]}},
                3:{'chns':{outfile3:3}},
                4:{'chns':[4,'v-v0',5,'v-v0']},  # arbitrary function
               }
    pn,x     = os.path.splitext(outfile3)
    pltfile3 = pn+'.png'

    figfiles1 = chnfobj.xyplots(optnchn1,optnfmt,pltfile1)
    figfiles2 = chnfobj.xyplots(optnchn2,optnfmt,pltfile2)
    figfiles3 = chnfobj.xyplots(optnchn3,optnfmt,pltfile3)

    figfiles = figfiles1[:]
    figfiles.extend(figfiles2)
    figfiles.extend(figfiles3)
    if figfiles:
        txt = ' Test3:Plot files saved:\n'
        for f in figfiles:
            txt += "    {}\n".format(f)
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

#

# =====================

# 4. Multiple subplots in a figure, but one trace in each subplot
#    Channels specified with Ordered dictionary

def test4_subplots_mult_trace_OrderedDict(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    chnfobj.set_plot_page_options(size='letter', orientation='portrait')
    chnfobj.set_plot_markers('square', 'triangle_up', 'thin_diamond', 'plus', 'x',
                             'circle', 'star', 'hexagon1')
    chnfobj.set_plot_line_styles('solid', 'dashed', 'dashdot', 'dotted')
    chnfobj.set_plot_line_colors('blue', 'red', 'black', 'green', 'cyan', 'magenta', 'pink', 'purple')

    optnfmt  = {'rows':2,'columns':1,'dpi':300,'showttl':False, 'showoutfnam':True, 'showlogo':False,
                'legendtype':2, 'addmarker':True}

    optnchn  = {1:{'chns':collections.OrderedDict([(outfile1,26), (outfile2,26), (outfile3,26)]),
                   'title':'Frequency(pu)'},
                2:{'chns':collections.OrderedDict([(outfile1,[26, '(1+v)*60']),
                                                   (outfile2,[26, '(1+v)*60']),
                                                   (outfile3,[26, '(1+v)*60'])]),
                   'title':'Frequency(Hz)'}
               }
    p,nx     = os.path.split(outfile1)
    pltfile  = os.path.join(p, 'plot_chns_ordereddict.png')

    figfiles = chnfobj.xyplots(optnchn,optnfmt,pltfile)

    if figfiles:
        txt = ' Test4:Plot files saved:\n'
        for f in figfiles:
            txt += "    {}\n".format(f)
        print(txt)

    if show:
        chnfobj.plots_show()
    else:
        chnfobj.plots_close()

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

#

# =====================

# 5. Do XY plots and insert them into word file
# Does not work because win32 API to Word does not work.

def test5_plots2word(outpath=None, show=True, outvrsn=0):

    import psspy
    import dyntools
    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.

    outfile1, outfile2, outfile3, prgfile = get_demotest_file_names(outpath, outvrsn)

    chnfobj = dyntools.CHNF(outfile1, outfile2, outfile3, outvrsn=outvrsn)

    p,nx       = os.path.split(outfile1)
    docfile    = os.path.join(p,'savnw_response')
    overwrite  = True
    caption    = True
    align      = 'center'
    captionpos = 'below'
    height     = 0.0
    width      = 0.0
    rotate     = 0.0

    optnfmt  = {'rows':3,'columns':1,'dpi':300,'showttl':True}

    optnchn  = {1:{'chns':{outfile1:1,  outfile2:1,  outfile3:1} },
                2:{'chns':{outfile1:[7,'v*100'],  outfile2:[7,'v*100'],  outfile3:[7,'v*100']} },
                3:{'chns':{outfile1:17, outfile2:17, outfile3:17} },
                4:{'chns':[1,2,3,4,5]},
                5:{'chns':{outfile2:[26,'(1+v)*60',27,'(1+v)*60',28,'(1+v)*60',29,'(1+v)*60']},
                   'title':'Frequency(Hz)'},
                6:{'chns':{outfile3:[1,2,3,4,5]} },
               }
    ierr, docfile = chnfobj.xyplots2doc(optnchn,optnfmt,docfile,show,overwrite,caption,align,
                        captionpos,height,width,rotate)

    if not ierr:
        txt  = ' Test5:Plots saved to file:\n    {}'.format(docfile)
        print(txt)
    else:
        txt  = ' Test5:Error saving plots to Word = {}'.format(ierr)
        print(txt)

    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

#

# =====================

def run_tests(which, outvrsn, show, datapath=None, prg2file=True):

    import psspy

    datapath = datapath

    outdnam  = "dyntools_demo_output_outvrn{}".format(outvrsn)
    outpath  = os.path.join(os.getcwd(), outdnam)
    if not os.path.exists(outpath): os.mkdir(outpath)

    if which in [0, 'all']:
        print(" <<<<<< Begin TEST=0 >>>>>>")
        test0_run_simulation(datapath, outpath, outvrsn)
        print(" Output files folder:{}".format(outpath))

    if which in [1, 'all']:
        print(" <<<<<< Begin TEST=1 >>>>>>")
        test1_data_extraction(outpath=outpath, show=show, outvrsn=outvrsn, prg2file=prg2file)

    if which in [2, 'all']:
        print(" <<<<<< Begin TEST=2 >>>>>>")
        test2_subplots_one_trace(outpath, show, outvrsn)

    if which in [3, 'all']:
        print(" <<<<<< Begin TEST=3 >>>>>>")
        test3_subplots_mult_trace(outpath, show, outvrsn)

    if which in [4, 'all']:
        print(" <<<<<< Begin TEST=4 >>>>>>")
        test4_subplots_mult_trace_OrderedDict(outpath, show, outvrsn)

    if which in [5, 'all']:
        print(" <<<<<< Begin TEST=5 >>>>>>")
        try:
            test5_plots2word(outpath, show, outvrsn)
        except:
            pass

#

# =====================

if __name__ == '__main__':

    import psse35

    show = True     # True  --> create, save and show Excel spreadsheets and Plots when done
                    # False --> create, save but do not show Excel spreadsheets and Plots when done

                    # Channel file format
    outvrsn = 0     # =0, for no Extended Channel output file type (.out)
                    # =1, for Extended Channel output file type (.outx) (default)

    prg2file = False

    #(a) Run one test a time
    #
    # 1) which=0
    # Need to run "test0_run_simulation(..)" before running other tests.
    #
    # 2)
    # which = 1 or 2 or 3 or 4 or 5
    # After running "test0_run_simulation(..)", run other tests one at a time with

    # which = 0
    # run_tests(which, outvrsn, show, prg2file)

    #(b) Run all tests
    #    Just uncomment next line to run all tests in this file.
    #run_all_tests(outvrsn)

#

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psseXX
    where XX is PSSE version number like 34, 35, 3500, 3501.
    
- call funtion
    run_export(qvfile)
    or
    run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd())

Excel file is saved to a file name derived from qvfile name.
'''

import os

shtlst = ['bus voltage', 'summary', 'generator dispatch', 'mismatch']

#

# =====================

def qv_summary(xlsobj,sheet,smry):
    '''
    Use this to create ->
    QV worksheet: 'Summary'
    '''
    xlsobj.set_active_sheet(sheet)
    row, col = 1, 1
    xlsobj.set_cell((row,col),"QV SOLUTION RESULTS",fontStyle="bold",fontSize=14, fontColor="blue")

    tmplst=[
        smry.casetitle.line1,
        smry.casetitle.line2,
        'QV output file                             = %s' % smry.file.qv,
        'Saved Case file                            = %s' % smry.file.sav]

    if smry.file.thr:
        tmplst.append('Load throwover file                        = %s' % smry.file.thr)

    tlst = [
        'DFAX file                                  = %s' % smry.file.dfx,
        'Subsystem file                             = %s' % smry.file.sub,
        'Monitored Element file                     = %s' % smry.file.mon,
        'Contingency Description file               = %s' % smry.file.con]

    tmplst.extend(tlst)

    if smry.file.inl:
        tmplst.append('Inertia and Governor Response file         = %s' % smry.file.inl)
    if smry.file.zip:
        tmplst.append('Incremental Save Case Archive file         = %s' % smry.file.zip)

    tlst = [
        ' ',                                                                       # blank row
        'Number of Contingencies+Base Case          = %d' % smry.qvsize.ncase,
        'Number of Monitored Generators(Plants)     = %d' % smry.qvsize.nmgnbus,
        'Number of Voltage Monitored Buses          = %d' % smry.qvsize.nmvbus,
        'Number of Voltage Monitored Records        = %d' % smry.qvsize.nmvrec,
        'Number of maximum voltage setpoint changes = %d' % smry.qvsize.nmxvstp,
        ]

    tmplst.extend(tlst)

    row_optn_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+opt ttl
    jnklst=[' ', 'QV Solution Options:']
    for i in range(len(smry.options)):
        j=smry.options[i]
        ti=str(i+1).rjust(2)
        tj=str(j)
        t1=arrbox.qv_pp._QV_INT_OPTIONS_NAMES[i]
        if (i+1)==arrbox.qv_pp._QV_INT_OPTIONS_STUDY_BUS_INDEX:
            jnklst.append("option(%(ti)s): %(t1)s =%(tj)s" % vars())
        else:
            t2=arrbox.qv_pp._QV_INT_OPTIONS_LIST[i][j]
            jnklst.append("option(%(ti)s): %(t1)s =%(tj)s =%(t2)s" % vars())

    tmplst.extend(jnklst)
    row_vals_ttl = len(tmplst) + 2 + 2 # 2 for top title+blank row and 2 for blank row+val ttl

    jnklst=[' ', 'QV Solution Values:']
    for i in range(len(smry.realvalues)):
        ti=str(i+1)
        tn=arrbox.qv_pp._QV_REAL_VALUES_NAMES[i]
        tv="%g" % smry.realvalues[i]
        jnklst.append("value(%(ti)s): %(tn)s =%(tv)s" % vars())

    tmplst.extend(jnklst)
    del jnklst

    row += 2
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True)
    xlsobj.font_color((row,col,row+1,col),'brown')
    xlsobj.font_color((row_optn_ttl,col),'red')
    xlsobj.font_color((row_vals_ttl,col),'red')

    if smry.qvsize.ncase:
        row = bottomRow+2
        xlsobj.set_cell((row,col),"QV Contingencies",fontStyle="Bold",fontSize=12, fontColor="red")

        conlst = [['CON#', 'LABEL', 'Min Vstp', 'Max Vstp', 'Min MVAR', 'Max MVAR',
                   'Max Mismatch', 'DESCRIPTION']]
        # determine rows for which QV is failed maxmsm>smry.realvalues[0]
        rfrm = row+1
        rto  = row+1
        failrows = []
        for i in range(smry.qvsize.ncase):
            rfrm += 1
            rto  += 1
            if i==0:
                srnum = ' '
            else:
                srnum = str(i)
            nam  = smry.colabel[i]
            minvstp = smry.minvstp[i]
            maxvstp = smry.maxvstp[i]
            minmvar = smry.minmvar[i]
            maxmvar = smry.maxmvar[i]
            maxmsm  = smry.maxmsm[i]
            for j in range(len(smry.codesc[i])):
                dsc = smry.codesc[i][j]
                if j==0:
                    conlst.append([srnum,nam,minvstp,maxvstp,minmvar,maxmvar,maxmsm,dsc])
                else:
                    conlst.append(['' ,'' ,'' ,'' ,'' ,'' ,'' ,dsc])
                    rto += 1
            if maxmsm>smry.realvalues[0]:
                failrows.append([rfrm, rto])
            else:
                failrows.append([0, 0])
            rfrm = rto

        row += 1
        bottomRow,rightCol = xlsobj.set_range(row,col,conlst)
        xlsobj.font_color((row,col,row,rightCol), "dgreen")
        xlsobj.font((row,col+2,bottomRow,col+3),numberFormat='0.00')  # Min Vstp and Max Vstp
        xlsobj.font((row,col+4,bottomRow,col+6),numberFormat='0.000') # Min MVAR, Max MVAR and Max MSM
        xlsobj.align((row,col),'right')
        xlsobj.font((row,col,row,rightCol),fontStyle=('Bold',))
        xlsobj.autofit_columns((row,col+1,row,rightCol))
        for each in failrows:
            r1 = each[0]
            r2 = each[1]
            if r1 and r2:
                xlsobj.font((r1,col,r2,rightCol),fontColor="cyan",fontStyle='bold')
    else:
        xlsobj.set_cell((row,col),"No Contingencies..",fontStyle="Bold",fontSize=12, fontColor="red")

#

# =====================

def qv_mismath(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,mvaworst,mvatotal,cnvflag,cnvcond):
    '''
    Use this to create ->
    QV worksheet: 'Mismatch'
    '''
    
    # assemble data in columns: 1st=MW Transfer, 2nd=MVAWORST and 3rd=MVATOTAL
    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label
    cnvyesno = []
    noclns   = []
    i = 1
    for each in cnvflag:
        i += 1
        if each:
            cnvyesno.append('YES')
            noclns.append(0)
        else:
            cnvyesno.append('NO')
            noclns.append(i)

    tmplst = [ rowttl ]
    for i in range(len(mwtransfer)):
        tmplst.append([mwtransfer[i],mvaworst[i],mvatotal[i],cnvyesno[i],cnvcond[i]])

    xlsobj.set_active_sheet(sheet)
    col = 1
    # added 1 to row in violation check for 'contitle' row
    xlsobj.set_cell((row,col+1),contitle,fontStyle='bold',fontSize=12,fontColor="dgreen")
    row += 1
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=True,numberFormat="0.00000")
    xlsobj.font((row,col,row,rightCol),fontColor="red",fontStyle='bold',numberFormat="0.000")
    xlsobj.align((row,col,row,rightCol),'h_center')
    xlsobj.align((row+3,col,row+3,rightCol),'h_center')
    xlsobj.align((row,col,bottomRow,col),'right')
    xlsobj.font((row+1,col,bottomRow,col),fontColor="blue",fontStyle='bold')
    for each in noclns:
        if each:
            xlsobj.font((row+3,each,bottomRow,each),fontColor="cyan",fontStyle='bold')

    row = bottomRow + 2 # one blank row

    return row

#

# =====================

def qv_one(xlsobj,sheet,lbl,ttl,row,rowttl,mwtransfer,solnvalue,options,cnvflag=[]):
    '''
    Use this to create ->
    QV worksheets: 'Bus Voltage', 'Generator Dispatch'
    '''

    contitle = 'CONTINGENCY: ' + lbl.strip() + 5*' ' + ttl # Contingency Label
    namesplit = options[0]
    nttlclns  = options[1]
    transpose = options[2]

    # determine non-converged solution columns
    noclns = []
    i = nttlclns
    for each in cnvflag:
        i += 1
        if each:
            noclns.append(0)
        else:
            noclns.append(i)

    # assemble data in columns: 1st=MW Transfer, rest=solution values
    t = []
    for i in range(len(mwtransfer)):
        t1 = list(solnvalue[i])
        t1.insert(0,mwtransfer[i])
        t.append(t1)
        
    tmplst = t
    tmplst.insert(0,rowttl)
    xlsobj.set_active_sheet(sheet)
    col = 1
    xlsobj.set_cell((row,col+nttlclns),contitle,fontStyle='bold',fontSize=12,fontColor="dgreen")
    row += 1
    bottomRow,rightCol = xlsobj.set_range(row,col,tmplst,transpose=transpose)
    xlsobj.font((row,col+nttlclns-1,row,rightCol),fontColor="red",fontStyle='bold')
    xlsobj.font((row,col+nttlclns,bottomRow,rightCol),numberFormat="0.000")
    xlsobj.align((row,col,row,rightCol),'h_center')
    if namesplit: xlsobj.merge((row,col,row,nttlclns))
    xlsobj.align((row,col),'right')
    xlsobj.font((row+1,col,bottomRow,nttlclns),fontColor="blue",fontStyle='bold')
    for each in noclns:
        if each:
            xlsobj.font((row+1,each,bottomRow,each),fontColor="cyan")
    row = bottomRow + 2 # one blank row

    return row

#

# =====================

def run_export(qvfile, overwritesheet=True, show=True, outpath=os.getcwd()):
    import arrbox.qv_pp
    import excelpy
    
    if not os.path.exists(qvfile):
        msgstr = " Error - QV file does not exist, no export.\n     {}." .format(qvfile)
        print(msgstr)
        return
        
    p, nx = os.path.split(qvfile)
    xlnam, x = os.path.splitext(nx)
    xlnam = "{}_qv".format(xlnam)
    xlsfile = os.path.join(outpath, xlnam)

    #

# =====================

xlsobj = excelpy.workbook(xlsfile, shtlst[0], overwritesheet=overwritesheet)
    if show:
        xlsobj.show()
    else:
        xlsobj.hide()

    xlsobj.show_alerts(0) # do not show pop-up alerts
    xlsfnam = xlsobj.XLSFNAM

    for shtnam in shtlst[1:]:
        xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)
    
    xlsobj.page_format(orientation="landscape",left=1.0,right=1.0,
                       top=0.5,bottom=0.5,header=0.25,footer=0.25)
    xlsobj.page_footer(left='page number of page total', right='date, time')
    xlsobj.page_header(center='file name:sheet name')
    xlsobj.font_sheet()

    #

# =====================

# Retrive QV data
    qvobj = arrbox.qv_pp.QV_PP(qvfile)
    smry = qvobj.summary()

    qv_summary(xlsobj, 'summary', smry)

    row_msm = 1
    msmlabel = ['VOLTAGE SETPOINT->', 'LARGEST MVA MISMATCH', 'TOTAL MVA MISMATCH', 'CONVERGED', 'CONVERGE CONDITION']

    row_vlt = 1
    options_vlt = [False,1,True]
    mvbuslabel = list(smry.mvbuslabel)
    mvbuslabel.insert(0,'VOLTAGE SETPOINT->')

    row_gen = 1
    options_gen = [False,1,True]
    mgenbuslabel = list(smry.mgenbus)
    mgenbuslabel.insert(0,'VOLTAGE SETPOINT->')
    
    ret_ierr = 0
    for lbl in smry.colabel:
        soln = qvobj.solution(lbl)
        if soln==None: continue                 # contingency solution not found, move to next
        if soln.ierr !=0: ret_ierr = soln.ierr  # return any non-zero ierr

        row_msm = qv_mismath(xlsobj, 'mismatch',lbl,'Mismatch (MVA)',
                             row_msm,msmlabel,soln.vsetpoint,soln.mvaworst,soln.mvatotal,
                             soln.cnvflag, soln.cnvcond)
        
        row_vlt = qv_one(xlsobj,'bus voltage',lbl,'Voltage (pu)',
                         row_vlt,mvbuslabel,soln.vsetpoint,soln.volts,options_vlt,soln.cnvflag)

        row_gen = qv_one(xlsobj,'generator dispatch',lbl,'Plant (MVAR)',
                         row_gen,mgenbuslabel,soln.vsetpoint,soln.mgenmvar,options_gen,soln.cnvflag)

    #

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- call function
    Run various functions from this file as desired.
    See notes in _run_one_test_api(..) (end of this file).
'''

"""
Use any of these keywords to run GIC_8.
Keyword               Default          Description
                                     # INTGOPTNS[]
tielevels           = 0              #  1  Number of levels of inter-tie buses to add to study subsystem
study_year          = 0              #  2  Year number to scale benchmark event GMD storm. These scaling factors account in the influence of geomagnetic latitude on the estimated geoelectric field magnitude and are provided in NERC TPL-007.
sid_supp            = 0              #  3  Subsystem sid for supplemental GMD event
thermal_ana_optn    = 0              #  4  Option for Transformer Thermal Analysis
degscan_pf_optn     = 0              #  5  Option to run power flow for each degree scan calculation
boundary_trn        = 0              #  6  Option to include buses of boundary transformers in study subsystem
worstcase_trn       = 0              #  7  Option for Transformers to include in worst case determination
supp_evt            = 0              #  8  Option for Supplemental event and moving box
supp_box_num        = 0              #  9  Option for number of Supplemental event moving boxes. It is not used when intgoptns(8)=0 and intgoptns(8)=4
brn_seg_efld        = 0              # 10  Option for treatment of the transmission line that intersect with Supplemental event moving box
                                     # REALOPTNS[]
efield_mag          = 8.0            #  1  electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform or supplemental
efield_deg          = 0              #  2  electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform or supplemental
substation_r        = 0.1            #  3  substation grounding dc resistance in ohms
branch_xbyr         = 30             #  4  transmission line X/R ratio, must be > 0, used to calculate branch DC resistance if R=0.0 in network data
transformer_xbyr    = 30             #  5  transformer winding X/R ratio, must be > 0, used to calculate winding DC resistance if R=0.0 in network data
efield_mag_supp     = 12.0           #  6  supplemental event electric field magnitude in units defined by charoptns(2), not used when charoptns(1)=nonuniform
efield_deg_supp     = 0.0            #  7  local GMD hot spots electric field direction in degrees, range 0 to 360 degrees, not used when charoptns(1)=nonuniform
branch_rac2rdc      = 1.0            #  8  transmission line AC to DC resistance conversion factor, must be > 0
transformer_rac2rdc = 1.0            #  9  transformer winding AC to DC resistance conversion factor, must be > 0
degscan_step        = 10.0           # 10  Degree Scan step size, range 1.0 to 180 degrees
magscan_step        = 4.0            # 11   Magnitude Scan step size, must be > 1.0 V/km
pf_qpct_step        = 100.0          # 12   Percent GMD Mvar loss step size. Total GMD Mvar losses added incrementally to the base case to obtain power flow solution, must be > 1.0
magscan_max         = 20.0           # 13   Magnitude Scan maximum storm strength, must be > 1.0
supp_box_ns_km      = 100.0          # 14   Supplemental event moving box North-South length in km, must be > 1.0, used when intgoptns(8)>0
supp_box_ew_km      = 500.0          # 15   Supplemental event moving box East-West length in km, must be > 1.0, used when intgoptns(8)>0
supp_box_lon_c      = 0.0            # 16   Supplemental event moving box center point longitude in degrees, used only when intgoptns(8)=4
supp_box_lat_c      = 0.0            # 17   Supplemental event moving box center point latitude in degrees, used only when intgoptns(8)=4
                                     # CHAROPTNS[]
efield_type         = "uniform"      #  1  Electric Field Type
efield_unit         = "v/km"         #  2  Units of Electric Field Magnitude
addfile_optn        = "rdch"         #  3  Option to add GIC updates to base case
gic2mvar_optn       = "kfactors"     #  4  Option to select method for GIC to Mvar Calculation
earth_model_name    = ""             #  5  Earth Model Name. A Standard or User defined model name must be provided when Benchmark Event or Non-uniform electric field is to be modeled or Transformer Thermal Analysis is to be performed.
scan_storm_event    = ""             #  6  Option to scan storm event scenarios
power_flow_optn     = ""             #  7 Option to solve Power Flow with GIC losses added to the base case
                                     # EJETOPTNS[]
ejet_million_amps   = 1.0            #  1  eletrojet current in million amperes, must be > 0
ejet_halfwidth_km   = 200.0          #  2  Cauchy distribution half-width in km, must be > 0
ejet_period_min     = 5.0            #  3  period of variation in minutes, must be > 0
ejet_height_km      = 100.0          #  4  height of current in km, must be > 0
ejet_center_deg     = 54.0           #  5  latitude of center of electrojet in degrees
                                     # FILEOPTNS[]
addfile             = ""             #  2  GIC updates to Base Case file name (output).
purgfile            = ""             #  3  RDCH file to remove GIC updates from GIC updated case in working memory to set it back to Base Case network condition (output).
rnwkfile            = ""             #  4  GIC dc resistive network raw file. This represents the dc network used to calculate GIC flow (output).
pygicfile           = "nooutput"     #  5  GIC Results map data file for given Efield magnitude and degrees OR Efield magnitude and degrees scans which give maximum Var losses when scans are performed (output).  This is used by GICMAPS to plot GIC results on network map.
gictfile            = "nooutput"     #  6  Transformer Thermal Analysis GIC(t) CSV file (output).
                                     # REPTOPTNS[]
rptoptn             = -1             #  1  what to report
rptbrn_indv         = 1              #  2  report induced branch voltages
rptdc_busv          = 1              #  3  report DC bus voltages
rptbrn_gic          = 1              #  4  report branch GIC flows
rpttrn_gic          = 1              #  5  report transformer GIC flows
rptstn_gic          = 1              #  6  report substation GIC flows
rpttrn_q            = 1              #  7  report transformer losses
rpt_sid             = 0              #  8  Subsystem sid for report
"""

import sys, os, time, collections

#

# =====================

def finish_timer(start_time):
    '''timstr = finish_timer(start_time)
    Finish timer and return elapsed time as string.
    where start_time is value returned by start_timer().
    '''
    finish_time = time.time()
    elapsed_sec = finish_time - start_time
    hr,mn1 = divmod(elapsed_sec,3600)
    mn,sc  = divmod(mn1,60)
    timstr = " Elapsed time: Hours=%d , Minutes=%d, Seconds=%g\n" % (hr, mn, sc)
    return timstr

#

# =====================

def get_output_dir(outpath=''):
    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.path.dirname(__file__)
        outdir = os.path.join(outdir, 'gic_demo_output')
        if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds):

    import psspy

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()

    name,major,minor,modlvl,date,stat = psspy.psseversion()
    vrsn = "v{}{}{}".format(major,minor,modlvl)

    if 'efield_type' not in kwds: kwds['efield_type'] = "benchmark"

    # add suffix to prg/rpt names (to make them unique, so they are not overwritten.)
    optn_nam_dict = collections.OrderedDict([
        ('efield_deg'      , 'deg' ),
        ('scan_storm_event', ''    ),
        ('power_flow_optn' , ''    ),
        ('boundary_trn'    , 'btrn'),
        ('worstcase_trn'   , 'wtrn'),
        ('supp_evt'        , 'optnbx' ),
        ('brn_seg_efld'    , 'brnseg'),
        ])

    sid_supp, supp_evt, brn_seg = 0, 0, 0
    if 'sid_supp' in kwds: sid_supp = kwds['sid_supp']
    if 'supp_evt' in kwds: supp_evt = kwds['supp_evt']
    if 'supp_box_num' in kwds: supp_box_num = kwds['supp_box_num']
    if 'supp_box_lon_c' in kwds: supp_box_lon_c = kwds['supp_box_lon_c']
    if 'supp_box_lat_c' in kwds: supp_box_lat_c = kwds['supp_box_lat_c']
    if 'brn_seg_efld' in kwds:brn_seg = kwds['brn_seg_efld']

    s_brnseg = ''
    subdir = ''
    outfsfx = kwds['efield_type'][0]
    if (supp_evt==1 and sid_supp>0)             or \
       (supp_evt in [2,3,4] and supp_box_num>0) or \
       (supp_evt==5 and abs(supp_box_lon_c)>0 and abs(supp_box_lat_c)>0):
        outfsfx += "+s"
        s_brnseg = "bseg{}".format(brn_seg)
        if supp_evt in [2,3] and supp_box_num>0:
            subdir = "supp_opbx{}_numbx{}_brnseg{}".format(supp_evt, supp_box_num, brn_seg)

    for k, s_nam in optn_nam_dict.items():
        if k in kwds:
            vin = kwds[k]
            if vin:
                if s_nam:
                    if supp_evt==1:
                        outfsfx += "_sid"
                    else:
                        outfsfx += "_{}{}".format(s_nam, vin)
                else:
                    outfsfx += "_{}".format(vin)

    if s_brnseg:
        outfsfx += "_{}".format(s_brnseg)

    outdir = get_output_dir(outdir)
    if subdir:
        outdir = os.path.join(outdir, subdir)
        if not os.path.exists(outdir): os.mkdir(outdir)

    if prg2file:
        nam = "{}_{}_progress.txt".format(outnam, outfsfx)
        prgfile = os.path.join(outdir, nam)

    if rpt2file:
        nam = "{}_{}_report.txt".format(outnam, outfsfx)
        rptfile = os.path.join(outdir, nam)

    # Create output file names when they are not provided
    for sfx in ['add', 'purg', 'rnwk', 'pygic', 'gict']:
        k = "{}file".format(sfx)
        if k not in kwds:
            s0 = sfx
            if sfx=='pygic': s0 = 'map'
            fnam = "{}_{}_{}".format(outnam, outfsfx, s0)
            kwds[k] = os.path.join(outdir, fnam)

    # run activity gic_8
    if prg2file: psspy.progress_output(2,prgfile,[0,0])
    if rpt2file: psspy.report_output(2,rptfile,[0,0])

    start_time = start_timer()
    psspy.gic_8(sid, allbus, **kwds)
    timstr = finish_timer(start_time)

    if prg2file: psspy.progress_output(1,"",[0,0])
    if rpt2file: psspy.report_output(1,"",[0,0])

    print(timstr)

    if rpt2file:
        print("  --------- Report saved to: {} ".format(rptfile))

#

# =====================

def run_test_sample(**optns):
    import psspy
    psspy.psseinit()

    gicfilevrsn = optns.get('gicfilevrsn', 4)

    if gicfilevrsn>4:
        savfnam = r'sample_nb.sav'      # SAV file with Node Breaker Modeling
        gicfnam = r'sample_fv5.gic'     # GIC file version 5
    else:
        savfnam = r'sample.sav'         # SAV file with NO Node Breaker Modeling
        gicfnam = r'sample_fv4.gic'     # GIC file version 4

    examdir = get_example_folder()

    savfile = os.path.join(examdir, savfnam)
    gicfile = os.path.join(examdir, gicfnam)

    sid      = 0
    allbus   = 1

    outnam, jnk = os.path.splitext(savfnam)

    outdir   = get_output_dir()
    prg2file = True
    rpt2file = True

    study_year = 2019
    earth_model_name = 'SHIELD'

    kwds = {}
    kwds['study_year'] = study_year
    kwds['earth_model_name'] = earth_model_name
    kwds['addfile']  = ''
    kwds['purgfile'] = ''

    for k, v in optns.items():
        if k=='gicfilevrsn': continue
        kwds[k] = v

    if 'thermal_ana_optn' not in kwds:
        kwds['thermal_ana_optn'] = -1

    psspy.case(savfile)
    psspy.gic_read(gicfile)

    if 'sid_supp' in kwds:
        kwds['sid_supp'] = 4
        areas = [5]
        ierr = psspy.bsys(kwds['sid_supp'], numarea=len(areas), areas=areas)

    run_gic(sid, allbus, outnam, outdir, prg2file, rpt2file, **kwds)

#

# =====================

def run_gicmaps(pygicfile):
    import arrbox.gicmaps

    outdir   = get_output_dir()
    fpth, nx = os.path.split(pygicfile)
    outnam, fxtn = os.path.splitext(nx)
    if not fpth: pygicfile = os.path.join(outdir, pygicfile)

    outdir_maps = os.path.join(outdir, 'maps')
    if not os.path.exists(outdir_maps): os.mkdir(outdir_maps)

    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    gicmapsobj.enable_draw_supp_box()

    pngfile = get_output_filename("{}_ssflow.png".format(outnam), outdir_maps)

    sublst = list(gicmapsobj.pygicobj.substation.keys())
    gicmapsobj.annotate_substations(sublst, color='blue', fontsize=10)

    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(pngfile, markersize=20)

    oufile_seg = get_output_filename("{}_brnsegments.txt".format(outnam), outdir_maps)
    gicmapsobj.report_supp_box_line_segments(rptfile=oufile_seg)

    oufile_evt = get_output_filename("{}_element_events.txt".format(outnam), outdir_maps)
    gicmapsobj.report_network_element_events(rptfile=oufile_evt)

    gicmapsobj.plots_show()

#

# =====================

def _template_sample():
    # 1) Benchmark event
    #    No storm scan, No supplemental event, No power flow solution
    run_test_sample(efield_type='benchmark', gicfilevrsn=5)

    # 2) Supplemental event
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='supplemental', gicfilevrsn=5)

    # 3) Benchmark + Supplemental event
    #    Supplemental event defined by subsystem
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4, gicfilevrsn=5)

    # 4) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank substations with maximum GIC flows as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2, gicfilevrsn=5)

    # 5) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank transformers with maximum GIC flows as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2, gicfilevrsn=5)

    # 6) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Use substation number provided as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10, gicfilevrsn=5)

    # 7) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Use location provided as center of the moving box
    #    No storm scan, No power flow solution
    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0, gicfilevrsn=5)

    # 8) Benchmark + Supplemental event
    #    Supplemental event defined by Moving Box,
    #    Rank substations with maximum GIC flows as center of the moving box

    #    Degree Scan with specified settings [step=1 deg, add Qloss in steps of 100%]
    #    FDNS - run PowerFlow for each scan step
    #       Number of degree scans = 1+ 180/degscan_step = 181
    #       Number PF due % Qstep = 100/pf_qpct_step = 5
    #       Number PF due to moving boxes = supp_box_num = 20
    #    Number of GIC calculations = 181 (for ranking) + 181*20 (one each supp box) = 3801
    #    Number of PF solved = 181*20*5 = 18100
##    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,
##                    scan_storm_event="scan_deg", power_flow_optn='fdns',
##                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20,
##                    gicfilevrsn=5)

    print(" all done - _template_sample")

#

# =====================

def _run_one_test_api():
    # Just run one of these calls as desired.

    run_test_sample(efield_type='benchmark')
    run_test_sample(efield_type='benchmark', gicfilevrsn=5)
    run_test_sample(efield_type='benchmark', gicfilevrsn=4)
    run_test_sample(efield_type='supplemental')
    run_test_sample(efield_type='benchmark', supp_evt=1, sid_supp=4)
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=2)
    run_test_sample(efield_type='benchmark', supp_evt=3, supp_box_num=2)
    run_test_sample(efield_type='benchmark', supp_evt=4, supp_box_num=10)
    run_test_sample(efield_type='benchmark', supp_evt=5, supp_box_lon_c=-82.0, supp_box_lat_c=32.0)
    run_test_sample(efield_type='benchmark', supp_evt=2, supp_box_num=20,
                    scan_storm_event="scan_deg", power_flow_optn='fdns',
                    degscan_pf_optn=1, degscan_step=1, pf_qpct_step=20)

    # Creat a function similar to "run_test_sample(..)"
    # - to use any power flow study cases
    # - define common arguments
    # - output directory etc
    # Then use that function to run the GIC study of interest.

#

# =====================

def _run_one_test_maps():
    # Just run one of these calls as desired.
    # The 'pygic' files created by tests in "_run_one_test_api" serve as input
    # for these tests.

    run_gicmaps(r"sample_b+s_sid_bseg0_map(deg)-oldVrsn.pygic")
    run_gicmaps(r"sample_b_map(deg).pygic")
    run_gicmaps(r"sample_s_map(deg).pygic")
    run_gicmaps(r"sample_b+s_sid_bseg0_map(deg).pygic")
    run_gicmaps(r"sample_b+s_optnbx4_bseg0_map(deg).pygic")
    run_gicmaps(r"sample_b+s_optnbx5_bseg0_map(deg).pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx2_numbx2_brnseg0\sample_b+s_optnbx2_bseg0_map(deg)_supp_box1.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx2_numbx2_brnseg0\sample_b+s_optnbx2_bseg0_map(deg)_supp_box2.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx3_numbx2_brnseg0\sample_b+s_optnbx3_bseg0_map(deg)_supp_box1.pygic")
    run_gicmaps(r".\gic_demo_output\supp_opbx3_numbx2_brnseg0\sample_b+s_optnbx3_bseg0_map(deg)_supp_box2.pygic")

#

# =====================

'''This is an example file showing how to:
- Create GIC data file templates in Excel spreadsheets and create GIC data file from those
  Excel spredsheets
- Perform GIC analysis, post process GIC results, create customized GIC analysis reports
- Perform GIC analysis, post process GIC results, export GIC analysis results to Excel
- Map GIC results on network maps

Python module "gicdata" is used for creating GIC data files.
    See help(gicdata) for details.

Result retrival Python module "pssarrays" is converted to Python package "arrbox".
This is done to provide object access instead of function access.

Using Python package "arrbox" it is possible to create multiple objects and compare
PSSE results.

Now Python module 'pssarrays' provide aliases to modules in package "arrbox".

GIC related objects 'GIC' and 'GICMAPS' in module 'pssarrays' will work as is (that is
without any code changes in your script). However, better way to access them is from
package arrbox as shown in this script.

See detailed help on GIC related objects in arrbox as:
import arrbox.gic;help(arrbox.gic.GIC)
import arrbox.gicmaps;help(arrbox.gicmaps.GICMAPS)

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    Run various functions from this file as desired. See notes in _run_one_test(..) (end of this file).

See function gic_results_on_network_map_custom(..) to know how you can decorate default plots with
data point annotations or any other custom settings.

# =====================

How to use PSSE and Python modules like numpy, matplotlib, Basemap together?
(a) In your python script, call following function before any of these modules are imported.
    psspy.set_fpcw_py()
(b) Call following function before exiting your python script.
    psspy.set_fpcw_psse()
To get details why this is needed, get help(..) on either of these functions.
Refer function gic_results_on_network_map(..) in this script for usage of these functions.
'''

#

# =====================

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()

    outdir = os.path.join(outdir, 'gic_report_output')
    if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def _get_outfnam_event(pfx, efield_type, efield_mag, efield_deg, scan_storm_event):

    if efield_type=='nonuniform':
        outfnam = r"{}_{}".format(pfx, efield_type[0])
    else:
        if scan_storm_event:
            outfnam = r"{}_{}_{:g}(mag)_{:g}(deg)_{}".format(pfx, efield_type[0], efield_mag, efield_deg, scan_storm_event)
        else:
            outfnam = r"{}_{}_{:g}(mag)_{:g}(deg)".format(pfx, efield_type[0], efield_mag, efield_deg)

    return outfnam

#

# =====================

def create_gicdata_template_sample(datapath=None, outpath=None, areas=[], showexcel=True):
    """ Create GIC data Excel template using sample.sav file from PSSE Example folder.
"""
    import psspy, gicdata

    f_sfx = _get_filenam_sfx(areas)

    savfile   = 'sample.sav'
    excelfile = 'gicdata_sample_template_{}'.format(f_sfx)

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    excelfile = get_output_filename(outpath, excelfile)

    basekv    = []
    areas     = areas
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    psspy.psseinit()

    excelfile = gicdata.template_excel(savfile, excelfile, basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
                           tielevels=tielevels, showexcel=showexcel)
    return excelfile

#

# =====================

def transfer_gicdata_sample(datapath=None, outpath=None, areas=[], showexcel=True):
    """ Transfer GIC data from .gic file into blank GIC data Excel template.
"""
    import psspy, gicdata

    f_sfx = _get_filenam_sfx(areas)

    gicfile_in   = 'sample_fv4.gic'
    tmplfile_in  = 'gicdata_sample_template_{}.xlsx'.format(f_sfx)
    excelfile_ou = 'gicdata_sample_{}.xlsx'.format(f_sfx)

    if not datapath: datapath = get_example_folder()

    gicfile_in   = os.path.join(datapath, gicfile_in)
    tmplfile_in  = get_output_filename(outpath, tmplfile_in)
    excelfile_ou = get_output_filename(outpath, excelfile_ou)

    showexcel = showexcel
    dbgout    = False
    prgfile   = None
    xlsfile = gicdata.transfer_data(gicfile_in, tmplfile_in, excelfile_ou,
                    showexcel=showexcel, prgfile=prgfile, dbgout=dbgout)

    return xlsfile

#

# =====================

def gicdata_excel2gicfile(outpath=None, areas=[]):
    """ Create GIC data text file (.gic) from GIC data Excel file.
"""
    import gicdata

    f_sfx = _get_filenam_sfx(areas)
    excelfile = 'gicdata_sample_{}.xlsx'.format(f_sfx)
    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)

    excelfile = get_output_filename(outpath, excelfile)
    gicfile = get_output_filename(outpath, gicfile)

    gicdata.excel2gicfile(excelfile, gicfile)

    return gicfile

#

# =====================

def gicdata_gicfile2excel(outpath=None, areas=[], showexcel=True):
    """ Create GIC data Excel file from GIC data text file (.gic).
"""
    import gicdata

    f_sfx = _get_filenam_sfx(areas)

    gicfile = 'gicdata_sample_{}.gic'.format(f_sfx)
    excelfile = 'gicdata_sample_{}(txt2xl).xlsx'.format(f_sfx)

    gicfile = get_output_filename(outpath, gicfile)
    excelfile = get_output_filename(outpath, excelfile)

    gicdata.gicfile2excel(gicfile, excelfile, showexcel=showexcel)

    return gicfile

#

# =====================

def gicdata_merge(outpath=None, showexcel=True):
    """ Merge GIC data Excel files into one GIC data Excel file.
"""
    import gicdata

    flist = ['gicdata_sample_123.xlsx', 'gicdata_sample_456.xlsx']
    xl_list = []
    for fnam in flist:
        fou = get_output_filename(outpath, fnam)
        xl_list.append(fou)

    outxlnam   = "merged_sample.xlsx"
    prgfnam    = "merged_sample_progress.txt"

    outexcel = get_output_filename(outpath, outxlnam)
    prgfile  = get_output_filename(outpath, prgfnam)
    dbgout   = False

    #Allowed kwds: outexcel='', showexcel=False, prgfile=None, dbgout=False
    xlsfile = gicdata.merge_data_excel(*xl_list, outexcel=outexcel, showexcel=showexcel,
                                       prgfile=prgfile, dbgout=dbgout)

    return xlsfile

#

# =====================

def run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):
    """ Use IEEE GIC Test Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.
Returns results in gicboj.
"""
    import psspy
    import arrbox.gic

    savfile = 'ieee_gic_test_case.sav'
    gicfile = 'ieee_gic_test_case.gic'

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    gicfile = os.path.join(datapath, gicfile)

    outdir = get_output_dir(outpath)

    if efield_type=='benchmark':
        efield_mag = 8.0
    else:
        efield_mag = 1.0

    efield_deg = 0.0

    outfnam   = _get_outfnam_event("ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    prgfile   = os.path.join(outdir, outfnam+'progress.txt')
    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')
    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')

    ejet_million_amps = 1.0
    ejet_halfwidth_km = 200.0
    ejet_period_min   = 5.0
    ejet_height_km    = 100.0
    ejet_center_deg   = 54.0

    earth_model_name = 'shield'

    efield_unit      = 'V/km'
    substation_r     = 0.1
    branch_xbyr      = 30.0
    transformer_xbyr = 30.0
    addfile          = ''
    addfile_optn     = 'rdch'
    purgfile         = ''
    rnwkfile         = ''

    basekv    = []  # specify subsystem options
    areas     = []
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    power_flow_optn  = ''   # specify power flow solution options
    pf_itmxn   = 100
    pf_toln    = 0.1
    pf_tap     = 0
    pf_area    = 0
    pf_phshft  = 0
    pf_dctap   = 1
    pf_swsh    = 1
    pf_flat    = 0
    pf_varlmt  = 99
    pf_nondiv  = 0

    psspy.psseinit()

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])
    psspy.alert_output(2,prgfile,[0,0])

    psspy.case(savfile)
    psspy.gic_read(gicfile)
    sid = 0
    busall = 1

    # run gic analysis
    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,
        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,
        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,
        efield_mag_local=0.0, efield_deg_local=0.0,
        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,
        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,
        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,
        power_flow_optn=power_flow_optn,
        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,
        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,
        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,
        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],
        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,
        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,
        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,
        pf_nondiv=pf_nondiv,
        )

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])
    psspy.alert_output(1,"",[0,0])

    return gicobj

#

# =====================

def run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder and run GIC calculations using arrbox.gic.GIC object.
Returns results in gicboj.
"""
    import psspy
    import arrbox.gic

    savfile = 'sample.sav'
    gicfile = 'sample_fv4.gic'

    outdir = get_output_dir(outpath)

    if not datapath: datapath = get_example_folder()

    savfile = os.path.join(datapath, savfile)
    gicfile = os.path.join(datapath, gicfile)

    if efield_type=='benchmark':
        efield_mag = 8.0
    else:
        efield_mag = 1.0

    efield_deg = 0.0

    outfnam   = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    prgfile   = os.path.join(outdir, outfnam+'progress.txt')
    pygicfile = os.path.join(outdir, outfnam+'_map.pygic')
    gictfile  = os.path.join(outdir, outfnam+'_gict.csv')

    ejet_million_amps = 1.0
    ejet_halfwidth_km = 200.0
    ejet_period_min   = 5.0
    ejet_height_km    = 100.0
    ejet_center_deg   = 54.0

    earth_model_name = 'shield'

    efield_unit      = 'V/km'
    substation_r     = 0.1
    branch_xbyr      = 30.0
    transformer_xbyr = 30.0
    addfile          = ''
    addfile_optn     = 'rdch'
    purgfile         = ''
    rnwkfile         = ''

    basekv    = []  # specify subsystem options
    areas     = []
    buses     = []
    owners    = []
    zones     = []
    tielevels = 0

    pf_itmxn   = 100    # specify power flow solution options
    pf_toln    = 0.1
    pf_tap     = 0
    pf_area    = 0
    pf_phshft  = 0
    pf_dctap   = 1
    pf_swsh    = 1
    pf_flat    = 0
    pf_varlmt  = 99
    pf_nondiv  = 0

    psspy.psseinit()

    psspy.lines_per_page_one_device(1,10000000)
    psspy.progress_output(2,prgfile,[0,0])

    print(savfile)
    print(gicfile)

    psspy.case(savfile)
    psspy.gic_read(gicfile)
    sid = 0
    busall = 1

    # run gic analysis
    gicobj = arrbox.gic.GIC(sid, busall, efield_mag=efield_mag, efield_deg=efield_deg,
        tielevels=tielevels, study_year=0, thermal_ana_optn=-1,
        substation_r=substation_r, branch_xbyr=branch_xbyr, transformer_xbyr=transformer_xbyr,
        efield_mag_local=0.0, efield_deg_local=0.0,
        branch_rac2rdc=1.0, transformer_rac2rdc=1.0,
        efield_type=efield_type, efield_unit=efield_unit, addfile_optn=addfile_optn,
        gic2mvar_optn='kfactors', earth_model_name=earth_model_name, scan_storm_event=scan_storm_event,
        power_flow_optn=power_flow_optn,
        ejet_million_amps=ejet_million_amps, ejet_halfwidth_km=ejet_halfwidth_km, ejet_period_min=ejet_period_min,
        ejet_height_km=ejet_height_km, ejet_center_deg=ejet_center_deg,
        addfile=addfile, purgfile=purgfile, rnwkfile=rnwkfile, pygicfile=pygicfile, gictfile=gictfile,
        basekv=basekv, areas=areas, buses=buses, owners=owners, zones=zones,
        basekv_local=[], areas_local=[], buses_local=[], owners_local=[], zones_local=[],
        pf_itmxn=pf_itmxn, pf_toln=pf_toln, pf_tap=pf_tap,
        pf_area=pf_area, pf_phshft=pf_phshft, pf_dctap=pf_dctap,
        pf_swsh=pf_swsh, pf_flat=pf_flat, pf_varlmt=pf_varlmt,
        pf_nondiv=pf_nondiv,
        )

    psspy.lines_per_page_one_device(2,10000000)
    psspy.progress_output(1,"",[0,0])

    return gicobj

#

# =====================

def run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, datapath=None, outpath=None):
    """ Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and create text report.
"""

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("ieee", efield_type, efield_mag, efield_deg, scan_storm_event)

    rptfile  = os.path.join(outdir, rptnam+'.txt')
    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')

    gicobj.text_report(rptfile)
    gicobj.qtotal_report(qrptfile)

    msg = " Report created in file: {:s}".format(rptfile)
    print(msg)

#

# =====================

def run_gic_ieee_text_report_DIY(datapath=None, outpath=None):
    """ Run GIC Analysis on IEEE GIC Test Case provided in PSSE Example folder and create customized report.
"""
    global _BIGREL

    import psspy
    _BIGREL = psspy.getdefaultreal()     # Largest real value

    efield_mag = 1.0
    efield_deg = 0.0
    efield_type = 'uniform'
    scan_storm_event = ''

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("DIY_ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    rptfile = os.path.join(outdir, rptnam+'.txt')

    rptfobj = open(rptfile, 'w')
    report  = rptfobj.write

    elecfld_mag = "{:10.2f}".format(gicobj.misc.efield_mag)
    elecfld_mag = elecfld_mag.strip()

    elecfld_unt = gicobj.misc.efield_unit

    elecfld_deg = "{:10.2f}".format(gicobj.misc.efield_deg)
    elecfld_deg = elecfld_deg.strip()

    txt  = "\n GMD Event: Uniform Electric Field, {} {}, {} deg\n".format(elecfld_mag, elecfld_unt, elecfld_deg)

    txt += "\n GIC data file: {}\n".format(gicobj.gicfile)
    txt += " Power flow data file: {}\n".format(gicobj.savfile)

    if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:
        txt += "\n Subsystem used for GIC studiies is defined as:\n"
        if gicobj.basekv: txt += "     Voltage = {}\n".format(str(gicobj.basekv))
        if gicobj.areas:  txt += "     Areas   = {}\n".format(str(gicobj.areas))
        if gicobj.buses:  txt += "     Buses   = {}\n".format(str(gicobj.buses))
        if gicobj.owners: txt += "     Owners  = {}\n".format(str(gicobj.owners))
        if gicobj.zones:  txt += "     Zones   = {}\n".format(str(gicobj.zones))
        txt += "     Subsystem Inter tie Levels = {}\n".format(gicobj.tielevels)
    else:
        txt += "\n Subsystem used for GIC studiies comprises entire network.\n"

    txt += "\n Number of buses in study subsystem        = {}\n".format(gicobj.misc.nbus_study)
    txt += " Number of substations in study subsystem  = {}\n".format(gicobj.misc.nsubstation_study)
    txt += " Number of branches in study subsystem     = {}\n".format(gicobj.misc.nbranch_study)
    txt += " Number of transformers in study subsystem = {}\n".format(gicobj.misc.ntransformer_study)
    report(txt)

    txt  = '\n Bus DC Voltages\n'
    txt += "    Bus Substation DC Voltage(V)\n"
    report(txt)

    buslist = list(gicobj.bus.keys())
    buslist.sort()
    for eachbus in buslist:
        # all of these work, shows how to use them
        #print "attr lower-->", eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts
        #print "dict lower-->", eachbus, gicobj.bus[eachbus]['substation'], gicobj.bus[eachbus]['dcvolts']
        #print "attr mixed-->", eachbus, gicobj.bus[eachbus].suBSTation, gicobj.bus[eachbus].dcVolts
        #print "dict mixed-->", eachbus, gicobj.bus[eachbus]['subStation'], gicobj.bus[eachbus]['DCvolts']
        txt = " {:6d}     {:6d}  {:12.5f}\n".format(eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts)
        report(txt)

    txt  = '\n Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground\n'
    txt += " Substation Name         Latitude(deg) Longitude(deg) DC Voltage(V)    GIC(Amps)\n"
    report(txt)

    sslist = list(gicobj.substation.keys())
    sslist.sort()
    for ss in sslist:
        txt = "     {:6d} {:12s}  {:12.6f}   {:12.6f}  {:12.5f} {:12.5f}\n".format(ss, gicobj.substation[ss].name,
                            gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,
                            gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic)
        report(txt)

    # Non-Transformer Branches
    txt  = '\n GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus\n'
    txt += " FromBus  ToBus Ckt  Distance(km) per-Phase(A)   3-Phase(A)\n"
    report(txt)

    brnlist = list(gicobj.branch.keys())
    brnlist.sort()
    for brn in brnlist:
        txt = "  {:6d} {:6d}  {:2s}  {:12.5f} {:12.5f} {:12.5f}\n".format(brn[0], brn[1], brn[2],
                            gicobj.branch[brn].distance, gicobj.branch[brn].gic,
                            3*gicobj.branch[brn].gic)
        report(txt)

    # Transformers
    trnlist = list(gicobj.transformer.keys())
    trnlist.sort()

    no_2wdg_nrml = "\n     No two winding transformers in GIC studied network.\n"
    no_2wdg_auto = "\n     No two winding auto transformers in GIC studied network.\n"
    no_3wdg_nrml = "\n     No three winding transformers in GIC studied network.\n"
    no_3wdg_auto = "\n     No three winding auto transformers in GIC studied network.\n"

    # Two Winding Transformers - normal
    txt  = '\n Two Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += "   Ibus   Jbus Ckt       Igic(A)      Jgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)

    for trn in trnlist:
        kbus  = trn[2]
        if kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if (autoi or autoj): continue

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(trn[0], trn[1], trn[3], igic, jgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_2wdg_nrml: no_2wdg_nrml=''

    if no_2wdg_nrml: report(no_2wdg_nrml)

    # Two Winding Transformers - auto
    txt  = '\n Two Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on Series Winding bus in power flow\n"
    txt += " Common Series Ckt Common gic(A) Series gic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)
    for trn in trnlist:
        kbus  = trn[2]
        if kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if ( (not autoi) or (not autoj) ): continue
        if autoi==1:
            ibus = trn[0]
            jbus = trn[1]
        else:
            ibus = trn[1]
            jbus = trn[0]

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:7.3f} {:s} {:s}\n".format(ibus, jbus, trn[3], igic, jgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_2wdg_auto: no_2wdg_auto=''

    if no_2wdg_auto: report(no_2wdg_auto)

    # Three Winding Transformers - normal
    txt  = '\n Three Winding Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += "   Ibus   Jbus   Kbus Ckt       Igic(A)      Jgic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)

    for trn in trnlist:
        kbus  = trn[2]
        if not kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        autok = gicobj.transformer[trn].wdg3_auto
        if (autoi or autoj or autok): continue

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d} {:6d}  {:2s}  {:s} {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(trn[0], trn[1], trn[2], trn[3], igic, jgic, kgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_3wdg_nrml: no_3wdg_nrml=''

    if no_3wdg_nrml: report(no_3wdg_nrml)

    # Three Winding Transformers - auto
    txt  = '\n Three Winding Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral\n'
    txt += " Reactive power loss, represented as constant current load on highest voltage bus in power flow\n"
    txt += " Common Series   Kbus Ckt Common gic(A) Series gic(A)      Kgic(A)    Effgic(A) Kfactor KftrTyp  Qloss(Mvar)\n"
    report(txt)
    for trn in trnlist:
        kbus  = trn[2]
        if not kbus: continue

        autoi = gicobj.transformer[trn].wdg1_auto
        autoj = gicobj.transformer[trn].wdg2_auto
        if ( (not autoi) or (not autoj) ): continue
        if autoi==1:
            ibus = trn[0]
            jbus = trn[1]
        else:
            ibus = trn[1]
            jbus = trn[0]

        igic    = _get_formatted_real_value(gicobj.transformer[trn].wdg1_gic)
        jgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg2_gic)
        kgic    = _get_formatted_real_value(gicobj.transformer[trn].wdg3_gic)
        effgic  = _get_formatted_real_value(gicobj.transformer[trn].eff_gic)
        qloss   = _get_formatted_real_value(gicobj.transformer[trn].qloss)

        kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

        txt = " {:6d} {:6d} {:6d}  {:2s}  {:s}  {:s} {:s} {:s} {:7.3f} {:s} {:s}\n".format(ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic,
                            gicobj.transformer[trn].kfactor, kftrtyp, qloss)
        report(txt)
        if no_3wdg_auto: no_3wdg_auto=''

    if no_3wdg_auto: report(no_3wdg_auto)

    # Total Qloss
    if no_2wdg_nrml:
        qwdg2_nrml = '        None'
    else:
        qwdg2_nrml = "{:12.5f} Mvar".format(gicobj.qtotal.wdg2_normal)
    if no_2wdg_auto:
        qwdg2_auto = '        None'
    else:
        qwdg2_auto = "{:12.5f} Mvar".format(gicobj.qtotal.wdg2_auto)
    if no_3wdg_nrml:
        qwdg3_nrml = '        None'
    else:
        qwdg3_nrml = "{:12.5f} Mvar".format(gicobj.qtotal.wdg3_normal)
    if no_3wdg_auto:
        qwdg3_auto = '        None'
    else:
        qwdg3_auto = "{:12.5f} Mvar".format(gicobj.qtotal.wdg3_auto)
    txt  = '\n Transformer Reactive Power Loss Summary\n'
    txt += ' Two Winding Transformers        = {:s}\n'.format(qwdg2_nrml)
    txt += ' Two Winding Auto Transformers   = {:s}\n'.format(qwdg2_auto)
    txt += ' Three Winding Transformers      = {:s}\n'.format(qwdg3_nrml)
    txt += ' Three Winding Auto Transformers = {:s}\n'.format(qwdg3_auto)
    txt += '                           Total = {:12.5f} Mvar\n'.format(gicobj.qtotal.total)
    report(txt)

    # done - close report file
    if rptfile:
        rptfobj.close()
        txt = "\n GIC analysis output report saved to file: {:s}\n".format(rptfile)
        sys.stdout.write(txt)

#

# =====================

def run_gic_ieee_excel_export_DIY(datapath=None, outpath=None, show=True):
    """ Use IEEE GIC Test Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.
"""
    import psspy
    import excelpy

    _BIGREL = psspy.getdefaultreal()     # Largest real value

    efield_mag = 1.0
    efield_deg = 0.0
    efield_type = 'uniform'
    scan_storm_event = ''

    gicobj = run_gic_ieee_test_case(efield_mag, efield_deg, efield_type, scan_storm_event, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("DIY_ieee", efield_type, efield_mag, efield_deg, scan_storm_event)
    xlsfile = os.path.join(outdir, rptnam)

    # What to export?
    overwritesheet = True
    do_sheets = ['optn', 'bus', 'sub', 'brn', 'trn']

    _EXPORT_QTY_GIC   = {
    'optn': 'options'     ,
    'bus' : 'bus'         ,
    'sub' : 'substation'  ,
    'brn' : 'branch'      ,
    'trn' : 'transformer' ,
    }

    _WORKSHT_SEQ_GIC = ['optn','bus','sub','brn','trn']

    _WORKSHT_COLUMN_LABELS_GIC = {
        'bus': ['Bus', 'Substation', 'DC Voltage(V)'],
        'sub': ['Substation', 'Name', 'Latitude(deg)', 'Longitude(deg)', 'DC Voltage(V)', 'GIC(Amps)'],
        'brn': ['FromBus', 'ToBus', 'Ckt', 'Distance(km)', 'per-Phase(A)', '3-Phase(A)'],
        'trn_nrml': ['Ibus', 'Jbus', 'Kbus', 'Ckt', 'Igic(A)', 'Jgic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],
        'trn_auto': ['Common', 'Series', 'Kbus', 'Ckt', 'Common gic(A)', 'Series gic(A)', 'Kgic(A)', 'Effgic(A)', 'Kfactor', 'KftrTyp', 'Qloss(Mvar)'],
        }

    _WORKSHT_INFO_TXT_GIC = {
        'bus': ['Bus DC Voltages'],
        'sub': ['Substations DC Voltages and GIC Flows, flowing from Bus to Substation Ground'],
        'brn': ['GIC flow in Non-Transformer Branches, flowing from From Bus to To Bus'],
        'trn_nrml': ['Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',
                     'Reactive power loss, represented as constant current load on highest voltage bus in power flow'],
        'trn_auto': ['Auto Transformers: Per Phase GIC flow in windings, flowing from winding Bus to Neutral',
                     'Reactive power loss, represented as constant current load on Series Winding bus in power flow'],
        }

    gicshts = []
    for each in _WORKSHT_SEQ_GIC:
        if each in do_sheets:
            if each=='trn':
                gicshts.extend( [ _EXPORT_QTY_GIC[each], 'auto '+_EXPORT_QTY_GIC[each] ] )
            else:
                gicshts.append(_EXPORT_QTY_GIC[each])

    for i, shtnam in enumerate(gicshts):
        if i==0:
            xlsobj = excelpy.workbook(xlsfile, shtnam, overwritesheet=overwritesheet)
            if show:
                xlsobj.show()
            else:
                xlsobj.hide()

            xlsobj.show_alerts(0) # do not show pop-up alerts
            xlsfnam = xlsobj.XLSFNAM
        else:
            xlsobj.worksheet_add_end(shtnam, overwritesheet=overwritesheet)
        xlsobj.page_format(orientation="landscape",left=1.0,right=1.0,
                           top=0.5,bottom=0.5,header=0.25,footer=0.25)
        xlsobj.page_footer(left='page number of page total', right='date, time')
        xlsobj.page_header(center='file name:sheet name')
        xlsobj.font_sheet()

    if not xlsobj:
        print("Excel file and worksheets not created.\n")

    # Options
    do_key = 'optn'
    if do_key in do_sheets:

        elecfld_mag = "{:10.2f}".format(gicobj.misc.efield_mag)
        elecfld_mag = elecfld_mag.strip()

        elecfld_unt = gicobj.misc.efield_unit

        elecfld_deg = "{:10.2f}".format(gicobj.misc.efield_deg)
        elecfld_deg = elecfld_deg.strip()

        txt  = "\n GMD Event: Uniform Electric Field, {:s} {:s}, {:s} deg\n".format(elecfld_mag, elecfld_unt, elecfld_deg)

        txt += "\n GIC data file: {:s}\n".format(gicobj.gicfile)
        txt += " Power flow data file: {:s}\n".format(gicobj.savfile)

        if gicobj.basekv or gicobj.areas or gicobj.buses or gicobj.owners or gicobj.zones:
            txt += "\n Subsystem used for GIC studies is defined as:\n"
            if gicobj.basekv: txt += "     Voltage = {:s}\n".format(str(gicobj.basekv))
            if gicobj.areas:  txt += "     Areas   = {:s}\n".format(str(gicobj.areas))
            if gicobj.buses:  txt += "     Buses   = {:s}\n".format(str(gicobj.buses))
            if gicobj.owners: txt += "     Owners  = {:s}\n".format(str(gicobj.owners))
            if gicobj.zones:  txt += "     Zones   = {:s}\n".format(str(gicobj.zones))
            txt += "     Subsystem Inter tie Levels = {:d}\n".format(gicobj.tielevels)
        else:
            txt += "\n Subsystem used for GIC studies comprises entire network.\n"

        txt += "\n Number of buses in study subsystem        = {:d}\n".format(gicobj.misc.nbus_study)
        txt += " Number of substations in study subsystem  = {:d}\n".format(gicobj.misc.nsubstation_study)
        txt += " Number of branches in study subsystem     = {:d}\n".format(gicobj.misc.nbranch_study)
        txt += " Number of transformers in study subsystem = {:d}\n".format(gicobj.misc.ntransformer_study)

        optnlist = txt.split("\n")

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br, rc = 1, 1
        br, rc = xlsobj.set_range(br, rc, optnlist, transpose=True)

    # DC Bus voltages
    do_key = 'bus'
    if do_key in do_sheets:
        buslist = list(gicobj.bus.keys())
        buslist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for eachbus in buslist:
            tlst = [eachbus, gicobj.bus[eachbus].substation, gicobj.bus[eachbus].dcvolts]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")

    # Substation
    do_key = 'sub'
    if do_key in do_sheets:
        sslist = list(gicobj.substation.keys())
        sslist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for ss in sslist:
            tlst = [ss, gicobj.substation[ss].name, gicobj.substation[ss].latitude, gicobj.substation[ss].longitude,
                    gicobj.substation[ss].dcvolts, gicobj.substation[ss].gic]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")

    # Non-Transformer Branches
    do_key = 'brn'
    if do_key in do_sheets:
        brnlist = list(gicobj.branch.keys())
        brnlist.sort()
        rowdata = [_WORKSHT_COLUMN_LABELS_GIC[do_key]]
        for brn in brnlist:
            tlst = [brn[0], brn[1], brn[2], gicobj.branch[brn].distance, gicobj.branch[brn].gic,3*gicobj.branch[brn].gic]
            rowdata.append(tlst)

        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 3, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata)
        del rowdata
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key][0],fontStyle="bold",fontSize=12, fontColor="blue")

    # Transformers
    do_key = 'trn'
    if do_key in do_sheets:
        do_key_nrml = 'trn_nrml'
        do_key_auto = 'trn_auto'

        trnlist = list(gicobj.transformer.keys())
        trnlist.sort()

        rowdata_nrml = [_WORKSHT_COLUMN_LABELS_GIC[do_key_nrml]]
        rowdata_auto = [_WORKSHT_COLUMN_LABELS_GIC[do_key_auto]]

        for trn in trnlist:
            kbus  = trn[2]
            igic  = gicobj.transformer[trn].wdg1_gic
            jgic  = gicobj.transformer[trn].wdg2_gic
            if kbus:
                kgic = gicobj.transformer[trn].wdg3_gic
            else:
                kgic = None

            effgic  = gicobj.transformer[trn].eff_gic
            qloss   = gicobj.transformer[trn].qloss
            kftr    = gicobj.transformer[trn].kfactor
            kftrtyp = gicobj._get_kfactor_type(gicobj.transformer[trn].kfactor_type)

            autoi = gicobj.transformer[trn].wdg1_auto
            autoj = gicobj.transformer[trn].wdg2_auto
            if autoi or autoj:
                if autoi==1:
                    ibus = trn[0]
                    jbus = trn[1]
                else:
                    ibus = trn[1]
                    jbus = trn[0]
            else:
                ibus = trn[0]
                jbus = trn[1]

            if igic:
                if igic>=_BIGREL: igic = ''
            else:
                igic = ''

            if jgic:
                if jgic>=_BIGREL: jgic = ''
            else:
                jgic = ''

            if kgic:
                if kgic>=_BIGREL: kgic = ''
            else:
                kgic = ''

            if effgic:
                if effgic>=_BIGREL: effgic = ''
            else:
                effgic = ''

            if qloss:
                if qloss>=_BIGREL: qloss = ''
            else:
                qloss = ''

            tlst = [ibus, jbus, kbus, trn[3], igic, jgic, kgic, effgic, kftr, kftrtyp, qloss]
            if autoi or autoj:
                rowdata_auto.append(tlst)
            else:
                rowdata_nrml.append(tlst)

        # Total Qloss
        txt  = ' Transformer Reactive Power Loss Summary\n'
        txt += ' Two Winding Transformers        = {:g} Mvar\n' .format(gicobj.qtotal.wdg2_normal)
        txt += ' Two Winding Auto Transformers   = {:g} Mvar\n' .format(gicobj.qtotal.wdg2_auto)
        txt += ' Three Winding Transformers      = {:g} Mvar\n' .format(gicobj.qtotal.wdg3_normal)
        txt += ' Three Winding Auto Transformers = {:g} Mvar\n' .format(gicobj.qtotal.wdg3_auto)
        txt += '                           Total = {:g} Mvar'   .format(gicobj.qtotal.total)
        qlosslist = txt.split("\n")

        # normal transformers
        xlsobj.set_active_sheet(_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 4, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata_nrml)
        del rowdata_nrml
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][0],fontStyle="bold",fontSize=12, fontColor="blue")
        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_nrml][1],fontStyle="bold",fontSize=12, fontColor="blue")

        br, rc = br+2, 1
        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)

        # auto transformers
        xlsobj.set_active_sheet('auto '+_EXPORT_QTY_GIC[do_key])
        br0, rc0 = 4, 1
        br, rc = xlsobj.set_range(br0, rc0, rowdata_auto)
        del rowdata_auto
        xlsobj.autofit_columns((br0,rc0,br0,rc))
        xlsobj.font_color((br0,rc0,br0,rc),"red")
        xlsobj.align_rows((br0, rc0),alignv='right')    #label row
        xlsobj.set_cell((1,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][0],fontStyle="bold",fontSize=12, fontColor="blue")
        xlsobj.set_cell((2,1),_WORKSHT_INFO_TXT_GIC[do_key_auto][1],fontStyle="bold",fontSize=12, fontColor="blue")

        br, rc = br+2, 1
        br, rc = xlsobj.set_range(br, rc, qlosslist, transpose=True)

    # done exporting
    xlsobj.save(xlsfile)

    if not show:
        txt = "\n GIC analysis output report saved to file: \n    {0}\n".format(xlsobj.XLSFNAM)
        xlsobj.close()
        sys.stdout.write(txt)

#

# =====================

def run_gic_sample_text_report(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder, run GIC calculations and create text report.
"""

    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    if power_flow_optn:  rptnam += '_pf'

    rptfile  = os.path.join(outdir, rptnam+'.txt')
    qrptfile = os.path.join(outdir, rptnam+'_qloss.txt')

    gicobj.text_report(rptfile)
    gicobj.qtotal_report(qrptfile)

    msg = "\n Report created in file: {:s}".format(rptfile)
    print(msg)

#

# =====================

def run_gic_sample_excel_export(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, show=True,
                                datapath=None, outpath=None):
    """ Use sample Case provided in PSSE Example folder, run GIC calculations and export results to spreadsheet.
"""
    gicobj = run_gic_sample_case(efield_mag, efield_deg, efield_type, scan_storm_event, power_flow_optn, datapath, outpath)

    if gicobj.ierr: return

    outdir = get_output_dir(outpath)
    rptnam = _get_outfnam_event("sample", efield_type, efield_mag, efield_deg, scan_storm_event)
    if power_flow_optn:  rptnam += '_pf'

    xlfile = os.path.join(outdir, rptnam)
    string = ''
    overwritesheet = True
    xlfile = gicobj.excel_export(string, xlfile, show, overwritesheet)

    msg = "\n Spreadsheet created in file:\n    {0}".format(xlfile)
    print(msg)

#

# =====================

def gic_results_on_network_map(pygicfile, outpath=None, outfext='.pdf', show=True):
    """ Plot GIC results on map.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()     # To use PSSE, numpy and matplotlib, this is needed.
    import arrbox.gicmaps

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(pygicfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(pygicfile):
            pygicfile = os.path.join(outdir, pygicfile)

    pltfiles = collections.OrderedDict()
    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',
              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:
        if outfext=='.pdf':
            pltfiles[k] = None
        else:
            fnam = "{}_{}{}".format(pyfnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    gicmapsobj  = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(pyfnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        gicmapsobj.pdf_open(pdffile)

    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_base'], case='base', limit='min', markersize=100)

    gicmapsobj.plot_bus_voltages(figfile=pltfiles['busvpu_gic'], case='gic', limit='min', markersize=100)

    # combine substations GICs flowing in and out on one legend
    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic1'], markersize=20)

    # separate substations GICs flowing in and out on two legends
    gicmapsobj.set_legend_options_ss_gic_values(loc=None)
    gicmapsobj.plot_substation_gicflows(figfile=pltfiles['ssgic2'], markersize=20)

    gicmapsobj.plot_branch_gicflows(figfile=pltfiles['brngic'])

    gicmapsobj.plot_qtotal(figfile=pltfiles['qtline'])

    gicmapsobj.plot_qtotal_barchart(figfile=pltfiles['qtbar'])

    gicmapsobj.plot_effgic(figfile=pltfiles['effgic'], gicmax=False)

    gicmapsobj.plot_effgic(figfile=pltfiles['effgicmax'], gicmax=True)

    if show:
        gicmapsobj.plots_show()
    else:
        gicmapsobj.plots_close()

    if outfext=='.pdf':
        gicmapsobj.pdf_close()

    if outfext=='.pdf':
        msg  = "\n GIC analysis custom plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC analysis custom plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()   # To use PSSE, numpy and matplotlib, this is needed.

#

# =====================

def gic_results_on_network_map_custom(pygicfile, outpath=None, outfext='.pdf', show=True):
    """ Plot GIC results on map with custom legends, annotations.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()
    import arrbox.gicmaps

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(pygicfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(pygicfile):
            pygicfile = os.path.join(outdir, pygicfile)

    outnam  = '{}_custom'.format(pyfnam)

    pltfiles = collections.OrderedDict()
    for k in ['busvpu_base','busvpu_gic', 'ssgic1', 'ssgic2', 'brngic',
              'qtline', 'qtline', 'qtbar', 'effgic', 'effgicmax']:
        if outfext!='.pdf':
            fnam = "{}_{}{}".format(outnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    gicmapsobj = arrbox.gicmaps.GICMAPS(pygicfile)

    if gicmapsobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(outnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        pdf2fobj = gicmapsobj.pdf2_open(pdffile)  # open pdf2 object to save custom plots to pdf file

    gicmapsobj.set_figure_size(6,4.8)

    gicmapsobj.set_state_boundary_options(show=True, color='#CCCCCC', linewidth=1.0)
    gicmapsobj.set_latitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 1], fontsize=10)
    gicmapsobj.set_longitude_options(show=True, color='#CCFFFF', linewidth=2.0, dashes=[1, 3], fontsize=10)

    gicmapsobj.annotate_substations([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18], color='blue', fontsize=10)

    # Plot1 - GIC case bus voltage
    pf_flag = gicmapsobj.pygicobj.power_flow_solution_flag
    if pf_flag==0:
        case = 'gic'
        if outfext!='.pdf': figfile = pltfiles['busvpu_gic']
        ttl = 'Bus Voltages - GIC Case'
    else:
        case = 'base'
        if outfext!='.pdf': figfile = pltfiles['busvpu_base']
        ttl = 'Bus Voltages - Base Case'
    ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None, case=case, limit='min', markersize=100,
                                 title=ttl)
    if ax is None:
        if outfext=='.pdf':
            gicmapsobj.pdf_close()
        return

    # data point annotation
    anptobj.set_options(xytext=(-15,-40), textcoords='offset points')
    anptobj.set_annote_from_key(5)                          # use SS number as key
    #anptobj.set_annote_from_key('ss05_mississippi')        # use SS name as key
    anptobj.set_options(xytext=(-40,-100), textcoords='offset points')
    anptobj.set_annote_from_key(7)                          # use SS number as key
    #anptobj.set_annote_from_key('ss07_yukon')
    anptobj.set_options(xytext=(-20,25), textcoords='offset points')
    anptobj.set_annote_from_key(13)                         # use SS number as key
    #anptobj.set_annote_from_key('ss13_oxus')               # use SS number as key
    anptobj.set_options(xytext=(-40,25), textcoords='offset points')
    #anptobj.set_annote_from_key(15)                        # use SS number as key
    anptobj.set_annote_from_key('ss15_heilong')             # use SS number as key

    # custom annotation
    gicmapsobj.annotate_text('LabelLeft', -89, 30.2, ax, basemap, xycoords='long_lat', color='cyan', fontsize=15)
    x, y = gicmapsobj.datapoint_xy_from_longitude_latiude(basemap, -84, 30.2)
    gicmapsobj.annotate_text('LabelRight', x, y, ax, basemap, xycoords='data', color='magenta', fontsize=15)

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)               # add custom plot to pdf file
    else:
        fig.savefig(figfile, dpi=300, bbox_inches='tight')   # save custom plot to file

    # Plot2 - Base case bus voltage
    if pf_flag==0:
        ax, fig, basemap, anptobj = gicmapsobj.plot_bus_voltages(figfile=None,  case='base', limit='min', markersize=100,
                                     title='Bus Voltages - Base Case')
        anptobj.set_options(xytext=(-50,-50), textcoords='offset points')
        anptobj.set_annote_from_key(15)

        if outfext=='.pdf':
            gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
        else:
            fig.savefig(pltfiles['busvpu_base'], dpi=300, bbox_inches='tight')

    # Plot3 - substations GICs (combine GICs flowing in and out on one legend)
    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)

    anptobj.set_options(xytext=(-65,40), textcoords='offset points')
    anptobj.set_annote_from_key('ss01_nile')
    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')
    anptobj.set_annote_from_key('ss02_yangtze')
    anptobj.set_options(xytext=(-60,-70), textcoords='offset points')
    anptobj.set_annote_from_key('ss03_arkansas')
    anptobj.set_options(xytext=(-20,-35), textcoords='offset points')
    anptobj.set_annote_from_key('ss09_indus')

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['ssgic1'], dpi=300, bbox_inches='tight')

    # Plot4 - substations GICs (separate GICs flowing in and out on two legends)
    gicmapsobj.set_legend_options_ss_gic_values(loc=None)
    ax, fig, basemap, anptobj = gicmapsobj.plot_substation_gicflows(figfile=None, markersize=20)
    anptobj.set_options(xytext=(-50,-50), textcoords='offset points')
    anptobj.set_annote_from_key(1)
    anptobj.set_annote_from_key(3)
    anptobj.set_annote_from_key(8)

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['ssgic2'], dpi=300, bbox_inches='tight')

    # Plot5 - Effective GIC
    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=False)
    anptobj.set_options(xytext=(-30,-30), textcoords='offset points')
    anptobj.set_annote_from_key('catdog_xmer')          # use transformer name as key
    anptobj.set_annote_from_key((3018, 3008, '11'))     # use transformer id tuple: (wdg1bus, wdg2bus, 'ckt')
                                                        # or (wdg1bus, wdg2bus, wdg3bus, 'ckt')
    anptobj.set_options(xytext=(-65,30), textcoords='offset points')
    anptobj.set_annote_from_key((203, 202, 't7'))

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['effgic'], dpi=300, bbox_inches='tight')

    # Plot6 - Maximum Effective GIC
    ax, fig, anptobj = gicmapsobj.plot_effgic(figfile=None, gicmax=True)
    anptobj.set_options(xytext=(-30,-40), textcoords='offset points')
    anptobj.set_annote_from_key('catdog_xmer')
    anptobj.set_options(xytext=(-30,-60), textcoords='offset points')
    anptobj.set_annote_from_key(('urb tx'))
    anptobj.set_options(xytext=(-10,20), textcoords='offset points')
    anptobj.set_annote_from_key(('mid ltc'))

    if outfext=='.pdf':
        gicmapsobj.pdf2_add_figure(pdf2fobj, fig)
    else:
        fig.savefig(pltfiles['effgicmax'], dpi=300, bbox_inches='tight')

    if show:
        gicmapsobj.plots_show()
    else:
        gicmapsobj.plots_close()

    if outfext=='.pdf':
        gicmapsobj.pdf2_close(pdf2fobj)

    if outfext=='.pdf':
        msg  = "\n GIC analysis custom plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC analysis custom plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()

#

# =====================

def gict_result_plots(gictfile, outpath=None, top_trn=10, nrows=2, ncols=2, outfext='.pdf', show=True):
    """ Plot GIC Thermal results.
top_trn - plot so many transformers with maximum GICs
nrows   - numbers of rows in plot figure
ncols   - numbers of columns in plot figure
nrows X ncols subplots are drawn on one figure.
"""
    import collections
    import psspy

    psspy.set_fpcw_py()
    import arrbox.gicthermal

    outdir = get_output_dir(outpath)

    p, nx = os.path.split(gictfile)
    pyfnam, x = os.path.splitext(nx)

    if not p:
        if not os.path.exists(gictfile):
            gictfile = os.path.join(outdir, gictfile)

    outnam  = '{}'.format(pyfnam)

    pltfiles = collections.OrderedDict()
    for k in ['evt','trn']:
        if outfext=='.pdf':
            pltfiles[k] = None
        else:
            fnam = "{}_{}{}".format(outnam, k, outfext)
            pltfiles[k] = os.path.join(outdir, fnam)

    thermalobj = arrbox.gicthermal.GICTHERMAL(gictfile)

    if thermalobj.ierr: return

    if outfext=='.pdf':
        fnam = "{}_allplots{}".format(outnam, outfext)
        pdffile = os.path.join(outdir, fnam)
        thermalobj.pdf_open(pdffile)

    evtnamlst, figdict, axdict = thermalobj.plot_events(figfile=pltfiles['evt'], show=show)

    figlst, axdict = thermalobj.plot_transformer_gict(figfile=pltfiles['trn'], top=top_trn, nrows=nrows, ncols=ncols, show=show)

    if show:
        thermalobj.plots_show()
    else:
        thermalobj.plots_close()

    if outfext=='.pdf':
        thermalobj.pdf_close()

    if outfext=='.pdf':
        msg  = "\n GIC Transformer Thermal GICT(t) profile plots saved in file:\n    {}\n".format(pdffile)
    else:
        msg  = "\n GIC Transformer Thermal GICT(t) profile plot [{}] files saved in folder:\n    {}\n".format(outfext, outdir)

    print(msg)
    psspy.set_fpcw_psse()

#

# =====================

def run_all_tests(datapath=None, outpath=None, efields='ubn', scan='d', pf='fdns', outfext='.pdf'):

    outdir = get_output_dir(outpath)

    efield_type_lst = []
    scan_lst = []
    pf_lst = []

    if efields:
        s_efld = efields.lower()
        if 'u' in s_efld: efield_type_lst.append('uniform')
        if 'b' in s_efld: efield_type_lst.append('benchmark')
        if 'n' in s_efld: efield_type_lst.append('nonuniform')

    if scan:
        s_scan = scan.lower()
        if 'd' in s_scan: scan_lst.append('scan_deg')
        if 'm' in s_scan: scan_lst.append('scan_mag')
        if 'd_m' in s_scan: scan_lst.append('scan_d_m')

    if pf:
        pf_lst.append(pf)

    if not efield_type_lst: efield_type_lst = ['uniform']
    if not scan_lst: scan_lst = ['']
    if not pf_lst: pf_lst = ['']

    #

# =====================

print ("\n >>>>>>>>>>>>> Running create_gicdata_template_sample")
    excelfile = create_gicdata_template_sample(datapath, outpath, showexcel=False)

    print ("\n >>>>>>>>>>>>> Running excel2gicfile")
    gicdata_excel2gicfile(outpath)

    efield_mag = 1.0
    efield_deg = 0.0

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_text_report")
    for efield_type in efield_type_lst:
        for scan_storm_event in scan_lst:
            run_gic_ieee_text_report(efield_mag, efield_deg, efield_type, scan_storm_event,datapath, outpath)
            break

    print ("\n >>>>>>>>>>>>> Running run_gic_sample_text_report")
    for efield_type in efield_type_lst:
        for scan_storm_event in scan_lst:
            for power_flow_optn in pf_lst:
                run_gic_sample_text_report(efield_mag, efield_deg, efield_type,
                                           scan_storm_event, power_flow_optn, datapath, outpath)
                break

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_text_report_DIY")
    run_gic_ieee_text_report_DIY(datapath, outpath)

    print ("\n >>>>>>>>>>>>> Running run_gic_ieee_excel_export_DIY")
    run_gic_ieee_excel_export_DIY(datapath, outpath, show=False)

    print ("\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, no scan, no powerflow")
    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='',
                                power_flow_optn='',     show=False, datapath=datapath, outpath=outpath)

    print ("\n >>>>>>>>>>>>> Running run_gic_sample_excel_export, uniform, scan_deg, fdns")
    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform', scan_storm_event='scan_deg',
                                power_flow_optn='fdns', show=False, datapath=datapath, outpath=outpath)

    pygicfile = ''
    for fnam in os.listdir(outdir):
        n, x = os.path.splitext(fnam)
        if x=='.pygic':
            i = n.find('sample')
            if i>=0:
                pygicfile = os.path.join(outdir, fnam)
                break

    print ("\n >>>>>>>>>>>>> Running gic_results_on_network_map")
    if pygicfile:
        gic_results_on_network_map(pygicfile, outpath, outfext=outfext, show=False)
    else:
        print ("    mapdata file does not exist.\n    {}\n".format(pygicfile))

    print ("\n >>>>>>>>>>>>> Running gic_results_on_network_map_custom")
    if pygicfile:
        gic_results_on_network_map_custom(pygicfile, outpath, outfext=outfext, show=False)
    else:
        print ("    mapdata file does not exist.\n    {}\n".format(pygicfile))

    gictfile = ''
    for fnam in os.listdir(outdir):
        n, x = os.path.splitext(fnam)
        if x=='.csv':
            i = n.find('sample')
            if i>=0:
                gictfile = os.path.join(outdir, fnam)
                break

    print ("\n >>>>>>>>>>>>> Running gicthermal")
    if gictfile:
        gict_result_plots(gictfile, outpath, outfext=outfext, show=False)
    else:
        print ("    GIC results gict CSV file does not exist.\n")

#

# =====================

def run_gicdata_templates(outpath=None):
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[], showexcel=True)
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = create_gicdata_template_sample(outpath=outpath, areas=[4,5,6], showexcel=False)

#

# =====================

def run_gicdata_transfer(outpath=None):
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[], showexcel=False)
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = transfer_gicdata_sample(outpath=outpath, areas=[4,5,6], showexcel=False)

#

# =====================

def run_gicdata_gicfile2excel(outpath=None):
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[], showexcel=False)
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[1,2,3], showexcel=False)
    excelfile = gicdata_gicfile2excel(outpath=outpath, areas=[4,5,6], showexcel=False)

#

# =====================

def _run_one_test():

    # Run these one by one in __main__ (just copy each line in __main__ and run).
    #
    # - Function create_gicdata_template_sample() must be run before running gicdata_excel2gicfile().
    # - Functions run_gic_ieee_text_report(..) and run_gic_sample_text_report(..) return pygicfile name.
    #   Use that as input to gic_results_on_network_map(..) and gic_results_on_network_map_custom(..).

    # GIC data tests
    run_gicdata_templates()
    run_gicdata_transfer()
    run_gicdata_excel2gicfile()
    run_gicdata_gicfile2excel()
    run_gicdata_merge()

    # GIC calculation tests
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg')
    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='')
    run_gic_ieee_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg')    # scan not allowed, so does not scan

    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',    scan_storm_event='scan_deg', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_deg', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_mag', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark',  scan_storm_event='scan_d_m', power_flow_optn='fdns')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='',         power_flow_optn='')
    run_gic_sample_text_report(efield_mag=1.0, efield_deg=0.0, efield_type='nonuniform', scan_storm_event='scan_deg', power_flow_optn='fdns') # scan not allowed, so does not scan

    run_gic_ieee_text_report_DIY()
    run_gic_ieee_excel_export_DIY(show=True)

    run_gic_sample_excel_export(efield_mag=1.0, efield_deg=0.0, efield_type='uniform',   scan_storm_event='',         power_flow_optn='',     show=True)
    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_deg', power_flow_optn='fdns', show=True)
    run_gic_sample_excel_export(efield_mag=8.0, efield_deg=0.0, efield_type='benchmark', scan_storm_event='scan_d_m', power_flow_optn='fdns', show=True)

    pygicfile = r"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic"
    gic_results_on_network_map(pygicfile, show=False)

    pygicfile = r"sample_b_8(mag)_0(deg)_scan_d_m_map(deg).pygic"
    gic_results_on_network_map_custom(pygicfile, show=False)

    #

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- call function
    Run various functions from this file as desired.
    Refer test1(..) ... functions towards end of this file.
'''

"""
Use any of these keywords to run har_analysis_2.
Keyword     Default     Description
                      # INTGAR[]
fscanoptn   = 1       # 1 frequency scan option: 0 no; =1 yes
dstnoptn    = 1       # 2 distortion calculations option: 0 no; =1 yes

linmdl      = 0       # 3 line model option:  =0 nominal pi; =1 long line with skin effect;
                      #                       =2 long line but no skin effect
dstnbuop    = 0       # 4 bus option in dstn: =0 all buses; =1 only study subsystem buses
dstnrptop   = 0       # 5 bus option in dstn: =0 only THDs; =1 THDs + contributions
imachimpop  = 0       # 6 induction machine impedance option =0 from power flow data; =1 from sequene data
dcimpop     = 0       # 7 2TDC, VSCDC and MTDC equivalent impedance option in fscan =0 block; 1=consider
triplenop   = 0       # 8 Triplen Harmonics Option in distortion calculations =0 ignore; =1 consider
genimpop    = 0       # 9 generatir impedance option:  =0 Use ZSORCE impedance from power flow data
                      #                                =1 Use subtransient impedance from sequence data
                      #                                =2 Use transient impedance from sequence data
                      #                                =3 Use synchronous impedance from sequence data
                      #                                =4 Use negative sequence impedance from sequence data
mdltypop    = 0       # 10 harmonics Model Type Option, allowed 0 or 1
load_mdltyp = 0       # 11 load model type
gen_mdltyp  = 0       # 12 gen model type
brnsh_mdltyp= 0       # 13 branch shunt model type
trn_mdltyp  = 0       # 14 trn model type
fctsh_mdltyp= 0       # 15 facts shunt model type
fctse_mdltyp= 0       # 16 facts series model type
imach_mdltyp= 0       # 17 induction machine model type

                      # REALAR[]
hord_min    =  0.1    # 1 Minimum Harmonic Order
hord_max    = 50.0    # 2 Maximum Harmonic Order
hord_stp    =  0.1    # 3 Harmonic Order Step
                      # FILEAR[]
hrsfile     = ''      # 1 Binary Results File Name (.hrs)
dstnfile    = ''      # 2 Distortion Calculation Report File Name (.txt)
resnfile    = ''      # 3 Frequency Scan Resonance Report File Name (.txt)
"""

import sys, os, math, traceback, textwrap

_COLOR_PREFERENCE = ['orange', 'green', 'blue', 'red']
_COLOR_PREFERENCE_BUS = ['red', 'blue']
_ALLOWED_FIG_FILE_TYPES = ['eps', 'jpeg', 'jpg', 'pdf', 'pgf', 'png', 'ps', 'raw', 'rgba', 'svg', 'svgz', 'tif', 'tiff']

#

# =====================

# This data is from file CASE1TB.XLS of IEEE Task Force on Harmonics Modeling & Simulation
# Frequency Scan Thevenin Impedance
# Distributed Line Model: ZRdist, ZXdist, Zdist
# Pi Line Model: Zpi

#    HORD       , ZRdist        ,  ZXdist       , Zdist , Zpi
_ieee_tf_scan_results = [
    [1.00	, 0.0534	, 0.2197	, 0.226	, 0.226  ],
    [1.33	, 0.0793	, 0.3239	, 0.334	, 0.334  ],
    [1.67	, 0.1371	, 0.4711	, 0.491	, 0.492  ],
    [2.00	, 0.2075	, 0.5667	, 0.603	, 0.606  ],
    [2.33	, 0.5381	, 0.9926	, 1.129	, 1.136  ],
    [2.67	, 1.7230	, 1.1320	, 2.062	, 2.081  ],
    [3.00	, 2.0150	, -0.9333	, 2.221	, 2.217  ],
    [3.33	, 0.7628	, -1.0731	, 1.317	, 1.312  ],
    [3.67	, 0.3951	, -0.7590	, 0.856	, 0.855  ],
    [4.00	, 0.3626	, -0.5387	, 0.649	, 0.652  ],
    [4.33	, 0.3141	, -0.7507	, 0.814	, 0.806  ],
    [4.67	, 0.0891	, -0.5594	, 0.566	, 0.564  ],
    [5.00	, 0.0570	, -0.4405	, 0.444	, 0.443  ],
    [5.33	, 0.0460	, -0.3673	, 0.370	, 0.370  ],
    [5.67	, 0.0430	, -0.3170	, 0.320	, 0.320  ],
    [6.00	, 0.0378	, -0.2885	, 0.291	, 0.291  ],
    [6.33	, 0.0219	, -0.2551	, 0.256	, 0.256  ],
    [6.67	, 0.0166	, -0.2223	, 0.223	, 0.224  ],
    [7.00	, 0.0144	, -0.1957	, 0.196	, 0.197  ],
    [7.33	, 0.0131	, -0.1732	, 0.174	, 0.175  ],
    [7.67	, 0.0122	, -0.1537	, 0.154	, 0.155  ],
    [8.00	, 0.0116	, -0.1364	, 0.137	, 0.138  ],
    [8.33	, 0.0112	, -0.1211	, 0.122	, 0.123  ],
    [8.67	, 0.0105	, -0.1076	, 0.108	, 0.109  ],
    [9.00	, 0.0091	, -0.0949	, 0.095	, 0.096  ],
    [9.33	, 0.0077	, -0.0823	, 0.083	, 0.084  ],
    [9.67	, 0.0072	, -0.0702	, 0.071	, 0.071  ],
    [10.00	, 0.0071	, -0.0593	, 0.060	, 0.060  ],
    [10.33	, 0.0067	, -0.0498	, 0.050	, 0.050  ],
    [10.67	, 0.0051	, -0.0409	, 0.041	, 0.041  ],
    [11.00	, 0.0029	, -0.0311	, 0.031	, 0.031  ],
    [11.33	, 0.0014	, -0.0207	, 0.021	, 0.021  ],
    [11.67	, 0.0008	, -0.0105	, 0.011	, 0.010  ],
    [12.00	, 0.0007	, -0.0009	, 0.001	, 0.001  ],
    [12.33	, 0.0007	, 0.0081	, 0.008	, 0.008  ],
    [12.67	, 0.0008	, 0.0168	, 0.017	, 0.017  ],
    [13.00	, 0.0008	, 0.0251	, 0.025	, 0.025  ],
    [13.33	, 0.0009	, 0.0331	, 0.033	, 0.033  ],
    [13.67	, 0.0010	, 0.0410	, 0.041	, 0.041  ],
    [14.00	, 0.0010	, 0.0487	, 0.049	, 0.049  ],
    [14.33	, 0.0010	, 0.0562	, 0.056	, 0.057  ],
    [14.67	, 0.0010	, 0.0636	, 0.064	, 0.065  ],
    [15.00	, 0.0010	, 0.0709	, 0.071	, 0.072  ],
    [15.33	, 0.0010	, 0.0782	, 0.078	, 0.080  ],
    [15.67	, 0.0009	, 0.0855	, 0.085	, 0.087  ],
    [16.00	, 0.0009	, 0.0927	, 0.093	, 0.095  ],
    [16.33	, 0.0009	, 0.0998	, 0.100	, 0.102  ],
    [16.67	, 0.0009	, 0.1070	, 0.107	, 0.110  ],
    [17.00	, 0.0010	, 0.1141	, 0.114	, 0.117  ],
    [17.33	, 0.0010	, 0.1213	, 0.121	, 0.124  ],
    [17.66	, 0.0010	, 0.1285	, 0.129	, 0.132  ],
    [18.00	, 0.0010	, 0.1357	, 0.136	, 0.139  ],
    [18.33	, 0.0011	, 0.1430	, 0.143	, 0.147  ],
    [18.66	, 0.0011	, 0.1504	, 0.150	, 0.154  ],
    [19.00	, 0.0012	, 0.1579	, 0.158	, 0.162  ],
    [19.33	, 0.0012	, 0.1654	, 0.165	, 0.170  ],
    [19.66	, 0.0013	, 0.1732	, 0.173	, 0.178  ],
    [20.00	, 0.0014	, 0.1811	, 0.181	, 0.186  ],
    [20.33	, 0.0015	, 0.1892	, 0.189	, 0.194  ],
    [20.66	, 0.0016	, 0.1975	, 0.198	, 0.203  ],
    [21.00	, 0.0018	, 0.2062	, 0.206	, 0.211  ],
    [21.33	, 0.0019	, 0.2153	, 0.215	, 0.218  ],
    [21.66	, 0.0022	, 0.2247	, 0.225	, 0.224  ],
    [22.00	, 0.0025	, 0.2348	, 0.235	, 0.229  ],
    [22.33	, 0.0029	, 0.2456	, 0.246	, 0.236  ],
    [22.66	, 0.0034	, 0.2573	, 0.257	, 0.245  ],
    [23.00	, 0.0041	, 0.2703	, 0.270	, 0.254  ],
    [23.33	, 0.0052	, 0.2850	, 0.285	, 0.263  ],
    [23.66	, 0.0068	, 0.3023	, 0.302	, 0.273  ],
    [24.00	, 0.0094	, 0.3239	, 0.324	, 0.282  ],
    [24.33	, 0.0142	, 0.3530	, 0.353	, 0.292  ],
    [24.66	, 0.0258	, 0.3988	, 0.400	, 0.302  ],
    [25.00	, 0.0767	, 0.4914	, 0.497	, 0.313  ],
    [25.33	, 0.3804	, 0.4516	, 0.590	, 0.324  ],
    [25.66	, 0.2886	, 0.2076	, 0.355	, 0.336  ],
    [26.00	, 0.1861	, 0.1507	, 0.239	, 0.350  ],
    [26.33	, 0.0983	, 0.1640	, 0.191	, 0.366  ],
    [26.66	, 0.0543	, 0.2017	, 0.209	, 0.391  ],
    [27.00	, 0.0341	, 0.2359	, 0.238	, 0.384  ],
    [27.33	, 0.0239	, 0.2646	, 0.266	, 0.348  ],
    [27.66	, 0.0184	, 0.2898	, 0.290	, 0.374  ],
    [28.00	, 0.0152	, 0.3130	, 0.313	, 0.392  ],
    [28.33	, 0.0133	, 0.3355	, 0.336	, 0.407  ],
    [28.66	, 0.0122	, 0.3581	, 0.358	, 0.422  ],
    [29.00	, 0.0117	, 0.3815	, 0.382	, 0.437  ],
    [29.33	, 0.0118	, 0.4067	, 0.407	, 0.451  ],
    [29.66	, 0.0123	, 0.4343	, 0.434	, 0.466  ],
    [30.00	, 0.0133	, 0.4655	, 0.466	, 0.481  ],
    [30.33	, 0.0151	, 0.5019	, 0.502	, 0.497  ],
    [30.66	, 0.0179	, 0.5456	, 0.546	, 0.513  ],
    [31.00	, 0.0225	, 0.6004	, 0.601	, 0.530  ],
    [31.33	, 0.0301	, 0.6723	, 0.673	, 0.547  ],
    [31.66	, 0.0439	, 0.7735	, 0.775	, 0.565  ],
    [32.00	, 0.0731	, 0.9304	, 0.933	, 0.583  ],
    [32.33	, 0.1517	, 1.2148	, 1.224	, 0.603  ],
    [32.66	, 0.5070	, 1.8932	, 1.960	, 0.623  ],
    [33.00	, 4.5494	, 1.5400	, 4.803	, 0.645  ],
    [33.33	, 0.7725	, -1.1678	, 1.400	, 0.667  ],
    [33.66	, 0.2861	, -0.3206	, 0.430	, 0.691  ],
    [34.00	, 0.3196	, 0.1241	, 0.343	, 0.716  ],
    [34.33	, 0.9273	, 0.2502	, 0.960	, 0.743  ],
    [34.66	, 0.5444	, -0.5749	, 0.792	, 0.771  ],
    [35.00	, 0.1669	, -0.3331	, 0.373	, 0.801  ],
    [35.33	, 0.0812	, -0.1640	, 0.183	, 0.834  ],
    [35.66	, 0.0508	, -0.0578	, 0.077	, 0.870  ],
    [36.00	, 0.0367	, 0.0179	, 0.041	, 0.909  ],
    [36.33	, 0.0293	, 0.0777	, 0.083	, 0.952  ],
    [36.66	, 0.0255	, 0.1291	, 0.132	, 1.001  ],
    [37.00	, 0.0242	, 0.1773	, 0.179	, 1.058  ],
    [37.33	, 0.0257	, 0.2270	, 0.228	, 1.125  ],
    [37.66	, 0.0320	, 0.2852	, 0.287	, 1.201  ],
    [38.00	, 0.0506	, 0.3663	, 0.370	, 1.266  ],
    [38.33	, 0.1213	, 0.5124	, 0.527	, 1.224  ],
    [38.66	, 0.6464	, 0.7361	, 0.980	, 1.079  ],
    [39.00	, 0.4533	, -0.3164	, 0.553	, 1.047  ],
    [39.33	, 0.1071	, -0.0794	, 0.133	, 1.102  ],
    [39.66	, 0.0490	, 0.0401	, 0.063	, 1.178  ],
    [40.00	, 0.0302	, 0.1057	, 0.110	, 1.260  ],
    ]

# Reference:
# "Test Systems for Harmonics Modeling and Simulation",
# IEEE Transactions on Power Delivery, Vol. 11, No. 1, January 1996, Pages 466-474
#     Bus, Nominal kV,  LF Volts pu, LF Ang deg,  THD%
_ieee_tf_dstn_pf_thd_results = [
    [   1,      230.0,       1.0600,       0.00,  1.767 ],
    [   2,      230.0,       1.0450,      -5.68,  2.177 ],
    [   3,      230.0,       1.0427,     -15.30,  1.516 ],
    [   4,      230.0,       1.0282,     -11.41,  0.755 ],
    [   5,      230.0,       1.0337,      -9.82,  1.462 ],
    [   6,      115.0,       1.0700,     -15.87,  0.468 ],
    [   7,      230.0,       1.0193,     -14.47,  0.423 ],
    [   8,       13.8,       1.0209,     -14.49,  0.522 ],
    [   9,      115.0,       1.0147,     -16.09,  0.482 ],
    [  10,      115.0,       1.0168,     -16.33,  0.421 ],
    [  11,      115.0,       1.0394,     -16.21,  0.394 ],
    [  12,      115.0,       1.0528,     -16.72,  0.391 ],
    [  13,      115.0,       1.0458,     -16.73,  0.376 ],
    [  14,      115.0,       1.0154,     -17.39,  0.343 ],
    [ 301,       35.4,       1.0417,     -16.18,  9.169 ],
    [ 302,       35.4,       1.0417,     -16.18,  9.169 ],
    ]

#   Hord,   %mag,    deg
_ieee_tf_dstn_cursrc_hvdc = [
    [  1, 100.00, -49.56 ],
    [  5,  19.41, -67.77 ],
    [  7,  13.09,  11.9  ],
    [ 11,   7.58,  -7.13 ],
    [ 13,   5.86,  68.57 ],
    [ 17,   3.79,  46.53 ],
    [ 19,   3.29, 116.46 ],
    [ 23,   2.26,  87.47 ],
    [ 25,   2.41, 159.32 ],
    [ 29,   1.93, 126.79 ],
    ]

_ieee_tf_dstn_cursrc_tcr = [
    [  1, 100.00,   46.92 ],
    [  5,   7.02, -124.40 ],
    [  7,   2.50,  -29.87 ],
    [ 11,   1.36,  -23.75 ],
    [ 13,   0.75,   71.50 ],
    [ 17,   0.62,   77.12 ],
    [ 19,   0.32,  173.43 ],
    [ 23,   0.43,  178.02 ],
    [ 25,   0.13,  -83.45 ],
    [ 29,   0.40,  -80.45 ],
    ]

#

# =====================

# IEEE 519-2022 and IEEE 519-2014
#
# Table 1 - Voltage Distortion Limits
# All values should be in percent of the rated power frequency voltage at the PCC.
# Applies to voltage harmonics whose frequencies are integer multiples of the power frequency.
_ieee519_table1_thd_limits = {
    1.0  : {'indv': 5.0, 'thd': 8.0},                   # V <= 1.0 kV
    69.0 : {'indv': 3.0, 'thd': 5.0},                   # 1 kV < V <= 69.0 kV
    161.0: {'indv': 1.5, 'thd': 2.5},                   # 69.0 kV < V <= 161.0 kV
    999.0: {'indv': 1.0, 'thd': 1.5, 'thd_hvdc': 2.0},  # 161.0 kV < V
    }

_ieee519_vlimits = list(_ieee519_table1_thd_limits.keys())
_ieee519_vlimits.sort()

#

# =====================

def get_ieee_tf_scan_results():
    """Get IEEE Harmonics Task Force Test Case Frequency Scan Results.
    """
    hord_lst, zcal_lst, zdst_lst, zpi_lst = [], [], [], []
    for eachlist in _ieee_tf_scan_results:
        h, zr, zx, z1d, z1pi = eachlist
        zrx = complex(zr, zx)
        z = abs(zrx)
        hord_lst.append(h)
        zcal_lst.append(z)
        zdst_lst.append(z1d)
        zpi_lst.append(z1pi)

    return hord_lst, zcal_lst, zdst_lst, zpi_lst

#

# =====================

def get_ieee_tf_dstn_pf_thd_results():
    """Get IEEE Harmonics Task Force Test Case Distortion Calculation Results.
    """
    tf_keytup = ('bus', 'basekv', 'vmag', 'vang', 'thd')

    tfresults_pf_thd_dict = {}
    for row in _ieee_tf_dstn_pf_thd_results:
        for dk, val in zip(tf_keytup, row):
            if dk=='bus':
                bus = val
                tfresults_pf_thd_dict[bus] = {}
            else:
                tfresults_pf_thd_dict[bus][dk] = val

    return tfresults_pf_thd_dict

#

# =====================

def get_ieee_tf_dstn_cursrc():
    """Get IEEE Harmonics Task Force Test Case Harmonic Current Source Spectrum.
    """

    tfresults_cursrc_dict = {'hvdc':{}, 'tcr':{}}

    for eachrow in _ieee_tf_dstn_cursrc_hvdc:
        hord, imag, iang = eachrow
        tfresults_cursrc_dict['hvdc'][hord] = {'imag':imag, 'iang':iang}

    tfresults_cursrc_tcr_dict = {}
    for eachrow in _ieee_tf_dstn_cursrc_tcr:
        hord, imag, iang = eachrow
        tfresults_cursrc_dict['tcr'][hord] = {'imag':imag, 'iang':iang}

    return tfresults_cursrc_dict

#

# =====================

def get_resn_legends(peak_lst_h, peak_lst_rx, valley_lst_h=None, valley_lst_rx=None):
    """Get Frequency Scan Resonance legends.
    """
    txtlst = []
    txtlst.append("")
    txtlst.append("Parallel (peaks)")
    if peak_lst_rx:
        txtlst.append("Hord, Z")
        for h, pu in zip(peak_lst_h, peak_lst_rx):
            txt = "{:g}, {:g}".format(h, pu)
            txtlst.append(txt)
    else:
        txt = " None"
        txtlst.append(txt)

    if valley_lst_h:
        txtlst.append("")
        txtlst.append("Series (valleys)")
        if valley_lst_rx:
            txtlst.append("H,  Z")
            for h, pu in zip(valley_lst_h, valley_lst_rx):
                txt = "{:4.2f}, {:5.3f}".format(h, pu)
                txtlst.append(txt)
        else:
            txt = " None"
            txtlst.append(txt)

    return txtlst

#

# =====================

def _write_verbose_report(txt, report):
    if report is not None:
        report(txt)

class _SimpleObject(object):
    """Used for creating dummy object and set attributes as needed.
    """
    pass

def _set_rsn_object(**kwds):
    rsnobj = _SimpleObject()
    for k in ['x1', 'y1', 'x2', 'y2', 'inam', 'hidx', 'rflg']:
        setattr(rsnobj, k, kwds[k])
    return rsnobj

def _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=None, dltn=None):
    ok1, ok2 = False, False

    ok_pctc1 = pctc>=pctmx1
    ok_pctc2 = pctc>=pctmx2

    if dltp is not None:
        ok_dltp1 = dltp>=dpctpn1
        ok_dltp2 = dltp>=dpctpn2

    if dltn is not None:
        ok_dltn1 = dltn>=dpctpn1
        ok_dltn2 = dltn>=dpctpn2

    if dltp is None:
        ok1 = ok_pctc1 and ok_dltn1
        ok2 = ok_pctc2 and ok_dltn2
    elif dltn is None:
        ok1 = ok_pctc1 and ok_dltp1
        ok2 = ok_pctc2 and ok_dltp2
    else:
        ok1 = ok_pctc1 and (ok_dltp1 or ok_dltn1)
        ok2 = ok_pctc2 and (ok_dltp2 or ok_dltn2)

    found = ok1 or ok2

    return found

def _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report):

    resn_pks_hord, resn_pks_zmag = [], []

    txtlst = []
    txtlst.append("")
    txtlst.append("Parallel (peaks)")

    if not resn_pkvls:
        txt = " None"
        txtlst.append(txt)

        txt = "\n".join(txtlst)
        _write_verbose_report(txt, report)

        return resn_pks_hord, resn_pks_zmag

    #

# =====================

nnlst = len(resn_pkvls)

    txtlst.append("   X1,     Y1,     X2,     Y2,  %Ymax,  %dltY,  Found")

    for ii in range(nnlst):

        pt_crnt = resn_pkvls[ii]
        inam = pt_crnt.inam
        if inam!='peak': continue

        ipt_p = False
        ipt_n = False

        if ii==0:
            if nnlst>1:
                ipt_n = True
                pt_next = resn_pkvls[ii+1]
        elif ii==nnlst-1:
            ipt_p = True
            pt_prev = resn_pkvls[ii-1]
        else:
            ipt_p = True
            ipt_n = True
            pt_prev = resn_pkvls[ii-1]
            pt_next = resn_pkvls[ii+1]

        pctc = pt_crnt.y2*100/ymxpk                 # current value in percent of max

        found = False
        if ii==0:
            if ipt_n:
                dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2
                found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltn=dltn)
        elif ii==nnlst-1:
            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2
            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp)
        else:
            dltp = abs(pt_crnt.y2 - pt_prev.y2)*100/pt_crnt.y2
            dltn = abs(pt_crnt.y2 - pt_next.y2)*100/pt_crnt.y2
            found = _set_resn_pt_state(pctc, pctmx1, dpctpn1, pctmx2, dpctpn2, dltp=dltp, dltn=dltn)

        if found:
            resn_pkvls[ii].rflg = 1

        if ipt_p:
            txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}".format(pt_prev.x1, pt_prev.y1, pt_prev.x2, pt_prev.y2, '', dltp)
            txtlst.append(txt)

        txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6.2f}, {:6s},  {}".format(pt_crnt.x1, pt_crnt.y1, pt_crnt.x2, pt_crnt.y2, pctc, '', found)
        txtlst.append(txt)

        if ipt_n:
            txt = " {:4.1f}, {:6.3f}, {:6.3f}, {:6.3f}, {:6s}, {:6.2f}".format(pt_next.x1, pt_next.y1, pt_next.x2, pt_next.y2, '', dltn)
            txtlst.append(txt)

        txtlst.append("")

    txt = "\n".join(txtlst)
    _write_verbose_report(txt, report)

    # done filtering
    for rsnobj in resn_pkvls:
        inam = rsnobj.inam
        rflg = rsnobj.rflg
        if inam=='peak' and rflg==1:
            resn_pks_hord.append(rsnobj.x2)
            resn_pks_zmag.append(rsnobj.y2)

    return resn_pks_hord, resn_pks_zmag

def check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=None):
    """Check and find Frequency Scan Resonances.
    """

    resn_pkvls = []
    nhord = len(hlst)
    for hh in range(nhord):
        hord = hlst[hh]
        zmag = zlst[hh]
        if hh==0:
            x1, y1 = hord, zmag
            xb, yb = hord, zmag    # beginning point
            ymxpk  = zmag
        else:
            x2, y2 = hord, zmag
            m2 = (y1-y2)/(x1-x2)
            if hh>1:
                if m1>0 and m2<0:           # found peak
                    inam = 'peak'
                    if y1>y2:
                        pt = 0
                    else:
                        pt = 1
                elif m1<0 and m2>0:         # found valley
                    inam = 'valy'
                    if y1<y2:
                        pt = 0
                    else:
                        pt = 1
                else:
                    inam = 'none'

                if inam!='none':
                    if pt==0:
                        xn = x1
                        yn = y1
                        hidx = hh-1
                    else:
                        xn = x2
                        yn = y2
                        hidx = hh

                    if inam=='peak' and yn>ymxpk:
                        ymxpk = yn

                    rsnobj = _set_rsn_object(x1=xb, y1=yb, x2=xn, y2=yn, inam=inam, hidx=hidx, rflg=0)
                    resn_pkvls.append(rsnobj)

                    # next segment begin point
                    xb, yb = xn, yn

            # update and go to next point
            m1, x1, y1 = m2, x2, y2

    # Filter Peak Resonance Points
    resn_pks_hord, resn_pks_zmag = _filter_rsn_pkvls(resn_pkvls, ymxpk, pctmx1, dpctpn1, pctmx2, dpctpn2, report)
    _write_verbose_report('\n', report)

    return resn_pks_hord, resn_pks_zmag

#

# =====================

def get_fscan_csvdata(csvfile):
    """Get frequency scan Thevenin Impedance data from PSSE results file.
    """
    import csv

    thevz_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        for row in reader:
            bus   = row[0]
            sec   = row[1]
            nam   = row[2]
            basekv= row[3]
            desc  = row[4].strip()
            if desc=='HORD':
                thevz_dict['hord'] = [float(v) for v in row[5:]]
            else:
                iext = int(bus)
                try:
                    isec = int(sec)
                except:
                    isec = 0
                if isec>0:
                    dkey = (iext, isec)
                else:
                    dkey = iext
                if desc=='pu abs(thevz)':
                    bnam = nam.strip()
                    bkv  = float(basekv)
                    thevz_dict[dkey] = {'basekv': bkv, 'name': bnam}
                    thevz_dict[dkey]['mag'] = [float(v) for v in row[5:]]
                elif desc=='deg phase(thevz)':
                    thevz_dict[dkey]['phase'] = [float(v) for v in row[5:]]
                else:
                    txt = "Reading Harmonics FSCAN CSVFILE error, should not come here."
                    raise Exception(txt)

    return thevz_dict

#

# =====================

def get_hord_thevz_list(thevz_dict, busnum=None):
    """Get frequency scan Thevenin impedance harmonic orders.
    """
    found = False
    klst = list(thevz_dict.keys())
    for k in klst:
        if k=='hord': continue
        if busnum is None:
            busnum = k
            found = True
            break
        else:
            if k==busnum:
                found = True
                break

    if found:
        hord_lst = thevz_dict['hord'][:]
        thevz_mag_lst = thevz_dict[busnum]['mag'][:]
        thevz_phs_lst = thevz_dict[busnum]['phase'][:]
        ierr = False
    else:
        ierr = True
        hord_lst, thevz_mag_lst, thevz_phs_lst = [], [], []

    return ierr, hord_lst, thevz_mag_lst, thevz_phs_lst

#

# =====================

def get_dstn_csvdata_volt(csvfile):
    """Get Distortion Calculations Bus Voltage THD data from PSSE results file.
    """
    import csv

    dkeytup = ('hord', 'bus', 'sec', 'basekv', 'vrpu', 'vxpu', 'vmagpu', 'vangdeg', 'thd_indv')
    dtyptup = ('r'   , 'i'  , 'i'  , 'r'     , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       )

    errmsg0 = " Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile)

    _NCLNS = len(dkeytup)

    volt_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        nrow = 0
        for row in reader:
            nrow += 1
            if nrow==1: continue # skip column header line
            nclns = len(row)
            if nclns!=_NCLNS:
                txt = "    ROW {} has {} data items. It should have {} data items.".format(nrow, nclns, _NCLNS)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)
            tempdct = {}
            for dk, dt, v0 in zip(dkeytup, dtyptup, row):
                if dt=='s':
                    val = v0
                elif dt=='i':
                    if dk=='sec':
                        try:
                            val = int(v0)
                        except:
                            val = 0
                    else:
                        val = int(v0)
                else:
                    val = float(v0)
                tempdct[dk] = val

            hord = tempdct['hord']
            ibus = tempdct['bus']
            isec = tempdct['sec']
            bus_sec = (ibus, isec)

            if bus_sec not in volt_dict:
                volt_dict[bus_sec] = {}

            if hord not in volt_dict[bus_sec]:
                volt_dict[bus_sec][hord] = {}
            else:
                txt = "    Duplicate harmonic order={} data found for '{}', at {}".format(hord, desc, srcktup)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)

            if hord==1.0:
                kk = 'thd'
            else:
                kk = 'indv'
            volt_dict[bus_sec][hord]['basekv'] = tempdct['basekv']
            volt_dict[bus_sec][hord]['vmag']   = tempdct['vmagpu']
            volt_dict[bus_sec][hord]['vang']   = tempdct['vangdeg']
            # When hord=1.0, pct is THD, else pct is indv
            volt_dict[bus_sec][hord]['pct']    = tempdct['thd_indv']

    # add this test here
##    txt = "    Fundamental harmonic order data not found for bus={}, section={}".format(ibus, isec)
##    errmsg = "{}{}".format(errmsg0, txt)
##    raise Exception(errmsg)

    return volt_dict

#

# =====================

def get_dstn_csvdata_cursrc(csvfile):
    """Get Distortion Calculations Harmonic Current Source Spectrum data from PSSE results file.
    """
    import csv

    dkeytup = ('hord', 'ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec', 'ckt', 'irpu', 'ixpu', 'imagpu', 'iangdeg', 'thd_indv', 'desc')
    dtyptup = ('r'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 'i'   , 's'  , 'r'   , 'r'   , 'r'     , 'r'      , 'r'       , 's'   )

    errmsg0 = " Error: Reading Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile)

    _NCLNS = len(dkeytup)

    cursrc_dict = {}
    with open(csvfile, newline='') as fobj:
        reader = csv.reader(fobj)
        nrow = 0
        for row in reader:
            nrow += 1
            if nrow==1: continue # skip column header line
            nclns = len(row)
            if nclns!=_NCLNS:
                txt = "    ROW {} has {} data items. It should have {} data items.".format(nrow, nclns, _NCLNS)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)
            tempdct = {}
            srcklst = []
            for dk, dt, v0 in zip(dkeytup, dtyptup, row):
                if dt=='s':
                    val = v0.strip().lower()
                elif dt=='i':
                    if dk in ['isec', 'jbus', 'jsec', 'kbus', 'ksec']:
                        try:
                            val = int(v0)
                        except:
                            val = 0
                    else:
                        val = int(v0)
                else:
                    val = float(v0)

                if dk in ['ibus', 'isec', 'jbus', 'jsec', 'kbus', 'ksec']:
                    if val>0:
                        srcklst.append(val)
                elif dk in ['ckt']:
                    if val:
                        srcklst.append(val)
                else:
                    tempdct[dk] = val

            srcktup = tuple(srcklst)
            hord = tempdct['hord']
            desc = tempdct['desc']

            if desc not in cursrc_dict:
                cursrc_dict[desc] = {}

            if srcktup not in cursrc_dict[desc]:
                cursrc_dict[desc][srcktup] = {}

            if hord not in cursrc_dict[desc][srcktup]:
                cursrc_dict[desc][srcktup][hord] = {}
            else:
                txt = "    Duplicate harmonic order={} data found for '{}', at {}".format(hord, desc, srcktup)
                errmsg = "{}{}".format(errmsg0, txt)
                raise Exception(errmsg)

            if hord==1.0:
                kk = 'thd'
            else:
                kk = 'indv'
            cursrc_dict[desc][srcktup][hord]['imag'] = tempdct['imagpu']
            cursrc_dict[desc][srcktup][hord]['iang'] = tempdct['iangdeg']
            cursrc_dict[desc][srcktup][hord][kk]     = tempdct['thd_indv']

    # add this test here
##    txt = "    Fundamental harmonic order data not found for '{}', at {}".format(desc, srcktup)
##    errmsg = "{}{}".format(errmsg0, txt)
##    raise Exception(errmsg)

    return cursrc_dict

#

# =====================

def _get_dstn_volt_ieee519_busgrps(volt_dict):

    hord = 1.0  # just consider HORD=1.0 to get bus information

    ierr = 0
    ieee519_vlmt_dict  = {}
    case_bus_vlmt_dict = {}
    for ii, lmtkv in enumerate(_ieee519_vlimits):
        if ii==0:
            vmn, vmx = 0, lmtkv
        else:
            vmn, vmx = _ieee519_vlimits[ii-1], lmtkv

        if vmn<=0.0:
            s_lmt = "kV <= {}".format(vmx)
        elif vmx>=999.0:
            s_lmt = "{} < kV".format(vmn)
        else:
            s_lmt = "{} < kV <= {}".format(vmn, vmx)

        ieee519_vlmt_dict[ii] = {'lmtkv':lmtkv, 'vmin':vmn, 'vmax':vmx, 'lmt_lgd':s_lmt}

    buses_not_added_to_grps = []
    for bus_sec, vdict in volt_dict.items():
        buskv = vdict[hord]['basekv']
        found = False
        for ii, lmtkv in enumerate(_ieee519_vlimits):
            if ii==0:
                vmn, vmx = 0, lmtkv
            else:
                vmn, vmx = _ieee519_vlimits[ii-1], lmtkv

            if buskv>vmn and buskv<=vmx:
                case_bus_vlmt_dict[bus_sec] = ii
                found = True
                break

        if not found:
            buses_not_added_to_grps.append(bus_sec) # should never happen

    if buses_not_added_to_grps:
        txtlst = []
        for each in buses_not_added_to_grps:
            txt = "{}".format(each)
            txtlst.append(txt)
        txt = " Error - These (bus, sec) are not added to IEEE 519 Voltage THD Bus Groups:"
        print(txt)
        alltxt = ", ".join(txtlst)
        tlnlst = textwrap.wrap(alltxt, width=90, initial_indent="    ", subsequent_indent="    ")
        tlntxt = "\n".join(tlnlst)
        print(tlntxt)

    if not case_bus_vlmt_dict:
        ierr = 1

    return ierr, ieee519_vlmt_dict, case_bus_vlmt_dict

#

# =====================

def get_dstn_volt_study_bus_results(volt_dict, *buses):
    """Return distortion results assembled in arrays for XY plots for specified study buses.
    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)
    """

    ierr = 0
    each_bus_xy = {}
    all_bus_xy = {}

    ierr, ieee519_vlmt_dict, case_bus_vlmt_dict = _get_dstn_volt_ieee519_busgrps(volt_dict)
    if ierr:
        return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy

    case_bus_exst_dict = {}
    for bus_sec, lmtidx in case_bus_vlmt_dict.items():
        bus, sec = bus_sec
        case_bus_exst_dict[bus] = 1

    if not buses: buses = [-1]

    stdy_bus_dict = {}
    if len(buses)==1 and buses[0]==-1:
        for bus, flag in case_bus_exst_dict.items():
            stdy_bus_dict[bus] = 1
    else:
        for bus in buses:
            if bus in case_bus_exst_dict:
                stdy_bus_dict[bus] = 1

    for bus_sec, vdict in volt_dict.items():
        bus, sec = bus_sec
        if bus not in stdy_bus_dict: continue
        if sec:
            xt = "{}-{}".format(bus, sec)
        else:
            xt = "{}".format(bus)

        idx = case_bus_vlmt_dict[bus_sec]

        # Each bus THD and INDV for all HORD
        # 'pct' key contains both THD and INDV
        each_bus_xy[bus_sec] = {'xnam':xt, 'hord':[], 'pct':[], 'lmtidx':idx}
        for hord, vdct2 in vdict.items():
            each_bus_xy[bus_sec]['hord'].append(hord)
            each_bus_xy[bus_sec]['pct'].append(vdct2['pct'])

    # THD and max INDV for all buses

    for kk in ['bus_sec', 'xnam', 'thd', 'indv', 'indv_hord', 'lmtidx']:
        all_bus_xy[kk] = []

    for bus_sec, vdict in each_bus_xy.items():
        all_bus_xy['bus_sec'].append(bus_sec)
        all_bus_xy['xnam'].append(vdict['xnam'])
        all_bus_xy['lmtidx'].append(vdict['lmtidx'])

        mx_indv = 0.0
        mx_indv_hord = 0.0
        for hord, pct in zip(vdict['hord'], vdict['pct']):
            if hord==1.0:
                thd = pct
            else:
                if pct>mx_indv:
                    mx_indv = pct
                    mx_indv_hord = hord

        all_bus_xy['thd'].append(thd)
        all_bus_xy['indv'].append(mx_indv)
        all_bus_xy['indv_hord'].append(mx_indv_hord)

##    print("\n each_bus_xy\n", each_bus_xy)
##    print("\n all_bus_xy\n",  all_bus_xy)

    return ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy

#

# =====================

def compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc):
    # Compare PSSE Distortion Calculation Results and IEEE Task Force Results

    if not os.path.exists(csvfile_volt):
        msg0 = " Distortion Calculation comparison table for IEEE Test case not done."
        msg  = " File not found.{}\n    {}".format(msg0, csvfile_volt)
        print(msg)
        return

    # get task force results table in dictionary
    tfresults_pf_thd_dict = get_ieee_tf_dstn_pf_thd_results()
    tfresults_cursrc_dict = get_ieee_tf_dstn_cursrc()

    # get distotion bus volts CSV data in dictionary
    volt_dict   = get_dstn_csvdata_volt(csvfile_volt)
    cursrc_dict = get_dstn_csvdata_cursrc(csvfile_cursrc)

    # create comparison table
    errmsg0 = " Error: Processing Harmonics Distortion Calculations Bus Voltage CSV file:\n    {}\n".format(csvfile_volt)

    hdr1 = " IEEE Task Force (TF) Harmonics Test Case: TF and PSSE Results Comparison\n"
    hdr2 = " (1) Power Flow Solution Bus Voltages and Harmonics %THD\n"
    hdr3 = "    Bus |nominal| IEEE TF| IEEE TF|IEEE TF|  PSSE  |  PSSE  | PSSE  |   DIFF   |   DIFF   |   DIFF   |"
    hdr4 = " Number |  kV   |  V pu  |  V deg | THD % |  V pu  |  V deg | THD % |   V pu   |   V deg  |   THD %  |\n"

    oubflst = []
    oubflst.append(hdr1)
    oubflst.append(hdr2)
    oubflst.append(hdr3)
    oubflst.append(hdr4)

    buslist = list(tfresults_pf_thd_dict.keys())
    buslist.sort()
    for bus in buslist:
        tfdct = tfresults_pf_thd_dict[bus]
        tf_basekv = tfdct['basekv']
        tf_mag    = tfdct['vmag']
        tf_ang    = tfdct['vang']
        tf_thd    = tfdct['thd']

        sec = 0
        bus_sec = (bus, sec)
        dstndct = volt_dict[bus_sec]

        hord = 1.0

        p_basekv = dstndct[hord]['basekv']
        p_mag    = dstndct[hord]['vmag']
        p_ang    = dstndct[hord]['vang']
        p_thd    = dstndct[hord]['pct']

        if p_basekv!=tf_basekv:
            txt1 = "    Nominal bus voltage does not match for bus={}\n".format(bus)
            txt2 = "    Bus voltage (kV)  TF paper={}, PSSE case={}\n".format(tf_basekv, p_basekv)
            errmsg = "{}{}{}".format(errmsg0, txt1, txt2)
            raise Exception(errmsg)

        tf_txt = "{:6d} | {:5.1f} | {:6.4f} | {:6.2f} | {:5.3f} |".format(bus, tf_basekv, tf_mag, tf_ang, tf_thd)
        p_txt  = "{:6.4f} | {:6.2f} | {:5.3f} |".format(p_mag, p_ang, p_thd)

        df_mag = tf_mag - p_mag
        df_ang = tf_ang - p_ang
        df_thd = tf_thd - p_thd
        df_txt = "{:8.5f} | {:8.4f} | {:8.5f} |".format(df_mag, df_ang, df_thd)

        txt = " {} {} {}".format(tf_txt, p_txt, df_txt)
        oubflst.append(txt)

    hdr1 = "\n (2) Harmonic Current Source Spectrum applied for Distortion Calculations\n"
    hdr2 = " Hord |    Bus |  IEEE TF |  IEEE TF |   PSSE   |   PSSE   |   DIFF   |"
    hdr3 = "      | Number |   %I     |   I deg  |   %I     |   I deg  |   %I     |\n"

    oubflst.append(hdr1)
    oubflst.append(hdr2)
    oubflst.append(hdr3)

    p_keylist = list(cursrc_dict['load'].keys())
    buslist.sort()

    tf_hord_list = list(tfresults_cursrc_dict['hvdc'].keys())
    p_elmt = 'load'

    for hord in tf_hord_list:
        for srcktup in p_keylist:
            ibus = srcktup[0]
            if ibus==8:
                tfk = 'tcr'
            else:
                tfk = 'hvdc'

            p_imag  = cursrc_dict[p_elmt][srcktup][hord]['imag']
            p1_imag = cursrc_dict[p_elmt][srcktup][1.0]['imag']
            p_pct   = p_imag*100/p1_imag

            p_iang  = cursrc_dict[p_elmt][srcktup][hord]['iang']

            tf_imag = tfresults_cursrc_dict[tfk][hord]['imag']
            tf_iang = tfresults_cursrc_dict[tfk][hord]['iang']

            df_pct  = tf_imag - p_pct

            txt = " {:4.1f} | {:6d} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.2f} | {:8.5f} |".format(hord, ibus, tf_imag, tf_iang, p_pct, p_iang, df_pct)
            oubflst.append(txt)

    #
    txt1 = "\n For multiple harmonic sources, the phase angles of harmonic current injections are"
    txt2 = " re-calculated considering power flow solution phase angle, spectrum phase angles and"
    txt3 = " harmonic order. Hence TF spectrum phase angles and PSSE phase angles are different."
    oubflst.extend([txt1, txt2, txt3])

    # write to output file
    pth, nx  = os.path.split(csvfile_volt)
    nam, xtn = os.path.splitext(nx)
    oufname = "{}_tf_THD_compare.txt".format(nam)
    outfile = os.path.join(outpath, oufname)
    outfobj = open(outfile, 'w')

    oubflst.append("")
    alltxt = "\n".join(oubflst)
    outfobj.write(alltxt)
    outfobj.close()

    msg = " IEEE Task Force Harmonics Test Case: TF and PSSE Results Comparison saved to file:\n    {}\n".format(outfile)
    print(msg)

#

# =====================

def plot_main_fscan_ieee_test_and_tf(outpath, **kwds):
    """Plot IEEE Test Case frequency scan impedance.
    Results from PSSE and IEEE Task Force are plotted.
    """

    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    filetyp = kwds.get('filetyp', 'png')
    verbose = kwds.get('verbose', False)
    pctmx1  = kwds.get('pctmx1',  60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx2',  20.0)
    dpctpn2 = kwds.get('dpctpn2', 85.0)

    flag_show = kwds.get('flag_show', True)

    casnam = "ieee_tf_psse"
    busnum = 3

    hmajor = []
    for ii in range(0, 41, 5):
        hmajor.append(ii)

    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]

    csv_dict = {
        1: {'nam': "ieee_testcase_linmdl=0_fscan.csv", 'ttl': "nominal PI"},
        2: {'nam': "ieee_testcase_linmdl=1_fscan.csv", 'ttl': "long line distibuted with skin effect"},
        3: {'nam': "ieee_testcase_linmdl=2_fscan.csv", 'ttl': "long line distibuted but no skin effect"},
        }

    csv_exists_dict = {}
    for k, vdict in csv_dict.items():
        nam = vdict['nam']
        csvfile = os.path.join(outpath, nam)
        if os.path.exists(csvfile):
            csv_exists_dict[k] = vdict

    if not csv_exists_dict:
        msg = "\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\n    {}".format(outpath)
        print(msg)
        return

    # PSSE results
    ierr_pi, ierr_dst_skin, ierr_dst = True, True, True
    ii = 0
    for k, vdict in csv_exists_dict.items():
        nam = vdict['nam']
        ttl = vdict['ttl']
        csvfile = os.path.join(outpath, nam)
        thevz_dict = get_fscan_csvdata(csvfile)
        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
        if not ierr:
            if ii==0:
                hlst_pi = hlst[:]
                zlst_pi = zlst[:]
                ttl_pi = ttl
                ierr_pi = False
            elif ii==1:
                hlst_dst_skin = hlst[:]
                zlst_dst_skin = zlst[:]
                ttl_dst_skin = ttl
                ierr_dst_skin = False
            elif ii==2:
                hlst_dst = hlst[:]
                zlst_dst = zlst[:]
                ttl_dst  = ttl
                ierr_dst = False
        ii += 1

    if ierr_pi or ierr_dst:
        print(" Error -- PSSE getting results data")
        return

    tf_hlst, tf_zlst_cal, tf_zlst_dst, tf_zlst_pi = get_ieee_tf_scan_results()

    peak_lst_h, peak_lst_rx = check_resonance(hlst_dst, zlst_dst, pctmx1, dpctpn1, pctmx2, dpctpn2)
    resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
    resn_lgd_lst.insert(0, "Resonance: distibuted but no skin")
    resn_lgd = "\n".join(resn_lgd_lst)

    clr_lst = ['red', 'blue', 'black', 'green', 'magenta']
    sty_lst = ['-', ':', '--', '-.', '-']
    wdt_lst = [2, 2, 1, 1, 1]

    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(8.0, 9.0)

    ii=0
    ax.plot(hlst_dst, zlst_dst, label=ttl_dst+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=1
    ax.plot(tf_hlst, tf_zlst_dst, label=ttl_dst+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=2
    ax.plot(hlst_pi, zlst_pi, label=ttl_pi+' - PSSE', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ii=3
    ax.plot(tf_hlst, tf_zlst_pi, label=ttl_pi+' - IEEE Task Force', color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])

    ax.set_xticks(hmajor)
    ax.set_yticks(ymajor)
    #ax.set_yscale('log')
    ax.set_xlabel("Harmonic Order")
    ax.set_ylabel("Harmonic Impedance (pu)")
    ax.set_title("IEEE 14 Bus Harmonics Test System")
    ax.grid(True, which='both')
    ax.legend()
    ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')

    if filetyp=='pdf':
        pdffile = os.path.join(outpath, "{}.pdf".format(casnam))
        pdfobj  = PdfPages(pdffile)
    else:
        figfile = os.path.join(outpath, "{}.png".format(casnam))

    if filetyp=='pdf':
        pdfobj.savefig(fig, bbox_inches='tight')
        pdfobj.close()
        print(" Plots saved: {}".format(pdffile))
    else:
        fig.savefig(figfile, bbox_inches='tight')
        print(" Plots saved: {}".format(figfile))

    if filetyp!='pdf':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

#

# =====================

def plot_main_fscan_ieee_test(outpath, **kwds):
    """Plot IEEE Test Case frequency scan Thevenin impedance.
    """
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    filetyp = kwds.get('filetyp', 'png')
    verbose = kwds.get('verbose', False)
    pctmx1  = kwds.get('pctmx1',  60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx2',  20.0)
    dpctpn2 = kwds.get('dpctpn2', 85.0)

    flag_show = kwds.get('flag_show', True)

    if verbose:
        report = sys.stdout.write
    else:
        report = None

    csv_dict = {
        1: {'nam': "ieee_testcase_linmdl=0_fscan.csv", 'ttl': "nominal PI"},
        2: {'nam': "ieee_testcase_linmdl=1_fscan.csv", 'ttl': "long line distibuted with skin effect"},
        3: {'nam': "ieee_testcase_linmdl=2_fscan.csv", 'ttl': "long line distibuted but no skin effect"},
        }

    csv_exists_dict = {}
    for k, vdict in csv_dict.items():
        nam = vdict['nam']
        csvfile = os.path.join(outpath, nam)
        if os.path.exists(csvfile):
            csv_exists_dict[k] = vdict

    if not csv_exists_dict:
        msg = "\n Error- IEEE Test Harmonics Frequency Scan result files not found, not ploted, terminated:\n    {}".format(outpath)
        print(msg)
        return

    hmajor = []
    for ii in range(0, 41, 5):
        hmajor.append(ii)

    ymajor = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]

    busnum = 3

    clr_lst = ['black', 'green', 'red']
    sty_lst = ['--', ':', '-']
    wdt_lst = [2, 3, 1]

    resn_lgd = ''
    fig, ax = plt.subplots(1,1)
    fig.set_size_inches(8.0, 9.0)
    ii = 0
    for k, vdict in csv_exists_dict.items():
        nam = vdict['nam']
        ttl = vdict['ttl']
        csvfile = os.path.join(outpath, nam)
        thevz_dict = get_fscan_csvdata(csvfile)
        ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
        if not ierr:
            ax.plot(hlst, zlst, label=ttl, color=clr_lst[ii], linestyle=sty_lst[ii], linewidth=wdt_lst[ii])
            if k==3:
                peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report=report)
                resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
                resn_lgd_lst.insert(0, "Resonance: linmdl-distibuted but no skin")
                resn_lgd = "\n".join(resn_lgd_lst)

        ii += 1

    ax.set_xticks(hmajor)
    ax.set_yticks(ymajor)
    #ax.set_yscale('log')
    ax.set_xlabel("Harmonic Order")
    ax.set_ylabel("Harmonic Impedance (pu)")
    ax.set_title("IEEE 14 Bus Harmonics Test System")
    ax.grid(True, which='both')
    ax.legend()
    if resn_lgd: ax.annotate(resn_lgd, (10, 1.75), fontfamily='monospace')

    casnam = 'ieee_test'
    if filetyp=='pdf':
        pdffile = os.path.join(outpath, "{}_fscan.pdf".format(casnam))
        pdfobj  = PdfPages(pdffile)
    else:
        figfile = os.path.join(outpath, "{}_fscan.png".format(casnam))

    if filetyp=='pdf':
        pdfobj.savefig(fig, bbox_inches='tight')
        pdfobj.close()
        print(" Plots saved: {}".format(pdffile))
    else:
        fig.savefig(figfile, bbox_inches='tight')
        print(" Plots saved: {}".format(figfile))

    if filetyp!='pdf':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

#

# =====================

def _har_ana_ieee_test(**kwds):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    Allowed kwds:

    outpath  = os.getcwd(), Folder name to save outfile files
    rpt2file = False, Save Report to file

    Thresholds to filter Thevenin Impedance
        dft_thresholds = True, Use defualt thresholds

        pctmx1  = kwds.get('pctmx1' , 60.0)
        dpctpn1 = kwds.get('dpctpn1', 75.0)
        pctmx2  = kwds.get('pctmx2' , 20.0)
        dpctpn2 = kwds.get('dpctpn2', 85.0)
    """
    import psspy

    name,major,minor,modlvl,date,stat = psspy.psseversion()

    kwds_api = {}
    kwds_api['anaoptn'   ] = 0
    kwds_api['dstnbuop'  ] = 0
    kwds_api['dstnrptop' ] = 1
    kwds_api['imachimpop'] = 0
    kwds_api['dcimpop'   ] = 0
    kwds_api['triplenop' ] = 0
    kwds_api['genimpop'  ] = 0

    kwds_api['hord_min' ] = 0.0
    kwds_api['hord_max' ] = 40.0
    kwds_api['hord_stp' ] = 0.33

    kwds_api['hrsfile'  ] = ''

    fscan_buslist = [3]
    sid = 3
    busall = 0
    psspy.bsys(sid, numbus=len(fscan_buslist), buses=fscan_buslist)

    outpath = kwds.get('outpath', os.getcwd())
    rpt2file = kwds.get('rpt2file', False)
    dft_thresholds = kwds.get('dft_thresholds', True)

    inherit = kwds.get('inherit', False)
    if inherit:
        kwds_api['load_mdltyp'] = 7

    if not dft_thresholds:
        pctmx1  = kwds.get('pctmx1' , 60.0)
        dpctpn1 = kwds.get('dpctpn1', 75.0)
        pctmx2  = kwds.get('pctmx2' , 20.0)
        dpctpn2 = kwds.get('dpctpn2', 85.0)

        s_pctmx1  = "{:g}".format(pctmx1)
        s_dpctpn1 = "{:g}".format(dpctpn1)
        s_pctmx2  = "{:g}".format(pctmx2)
        s_dpctpn2 = "{:g}".format(dpctpn2)
        usr_thresholds = "thresholds_usr_{}_{}_{}_{}".format(s_pctmx1, dpctpn1, s_pctmx2, dpctpn2)

    for linmdl in [0, 1, 2]:
        outnam = "ieee_testcase_linmdl={}".format(linmdl)
        if dft_thresholds:
            if not inherit:
                outpath1 = os.path.join(outpath,"dft_thresholds")
            else:
                outpath1 = os.path.join(outpath,"dft_thresholds_inherit")
        else:
            outpath1 = os.path.join(outpath,usr_thresholds)

        if not os.path.exists(outpath1): os.makedirs(outpath1)

        if rpt2file:
            dstnfile = os.path.join(outpath1, "{}_dstn.txt".format(outnam))
            resnfile = os.path.join(outpath1, "{}_resn.txt".format(outnam))
        else:
            dstnfile = ''
            resnfile = ''

        kwds_api['linmdl']   = linmdl
        kwds_api['dstnfile'] = dstnfile
        kwds_api['resnfile'] = resnfile

        if dft_thresholds:
            psspy.har_set_resn_thresholds_default()
        else:
            psspy.har_set_resn_thresholds(pctmx1=pctmx1, dpctpn1=dpctpn1, pctmx2=pctmx2, dpctpn2=dpctpn2)

        ierr = psspy.har_analysis_2(sid, busall, **kwds_api)

        if not ierr:
            if kwds_api['anaoptn'] in [0, 1]:
                fscan_csvfile = os.path.join(outpath1, "{}_fscan.csv".format(outnam))
                psspy.har_export_fscan(fscan_csvfile)

                msg = "\n Frequency Scan Thevenin impedance exported to file:\n    {}".format(fscan_csvfile)
                print(msg)

            ok350402 = major==35 and minor>=4 and modlvl>=2
            ok3505   = major>=35 and minor>=5
            ok3600   = major>=36

            if ok350402 or ok3505 or ok3600:
                if kwds_api['anaoptn'] in [0, 2]:
                    dstn_csvfile = os.path.join(outpath1, "{}_dstn.csv".format(outnam))
                    voltoptn, flowoptn, cursrcoptn = 2, 2, 2
                    psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )

                    pn, xtn = os.path.splitext(dstn_csvfile)
                    msg  = "\n Distortion calculation results exported to files:\n"
                    msg += "    {}_volt{}\n".format(pn, xtn)
                    msg += "    {}_flow{}\n".format(pn, xtn)
                    msg += "    {}_cursrc{}\n".format(pn, xtn)
                    print(msg)

#

# =====================

def _ieee_test_get_names(datapath, outpath):

    if datapath is None:        # use Example folder
        exampath = os.path.dirname(__file__)
        datapath = exampath

    savfile = os.path.join(datapath, 'ieee_harmonics_test_case.sav')
    harfile = os.path.join(datapath, 'ieee_harmonics_test_case_har.rawx')

    if not os.path.exists(savfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(savfile)
        print(msg)

    if not os.path.exists(harfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(harfile)
        print(msg)

    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee')
        if not os.path.exists(outpath): os.makedirs(outpath)

    return savfile, harfile, outpath

#

# =====================

def run_ieee_test(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    _har_ana_ieee_test(outpath=outpath, rpt2file=True)

#

# =====================

def run_ieee_test_inherit(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    hnam, hext = os.path.splitext(harfile)
    harfile = "{}_inherit{}".format(hnam, hext)
    if not os.path.exists(harfile):
        msg = " Error - harmonics data file not found, calculations terminated\n    {}".format(harfile)
        print(msg)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    _har_ana_ieee_test(outpath=outpath, rpt2file=True, inherit=True)

#

# =====================

def run_ieee_test_thevz_thresholds(datapath=None, outpath=None):
    """Run PSSE Harmonic Analysis using IEEE Test Case.
    """
    import psspy

    psspy.psseinit()

    savfile, harfile, outpath = _ieee_test_get_names(datapath=datapath, outpath=outpath)
    psspy.case(savfile)
    psspy.readrawx(harfile, 'harmonics', 'new')

    kwds = {}
    kwds['outpath' ] = outpath
    kwds['rpt2file' ] = True
    kwds['dft_thresholds' ] = False

    kwds['pctmx1' ] = 60.0
    kwds['dpctpn1'] = 75.0
    kwds['pctmx2' ] = 20.0
    kwds['dpctpn2'] = 65.0

    _har_ana_ieee_test(**kwds)

#

# =====================

def plot_fscan_ieee_test(outpath=None, **kwds):
    """Plot PSSE Harmonic Analysis Frequency Scan results of IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

##    kwds = {}
##    kwds['filetyp'] = 'png'
##    kwds['verbose'] = verbose
##    kwds['pctmx1' ] = pctmx1
##    kwds['dpctpn1'] = dpctpn1
##    kwds['pctmx2' ] = pctmx2
##    kwds['dpctpn2'] = dpctpn2

    plot_main_fscan_ieee_test(outpath, **kwds)

#

# =====================

def plot_fscan_ieee_test_tf_psse(outpath=None, **kwds):
    """Plot Frequency Scan results of PSSE Harmonic Analysis and IEEE Task Force for IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Frequency Scan results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

##    kwds = {}
##    kwds['filetyp'] = 'png'
##    kwds['verbose'] = verbose
##    kwds['pctmx1' ] = pctmx1
##    kwds['dpctpn1'] = dpctpn1
##    kwds['pctmx2' ] = pctmx2
##    kwds['dpctpn2'] = dpctpn2

    plot_main_fscan_ieee_test_and_tf(outpath, **kwds)

#

# =====================

def compare_dstn_ieee_test(outpath=None, inherit=False):

    if outpath is None:
        exampath = os.path.dirname(__file__)
        if not inherit:
            outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
        else:
            outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds_inherit')

    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

    csvnam_volt   = "ieee_testcase_linmdl=2_dstn_volt.csv"
    csvnam_flow   = "ieee_testcase_linmdl=2_dstn_flow.csv"
    csvnam_cursrc = "ieee_testcase_linmdl=2_dstn_cursrc.csv"

    csvfile_volt   = os.path.join(outpath, csvnam_volt)
    csvfile_cursrc = os.path.join(outpath, csvnam_cursrc)
    compare_dstn_ieee_test_and_tf(outpath, csvfile_volt, csvfile_cursrc)

#

# =====================

def plot_dstn_ieee_test_volt_ieee519(outpath=None, *buses, **kwds):
    """Plot PSSE Harmonic Distortion Calculations results of IEEE Test Case.
    """
    if outpath is None:
        exampath = os.path.dirname(__file__)
        outpath  = os.path.join(exampath, r'output_harmonics_demo\ieee\dft_thresholds')
    if not os.path.exists(outpath):
        msg = "\n Error- IEEE Harmonics Distortion Calculations results folder not found, terminated:\n    {}".format(outpath)
        print(msg)
        return

    csvfnam = r"ieee_testcase_linmdl=2_dstn_volt.csv"
    csvfile = os.path.join(outpath, csvfnam)

    figfnam = 'ieee_testcase_linmdl=2_dstn_volt'
    figfile = os.path.join(outpath, figfnam)

    kwds2 = {}
    kwds2['figfiletyp'  ] = kwds.get('figfiletyp'  , 'pdf'   )
    kwds2['figfile'     ] = kwds.get('figfile'     , figfile )
    kwds2['flag_thd'    ] = kwds.get('flag_thd'    , True    )
    kwds2['flag_indv'   ] = kwds.get('flag_indv'   , True    )
    kwds2['flag_busgrps'] = kwds.get('flag_busgrps', False   )
    kwds2['plt_buses'   ] = kwds.get('plt_buses'   , [-1]    )
    kwds2['flag_show'   ] = kwds.get('flag_show'   , True    )

    plot_distortion_volt_ieee519(csvfile, *buses, **kwds2)

#

# =====================

def _run_har_ana_main(*fscanbuses, **kwds):
    # Run Harmonic Analysis using working case
    import psspy

    name,major,minor,modlvl,date,stat = psspy.psseversion()

    # subsystem
    onezerobus = False
    if fscanbuses:
        if len(fscanbuses)==1:
            if fscanbuses[0]==0:
                onezerobus = True

    if fscanbuses:
        if not onezerobus:
            sid = 3
            busall = 0
            psspy.bsys(sid, numbus=len(fscanbuses), buses=fscanbuses)
        else:
            # no scan, just run distortion calculations
            sid = 0
            busall = 0
    else:
        totbus = psspy.totbus()
        # if case has <100 buses, run scan on all buses
        if totbus<100:
            sid = 0
            busall = 1
        else:
            # no scan, just run distortion calculations
            sid = 0
            busall = 0

    ierr = True
    outfdict = {}
    outfdict['dstn'] = ''
    outfdict['resn'] = ''
    outfdict['scan'] = ''

    anaoptn = kwds.get('anaoptn', 0)
    if sid==0 and busall==0:
        if anaoptn==0:
            kwds['anaoptn'] = 2  # only distortion anlysis
        elif anaoptn==2:
            pass
        else:
            msg = "\n Error- Specify frequency scan buses, terminated"
            print(msg)
            return ierr, outfdict

    outfnam  = kwds.get('outfnam' , '')
    outpath  = kwds.get('outpath' , '')

    if not outfnam:
        savfile, snpfile = psspy.sfiles()
        if not savfile:
            outfnam = "tmpout"
        else:
            p, nx = os.path.split(savfile)
            outfnam, xtn = os.path.splitext(nx)

    if outpath:
        if not os.path.exists(outpath): os.makedirs(outpath)
        dstnfile = os.path.join(outpath, "{}_dstn.txt".format(outfnam))
        resnfile = os.path.join(outpath, "{}_resn.txt".format(outfnam))
    else:
        dstnfile = ''
        resnfile = ''

    kwds['hrsfile']  = ''
    kwds['dstnfile'] = dstnfile
    kwds['resnfile'] = resnfile

    if 'outpath' in kwds: del kwds['outpath']
    if 'outfnam' in kwds: del kwds['outfnam']

    ierr = psspy.har_analysis(sid, busall, **kwds)

    fscan_csvfile = ''
    dstn_volt_csvfile = ''
    dstn_flow_csvfile = ''
    dstn_cursrc_csvfile = ''

    if not ierr and outpath:
        if anaoptn in [0,1]:
            if not ierr and outpath:
                fscan_csvfile = os.path.join(outpath, "{}_fscan.csv".format(outfnam))
                psspy.har_export_fscan(fscan_csvfile)
                msg = "\n Frequency Scan Thevenin impedance saved to file:\n    {}".format(fscan_csvfile)
                print(msg)

        ok350402 = major==35 and minor>=4 and modlvl>=2
        ok3505   = major>=35 and minor>=5
        ok3600   = major>=36

        if ok350402 or ok3505 or ok3600:
            if anaoptn in [0, 2]:
                dstn_csvfile = os.path.join(outpath, "{}_dstn.csv".format(outfnam))
                voltoptn, flowoptn, cursrcoptn = 2, 2, 2

                psspy.har_export_dstn(dstn_csvfile, voltoptn=voltoptn, flowoptn=flowoptn, cursrcoptn=cursrcoptn )

                pn, xtn = os.path.splitext(dstn_csvfile)
                dstn_volt_csvfile = r"{}_volt{}".format(pn, xtn)
                dstn_flow_csvfile = r"{}_flow{}".format(pn, xtn)
                dstn_cursrc_csvfile = r"{}_cursrc{}".format(pn, xtn)

                msg += r"    {}\n".format(dstn_volt_csvfile)
                msg += r"    {}\n".format(dstn_flow_csvfile)
                msg += r"    {}\n".format(dstn_cursrc_csvfile)
                print(msg)

    outfdict['dstn'] = dstnfile
    outfdict['resn'] = resnfile
    outfdict['scan'] = fscan_csvfile
    outfdict['dstn_volt'] = dstnfile
    outfdict['dstn_flow'] = resnfile
    outfdict['dstn_cursrc'] = fscan_csvfile

    return ierr, outfdict

#

# =====================

def run_har_analysis(savfile, *fscanbuses, **kwds):
    """Run PSSE Harmonic Analysis using savfile and harfile provided.

    Arguments:
        savfile (str): PSSE Saved Case file name

        fscanbuses (int): One or bus numbers at which frequency scan done

        kwds (dict):  All PSSE har_analysis() API keywords plus followng
            are allowed key words.

            harfile (str) : PSSE harmonics data (.har) file
            outpath (str) : Output Results File Folder name
            outfnam (str) : Output Results File Name prefix
    """

    import psspy

    if not os.path.exists(savfile):
        msg = "\n Error- File not found, terminated:\n    {}".format(savfile)
        print(msg)
        return True, {}

    harfile = kwds.get('harfile', '')
    if harfile:
        if not os.path.exists(harfile):
            msg = "\n Error- File not found, ignored:\n    {}".format(harfile)
            print(msg)
            harfile = ''

    psspy.psseinit()

    ierr = psspy.case(savfile)
    if ierr:
        msg = "\n Error- reading SAV file, terminated:\n    {}".format(savfile)
        print(msg)
        return True, {}

    if harfile:
        ierr = psspy.readrawx(harfile, 'harmonics', 'new')
        if ierr:
            msg = "\n Error- reading Harmonics data file, terminated:\n    {}".format(harfile)
            print(msg)
            return True, {}

    if 'harfile' in kwds: del kwds['harfile']
    ierr, outfdict = _run_har_ana_main(*fscanbuses, **kwds)

    return ierr, outfdict

#

# =====================

def _plot_fscan_one(ax, hlst, zlst, **kwds):
    #  main plot function
    basemva  = kwds.get('basemva' , 100.0)
    basekv   = kwds.get('basekv'  , None)
    hmajor   = kwds.get('hmajor'  , [])
    ymajor   = kwds.get('ymajor'  , [])
    plotzpu  = kwds.get('plotzpu' , False)
    title    = kwds.get('title'   , '')
    add_xlbl = kwds.get('add_xlbl', None)
    add_lgnd = kwds.get('add_lgnd', False)
    annot_xy = kwds.get('annot_xy', (0.5, 0.5))

    pctmx1  = kwds.get('pctmx1' , 60.0)
    dpctpn1 = kwds.get('dpctpn1', 75.0)
    pctmx2  = kwds.get('pctmx1' , 20.0)
    dpctpn2 = kwds.get('dpctpn1', 85.0)
    report  = kwds.get('report' , None)

    if add_lgnd:
        peak_lst_h, peak_lst_rx = check_resonance(hlst, zlst, pctmx1, dpctpn1, pctmx2, dpctpn2, report)

    ylbl = "Thevenin Impedance (pu)"
    if not plotzpu:
        if basemva and basekv:
            zbase = basekv*basekv/basemva
            zlst_ohm = [zbase*each for each in zlst]
            zlst = zlst_ohm[:]
            del zlst_ohm
            ylbl = "Thevenin Impedance (ohm)"

            if add_lgnd:
                peak_lst_rx_ohm = [zbase*each for each in peak_lst_rx]
                peak_lst_rx = peak_lst_rx_ohm[:]
                del peak_lst_rx_ohm

    if add_lgnd:
        resn_lgd_lst = get_resn_legends(peak_lst_h, peak_lst_rx)
        resn_lgd = "\n".join(resn_lgd_lst)

    if add_lgnd:
        ax.plot(hlst, zlst, label=resn_lgd)
    else:
        ax.plot(hlst, zlst)
    #ax.set_yscale('log')
    if hmajor: ax.set_xticks(hmajor)
    if ymajor: ax.set_yticks(ymajor)
    if (add_xlbl): ax.set_xlabel("Harmonic Order")
    ax.set_ylabel(ylbl)

    ax.grid(True, which='both')

    if add_lgnd:
        ax.legend(loc='best')

    if title: ax.set_title(title)

#

# =====================

def _set_output_figfile_name(outfigfile, figfiletyp):

    figfiletyp_in = figfiletyp
    if figfiletyp_in:
        if figfiletyp_in not in _ALLOWED_FIG_FILE_TYPES:
            figfiletyp_in = ''

    opth, nx = os.path.split(outfigfile)
    n, x = os.path.splitext(nx)

    if x:
        figfiletyp_fl = ''
        xlw = x.lower().strip()
        if xlw:
            if xlw[1:] in _ALLOWED_FIG_FILE_TYPES:
                figfiletyp_fl = xlw[1:]

    if figfiletyp_in:
        figfiletyp = figfiletyp_in
    elif figfiletyp_fl:
        figfiletyp = figfiletyp_fl
    else:
        figfiletyp = 'pdf'

    xlw = ".{}".format(figfiletyp)

    if not opth: opth = os.getcwd()
    outfigfile = os.path.join(opth, "{}{}".format(n, xlw))

    return outfigfile, figfiletyp

#

# =====================

def plot_frequency_scan(busnum, *csvfiles, **kwds):
    """Plot Harmonics Frequency Scan Thevenin Impedance.
    for one bus from multiple Frequency Scan Result Files

    Arguments:
        busnum (int): Bus Number. The 'csvfiles' provided must have Thevenin Impedance
            for this bus.

        csvfiles (str): One or more CSV files that contain Frequency Scan results.
            These files are created by api psspy.har_export_fscan(..).

        kwds (dict):  Followng are allowed key words.

            (A) These keywords are for plot figure options.

            figfiletyp (str): File type to which plots are saved.
                              ='pdfobj' -- files are saved to already created pdfobj
                              [Create pdfobj = PdfPages(pdffile). This is done so
                              as to save many plots to one pdffile.]
                              ='pdf', 'png', 'jpg' etc. [all allowed file types].
                              (default: '')
            figfile (str)   : Name of the file or pdfobj to save plots
                              When file name is not provided plot is not saved.
                              (default: '')
            flag_show (bool): Flag (True or False), Option to show plots on screen or not.
                              (default: True)
            basemva (float) : Base MVA (used to calculate Thev Z in ohms)
                              (default: 100.0)
            basekv  (float) : Base kV of the bus (used to calculate Thev Z in ohms)
                              (default: No default allowed)
            hmajor  (float) : List of Harmonics Orders (used to draw X axis grid)
                              (default: [])
            ymajor  (float) : List of Thev Z (used to draw X axis grid)
                              (default: [])
            ttl_lst (str)   : Title list (one for each csvfile provided)
                              When one title is provided, same title is used for all.
                              (default: [])
            plotzpu (bool)  : True for Plot PU Thev Z
                              (default: False)
            add_lgnd (bool) : True to add resonance rrequeny legend
                              (default: False)
            annot_xy (tuple): Resonance Frequency legend location
                              Specify normalized (0 through 1) XY co-ordinates of a point
                              (default: (0.5, 0.5))
            subplts (bool)  : True, plot as subplots for more than one csvfiles.
                              (default: True) Subplots are drawn with 3 rows and 1 column.
            fwidth  (float) : Figure Width in inches
                              (default: matplotlib rcParms default figure width)
            fheight (float) : Figure Height in inches
                              (default: matplotlib rcParms default figure height)

            (B) These keywords are for filtering and reporting Thevenin Impedance Peaks.

            - Criterion 1 to select Thevenin Impedance Peak - slow rising peak point
            pctmx1 (float)     : current point in percent of maximum peak value
                                 (default:60.0)
            dpctpn1 (float)    : delta previous and delta next points in percent of current point
                                 (default:75.0)

            - Criterion 2 to select Thevenin Impedance Peak - fast rising peak point
            pctmx2 (float)     : current point in percent of maximum peak value
                                 (default:20.0)
            dpctpn2 (float)    : delta previous and delta next points in percent of current point
                                 (default:85.0)

            verbose (bool)     : Show verbose (detailed) output of Thevenin Impedance filtering
                                 (default: False)
            verbose_file (str) : File name to write verbose output.
                                 (default: '')
    """
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    # Use outfigfile to save output figure file and
    # also use its path to find csvfile when csvfile path is not provided.
    csvpath = ''

    figfiletyp = kwds.get('figfiletyp', '')
    figfiletyp = figfiletyp.lower()

    outfigfile = kwds.get('figfile', '')
    flag_show  = kwds.get('flag_show', True)

    if outfigfile:
        if figfiletyp=='pdfobj':
            pass
        else:
            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)
    else:
        figfiletyp = ''

    title = ''
    has_ttl4each = False
    ttl_lst = kwds.get('ttl_lst', [])
    nttl = len(ttl_lst)
    ncsv = len(csvfiles)
    if nttl==ncsv:
        has_ttl4each = True
    elif nttl==1 and ncsv>1:
        title = ttl_lst[0]

    exists_csvfiles = []
    exists_titles   = []
    for ii, csvnam in enumerate(csvfiles):
        if has_ttl4each:
            ttl = ttl_lst[ii]
        else:
            ttl = title
        if os.path.exists(csvnam):
            exists_csvfiles.append(csvnam)
            exists_titles.append(ttl)
        else:
            p, nx = os.path.split(csvnam)
            if not p and csvpath:
                csvnam2 = os.path.join(csvpath, nx)
                if os.path.exists(csvnam2):
                    exists_csvfiles.append(csvnam2)
                    exists_titles.append(ttl)
            else:
                msg = " File not found: {}".format(csvnam)
                print(msg)

    if not exists_csvfiles:
        return

    fwidth  = kwds.get('fwidth',  None)
    fheight = kwds.get('fheight', None)
    subplts = kwds.get('subplts', True)

    verbose  = kwds.get('verbose', False)
    verbose_file = kwds.get('verbose_file', '')
    report = None
    if verbose:
        if verbose_file:
            verbose_fobj = open(verbose_file, 'w')
            report = verbose_fobj.write
        else:
            report = sys.stdout.write

    if subplts:
        if fwidth is None or fheight is None:
            fwidth, fheight = 8.0, 9.0

    nfigs = len(exists_csvfiles)
    if not subplts:
        npages = nfigs
        nrows = 1
    else:
        if nfigs>3:
            npages = int(math.ceil(nfigs/3.0))   # three subplots per page
            nrows = 3
        else:
            npages = 1
            nrows = nfigs

    if outfigfile and figfiletyp=='pdf':
        pdffile = outfigfile
        pdfobj = PdfPages(pdffile)
    elif outfigfile and figfiletyp=='pdfobj':
        pdfobj = outfigfile

    nn = 0
    for pp in range(npages):
        fig, axlst = plt.subplots(nrows,1)
        if nrows==1: axlst = [axlst]
        fig.subplots_adjust(hspace=0.25)
        if fwidth is not None or fheight is not None:
            fig.set_size_inches(fwidth, fheight)

        for nr in range(nrows):
            ii = pp*nrows + nr
            if ii<nfigs:
                csvfile = exists_csvfiles[ii]
                ttl = exists_titles[ii]
                ax = axlst[nr]
                if (nr+1==nrows):
                    add_xlbl = True
                else:
                    add_xlbl = False

                kwds['title'] = ttl
                kwds['add_xlbl'] = add_xlbl
                kwds['report'] = report

                thevz_dict = get_fscan_csvdata(csvfile)
                ierr, hlst, zlst, phlst = get_hord_thevz_list(thevz_dict, busnum)
                if not ierr:
                    _plot_fscan_one(ax, hlst, zlst, **kwds)
            else:
                axlst[nr].set_visible(False)

        if outfigfile:
            if figfiletyp=='pdf':
                pdfobj.savefig(fig, bbox_inches='tight')
            elif figfiletyp=='pdfobj':
                try:
                    pdfobj.savefig(fig, bbox_inches='tight')
                except:
                    traceback.print_last()
            else:
                if npages>1:
                    pn, x = os.path.splitext(outfigfile)
                    zn = "{}".format(pp).zfill(2)
                    tmpfnam = "{}_{}{}".format(pn,zn,x)
                else:
                    tmpfnam = outfigfile
                fig.savefig(tmpfnam, bbox_inches='tight')

    if outfigfile:
        if figfiletyp=='pdf':
            pdfobj.close()

        if figfiletyp=='pdfobj':
            plt.close(fig=fig)
        else:
            print(" Plots saved: {}".format(outfigfile))

    if verbose:
        if verbose_file:
            verbose_fobj.close()

    if figfiletyp!='pdfobj':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

#

# =====================

def plot_distortion_volt_ieee519(csvfile, *buses, **kwds):
    """Plot Distortion Calculations Bus Voltages THD and Individual Harmonic levels with
    IEEE 519 Voltage Distortion Limits.
    Arguments:
        csvfile (str): CSV file that contain Distortion Calculations Bus Voltages results.
            This file is created by api psspy.har_export_dstn(..).
            No default allowed.

        buses (int): One or more Study Bus Numbers. THD and Individual harmonic levels are plotted
            for these many buses when provided.
            (default - consider all buses)

        kwds (dict):  Followng are allowed key words.

            (A) These keywords are for plot figure options.

            figfiletyp (str)   : File type to which plots are saved.
                                 ='pdfobj' -- files are saved to already created pdfobj
                                 [Create pdfobj = PdfPages(pdffile). This is done so
                                 as to save many plots to one pdffile.]
                                 ='pdf', 'png', 'jpg' etc. [all allowed file types].
                                 (default: '')
            figfile (str)      : Name of the file or pdfobj to save plots
                                 When file name is not provided plot is not saved.
                                 (default: '')
            flag_thd (bool)    : Flag (True or False), Option to plot THD of all study buses.
                                 (default: True)
            flag_indv (bool)   : Flag (True or False), Option to plot maximum individual harmonic levels
                                 of all study buses. For each bus, maximum individual harmonic level among all
                                 harmonic orders is found and plotted.
                                 (default: True)
            flag_busgrps (bool): Flag (True or False) Option to plot bus THD and INDV of bus groups.
                                 True -- Group buses as per their nominal voltage and IEEE 519 - Table 1
                                 voltage at PCC. Plot those bus groups in separate figures.
                                 False -- Plot all buses in one figure.
                                 (default: True)
            plt_buses (list)   : List of bus numbers (subset of Study Bus Numbers) to plot harmonic distortions.
                                 Bus THD and INDV harmonic distortions are plotted on the same figure.
                                 A separate figure created for each bus.
                                 Specify =[-1] or =-1 to plot all study buses.
                                 (default: [])
            flag_show (bool)   : Flag (True or False), Option to show plots on screen or not.
                                 (default: True)
            flag_xtick (bool)  : Flag (True or False), Option to Lable and Tick all X axis bus numbers.
                                 (default: True). Set this false if plotting for many numbers. Plot
                                 automatically assigns few labels and ticks in that case.
    """

    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    if not os.path.exists(csvfile):
        msg = " Distortion Bus Volts file not found: {}".format(csvfile)
        print(msg)
        return

    volt_dict = get_dstn_csvdata_volt(csvfile)

    # get organized Distortion results data
    ierr, ieee519_vlmt_dict, each_bus_xy, all_bus_xy = get_dstn_volt_study_bus_results(volt_dict, *buses)
    if ierr==1:
        msg = " IEEE 519 Bus Groups not found in Distortion Bus Volts file: {}".format(csvfile)
        print(msg)
        return

    all_xnam = all_bus_xy['xnam']
    all_xnum = range(len(all_xnam))

    # separate groups and plot their bars so as to have ONE legend lable for a group
    bar_grps = {}
    for idx, xnum, thd, indv, indv_hord in zip(all_bus_xy['lmtidx'], all_xnum, all_bus_xy['thd'],
                                               all_bus_xy['indv'], all_bus_xy['indv_hord']):
        if idx not in bar_grps:
            bar_grps[idx] = {'xnum':[], 'thd':[], 'indv':[], 'indv_hord':[]}
        bar_grps[idx]['xnum'].append(xnum)
        bar_grps[idx]['thd'].append(thd)
        bar_grps[idx]['indv'].append(indv)
        bar_grps[idx]['indv_hord'].append(indv_hord)

    # preserve legend order
    grpidx_ordr = list(bar_grps.keys())
    grpidx_ordr.sort()

    # Use outfigfile to save output figure file and
    # also use its path to find csvfile when csvfile path is not provided.

    figfiletyp = kwds.get('figfiletyp', '')
    figfiletyp = figfiletyp.lower()

    outfigfile = kwds.get('figfile', '')

    flag_thd     = kwds.get('flag_thd', True)
    flag_indv    = kwds.get('flag_indv', True)
    flag_busgrps = kwds.get('flag_busgrps', False)
    plt_buses    = kwds.get('plt_buses', [])
    flag_show    = kwds.get('flag_show', True)
    flag_xtick   = kwds.get('flag_xtick', True)

    # validate plt_buses
    ok_pltbus_list = []
    if plt_buses:
        bus_ok_dict = {}
        for bus_sec, vdict in each_bus_xy.items():
            bus, sec = bus_sec
            if bus not in bus_ok_dict:
                bus_ok_dict[bus] = []
            bus_ok_dict[bus].append(bus_sec)

        if type(plt_buses)==int:
            buslst = [plt_buses]
        elif type(plt_buses) in [list, tuple]:
            buslst = plt_buses[:]
        else:
            buslst = []
            msg = " Invalid plt_buses={} specified, ignored. Individual Bus plots not done.".format(plt_buses)
            print(msg)

        if len(buslst)==1 and buslst[0]==-1:
            for bus in bus_ok_dict:
                ok_pltbus_list.extend(bus_ok_dict[bus])
        else:
            buslst.sort()
            for bus in buslst:
                if bus not in bus_ok_dict:
                    msg = " Invalid plt_bus={}, ignored. Bus does not exist in results.".format(bus)
                    print(msg)
                else:
                    ok_pltbus_list.extend(bus_ok_dict[bus])

    if outfigfile:
        if figfiletyp=='pdfobj':
            pass
        else:
            outfigfile, figfiletyp = _set_output_figfile_name(outfigfile, figfiletyp)
    else:
        figfiletyp = ''

    if outfigfile and figfiletyp=='pdf':
        pdffile = outfigfile
        pdfobj = PdfPages(pdffile)
    elif outfigfile and figfiletyp=='pdfobj':
        pdfobj = outfigfile

    fignum = 0
    if flag_thd:
        bgn_allbus_thd = False
        for idx in grpidx_ordr:
            if flag_busgrps:
                fignum += 1
                fig = plt.figure(num=fignum)
                ax = fig.add_subplot(111)
                do_lbls = True
            else:
                if not bgn_allbus_thd:
                    bgn_allbus_thd = True
                    fignum += 1
                    fig = plt.figure(num=fignum)
                    ax = fig.add_subplot(111)
                if idx==grpidx_ordr[-1]:
                    do_lbls = True
                else:
                    do_lbls = False

            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']
            lmt_hvdc = _ieee519_table1_thd_limits[lmtkv].get('thd_hvdc', 0.0)
            if lmt_hvdc>0.0:
                lbl = "{} [{}] [with HVDC={}%]".format(lmt_thd, lbl, lmt_hvdc)
            else:
                lbl = "{} [{}]".format(lmt_thd, lbl)
            clr = _COLOR_PREFERENCE[idx]
            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['thd'], width=0.1, label=lbl, color=clr)

            # draw limit lines
            ax.axhline(y=lmt_thd, color=clr, linestyle='--', linewidth=1.5)
            if lmt_hvdc>0.0:
                ax.axhline(y=lmt_hvdc, color=clr, linestyle='--', linewidth=1.5)

            # labels and title
            if do_lbls:
                ttl = " Voltage THD"
                ax.set_title(ttl)
                ax.set_xlabel("Bus Numbers")
                ax.set_ylabel("% THD")
                if flag_xtick:
                    ax.set_xticks(all_xnum, all_xnam)
                h_lgd = ax.legend(title="IEEE 519 %THD Limits")
                h_lgd.get_frame().set_linewidth(0)
                h_lgd.set_draggable(True)

                if outfigfile:
                    if figfiletyp=='pdf':
                        pdfobj.savefig(fig, bbox_inches='tight')
                    elif figfiletyp=='pdfobj':
                        try:
                            pdfobj.savefig(fig, bbox_inches='tight')
                        except:
                            traceback.print_last()
                    else:
                        pn, x = os.path.splitext(outfigfile)
                        if flag_busgrps:
                            tmpfnam = "{}_thd_{}{}".format(pn,idx,x)
                        else:
                            tmpfnam = "{}_thd{}".format(pn,x)
                        fig.savefig(tmpfnam, bbox_inches='tight')

    if flag_indv:
        bgn_allbus_indv = False
        for idx in grpidx_ordr:
            if flag_busgrps:
                fignum += 1
                fig = plt.figure(num=fignum)
                ax = fig.add_subplot(111)
                do_lbls = True
            else:
                if not bgn_allbus_indv:
                    bgn_allbus_indv = True
                    fignum += 1
                    fig = plt.figure(num=fignum)
                    ax = fig.add_subplot(111)
                if idx==grpidx_ordr[-1]:
                    do_lbls = True
                else:
                    do_lbls = False

            lbl     = ieee519_vlmt_dict[idx]['lmt_lgd']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']
            lbl     = "{} [{}]".format(lmt_indv, lbl)
            clr = _COLOR_PREFERENCE[idx]
            h = ax.bar(bar_grps[idx]['xnum'], bar_grps[idx]['indv'], width=0.1, label=lbl, color=clr)

            do_bar_lbl_nam = False
            if flag_busgrps:
                do_bar_lbl_nam = True
            else:
                if all_xnum[0]==bar_grps[idx]['xnum'][0]:
                    do_bar_lbl_nam = True

            lbls = []
            for hord in bar_grps[idx]['indv_hord']:
                if do_bar_lbl_nam:
                    lbls.append("HORD={}".format(int(hord)))
                    do_bar_lbl_nam = False
                else:
                    lbls.append("{}".format(int(hord)))
            if flag_xtick:
                ax.bar_label(h, labels=lbls, padding=2)

            # draw limit lines
            ax.axhline(y=lmt_indv, color=clr, linestyle='--', linewidth=1.5)

            # labels and title
            if do_lbls:
                ttl = " Voltage Individual Harmonic Levels (maximum)"
                ax.set_title(ttl)
                ax.set_xlabel("Bus Numbers")
                ax.set_ylabel("% INDV")
                if flag_xtick:
                    ax.set_xticks(all_xnum, all_xnam)
                h_lgd = ax.legend(title="IEEE 519 %INDV Limits")
                h_lgd.get_frame().set_linewidth(0)
                h_lgd.set_draggable(True)

                if outfigfile:
                    if figfiletyp=='pdf':
                        pdfobj.savefig(fig, bbox_inches='tight')
                    elif figfiletyp=='pdfobj':
                        try:
                            pdfobj.savefig(fig, bbox_inches='tight')
                        except:
                            traceback.print_last()
                    else:
                        pn, x = os.path.splitext(outfigfile)
                        if flag_busgrps:
                            tmpfnam = "{}_indv_{}{}".format(pn,idx,x)
                        else:
                            tmpfnam = "{}_indv{}".format(pn,x)
                        fig.savefig(tmpfnam, bbox_inches='tight')

    if ok_pltbus_list:
        for bus_sec in ok_pltbus_list:
            vdict = each_bus_xy[bus_sec]
            xnam  = vdict['xnam']

            idx     = vdict['lmtidx']
            lmtkv   = ieee519_vlmt_dict[idx]['lmtkv']
            lmt_thd = _ieee519_table1_thd_limits[lmtkv]['thd']
            lmt_indv= _ieee519_table1_thd_limits[lmtkv]['indv']

            lbl_thd = "%THD={}".format(lmt_thd)
            lbl_indv = "%INDV={}".format(lmt_indv)

            fignum += 1
            fig = plt.figure(num=fignum)
            ax = fig.add_subplot(111)

            clr_thd = _COLOR_PREFERENCE_BUS[0]
            h = ax.bar(vdict['hord'][0], vdict['pct'][0], width=0.3, label=lbl_thd, color=clr_thd)

            clr_indv = _COLOR_PREFERENCE_BUS[1]
            h = ax.bar(vdict['hord'][1:], vdict['pct'][1:], width=0.3, label=lbl_indv, color=clr_indv)

            # draw limit lines if any limit is violated
            maxpct = max(vdict['pct'])
            if maxpct>lmt_thd or maxpct>lmt_indv:
                ax.axhline(y=lmt_thd,  color=clr_thd, linestyle='--', linewidth=1.5)
                ax.axhline(y=lmt_indv, color=clr_indv, linestyle='--', linewidth=1.5)

            ttl = " Bus={}, Voltage THD and Individual Harmonic Levels".format(xnam)
            ax.set_title(ttl)
            ax.set_xlabel("Harmonic Order")
            ax.set_ylabel("%THD and % INDV")
            if flag_xtick:
                ax.set_xticks(vdict['hord'])
            h_lgd = ax.legend(title="IEEE 519 Limits")
            h_lgd.get_frame().set_linewidth(0)
            h_lgd.set_draggable(True)

            if outfigfile:
                if figfiletyp=='pdf':
                    pdfobj.savefig(fig, bbox_inches='tight')
                elif figfiletyp=='pdfobj':
                    try:
                        pdfobj.savefig(fig, bbox_inches='tight')
                    except:
                        traceback.print_last()
                else:
                    pn, x = os.path.splitext(outfigfile)
                    tmpfnam = "{}_thd_bus_{}{}".format(pn,xnam,x)
                    fig.savefig(tmpfnam, bbox_inches='tight')

    if outfigfile:
        if figfiletyp=='pdf':
            pdfobj.close()

        if figfiletyp=='pdfobj':
            plt.close(fig=fig)
        else:
            if figfiletyp=='pdf':
                print(" Plots saved: {}".format(outfigfile))
            else:
                pn, x = os.path.splitext(outfigfile)
                print(" Plots saved: {}..., File Type={}".format(pn, x[1:]))

    if figfiletyp!='pdfobj':
        if flag_show:
            plt.show()
        else:
            plt.close('all')

#

# =====================

def test1():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Uses Example folder files.
    Compare PSSE and TF distortion calculation results.
    """
    run_ieee_test()
    compare_dstn_ieee_test()

def test1A():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Specify Load Models from API argument and specify them as inherit in harmonics data file.
    Uses Example folder files.
    """
    run_ieee_test_inherit()
    compare_dstn_ieee_test(inherit=True)

def test1B():
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Also specify thresholds to filter thevenin resonance frequencies.
    Uses Example folder files.
    """
    run_ieee_test_thevz_thresholds()

def test2():
    """Plot Harmonics Test PSSE Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test()

def test2A():
    """Plot Harmonics Test PSSE Results.
    Also specify thresholds to filter thevenin resonance frequencies.
    Uses Example folder files.
    """
    plot_fscan_ieee_test(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0)

def test3(figfiletyp='pdf', flag_show=True):
    """Plot Harmonics Test PSSE and harmonics Task Force Results.
    Also specify thresholds to filter thevenin resonance frequencies.
    Plot Distortion Calculation Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test_tf_psse(verbose=True, pctmx1=60.0, dpctpn1=75.0, pctmx2=20.0, dpctpn2=65.0, figfiletyp=figfiletyp, flag_show=flag_show)
    plot_dstn_ieee_test_volt_ieee519(figfiletyp=figfiletyp, flag_show=flag_show)

def test3A():
    """Plot Harmonics Test PSSE and harmonics Task Force Results.
    Uses Example folder files.
    """
    plot_fscan_ieee_test_tf_psse()

def test4():
    """Run Harmonics Analysis on Example folder 'sample' case.
    Output Reports created in Report Window
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample.sav")
    harfile  = os.path.join(datapath, "sample_har.rawx")
    run_har_analysis(savfile, harfile=harfile)

def test5():
    """Run Harmonics Analysis on Example folder 'sample_zils' case.
    Output Reports created in 'outpath' folder with savfile name used for file name prefix.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir,  "output_harmonics_demo", "sample_zils")
    run_har_analysis(savfile, harfile=harfile, outpath=outpath)

def test6():
    """Run Harmonics Analysis on Example folder 'sample_nb' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_nb.sav")
    harfile  = os.path.join(datapath, "sample_har.rawx")
    outfnam  = "sample_nbXX"
    outpath  = os.path.join(workdir, "output_harmonics_demo", outfnam)
    run_har_analysis(savfile, harfile=harfile, outpath=outpath, outfnam=outfnam)

def test7():
    """Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    Also specified values to some API arguments.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils_nb_sec.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec")
    run_har_analysis(savfile, harfile=harfile, outpath=outpath, linmdl=1,
                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)

def test8():
    """Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case.
    Output Reports created in 'outpath' folder with 'outfnam' used for file name prefix.
    Also specified values to some API arguments.
    Do frequency scan on few buses.
    """
    workdir  = os.path.dirname(__file__)
    datapath = workdir
    savfile  = os.path.join(datapath, "sample_zils_nb_sec.sav")
    harfile  = os.path.join(datapath, "sample_zils_har.rawx")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    run_har_analysis(savfile, 101, 212, 154, harfile=harfile, outpath=outpath, linmdl=1,
                     dstnrptop=1, imachimpop=1, dcimpop=1, triplenop=1)

def test9():
    """Plot Frequency Scan, one file
    """
    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    kwds['figfile'] = os.path.join(outpath, "fscan_bus101_ohms.png")
    kwds['flag_show'] = True
    plot_frequency_scan(101, csvfile1, **kwds)

def test10():
    """Plot Frequency Scan, two files
    """
    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils")
    csvfile2 = os.path.join(outpath, "sample_zils_fscan.csv")
    kwds['figfile'] = os.path.join(outpath, "fscan_bus101_ohms.pdf")
    kwds['flag_show'] = True
    plot_frequency_scan(101, csvfile1, csvfile2, **kwds)

def test11():
    """Plot Frequency Scan, two files, figfiletype=pdfobj
    """
    from matplotlib.backends.backend_pdf import PdfPages

    kwds = {}
    kwds['basemva'] = 100.0
    kwds['basekv']  = 21.6
    kwds['basehz']  = 60.0
    kwds['hmajor']  = []
    kwds['ymajor']  = []
    kwds['ttl_lst'] = ['bus101_ohms (sample_zils_nb_sec_few)', 'bus101_ohms (sample_zils)']
    kwds['add_lgnd']= True
    kwds['plotzpu'] = False
    workdir  = os.path.dirname(__file__)
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils_nb_sec_few")
    csvfile1 = os.path.join(outpath, "sample_zils_nb_sec_fscan.csv")
    outpath  = os.path.join(workdir, "output_harmonics_demo", "sample_zils")
    csvfile2 = os.path.join(outpath, "sample_zils_fscan.csv")

    pdffile = os.path.join(outpath, "fscan_bus101_ohms_2.pdf")
    pdfobj = PdfPages(pdffile)

    kwds['figfiletyp'] = 'pdfobj'
    kwds['figfile'] = pdfobj
    kwds['flag_show'] = True

    plot_frequency_scan(101, csvfile1, **kwds)
    plot_frequency_scan(101, csvfile2, **kwds)

    pdfobj.close()
    print(" Plots saved: {}".format(pdffile))

#

# =====================

def _temp():
    pass
    # Available tests
    # Note 1: Run tests 2, 2A, 3, 3A, 9, 10, 11 from outside of PSSE GUI.
    # Note 2: Other tests can be run from inside as well as outside of PSSE GUI.
    # Note 3: Copy and Modify test4() and later tests to use on any SAV and HAR files.
    #
    test1()    # (a) Run Harmonics Analysis using IEEE Test case
               # (b) Compare PSSE and TF distortion calculation results
    test1A()   # (a) Run Harmonics Analysis using IEEE Test case, but use inherit load model in data file
               # (b) Compare PSSE and TF distortion calculation results
    test1B()   # Run Harmonics Analysis using IEEE Test case and specify thresholds to filter thevenin resonance frequencies
    test2()    # Plot IEEE Test case Frequency scan.
    test2A()   # Plot IEEE Test case PSSE Results and specify thresholds to filter thevenin resonance frequencies
    test3()    # (a) Plot Harmonics Test case PSSE and harmonics Task Force Frequency scan Results
               #     with thresholds specified to filter thevenin resonance frequencies.
               # (b) Plot distortion calculation results.
    test3A()   # Plot IEEE Test case PSSE and harmonics Task Force Results (default thresholds)
    test4()    # Run Harmonics Analysis on Example folder 'sample' case, Output Reports created in Report Window
    test5()    # Run Harmonics Analysis on Example folder 'sample_zils' case, Output Reports created in files
    test6()    # Run Harmonics Analysis on Example folder 'sample_nb' case
    test7()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case
    test8()    # Run Harmonics Analysis on Example folder 'sample_zils_nb_sec' case and frequency scan on few buses
    test9()    # Plot Frequency Scan, one file [sample_zils_nb_sec_few]
    test10()   # Plot Frequency Scan, two files [sample_zils_nb_sec_fscan, sample_zils_fscan]
    test11()   # Plot Frequency Scan, two files, figfiletype=pdfobj

    # To compare PSSE and IEEE Test Case Results, run following tests.
    test1()    # Run Analysis
    test3()    # Write DSTN results comparison report, plot FSCAN TF and PSSE results, plot DSTN results
    # or run test3() with
    # figfiletyp as below, so as to create png file that can be inserted into DOC report
    # flag_show as below to create and save plots to files, do not show plots to the screen
    test3(figfiletyp='png')
    test3(figfiletyp='png', flag_show=False)

#

# =====================

'''This is an example file showing how to use arrbox.harmonics module to post process
   harmonic analysis results.

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example [where XX is psse version number]:
    import psseXX

- Refer ieee_test_pp function that shows
    - how to get frequency scan results in python object
    - how to get distortion calculation results in python object
    - set desired voltage distortion limits
    - create voltage distortion limits violations report
    - plot and decorate frequency scan and voltage distortion results

- Refer API manual arrbox > HAR_PP object for all available methods.
'''

import os
import sys

#

# =====================

def ieee_test_pp(do_fscan_plts=False, do_dstn_plts=False, show_plts=False):
    """Run Harmonics Analysis using IEEE Harmonics Test case.
    Uses Example folder files.
    """

    # Use from Example folder to run har_analysis.
    import harmonics_demo

    import arrbox.harmonics

    outpath = os.path.dirname(__file__)
    outpath = os.path.join(outpath, "output_har_demo_arrbox")
    if not os.path.exists(outpath): os.makedirs(outpath)

    harmonics_demo.run_ieee_test(outpath=outpath)

    outpath2 = os.path.join(outpath, "har_pp")
    if not os.path.exists(outpath2): os.makedirs(outpath2)

    prgfile = os.path.join(outpath2, "ieee_test_har_demo_arrbox_progress.txt")
    prgfile_fobj = open(prgfile, 'w')
    progress = prgfile_fobj.write

    harobj = arrbox.harmonics.HAR_PP(progress=progress)

    # Frequency Scan Results
    ierr = harobj.fscan_obj()
    fscanobj = harobj.fscan

    buses = list(fscanobj.bus.keys())
    progress("fscanobj.ierr={}\n".format(fscanobj.ierr))
    progress("fscanobj.hord=\n{}\n".format(fscanobj.hord))

    for b in buses:
        progress("Scanned Bus={}\n".format(b))
        progress("{}\n".format(fscanobj['bus'][b].keys()))
        progress("name={}, basekv={}\n".format(fscanobj.bus[b].name, fscanobj.bus[b].basekv))
        progress("{}\n".format(fscanobj.bus[b].mag))
        progress("{}\n".format(fscanobj.bus[b].phase))

    # Distortion Calculation Results
    ierr = harobj.dstn_obj()
    dstn_vltobj = harobj.dstn.volt

    progress("dstn_vltobj.keys()={}\n".format(dstn_vltobj.keys()))

    progress("dstn_vltobj.thd.bus={}\n{}\n".format(len(dstn_vltobj.thd.bus), dstn_vltobj.thd.bus))
    progress("dstn_vltobj.thd.pct={}\n{}\n".format(len(dstn_vltobj.thd.pct), dstn_vltobj.thd.pct))

    progress("dstn_vltobj.indv.bus={}\n{}\n".format(len(dstn_vltobj.indv.bus), dstn_vltobj.indv.bus))
    progress("dstn_vltobj.indv.hord_max={}\n{}\n".format(len(dstn_vltobj.indv.hord_max), dstn_vltobj.indv.hord_max))
    progress("dstn_vltobj.indv.pct_max={}\n{}\n".format(len(dstn_vltobj.indv.pct_max), dstn_vltobj.indv.pct_max))

    progress("dstn_vltobj.bus.keys()={}\n".format(dstn_vltobj.bus.keys()))
    buslist = harobj.dstn.volt.bus
    for bus in buslist:
        basekv = harobj.dstn.volt.bus[bus].basekv
        lmt_thd = harobj.dstn.volt.bus[bus].lmt_thd
        lmt_indv = harobj.dstn.volt.bus[bus].lmt_indv

        vdict = harobj.dstn.volt.bus[bus].hord
        for hord, vdc2 in  vdict.items():
            vr, vx, vmag, vang, pct  = vdc2.vr,  vdc2.vx, vdc2.vmag,  vdc2.vang, vdc2.pct
            txt = "{}, {}, {}, {}, {}, {}, {}, basekv={}, lmt_indv={}, lmt_thd={}\n".\
                  format(bus, hord, vr, vx, vmag, vang, pct, basekv, lmt_indv, lmt_thd)
            progress(txt)

    harobj.show_vlt_dstn_limits()

    vlmt_dict = harobj.get_vlt_dstn_limits()
    progress("vlmt_dict\n")
    for lmtkv, vdct in vlmt_dict.items():
        progress("   key={}, value={}\n".format(lmtkv, vdct))
    progress('\n')

    progress("\nVoltage violations report - rptoptn=0\n")
    harobj.report_vlt_dstn_limits_violations(rptfile=None)

    progress("\nVoltage violations report - rptoptn=1\n")
    harobj.report_vlt_dstn_limits_violations(rptoptn=1, rptfile=None)

    progress("\nVoltage violations report - rptoptn=2\n")
    harobj.report_vlt_dstn_limits_violations(rptoptn=2, rptfile=None)

    prgfile_fobj.close()
    print(" Progress Saved to file: {}".format(prgfile))

    # Frequency Scan Plots
    if do_fscan_plts:
        if not harobj.fscan.ierr:
            fig1, ax1 = harobj.plot_fscan_mag(3, color='r')
            fig1.savefig("zz_001.png")

            fig1, ax1 = harobj.plot_fscan_mag(3, color='r', marker='D', markevery=(0, 0.2))
            harobj.plot_decorate(ax1, xmin=10)
            fig1.savefig("zz_001-1.png")

            harobj.plot_decorate(ax1, add_legend=True)

            if show_plts:
                harobj.plot_show()
            else:
                harobj.plot_close()

    # Distortion Calculation Plots
    if do_dstn_plts:
        if not harobj.dstn.ierr:
            pdffile = os.path.join(outpath2, 'zplt_dstn_1.pdf')
            harobj.plot_pdf_open(pdffile)
            fig1, ax1 = harobj.plot_vlt_dstn_thd(0, 1, optn_lmtgrp=True, optn_lmtlin=True)
            #harobj.plot_decorate(ax1, add_legend=True)
            #harobj.plot_decorate(ax1, add_legend=True, xticks='all')
            harobj.plot_decorate(ax1, add_legend=True, xticks=[302, 301, 11, 3, 4])

            fig2, ax2 = harobj.plot_vlt_dstn_indv(0, 1, optn_lmtgrp=True, optn_lmtlin=True)
            harobj.plot_decorate(ax2, add_legend=True, xticks='all')

            fig3, ax3 = harobj.plot_vlt_dstn_bus(1)
            harobj.plot_decorate(ax3, xscale='log', yscale='log')

            harobj.plot_pdf_add_figure(fig1, fig2, fig3)
            harobj.plot_pdf_close()

            figfile = os.path.join(outpath2, 'zplt_dstn_2.pdf')
            harobj.plot_save(figfile, fig1, fig2)

            figfile = os.path.join(outpath2, 'zplt21_dstn')
            harobj.plot_save(figfile, fig1)

            figfile = os.path.join(outpath2, 'zplt22_dstn')
            harobj.plot_save(figfile, fig1, fig2)

            figfile = os.path.join(outpath2, 'zplt23_dstn')
            harobj.plot_save(figfile, fig1, fig2, fig3)

            if show_plts:
                harobj.plot_show()
            else:
                harobj.plot_close()

#

# =====================

'''
This file calculates 3 Phase Fault Currents for IEC Test Network (IEC 60909-4, Figure 16) by network reduction.
Refer to Program Application Guide, Volume I, Chapter 10 for schematics and equations.
It uses network data from IEC 60909-4 Table 11.
This impedance data (corrected if necessary) of the electrical equipment
(see figure 16) is referred to the 110 kV side. Z(2) = Z(1) = Z
Results from these calculations are compared against results from PSS(R)E and those provided in
IEC 60909-4 Table 12.
'''

import os, math, time
sqrt3 = math.sqrt(3.0)
sbase = 100.0     # MVA

str_time = time.strftime("%Y%m%d_%H%M%S_", time.localtime())
fnamout  = str_time + 'iec60909_testnetwork_calculations.txt'
fnamout  = os.path.join(os.getcwd(),fnamout)
foutobj  = open(fnamout,'w')

#

# =====================

def format_complex(v):
    vre = v.real
    vim = abs(v.imag)
    if v.imag<0:
        sgn = '-'
    else:
        sgn = '+'
    retv = '%-10.6g %s j %-10.6g' % (vre, sgn, vim)
    return retv

def format_z_ratio(vlst,method=None):
    retvlst = []
    for v in vlst:
        vstr = format_complex(v)
        xbyr = v.imag/v.real
        if method=='C':
            xbyr = xbyr/0.4
        elif method=='DC':
            xbyr = xbyr/0.055
        retv = '%s, %-10.6g' % (vstr, xbyr)
        retvlst.append(retv)
    return retvlst

def print_complex(nam, v):
    vstr = format_complex(v)
    retv = '%-7s = %s\n' % (nam, vstr)
    #print retv.strip()
    return retv

def print_impedance_xr_ratio(nam, v, adj=1.0):
    vstr = format_complex(v)
    xbyr = adj*v.imag/v.real
    if adj!=1.0:
        retv = '%-6s = %s  X/R adj = %-10.6g\n' % (nam, vstr, xbyr)
    else:
        retv = '%-6s = %s  X/R     = %-10.6g\n' % (nam, vstr, xbyr)
    print(retv.strip())
    return retv

def print_fault_current(nam,v):
    vrect = format_complex(v)
    vmag = abs(v)
    vang = math.degrees(math.atan(v.imag/v.real))
    #retv = '%-6s = %s    OR %-10.6g / %-5.2g deg\n' % (nam, vrect, vmag, vang)
    retv = '%-6s = %-10.6g\n' % (nam, vmag)
    print(retv.strip())
    return retv

#

# =====================

def print_z():
    dat_from_table11 = True
    txt = ''
    txt  += print_complex('zq1',    zq1)
    txt  += print_complex('zq1t',   zq1t)
    txt  += print_complex('zq2',    zq2)
    txt  += print_complex('zt3amv', zt3amv)
    txt  += print_complex('zt3bmv', zt3bmv)
    txt  += print_complex('zt3cmv', zt3cmv)
    txt  += print_complex('zt5mv',  zt5mv)
    if not dat_from_table11:
        txt  += print_complex('zt1mv',  zt1mv)
        txt  += print_complex('zg1',    zg1)
        txt  += print_complex('zg1t',   zg1t)
    txt  += print_complex('zs1',     zs1)
    if not dat_from_table11:
        txt  += print_complex('zt2mv',  zt2mv)
        txt  += print_complex('zg2',    zg2)
        txt  += print_complex('zg2t',   zg2t)
    txt  += print_complex('zs2',    zs2)
    txt  += print_complex('zg3',    zg3)
    txt  += print_complex('zg3t',   zg3t)
    txt  += print_complex('zm1',    zm1)
    txt  += print_complex('zm1t',   zm1t)
    txt  += print_complex('zm2',    zm2)
    txt  += print_complex('zm2t',   zm2t)
    txt  += print_complex('zl1',    zl1)
    txt  += print_complex('zl2',    zl2)
    txt  += print_complex('zl3',    zl3)
    txt  += print_complex('zl4',    zl4)
    txt  += print_complex('zl5',    zl5)
    txt  += print_complex('zl6',    zl6)
    txt  += print_complex('zl6t',   zl6t)
    return txt

def print_network_reduction_z(txstr,zdct):
    for k,v in list(zdct.items()):
        txstr += print_complex(k,v)
    return txstr

#

# =====================

def table11_data(xftr,peak=False):
    # peak = True, calculations are for Peak current, use Rgf for generators.
    
    global zq1, zq1t, zq2, zt3amv, zt3bmv, zt3cmv, zt5mv, zs1
    global zs2, zg3, zg3t, zm1, zm1t, zm2, zm2t
    global zl1, zl2, zl3, zl4, zl5, zl6, zl6t

    # TABLE 11 Data
    zq1    =  0.631933 +   6.319335j
    zq1t   =  0.056874 +   0.568740j
    zq2    =  0.434454 +   4.344543j

    zt3amv =  0.045714 +   8.096989j
    zt3bmv =  0.053563 -   0.079062j
    zt3cmv =  0.408568 +  20.292035j

    zt5mv  =  2.046454 +  49.072241j

    # power station unit 1 data
    #Ks       = 0.995975
    #zg1t     = (0.059977324263+12.3433333333j)
    #zg1t*Ks  = (0.0597359155329+12.2936514167j)
    #zt1mv*Ks = (0.439058979167+14.0430253611j)
    #zs1 = Ks*(zg1t + zt1mv) = (0.4987948947+26.3366767778j)

    Ks1    =  0.995975
    zg1    =  0.059977 +  12.343333j
    zg1c   =  0.059736 +  12.293651j
    zt1c   =  0.439059 +  14.043025j
    #zs1    =  0.498795 +  26.336676j
    zs1    =  zg1c + zt1c

    # power station unit 2 data
    #Ks       = 0.876832
    #zg2t     = (0.65306122449+23.04j)
    #zg2t*Ks  = (0.572624979592+20.20220928j)
    #zt2mv*Ks = (0.63131904+15.1384987665j)
    #zs2 = Ks*(zg2t + zt2mv) = (1.20394401959+35.3407080465j)

    Ks2    =  0.876832
    zg2    =  0.653061 +  23.04j
    zg2c   =  0.572625 +  20.202214j
    zt2c   =  0.631319 +  15.138499j
    #zs2    =  1.203944 +  35.340713j
    zs2    =  zg2c + zt2c

    zg3    =  0.017790 +   1.089623j
    zg3t   =  2.133964 + 130.705301j

    zm1    =  0.341497 +   3.414968j
    zm1t   = 40.964124 + 409.641243j
    zm2    =  0.412137 +   4.121368j
    zm2t   = 49.437719 + 494.377190j

    zl1    = 2.4   + 7.8j
    zl2    = 1.2   + 3.9j
    zl3    = 0.3   + 0.975j
    zl4    = 0.96  + 3.88j
    zl5    = 1.8   + 5.79j
    zl6    = 0.082 + 0.086j
    zl6t   = 9.836281 + 10.316100j

    # Fictitious resistances RGf may be used for the calculation of the peak short circuit current
    # RGf = 0.05 X''d for generators with UrG > 1 kV and SrG >= 100 MVA
    # RGf = 0.07 X''d for generators with UrG > 1 kV and SrG < 100 MVA
    # RGf = 0.15 X''d for generators with UrG <= 1 000 V
    if peak:
        # G1 -> 150 MVA, 21 kV
        # G2 -> 100 MVA, 10.5 kV
        # RGf = 0.05 X''d
        zg1  = complex(0.05*zg1.imag, zg1.imag)
        zg1c = zg1*Ks1
        zs1  = zg1c + zt1c

        zg2  = complex(0.05*zg2.imag, zg2.imag)
        zg2c = zg2*Ks2
        zs2  = zg2c + zt2c

        zg3  = complex(0.07*zg3.imag, zg3.imag)
        zg3t = complex(0.07*zg3t.imag, zg3t.imag)

    if xftr != 1.0:
        zq1    = complex(zq1.real,    zq1.imag*xftr)
        zq1t   = complex(zq1t.real,   zq1t.imag*xftr)
        zq2    = complex(zq2.real,    zq2.imag*xftr)
        zt3amv = complex(zt3amv.real, zt3amv.imag*xftr)
        zt3bmv = complex(zt3bmv.real, zt3bmv.imag*xftr)
        zt3cmv = complex(zt3cmv.real, zt3cmv.imag*xftr)
        zt5mv  = complex(zt5mv.real,  zt5mv.imag*xftr)
        zs1    = complex(zs1.real,    zs1.imag*xftr)
        zs2    = complex(zs2.real,    zs2.imag*xftr)
        zg3    = complex(zg3.real,    zg3.imag*xftr)
        zg3t   = complex(zg3t.real,   zg3t.imag*xftr)
        zm1    = complex(zm1.real,    zm1.imag*xftr)
        zm1t   = complex(zm1t.real,   zm1t.imag*xftr)
        zm2    = complex(zm2.real,    zm2.imag*xftr)
        zm2t   = complex(zm2t.real,   zm2t.imag*xftr)
        zl1    = complex(zl1.real,    zl1.imag*xftr)
        zl2    = complex(zl2.real,    zl2.imag*xftr)
        zl3    = complex(zl3.real,    zl3.imag*xftr)
        zl4    = complex(zl4.real,    zl4.imag*xftr)
        zl5    = complex(zl5.real,    zl5.imag*xftr)
        zl6    = complex(zl6.real,    zl6.imag*xftr)
        zl6t   = complex(zl6t.real,   zl6t.imag*xftr)

#

# =====================

def parallel(zp,zq):
    return (zp*zq)/(zp+zq)

def calculate_3ph_fault_zthev():
    # Reduction at Bus 5
    z7g  = parallel(zm1t, zm2t)
    z6g1 = zl6t + z7g
    z6g2 = parallel(zg3t, z6g1)
    z56  = zt5mv/2.0
    z5g1 = z56 + z6g2
    z5g2 = parallel(zq2, z5g1)

    rdzstr = ''
    rdzstr = print_network_reduction_z(rdzstr,{'z7g':z7g, 'z6g1':z6g1, 'z6g2':z6g2, 'z56':z56, 'z5g1':z5g1, 'z5g2':z5g2})

    # Reduction at Bus 2
    z12t3   = zt3amv + zt3bmv
    z12t3t4 = z12t3/2.0
    z2g1    = zq1t + z12t3t4
    
    rdzstr = print_network_reduction_z(rdzstr,{'z12t3':z12t3, 'z12t3t4':z12t3t4, 'z2g1':z2g1})

    # delta to star of buses 2, 3, 5, star point=N1
    zden1 = zl1 + zl3 + zl4
    za    = (zl1*zl3) / zden1
    zb    = (zl1*zl4) / zden1
    zc    = (zl3*zl4) / zden1

    rdzstr = print_network_reduction_z(rdzstr,{'za':za, 'zb':zb, 'zc':zc})

    # star to delta of buses N1, 3, 4, and ground
    znum1 = zb*zs2 + zb*zl2 + zs2*zl2
    zd = znum1/zs2
    ze = znum1/zl2
    zf = znum1/zb

    rdzstr = print_network_reduction_z(rdzstr,{'zd':zd, 'ze':ze, 'zf':zf})

    # delta to star of buses N1, 4, 5, star point=N2
    zden2 = zc + zd + zl5
    zg    = (zc*zd)  / zden2
    zh    = (zd*zl5) / zden2
    zi    = (zc*zl5) / zden2

    rdzstr = print_network_reduction_z(rdzstr,{'zg':zg, 'zh':zh, 'zi':zi})

    # Zthev at Bus 4
    z1    = z2g1 + za
    z2    = parallel(z1, ze)
    z3    = z2 + zg
    z4    = zi + z5g2
    z5    = parallel(z3, z4)
    z6    = z5 + zh
    z7    = parallel(z6,zf)
    zthv4 = parallel(z7, zs1)

    rdzstr = print_network_reduction_z(rdzstr,{'z1':z1, 'z2':z2, 'z3':z3, 'z4':z4, 'z5':z5, 'z6':z6, 'z7':z7})

    # Zthev at Bus 5
    z8    = parallel(zs1,zf)
    z9    = z8 + zh
    z10   = parallel(z3,z9)
    z11   = zi + z10
    zthv5 = parallel(z11, z5g2)

    rdzstr = print_network_reduction_z(rdzstr,{'z8':z8, 'z9':z9, 'z10':z10, 'z11':z11})

    # Zthev at Bus 2
    z12   = parallel(z4,z9)
    z13   = z12 + zg
    z14   = parallel(z13,ze)
    z15   = za + z14
    zthv2 = parallel(z15, z2g1)

    rdzstr = print_network_reduction_z(rdzstr,{'z12':z12, 'z13':z13, 'z14':z14, 'z15':z15})

    # Zthev at Bus 1
    z16   = z15 + z12t3t4
    z17   = z16*(400.*400.)/(120.*120.)
    zthv1 = parallel(z17, zq1)

    rdzstr = print_network_reduction_z(rdzstr,{'z16':z16, 'z17':z17})

    # Zthev at Bus 6
    zt5lv = zt5mv*(10.5*10.5)/(115.0*115.0)
    z21   = parallel(z11, zq2)
    z21lv = z21*(10.5*10.5)/(115.0*115.0)
    z22   = z21lv + zt5lv*0.5
    z24   = parallel(zm1, zm2)
    z25   = zl6 + z24
    z26   = parallel(zg3, z25)
    zthv6 = parallel(z22, z26)

    rdzstr = print_network_reduction_z(rdzstr,{'zt5lv':zt5lv, 'z21':z21, 'z21lv':z21lv, 'z22':z22, 'z24':z24, 'z25':z25, 'z26':z26})

    # Zthev at Bus 7
    z27   = parallel(z22, zg3)
    z28   = z27 + zl6
    zthv7 = parallel(z28, z24)

    rdzstr = print_network_reduction_z(rdzstr,{'z27':z27, 'z28':z28})

    zthev = [zthv1, zthv2, zthv4, zthv5, zthv6, zthv7]
    
    return zthev, rdzstr

#

# =====================

def calculate_3ph_fault_ik(zthev):

    zthv1 = zthev[0]
    zthv2 = zthev[1]
    zthv4 = zthev[2]
    zthv5 = zthev[3]
    zthv6 = zthev[4]
    zthv7 = zthev[5]

    vflt = 1.1*110.0/sqrt3
    if2   = vflt/zthv2
    if4   = vflt/zthv4
    if5   = vflt/zthv5

    vflt1 = 1.1*380.0/sqrt3
    if1   = vflt1/zthv1

    vfl67 = 1.1*10.0/sqrt3
    if6   = vfl67/zthv6
    if7   = vfl67/zthv7

    ik = [if1, if2, if4, if5, if6, if7]
    return ik

#

# =====================

def calculate_k_factor_method_B(bus,zc):
    r = zc.real
    x = zc.imag
    rx = r/x
    rbyx = -3.0*rx
    k = 1.02 + 0.98*math.exp(rbyx)
    if bus==7: k = k*1.15   # add safety factor for bus 7 faults
    if k>2.0: k=2.0
    return k    
    
def calculate_k_factor_method_C(zc):
    r = zc.real
    x = zc.imag
    rx = r/x
    rbyx = 0.4*rx
    rbyx = -3.0*rbyx
    k = 1.02 + 0.98*math.exp(rbyx)
    #print 'K factor for r/x=%f, is k=%f' % (rbyx,k)
    return k

def calculate_ip(buslst,iklst,zclst,method):
    klst  = []
    iplst = []
    for bus,ik,zc in zip(buslst,iklst,zclst):
        ik = abs(ik)
        if method=='B':
            k  = calculate_k_factor_method_B(bus,zc)
        if method=='C':
            k  = calculate_k_factor_method_C(zc)
        ip = k*math.sqrt(2.0)*ik
        klst.append(k)
        iplst.append(ip)

    return klst, iplst

def back_calculate_k(iklst,iplst):
    klst = []
    for ik,ip in zip(iklst,iplst):
        # ip=k*sprt(2)*ik
        k = ip/(math.sqrt(2)*ik)
        klst.append(k)
    return klst

def calculate_idc(iklst,zlst):
    # idc = sprt(2)*ik*e^(-2piftR/X)
    idclst = []
    for ik,z in zip(iklst,zlst):
        r = z.real
        x = z.imag
        rx = r/x
        rx = 0.055*rx
        rbyx = -2.0*math.pi*50.0*0.1*rx
        k = math.exp(rbyx)
        idc = math.sqrt(2)*abs(ik)*k
        #print 'dc component: z, k, abs(ik), idc = ',z,k,abs(ik),idc
        idclst.append(idc)
    return idclst
    
#

# =====================

foutobj.write('IEC 60909-4:2000 Figure 16 (Page 121) 3-phase Fault Calculations with Network reduction')
foutobj.write(' '+time.asctime())
foutobj.write('\n')

buses = [1,2,4,5,6,7]

# Base frequency calculations
xftr = 1.0
table11_data(xftr)
base_z = print_z()

zthev_bas, rdzstr_bas = calculate_3ph_fault_zthev()

ik_bas = calculate_3ph_fault_ik(zthev_bas)

# Method B
# Method B peak currents are worse (compared to results in standard) when Rgf is used.
#xftr = 1.0
#table11_data(xftr,peak=True)
#mthdB_z = print_z()
#zthev_b, rdzstr_b = calculate_3ph_fault_zthev()
#k_b, ip_b = calculate_ip(buses,ik_bas,zthev_b,method='B')
k_b, ip_b = calculate_ip(buses,ik_bas,zthev_bas,method='B')

# Method C
xftr = 20.0/50.0
table11_data(xftr,peak=True)
mthdC_z = print_z()

zthev_c, rdzstr_c = calculate_3ph_fault_zthev()
k_c, ip_c = calculate_ip(buses,ik_bas,zthev_c,method='C')

# DC Component
# tmin=0.1 s, f*t = 50*0.1 = 5, fc/f=0.055
xftr = 0.055
table11_data(xftr,peak=False)
dc_z = print_z()

zthev_dc, rdzstr_dc = calculate_3ph_fault_zthev()
idc_cal = calculate_idc(ik_bas,zthev_dc)

# Table 12 from Standard
ik1_tbl12   = 40.6447
ip1_b_tbl12 = 100.5766
ip1_c_tbl12 = 100.5677
ib1_tbl12   = 40.645

ik2_tbl12   = 31.7831
ip2_b_tbl12 = 80.8249
ip2_c_tbl12 = 80.6079
ib2_tbl12   = 31.570

ik4_tbl12   = 16.2277
ip4_b_tbl12 = 36.8041
ip4_c_tbl12 = 36.8427
ib4_tbl12   = 16.017

ik5_tbl12   = 33.1894
ip5_b_tbl12 = 83.6266
ip5_c_tbl12 = 83.4033
ib5_tbl12   = 32.795

ik6_tbl12   = 37.5629
ip6_b_tbl12 = 99.1910
ip6_c_tbl12 = 98.1434
ib6_tbl12   = 34.028

ik7_tbl12   = 25.5895
ip7_b_tbl12 = 51.3864*1.15
ip7_c_tbl12 = 51.6899
ib7_tbl12   = 23.212

ik_tbl12   = [ik1_tbl12,   ik2_tbl12,   ik4_tbl12,   ik5_tbl12,   ik6_tbl12,   ik7_tbl12  ] 
ip_b_tbl12 = [ip1_b_tbl12, ip2_b_tbl12, ip4_b_tbl12, ip5_b_tbl12, ip6_b_tbl12, ip7_b_tbl12] 
ip_c_tbl12 = [ip1_c_tbl12, ip2_c_tbl12, ip4_c_tbl12, ip5_c_tbl12, ip6_c_tbl12, ip7_c_tbl12] 
ib_tbl12   = [ib1_tbl12,   ib2_tbl12,   ib4_tbl12,   ib5_tbl12,   ib6_tbl12,   ib7_tbl12  ] 

k_b_tbl12  = back_calculate_k(ik_tbl12,ip_b_tbl12)
k_c_tbl12  = back_calculate_k(ik_tbl12,ip_c_tbl12)

# PSS(R)E Results
# Bus Nums      1        2        4        5        6       7
ik_psse  = [ 40.6447, 31.7830, 16.2277, 33.1894, 37.5628, 25.5894]
ipb_psse = [100.5766, 80.5119, 36.8041, 83.6265, 99.1908, 59.0943]
ipc_psse = [100.5676, 80.6079, 36.8427, 83.4033, 98.1432, 51.6898]
idc_psse = [  2.7396, 12.7917,  2.6296,  3.9796, 15.1072,  0.0671]
ibs_psse = [ 40.6426, 31.5777, 16.0211, 32.8065, 34.0131, 23.1936]
iba_psse = [ 40.7348, 34.0702, 16.2354, 33.0470, 37.2171, 23.1937]

# Print Base frequency and Method C impedances
base_z_lst  = base_z.split('\n')
mthdC_z_lst = mthdC_z.split('\n')
dc_z_lst = dc_z.split('\n')

rdzstr_bas_lst = rdzstr_bas.split('\n')
rdzstr_c_lst   = rdzstr_c.split('\n')
rdzstr_dc_lst  = rdzstr_dc.split('\n')

hdr = r"""NETWORK ELEMENT IMPEDANCES in OHMS (COMPARE this to TABLE 11, PP 127)
|

# =====================

BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|"""
foutobj.write(hdr)
foutobj.write('\n')

for v1,v2,v3 in zip(base_z_lst, mthdC_z_lst,dc_z_lst):
    if not v1: continue
    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\n'
    foutobj.write(txt)
    

hdr = r"""
NETWORK REDUCTION  CALCULATION IMPEDANCES in OHMS 
|

# =====================

BASE FREQUENCY ------|   |  |---- METHOD C FREQ (fc/f=0.4)---|   |  |--- DC COMPONENT (fc/f=0.055)---|"""
foutobj.write(hdr)
foutobj.write('\n')

for v1,v2,v3 in zip(rdzstr_bas_lst, rdzstr_c_lst, rdzstr_dc_lst):
    if not v1: continue
    txt = v1 + '  |  ' + v2 + '  |  ' + v3 + '\n'
    foutobj.write(txt)

hdr = r"""
Thevenin Impedance in OHMS calculated with NETWORK REDUCTION (R+jX, X/R ratio)
|BUS| |

# =====================

BASE FREQUENCY --------|    |   |----- METHOD C FREQ (fc/f=0.4)----|    |   |---- DC COMPONENT (fc/f=0.055)----|"""
foutobj.write(hdr)
foutobj.write('\n')

zstrlst_bas = format_z_ratio(zthev_bas)
zstrlst_c   = format_z_ratio(zthev_c,method='C')
zstrlst_dc  = format_z_ratio(zthev_dc,method='DC')
for b,zstr, zstr_c, zstr_dc in zip(buses,zstrlst_bas,zstrlst_c,zstrlst_dc):
    foutobj.write('  %d    %s       %s       %s' % (b, zstr, zstr_c, zstr_dc))
    foutobj.write('\n')

hdr ="""
 METHOD        BUS    I"k       K ip(50)     ip(50)     K ip(20)     ip(20)      Ib dc"""
foutobj.write(hdr)
foutobj.write('\n')

for b1,ik,kb,ipb,kc,ipc,idc,ik_t,kb_t,ipb_t,kc_t,ipc_t,ik_e,ipb_e,ipc_e,idc_e in zip(buses, ik_bas, k_b, ip_b, k_c, ip_c, idc_cal,
                                                            ik_tbl12, k_b_tbl12, ip_b_tbl12, k_c_tbl12, ip_c_tbl12,
                                                            ik_psse, ipb_psse, ipc_psse, idc_psse):
    ikabs = abs(ik)
    s1    = ' '
    lin1 = " CALCULATED   %(b1)3d   %(ikabs)-10.4f   %(kb)-10.4f %(ipb)-10.4f   %(kc)-10.4f %(ipc)-10.4f   %(idc)-10.4f" % vars()
    lin2 = " PSS(R)E      %(s1)3s   %(ik_e)-10.4f   %(s1)10s %(ipb_e)-10.4f   %(s1)10s %(ipc_e)-10.4f   %(idc_e)-10.4f" % vars()
    lin3 = " STANDARD     %(s1)3s   %(ik_t)-10.4f   %(kb_t)-10.4f %(ipb_t)-10.4f   %(kc_t)-10.4f %(ipc_t)-10.4f" % vars()
    foutobj.write(lin1)
    foutobj.write('\n')

    foutobj.write(lin2)
    foutobj.write('\n')

    foutobj.write(lin3)
    foutobj.write('\n\n')

foutobj.close()    

msg = " Results saved in file: %s" % fnamout
print(msg)
#

# =====================

'''There are three different ways to calculate faults using IECS.
1) Using activity IECS (psspy.iecs_4)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.iecs.iecs_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run IECS fault calculations using either of these methods.

# =====================

How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psseXX
    [Here XX is PSSE major version number.]

B) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.
    run_iecs_4(..)
    run_iecs_currents_txtrpt(..)
    run_iecs_currents_xls(..)
    run_fault_summary_iecs(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
#

# =====================

#
"""
Use any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default   Description
                    # STATUS array
flt3ph   = 0        # 1 0=>omit, 1=>include
fltlg    = 0        # 2 0=>omit, 1=>include
fltllg   = 0        # 3 0=>omit, 1=>include
fltll    = 0        # 4 0=>omit, 1=>include
rptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl   = 0        # 6  number of contribution levels
fltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,
                    #    2=>AUX.XMER (connected to power station unit) LV bus
linout   = 0        # 8  0=>omit, 1=>include
linend   = 0        # 9  0=>omit, 1=>include
tpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,
                    #    3=>N unchanged and phi=0
lnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,
                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
dcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
cfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,
                    #    2=>User specified, maximum current, 3=>User specified, minimum current
loadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
genxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs
                    # VALUES array
brktime  = 0.1      # 0.1 seconds, breaker contact parting time
ucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)
                    # File args
iecfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""

#

# =====================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

#

# =====================

def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    #

# =====================

def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    #

# =====================

def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    #

# =====================

def report_iecs_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E IECS SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        #

# =====================

def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using IECS"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

#

# =====================

def _get_outpath():
    import psspy
    
    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()
    s_mjr = "{}".format(mjr)
    s_mnr = "{}".format(mnr)
    s_pch = "{}".format(pch)
    vnam = "v{}{}{}".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))
    outnam = "output_iecs_demo_{}".format(vnam)
    
    outpath = os.path.join(os.getcwd(), outnam)
    if not os.path.exists(outpath): os.makedirs(outpath)
    
    return outpath
    
#

# =====================

def _get_iec60909_network_files():
    savfile = 'iec60909_testnetwork_50Hz.sav'
    iecfile = 'iec60909_testnetwork.iec'
    
    if not os.path.exists(savfile):
        examdir = _get_exam_path()
        savfile = os.path.join(examdir, savfile)
        iecfile = os.path.join(examdir, iecfile)
        if not os.path.exists(savfile):
            msg = " IEC 60909 Network case not found.\n    {}".format(savfile)
            print(msg)
            raise Exception(" Case File not found")

    return savfile, iecfile

#

# =====================

def run_iecs_4(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    iecsobj.run_iecs_api(sid, allbus, **kwds)

    reset_prg_rpt()

#

# =====================

def run_iecs_currents_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_currents_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.report_iecs_currents(rlst, rptfile)

#

# =====================

def run_iecs_currents_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_iecs_currents_{}".format(nam_unt[unt])
    outpath = _get_outpath()
    xlsfile = os.path.join(outpath, xlsfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.excel_iecs_currents(rlst, xlsfile)

#

# =====================

def run_fault_summary_iecs(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_fault_summary_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

##    kwds = {
##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,
##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,
##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,
##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,
##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

#

# =====================

# IEC 60909 Test Network - Compare PSSE Results  
def run_iec60909_test_network():
    # Results output of following run_iecs_4(..)
    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)
    
#

# =====================

def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

    run_iec60909_test_network()

#

# =====================

'''There are three different ways to calculate faults using IECS.
1) Using activity IECS (psspy.iecs_4)
   Runs all types of faults, creates text reports, but no access to results from Python script.

2) Using Python module arrbox.iecs.iecs_currents
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain both phase and sequence fault currents.
       b) contain faults currents for bus faults only.
       c) does not contain faults currents for linout and linend faults.

3) Using Python module arrbox.fault.FAULT_SUMMARY
   Runs all types of faults, creates text reports and returns results in python object that can be
   accessed from Python script.
   The returned python object
       a) contain only total fault currents for faults calculated.
       b) contain faults currents for bus, linout and linend faults.

This is an example file showing how to run IECS fault calculations using either of these methods.

# =====================

How to use this file?

A) As showed in __main__ (end of this file), enable PSSE version specific environment, as an example:
    import psseXX
    [Here XX is PSSE major version number.]

B) This file contain following functions that uses IEC 60909 Test Network file run IECS calculations.
    run_iecs_4(..)
    run_iecs_currents_txtrpt(..)
    run_iecs_currents_xls(..)
    run_fault_summary_iecs(..)

    Run either of these functions under  __main__ to see how they work.

C) Create similar functions for the network case and faults you want to run.

'''
#

# =====================

#
"""
Use any of these keywords to run psspy.iecs or arrbox.iecs.iecs_currents or arrbox.fault.FAULT_SUMMARY.
Keyword   Default   Description
                    # STATUS array
flt3ph   = 0        # 1 0=>omit, 1=>include
fltlg    = 0        # 2 0=>omit, 1=>include
fltllg   = 0        # 3 0=>omit, 1=>include
fltll    = 0        # 4 0=>omit, 1=>include
rptop    = 1        # 5  -1=>no report, 0=>summary, 1=>total, 2=>contributions 3=>total+contributions
rptlvl   = 0        # 6  number of contribution levels
fltloc   = 0        # 7  0=>network, 1=>LV bus of power station unit,
                    #    2=>AUX.XMER (connected to power station unit) LV bus
linout   = 0        # 8  0=>omit, 1=>include
linend   = 0        # 9  0=>omit, 1=>include
tpunty   = 0        # 10 0=>N and phi unchanged, 1=>N=1 and phi=0, 2=>N=1 and phi unchanged,
                    #    3=>N unchanged and phi=0
lnchrg   = 1        # 11 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (line charging)
shntop   = 1        # 12 0=>unchanged, 1=>0.0 in +/- sequences,
                    #    2=>0.0 in all sequences (line, fixed, swicthed shunts, xmer magnetization)
dcload   = 0        # 13 0=>blocked, 1=>represent as load (dc line and FACTS option)
zcorec   = 0        # 14 0=>ignore, 1=>apply  (zero sequence transformer impedance correction option)
cfactor  = 0        # 15 0=>Maximum fault current, 1=>Minimum fault current,
                    #    2=>User specified, maximum current, 3=>User specified, minimum current
loadop   = 0        # 16 0=>unchanged, 1=>0.0 in +/- sequences, 2=>0.0 in all sequences (load)
genxop   = 0        # 17 0=>X'' 1=>X', 2=>Xs
                    # VALUES array
brktime  = 0.1      # 0.1 seconds, breaker contact parting time
ucfactor = 1.0      # specified voltage factor c value (used when option cfactor= 2 or 3)
                    # File args
iecfile   = ''
fcdfile   = ''
scfile    = 'nooutput'
"""

#

# =====================

import sys, os, time, math

bsys_kwds = {'usekv':0, 'basekv':[0.0, 999.0], 'areas':[], 'buses':[],
             'owners':[], 'zones':[]}

def fault_bsys(sid, **kwds):
    import psspy

    if sid==0: return

    actv_kwds = {}  # activity keywords
    for k, v in bsys_kwds.items():
        if k in kwds:
            actv_kwds[k] = kwds[k]
        else:
            actv_kwds[k] = v

    actv_kwds['sid']      = sid
    actv_kwds['numarea']  = len(actv_kwds['areas'])
    actv_kwds['numbus']   = len(actv_kwds['buses'])
    actv_kwds['numowner'] = len(actv_kwds['owners'])
    actv_kwds['numzone']  = len(actv_kwds['zones'])

    ierr = psspy.bsys(**actv_kwds)

    return ierr

#

# =====================

def _frmted_z(self, cnum):
        r=cnum.real
        x=cnum.imag
        csign='+j'
        if x<0:
            csign='-j'
            x=abs(x)

        if r==0:
            rstr=''
        else:
            rstr="%9.6f" % r

        if x==0:
            xstr=''
            csign=''
        else:
            xstr="%9.6f" % x

        zstr = "%(rstr)s%(csign)s%(xstr)s" % vars()

        return zstr

    #

# =====================

def _crnt_mva_mag(self, scfmt, scunit, cval, basekv, sbase):
        if scfmt=='rectangular':
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval
            crnt = abs(crnt)
        else:
            cval = cval.real
            if scunit=='pu':
                baseamp = (1000.0*sbase)/(math.sqrt(3.0)*basekv)
                crnt = cval*baseamp
            else:
                crnt = cval

        mva  = math.sqrt(3.0)*basekv*crnt/1000.0

        return crnt, mva

    #

# =====================

def run_fault_summary(self, sid, allbus, **kwds):
        import psspy, arrbox.fault

        fltobj = arrbox.fault.FAULT_SUMMARY('IECS', sid, allbus, **kwds)

        if fltobj.ierr!=0:
            raise Exception("arrbox.fault.FAULT_SUMMARY error= {}\n".format(fltobj.ierr))

        return fltobj

    #

# =====================

def report_iecs_currents(self, rlst, rptfile=''):
        import psspy

        if rlst.ierr: return

        if rptfile:
            p, nx = os.path.split(rptfile)
            n, x = os.path.splitext(nx)
            if not x:
                x = '.txt'
                nx = n + x
            if p:
                rptfile = os.path.join(p, nx)
            else:
                rptfile = os.path.join(os.getcwd(), nx)
            rptfile_h = open(rptfile,'w')
            report    = rptfile_h.write
        else:
            psspy.beginreport()
            report = psspy.report

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        nfbus=len(rlst.fltbus)

        txtlst = []
        if not rptfile: txtlst.append('')

        ttlstr="PSS(R)E IECS SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
        ln1str,ln2str=psspy.titldt()
        maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
        txtlst.append(ttlstr.center(maxlen))
        txtlst.append(ln1str.center(maxlen))
        txtlst.append(ln2str.center(maxlen))
        txtlst.append('')
        txtall = "\n".join(txtlst)
        report(txtall)

        scunit = rlst.scunit
        scfmt  = rlst.scfmt

        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        if scunit == 'pu':
            units = 'PU'
        else:
            units = 'AMP'
        unitstr   = units.center(10)
        clnhdr    = "   BUS     " + 6*unitstr

        for i in range(nfbus):
            txtlst = []
            txtlst.append('')
            txtlst.append("           <--ia1--> <--ia2--> <--ia0--> <--ia---> <--ib---> <--ic--->")
            txtlst.append(clnhdr)
            fbus   = rlst.fltbus[i]
            if flt3ph:
                ttxt   = "%6d" % fbus
                spc    = '3PH'
                ia1    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.flt3ph[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.flt3ph[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.flt3ph[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.flt3ph[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltlg:
                if flt3ph:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = ' LG'
                ia1    = self._crnt_mag(scfmt,rlst.fltlg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltlg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltlg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltlg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltlg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltlg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltllg:
                if flt3ph or fltlg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc    = 'LLG'
                ia1    = self._crnt_mag(scfmt,rlst.fltllg[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltllg[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltllg[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltllg[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltllg[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltllg[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            if fltll:
                if flt3ph or fltlg or fltllg:
                    ttxt = 6*' '
                else:
                    ttxt = "%6d" % fbus
                spc     = ' LL'
                ia1    = self._crnt_mag(scfmt,rlst.fltll[i].ia1)
                ia2    = self._crnt_mag(scfmt,rlst.fltll[i].ia2)
                ia0    = self._crnt_mag(scfmt,rlst.fltll[i].ia0)
                ia     = self._crnt_mag(scfmt,rlst.fltll[i].ia)
                ib     = self._crnt_mag(scfmt,rlst.fltll[i].ib)
                ic     = self._crnt_mag(scfmt,rlst.fltll[i].ic)
                tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ia2)9.2f %(ia0)9.2f %(ia)9.2f %(ib)9.2f %(ic)9.2f" % vars()
                txtlst.append(tmptxt)

            txtlst.append("\nTHEVENIN IMPEDANCE (pu), X/R")

            z1str = self._frmted_z_xbyr(rlst.thevzpu[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = self._frmted_z_xbyr(rlst.thevzpu[i].z2)
                z2str ="Z2: " + z2str
                z0str = self._frmted_z_xbyr(rlst.thevzpu[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
            else:
                tmptxt="%(z1str)s" % vars()
            txtlst.append(tmptxt)

            if scunit_z!='pu':
                txtlst.append("\nTHEVENIN IMPEDANCE (ohms), X/R")
                z1str = self._frmted_z_xbyr(rlst.thevz[i].z1)
                z1str ="Z1: " + z1str
                if fltlg or fltllg or fltll:
                    z2str = self._frmted_z_xbyr(rlst.thevz[i].z2)
                    z2str ="Z2: " + z2str
                    z0str = self._frmted_z_xbyr(rlst.thevz[i].z0)
                    z0str ="Z0: " + z0str
                    tmptxt="%(z1str)s    %(z2str)s    %(z0str)s" % vars()
                else:
                    tmptxt="%(z1str)s" % vars()
                txtlst.append(tmptxt)

            tmptxt=110*'-'
            txtlst.append(tmptxt)
            txtlst.append('')

            txtall = "\n".join(txtlst)
            report(txtall)

        # Maximum Fault Currents
        inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
        unitstr   = units.center(11)
        unitstr = ''
        for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
            t = each+'('+units+')'
            t = ' ' + t.center(9) + ' '
            unitstr += t

        txtlst = []
        txtlst.append('')

        clnhdr    = "   BUS  " + unitstr + "  Description"
        txtlst.append("BREAKER DUTY CURRENTS")
        txtlst.append(clnhdr)
        txtall = "\n".join(txtlst)
        report(txtall)

        for i in range(nfbus):
            fbus   = rlst.fltbus[i]
            ia1    = self._crnt_mag(scfmt,rlst.maxflt[i].ia1)
            ia2    = self._crnt_mag(scfmt,rlst.maxflt[i].ia2)
            ia0    = self._crnt_mag(scfmt,rlst.maxflt[i].ia0)
            ia     = self._crnt_mag(scfmt,rlst.maxflt[i].ia)
            ib     = self._crnt_mag(scfmt,rlst.maxflt[i].ib)
            ic     = self._crnt_mag(scfmt,rlst.maxflt[i].ic)
            dsc    = rlst.maxfltdsc[i]
            if rptfile: report('\n')
            tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s" % vars()
            report(tmptxt)

        #

# =====================

def excel_iecs_currents(self, rlst, faults_applied, xlsfile=''):
        import psspy
        import excelpy

        if rlst.ierr: return

        # bus data
        sid  = -1   # consider subsystem of all buses
        flag = 1    # consider only in-service buses
        ierr,(busnums,)   = psspy.abusint(sid,flag,['NUMBER'])
        ierr,(busbasevs,) = psspy.abusreal(sid,flag,'BASE')
        ierr,(busvlt,)    = psspy.abuscplx(sid,flag,'VOLTAGE') # pre-fault bus voltages in pu
        ierr,(busname,)   = psspy.abuschar(sid,flag,'NAME')

        bus_data = {}
        for bnum, bbasev, bvlt, bnam in zip(busnums,busbasevs,busvlt,busname):
            bus_data[bnum] = {'prefltv': bvlt, 'basekv': bbasev, 'name': bnam}

        flt3ph = rlst.flt3ph
        fltlg  = rlst.fltlg
        fltllg = rlst.fltllg
        fltll  = rlst.fltll

        scunit   = rlst.scunit
        scfmt    = rlst.scfmt
        scunit_z = rlst.scunit_z
        scfmt_z  = rlst.scfmt_z

        nfbus=len(rlst.fltbus)

        xlswbk = excelpy.workbook(xlsfile)
        xlswbk.show()

        savfile, snpfile = psspy.sfiles()
        line1, line2 = psspy.titldt()

        ttl      = r"PSSE Short Circuit Calculations Using IECS"
        ttl      = ttl + 5*' ' + time.ctime()
        ttl_file = savfile
        ttl_line1= line1.strip()
        ttl_line2= line2.strip()

        cln_mrglst = []
        cln_heads_r1 = ['BUS', '', 'BASE', 'PREFLT']
        cln_heads_r2 = ['NUMBER', 'NAME', 'kV', 'kV']
        for fltok, clnnam in zip([flt3ph, fltlg, fltllg, fltll],
                                 ['3-PH FAULT', 'LG FAULT', 'LLG FAULT', 'LL FAULT']):
            if fltok:
                cln_mrglst.append(len(cln_heads_r1)+1)
                cln_heads_r1.extend([clnnam, ''])
                cln_heads_r2.extend(['MVA', 'AMP'])

        cln_heads_r1.extend(['THEVENIN IMPEDANCE (PU on 100 MVA and bus base KV)','', ''])
        cln_heads_r2.extend(['Positive Sequence', 'Negative Sequence', 'Zero Sequence'])

        colheads = [cln_heads_r1, cln_heads_r2]

        row = 7
        cln = 1

        sbase = psspy.sysmva()

        for i in range(nfbus):
            rowdata = []
            fbus    = rlst.fltbus[i]
            basekv  = bus_data[fbus]['basekv']
            prefltv = bus_data[fbus]['prefltv']

            rowdata.append(fbus)
            rowdata.append(bus_data[fbus]['name'])
            rowdata.append(basekv)
            rowdata.append(basekv*abs(prefltv))

            if flt3ph:
                cval = rlst.flt3ph[i].ia1   # Ifault=Ia1=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            if fltlg:
                cval = rlst.fltlg[i].ia0    # Ifault=3*Ia0=Ia
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltllg:
                cval = rlst.fltllg[i].ia0   # Ifault=3*Ia0
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([3*mva, 3*crnt])

            if fltll:
                cval = rlst.fltll[i].ib   # Ifault=Ib
                crnt, mva = self._crnt_mva_mag(scfmt, scunit, cval, basekv, sbase)
                rowdata.extend([mva, crnt])

            zpos  = rlst.thevzpu[i].z1
            zneg  = rlst.thevzpu[i].z2
            zzero = rlst.thevzpu[i].z0

            s_zpos  = self._frmted_z(zpos)
            s_zneg  = self._frmted_z(zneg)
            s_zzero = self._frmted_z(zzero)

            rowdata.extend([s_zpos, s_zneg, s_zzero])

            brow,rcln = xlswbk.set_range(row,cln,rowdata)
            row = brow + 1

        xlswbk.font((6,3,brow,8),numberFormat="0.00")
        xlswbk.autofit_columns((6,9,brow,rcln))
        xlswbk.align((6,9,brow,rcln),'right')

        # headings and column titles
        xlswbk.set_cell((1,1),ttl,fontStyle="Bold",fontSize=12, fontColor="red")
        xlswbk.merge((1,1,1,rcln))

        xlswbk.set_cell((2,1),ttl_file,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((2,1,2,rcln))

        xlswbk.set_cell((3,1),ttl_line1,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((3,1,3,rcln))

        xlswbk.set_cell((4,1),ttl_line2,fontStyle="Bold",fontSize=10, fontColor="red")
        xlswbk.merge((4,1,4,rcln))

        brow,rcln = xlswbk.set_range(5,1,colheads,fontSize=11, fontColor="blue")

        xlswbk.merge((5,1,5,2))
        for cln in cln_mrglst:
            xlswbk.merge((5,cln,5,cln+1))
        xlswbk.merge((5,rcln-2,5,rcln))

        xlswbk.align((1,1),'h_center')
        xlswbk.align_rows((1,1,6,1),'h_center')

        if xlsfile: xlswbk.save(xlsfile)

#

# =====================

def _get_outpath():
    import psspy
    
    nam, mjr, mnr, pch, dt, stat = psspy.psseversion()
    s_mjr = "{}".format(mjr)
    s_mnr = "{}".format(mnr)
    s_pch = "{}".format(pch)
    vnam = "v{}{}{}".format(s_mjr.zfill(2), s_mnr.zfill(2), s_pch.zfill(2))
    outnam = "output_iecs_demo_{}".format(vnam)
    
    outpath = os.path.join(os.getcwd(), outnam)
    if not os.path.exists(outpath): os.makedirs(outpath)
    
    return outpath
    
#

# =====================

def _get_iec60909_network_files():
    savfile = 'iec60909_testnetwork_50Hz.sav'
    iecfile = 'iec60909_testnetwork.iec'
    
    if not os.path.exists(savfile):
        examdir = _get_exam_path()
        savfile = os.path.join(examdir, savfile)
        iecfile = os.path.join(examdir, iecfile)
        if not os.path.exists(savfile):
            msg = " IEC 60909 Network case not found.\n    {}".format(savfile)
            print(msg)
            raise Exception(" Case File not found")

    return savfile, iecfile

#

# =====================

def run_iecs_4(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iec60909_testnetwork_iecs_4_{}_rpt{}_report.txt".format(nam_unt[unt], kwds['rptop'])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    set_prg_rpt(rptfile=rptfile)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    iecsobj.run_iecs_api(sid, allbus, **kwds)

    reset_prg_rpt()

#

# =====================

def run_iecs_currents_txtrpt(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_currents_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.report_iecs_currents(rlst, rptfile)

#

# =====================

def run_iecs_currents_xls(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    xlsfile = "z_iecs_currents_{}".format(nam_unt[unt])
    outpath = _get_outpath()
    xlsfile = os.path.join(outpath, xlsfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    rlst = iecsobj.run_iecs_currents(sid, allbus, **kwds)
    iecsobj.excel_iecs_currents(rlst, xlsfile)

#

# =====================

def run_fault_summary_iecs(**kwds):
    import psspy
    psspy.psseinit(buses=150000)

    savfile, iecfile = _get_iec60909_network_files()

    buses = [1,2,3,4,5,6,7,8]
    sid, allbus = 3, 0

    nam_unt = {0:'pu', 1:'amp'}
    unt=1

    rptfile = "z_iecs_fault_summary_{}.txt".format(nam_unt[unt])
    outpath = _get_outpath()
    rptfile = os.path.join(outpath, rptfile)

    ierr = psspy.case(savfile)
    ierr = fault_bsys(sid, buses=buses)

    # set short circuit options
    psspy.short_circuit_units(unt)          # 0=PU, 1=Physical
    psspy.short_circuit_z_units(unt)        # 0=PU, 1=Physical
    psspy.short_circuit_coordinates(1)      # 0=rectangular, 1=polar
    psspy.short_circuit_z_coordinates(0)    # 0=rectangular, 1=polar
    psspy.short_circuit_warning(0)          # 0= disable, printing of of RESQ/TRSQ/solution warnings

##    kwds = {
##        'flt3ph'   : 1, 'fltlg'    : 1, 'fltllg'   : 1, 'fltll'    : 1,
##        'rptop'    : 1, 'rptlvl'   : 0, 'fltloc'   : 0, 'linout'   : 0,
##        'linend'   : 0, 'tpunty'   : 0, 'lnchrg'   : 1, 'shntop'   : 1,
##        'dcload'   : 0, 'zcorec'   : 0, 'cfactor'  : 0, 'loadop'   : 0,
##        'genxop'   : 0, 'brktime'  : 0.1, 'ucfactor' : 1.0 }

    kwds['iecfile'] = iecfile
    iecsobj = IECS_DEMO()
    fltobj = iecsobj.run_fault_summary(sid, allbus, **kwds)
    fltobj.text_report(rptfile)

#

# =====================

# IEC 60909 Test Network - Compare PSSE Results  
def run_iec60909_test_network():
    # Results output of following run_iecs_4(..)
    # match to those in Table 12 and Table 13 of IEC 60909-4 2001.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=-1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=-1, linout=1, linend=1)
    
#

# =====================

def _temp():
    # Run either of these functions under  __main__ to see how they work.
    run_iecs_4(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)

    run_iecs_currents_txtrpt(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_iecs_currents_xls(flt3ph=1, fltlg=1, fltllg=1, fltll=1)

    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=1, fltll=1, rptop=1)
    run_fault_summary_iecs(flt3ph=1, fltlg=1, fltllg=0, fltll=1, rptop=0, linout=1, linend=1)

    run_iec60909_test_network()

#

# =====================

'''
This is an example file showing how to use "iecs_currents" function from pssarrays module.

IECS_CURRENTS function returns IEC 60909 standard fault currents for each faulted bus and
each type of fault applied. They are:
    ia1   = Positive Sequence Current
    ia2   = Negative Sequence Current
    ia0   = Zero Sequence Current
    ia    = Phase A current
    ib    = Phase B current
    ic    = Phase C current
    ipb   = peak Current - Method B, ip(B)
    ipc   = peak Current - Method C, ip(C)
    idc   = DC component of asymmetrical breaking current, idc
    ibsym = symmetrical breaking current (r.m.s.), ib(sym)
    ibuns = asymmetrical breaking current (r.m.s.), ib(uns)

The APIs used in this program are part of python "pssarrays" module.

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call funtion
    run_iecs_report()

    You may want to change inputs specified in this function.
    run_iecs_report(savfile, iecfile, fltbuses, rptfile)
    Defaults:
        savfile  = 'iec60909_testnetwork_50Hz.sav'
        iecfile  = 'iec60909_testnetwork.iec'
        fltbuses = [1,2,3,4,5,6,7,8]
        rptfile  = 'iecs_report_iec60909_testnetwork_50Hz.txt'
                   When this script is called from PSSE's Example Folder,
                   report is created in subfolder 'Output_Pyscript'
'''

#

# =====================

def encode_complex_number_xbyr(cnum):
    r=cnum.real
    x=cnum.imag
    csign='+j'
    if x<0:
        csign='-j'
        x=abs(x)

    if r==0:
        rstr=''
        xbyr=''
    else:
        rstr="%9.6f" % r
        xbyr="%9.6f" % (x/r)

    if x==0:
        xstr=''
        csign=''
    else:
        xstr="%9.6f" % x

    cstr="%(rstr)s%(csign)s%(xstr)s, %(xbyr)s" % vars()

    return cstr

#

# =====================

def create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,
                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,
                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl):

    import psspy, arrbox.iecs

    # open case
    if savfile: psspy.case(savfile)

    # set sc units and format
    psspy.short_circuit_units(units)
    psspy.short_circuit_coordinates(fmt)

    sid = 3
    if fltbuses:
        psspy.bsys(sid,0,[0.0,0.0],0,[],len(fltbuses),fltbuses,0,[],0,[])
        busall = 0
    else:
        busall = 1

    # call pssarrays routine
    rlst=arrbox.iecs.iecs_currents(sid=sid, all=busall, flt3ph=flt3ph, fltlg=fltlg, fltllg=fltllg,
            fltll=fltll, linout=linout, linend=linend, tpunty=tpunty, lnchrg=lnchrg,
            shntop=shntop, dcload=dcload, zcorec= zcorec, optnftrc=optnftrc, loadop=loadop,
            genxop=genxop, brktime=brktime, vfactorc=vfactorc,
            iecfile=iecfile, fcdfile=fcdfile, scfile=scfile, rprtyp=rprtyp, rprlvl=rprlvl)
    if rlst.ierr!=0:
        raise Exception("arrbox.iecs.iecs_currents error= %d\n" % rlst.ierr)

    if rptfile:
        p, nx = os.path.split(rptfile)
        n, x = os.path.splitext(nx)
        if not x:
            x = '.txt'
            nx = n + x
        if p:
            rptfile = os.path.join(p, nx)
        else:
            rptfile = os.path.join(os.getcwd(), nx)
        rptfile_h = open(rptfile,'w')
        report    = rptfile_h.write
    else:
        psspy.beginreport()
        report = psspy.report

    nfbus=len(rlst.fltbus)

    ttlstr="PSS(R)E IEC 60909 SHORT CIRCUIT CURRENTS" + 10*' ' + time.ctime()
    ln1str,ln2str=psspy.titldt()
    maxlen=max(len(ttlstr),len(ln1str),len(ln2str))
    report(ttlstr.center(maxlen))
    report("\n")
    report(ln1str.center(maxlen))
    report("\n")
    report(ln2str.center(maxlen))
    report("\n\n")

    scunit = rlst.scunit
    scfmt  = rlst.scfmt
    if scunit == 'pu':
        units = 'PU'
    else:
        units = 'AMP'
    unitstr   = units.center(10)
    clnhdr    = "   BUS     " + 6*unitstr + "\n"

    for i in range(nfbus):
        report("           <-i''k--> <-ip(B)-> <-ip(C)-> <--idc--> <ib(sym)> <ib(uns)>\n")
        report(clnhdr)
        fbus   = rlst.fltbus[i]
        if flt3ph:
            ttxt   = "%6d" % fbus
            spc    = '3PH'
            ia1    = current_magnitude(scfmt,rlst.flt3ph[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.flt3ph[i].ia2)
            ia0    = current_magnitude(scfmt,rlst.flt3ph[i].ia0)
            ia     = current_magnitude(scfmt,rlst.flt3ph[i].ia)
            ib     = current_magnitude(scfmt,rlst.flt3ph[i].ib)
            ic     = current_magnitude(scfmt,rlst.flt3ph[i].ic)
            ipb    = current_magnitude(scfmt,rlst.flt3ph[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.flt3ph[i].ipc)
            idc    = current_magnitude(scfmt,rlst.flt3ph[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.flt3ph[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.flt3ph[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia1)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltlg:
            if flt3ph:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = ' LG'
            ia1    = current_magnitude(scfmt,rlst.fltlg[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltlg[i].ia2)
            ia0    = current_magnitude(scfmt,3*rlst.fltlg[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltlg[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltlg[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltlg[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltlg[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltlg[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltlg[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltlg[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltlg[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltllg:
            if flt3ph or fltlg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc    = 'LLG'
            ia1    = current_magnitude(scfmt,rlst.fltllg[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltllg[i].ia2)
            ia0    = current_magnitude(scfmt,3*rlst.fltllg[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltllg[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltllg[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltllg[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltllg[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltllg[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltllg[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltllg[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltllg[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ia0)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        if fltll:
            if flt3ph or fltlg or fltllg:
                ttxt = 6*' '
            else:
                ttxt = "%6d" % fbus
            spc     = ' LL'
            ia1    = current_magnitude(scfmt,rlst.fltll[i].ia1)
            ia2    = current_magnitude(scfmt,rlst.fltll[i].ia2)
            ia0    = current_magnitude(scfmt,rlst.fltll[i].ia0)
            ia     = current_magnitude(scfmt,rlst.fltll[i].ia)
            ib     = current_magnitude(scfmt,rlst.fltll[i].ib)
            ic     = current_magnitude(scfmt,rlst.fltll[i].ic)
            ipb    = current_magnitude(scfmt,rlst.fltll[i].ipb)
            ipc    = current_magnitude(scfmt,rlst.fltll[i].ipc)
            idc    = current_magnitude(scfmt,rlst.fltll[i].idc)
            ibsym  = current_magnitude(scfmt,rlst.fltll[i].ibsym)
            ibuns  = current_magnitude(scfmt,rlst.fltll[i].ibuns)
            tmptxt = "%(ttxt)s %(spc)s %(ib)9.2f %(ipb)9.2f %(ipc)9.2f %(idc)9.2f %(ibsym)9.2f %(ibuns)9.2f \n" % vars()
            report(tmptxt)

        report("\nTHEVENIN IMPEDANCE (pu), X/R\n")
        z1str = encode_complex_number_xbyr(rlst.thevzpu[i].z1)
        z1str ="Z1: " + z1str
        if fltlg or fltllg or fltll:
            z2str = encode_complex_number_xbyr(rlst.thevzpu[i].z2)
            z2str ="Z2: " + z2str
            z0str = encode_complex_number_xbyr(rlst.thevzpu[i].z0)
            z0str ="Z0: " + z0str
            tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
        else:
            tmptxt="%(z1str)s\n" % vars()
        report(tmptxt)

        if scunit != 'pu':
            report("\nTHEVENIN IMPEDANCE (ohms), X/R\n")
            z1str = encode_complex_number_xbyr(rlst.thevz[i].z1)
            z1str ="Z1: " + z1str
            if fltlg or fltllg or fltll:
                z2str = encode_complex_number_xbyr(rlst.thevz[i].z2)
                z2str ="Z2: " + z2str
                z0str = encode_complex_number_xbyr(rlst.thevz[i].z0)
                z0str ="Z0: " + z0str
                tmptxt="%(z1str)s    %(z2str)s    %(z0str)s\n" % vars()
            else:
                tmptxt="%(z1str)s\n" % vars()
            report(tmptxt)

        tmptxt=110*'-'
        report(tmptxt)
        report("\n")

    # Maximum Fault Currents
    inam = ['ia1', 'ia2', 'ia0', 'ia', 'ib', 'ic']
    unitstr   = units.center(11)
    unitstr = ''
    for each in ['ia1', 'ia2', 'ia0', ' ia', ' ib', ' ic']:
        t = each+'('+units+')'
        t = ' ' + t.center(9) + ' '
        unitstr += t

    clnhdr    = "   BUS  " + unitstr + "  Description\n"
    report("\nBREAKER DUTY CURRENTS\n")
    report(clnhdr)
    for i in range(nfbus):
        fbus   = rlst.fltbus[i]
        ia1    = current_magnitude(scfmt,rlst.maxflt[i].ia1)
        ia2    = current_magnitude(scfmt,rlst.maxflt[i].ia2)
        ia0    = current_magnitude(scfmt,rlst.maxflt[i].ia0)
        ia     = current_magnitude(scfmt,rlst.maxflt[i].ia)
        ib     = current_magnitude(scfmt,rlst.maxflt[i].ib)
        ic     = current_magnitude(scfmt,rlst.maxflt[i].ic)
        dsc    = rlst.maxfltdsc[i]
        tmptxt = "%(fbus)6d   %(ia1)9.2f  %(ia2)9.2f  %(ia0)9.2f  %(ia)9.2f  %(ib)9.2f  %(ic)9.2f   %(dsc)s\n" % vars()
        report(tmptxt)

    #

# =====================

def check_psse_example_folder(rptfile):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'
    rptpath, rptfnam = os.path.split(rptfile)
    if not rptpath:
        rptpath = os.getcwd()
        cwd = rptpath.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(os.getcwd(), 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)
        else:
            outdir = os.getcwd()
        rptfile  = os.path.join(outdir, rptfnam)

    return rptfile

#

# =====================

def run_iecs_report(savfile='iec60909_testnetwork_50Hz.sav', iecfile='iec60909_testnetwork.iec',
                    fltbuses=[1,2,3,4,5,6,7,8], rptfile='iecs_report_iec60909_testnetwork_50Hz.txt'):

    import psspy

    psspy.psseinit()

    # Inputs, change as required

    units    = 1       # 0=per unit,    1=physical
    fmt      = 0       # 0=rectangular, 1=polar coordinates

    flt3ph   = 1       #
    fltlg    = 1       #
    fltllg   = 1       #
    fltll    = 1       #
    linout   = 0       #
    linend   = 0       #
    tpunty   = 0       #
    lnchrg   = 1       #
    shntop   = 1       #
    dcload   = 0       #
    zcorec   = 0       #
    optnftrc = 0       #
    loadop   = 1       #
    genxop   = 0       # 0=X", 1=X', 2=Xs (generator reactance)

    brktime  = 0.1     # 0.1 seconds
    vfactorc = 1.0     #

    rptfile  = check_psse_example_folder(rptfile)

    fcdfile  = ""
    scfile   = ""

    rprtyp   = -1      # no report
    rprlvl   = 0       # number of contribution levels

    create_report(units,fmt,fltbuses,flt3ph,fltlg,fltllg,fltll,linout,linend,tpunty,
                  lnchrg,shntop,dcload,zcorec,optnftrc,loadop,genxop,brktime,vfactorc,
                  savfile,iecfile,fcdfile,scfile,rptfile,rprtyp,rprlvl)

#

# =====================

def get_nlevel_buses(homebus, nlevels):
    """
    Python Syntax:
        lvl_busdict = get_nlevel_buses(savfile, homebus, nlevels)

    Arguments:
        homebus(integer) : Home (starting) bus number to start finding next buses
        nlevels(integer) : Number of levels of buses from Home Bus
    """
    import psspy
    psspy.psseinit()

    lvl_list = [n+1 for n in range(nlevels)]

    lvl_busdict = {}
    lvl_busdict[0] = [homebus]

    do_buslist = [homebus]
    done_busdict = {}

    for lvl in lvl_list:
        if not do_buslist: break
        tmp_busdict = {}

        # Search for branches and two winding transformers
        for ibus in do_buslist:
            ierr = psspy.inibrn(ibus, single=2)
            #print("0 inibrn: ierr={}, ibus={}".format(ierr, ibus))
            if ierr == 0:
                while True:
                    ierr,jbus,ickt = psspy.nxtbrn(ibus)
                    #print("1 nxtbrn: ierr={}, jbus={}".format(ierr, jbus))
                    if ierr: break
                    tmp_busdict[jbus] = 1

        # Search for three winding transformers
        for ibus in do_buslist:
            ierr = psspy.inibrn(ibus, single=2)
            if ierr == 0:
                while True:
                    ierr,jbus,kbus,ickt = psspy.nxtbrn3(ibus)
                    #print("2 nxtbrn3: ierr={}, jbus={}, kbus={}".format(ierr, jbus, kbus))
                    if ierr: break
                    tmp_busdict[jbus] = 1
                    if (kbus>0): tmp_busdict[kbus] = 1

        tmp_buslist = list(tmp_busdict.keys())
        tmp_buslist.sort()

        for ibus in do_buslist:
            done_busdict[ibus] = 1

        do_buslist = []
        for ibus in tmp_buslist:
            if ibus not in done_busdict:
                do_buslist.append(ibus)

        lvl_busdict[lvl] = do_buslist[:]

    # all done
    return lvl_busdict

#

# =====================

def test_me():
    import psse3502
    import psspy
    psspy.psseinit()
    savfile = "sample.sav"
    psspy.case(savfile)
    lvl_busdict = get_nlevel_buses(151, 3)
    #lvl_busdict = get_nlevel_buses(206, 10)
    #lvl_busdict = get_nlevel_buses(101, 10)
    print("N Level Buses")
    for lvl, buslist in lvl_busdict.items():
        print("Level={}, Buses={}".format(lvl, buslist))

#

# =====================

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def otdf_excel(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None, show=True):

    import psspy, arrbox.dfax_pp

    import excelpy

    if not os.path.exists(savfile):
        print("\n SAV file '%s' not found." % savfile)
        return

    if not os.path.exists(dfxfile):
        print("\n DFAX file '%s' not found." % dfxfile)
        return

    p, nx = os.path.split(dfxfile)
    n, x  = os.path.splitext(nx)
    xlfile = get_output_filename(outpath, 'otdffactors_'+n)

    psspy.psseinit()

    psspy.case(savfile)

    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)

    otdfobj = dfxobj.otdf_factors()
    if otdfobj.ierr != 0: return

    otdfxls = excelpy.workbook(xlfile, 'OTDF FACTORS', overwritesheet=True)
    if show: otdfxls.show()
    otdfxls.show_alerts(0) # do not show pop-up alerts

    otdfxls.page_format(orientation="landscape",left=1.0,right=1.0,
                       top=0.5,bottom=0.5,header=0.25,footer=0.25)
    otdfxls.page_footer(left='page number of page total', right='date, time')
    otdfxls.page_header(center='file name:sheet name')
    otdfxls.font_sheet()

    # Report Title
    col = 1
    row = 1
    tmplst = (["OTDF Factors Report"],[dfxfile])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.font((1,1),fontColor='red',fontSize=14)
    otdfxls.font_color((2,1),'blue')

    row = bottomRow + 1

    tmplst = [
        otdfobj.casetitle.line1,                                       #
        otdfobj.casetitle.line2,                                       #
        ''
        'Saved Case file              = %s' % otdfobj.file.sav,         #
        'DFAX file                    = %s' % otdfobj.file.dfx,         #
        'Subsystem file               = %s' % otdfobj.file.sub,         #
        'Monitored Element file       = %s' % otdfobj.file.mon,         #
        'Contingency Description file = %s' % otdfobj.file.con,         #
        ]

    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst,transpose=True)
    row = bottomRow + 2 # one blank row

    txt = "'*** OTDF Contingency Description ***"
    otdfxls.set_cell((row,col),txt,fontStyle="Bold",fontSize=12, fontColor="red")
    row = row + 1

    tmplst=[]
    for i in range(otdfobj.size.ncase):
        lbl  = otdfobj.colabel[i]
        desc = otdfobj.codesc[i]
        tmplst.append([lbl,desc])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,col),'right')
    otdfxls.font_color((row,col,bottomRow,col),'dgreen')

    row = bottomRow + 2 # one blank row

    txt = "'*** OTDF Factors ***"
    otdfxls.set_cell((row,col),txt,fontStyle="Bold",fontSize=12, fontColor="red")
    row = row + 1

    tmplst=['<

# =====================

>']
    for each in otdfobj.colabel:
        tmplst.append(each.strip())
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,rightCol),'right')
    otdfxls.font_color((row,col,bottomRow,rightCol),'blue')

    row = bottomRow + 1

    tmplst=[]
    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):
        tmplst.append([otdfobj.melement[i].strip()])
    bottomRow,rightCol = otdfxls.set_range(row,col,tmplst)
    otdfxls.align((row,col,bottomRow,col),'right')
    otdfxls.font_color((row,col,bottomRow,col),'dgreen')

    col = rightCol + 1
    bottomRow,rightCol = otdfxls.set_range(row,col,otdfobj.factor,transpose=True,numberFormat='0.0000')

    otdfxls.width((1,1),53)
    otdfxls.width((1,2,1,rightCol),12)

    #

# =====================

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def otdf_report(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):

    import psspy, arrbox.dfax_pp

    if not os.path.exists(savfile):
        print("\n SAV file '%s' not found." % savfile)
        return

    if not os.path.exists(dfxfile):
        print("\n DFAX file '%s' not found." % dfxfile)
        return

    p, nx = os.path.split(dfxfile)
    n, x  = os.path.splitext(nx)
    rptfile = get_output_filename(outpath, 'otdffactors_'+n+'.txt')

    psspy.psseinit()

    psspy.case(savfile)

    dfxobj = arrbox.dfax_pp.DFAX_PP(dfxfile)
    otdfobj = dfxobj.otdf_factors()
    if otdfobj.ierr != 0: return

    rptfile_h = open(rptfile,'w')
    report    = rptfile_h.write

    # (0) Report title
    ttl_hline = '*' + 46* ' *' + '\n\n'
    ttl       = 30*' ' + "OTDF Factors Report" + "\n"
    ttl_file  = 30*' ' + otdfobj.file.dfx + "\n"
    ttl_time  = 30*' ' + time.ctime() + "\n\n"
    report(ttl_hline)
    report(ttl)
    report(ttl_file)
    report(ttl_time)
    report(ttl_hline)

    report('%s\n' % otdfobj.casetitle.line1)
    report('%s\n' % otdfobj.casetitle.line2)
    report('\n')

    report('Saved Case file              = %s\n' % otdfobj.file.sav)
    report('DFAX file                    = %s\n' % otdfobj.file.dfx)
    report('Subsystem file               = %s\n' % otdfobj.file.sub)
    report('Monitored Element file       = %s\n' % otdfobj.file.mon)
    report('Contingency Description file = %s\n' % otdfobj.file.con)
    report('\n')

    report('*** OTDF Contingency Description ***\n')
    for i in range(otdfobj.size.ncase):
        lbl  = otdfobj.colabel[i]
        desc = otdfobj.codesc[i]
        report("  %(lbl)12s  %(desc)s\n" %vars())

    report("\n")
    report('*** OTDF Factors ***\n')
    report('  <

# =====================

>  ')
    for each in otdfobj.colabel:
        report("%12s  " %each.strip())
    report("\n")
    for i in range(otdfobj.size.nmline+otdfobj.size.ninter):
        report("  %52s  " % otdfobj.melement[i].strip())
        for j in range(otdfobj.size.ncase):
            report("%12.6f  " % otdfobj.factor[j][i])
        report("\n")

    #

# =====================

'''
In some PSSE Saved Cases, especially some old sav files, all transformer data is provided on
System MVA base (SBASE). When this network data is to be used to calculate fault currents
according to "IEC 60909" standard, in order to calculate correct IEC impedance correction factors,
nameplate transformer winding MVA data is required.

This file is used to:
(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and
    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.
    Refer function: change_winding_mva(rating='')
    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),
    then this files can be used to change transformer winding MVA with selected Rating. 

(2) Create transformers IEC data file.
    Refer function: create_iecdata(wdgmva='',rptfile='')
    Create a text file with all transformer branches and then use this file to provide
    nameplate transformer winding MVA as part of transformer nameplate IEC data records.

# =====================

Functions:

(1) change_winding_mva(rating='')
    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.

(2) create_iecdata(wdgmva='',rptfile='')
    Create IEC data file for all Transformers Winding MVA.
    Each IEC data record for a transformer has following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1

    Transformers IEC data records created here need to put in complete IEC data file.
        Refer POM Volume 1, API IECS for format of IEC data file.
        
    This function creates output file depending on the wndmva input provided.
    (1) If wndmva is not provided, it creates records in the following format.
    IBUS, JBUS, KBUS, CKT
    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.

    (2) If wndmva="SBASE", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

    (3) If wndmva="RATEA" or "RATEB" or "RATEC", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)
          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)
          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)
          If any of the winding MVA is zero, it is ignored.
    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

# =====================

How to use this file?

(1) Open the Saved Case using PSS(R)E GUI

(2) Without PROMPT for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    change_winding_mva(rating)
    or
    create_iecdata(wndmva, rptfile)

(3) With PROMPTS for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    dochng()
    or
    docreate()
'''

import psspy, os

#

# =====================

def _splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

#

# =====================

def _check_wdgmva(instr):
    '''check for valid wdgmva string.'''

    if type(instr) != str: instr = str(instr)
    instr0 = instr
    
    instr = instr.strip().lower()
    if not instr:
        retv = ''
    elif instr =='ratea':
        retv = "RATEA"
    elif instr =='rateb':
        retv = "RATEB"
    elif instr =='ratec':
        retv = "RATEC"
    elif instr =='sbase':
        retv = "SBASE"
    else:
        print(' Input value "%s" not recognized.\n' % str(instr0))
        retv = ''

    return retv

#

# =====================

def _get_xmer_data(wdgmva=''):

    '''
    wdgmva = 0 or ''    # return just transfomrer buses and ckt id
           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE
           
           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from
           = 'rateb'    # winding rating A or B or C
           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)
    '''
    
    sid   = -1       # all buses
    owner = 1        # ignored
    ties  = 1        # ignored

    # Get Two Winding Transformer Specified Rating
    flag  = 2        # =1 in-service transformers, =2 all
    entry = 1        # each branch once only

    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])
    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        if wdgmva == "SBASE":
            strval = "SBASE1"
        else:
            strval = wdgmva
        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])

    two_wdg_xmers = {}
    for i in range(len(tmplist1[0])):
        busi  = tmplist1[0][i]
        busj  = tmplist1[1][i]
        cktid = tmplist2[0][i]
        if wdgmva:
            val = tmplist3[0][i]
        else:
            val = ''
        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}

    # Three Winding Transformer Specified Rating
    flag  = 3        # =2 all windings of in-service transformers
                     # =3 all transformers
    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)
                     # need to be done differently when entry = 1

    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])
    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])

    three_wdg_xmers = {}
    nwdgs = len(tmplist1[0])
    for i in range(0,nwdgs,3):
        busi     = tmplist1[0][i]
        busj     = tmplist1[1][i]
        busk     = tmplist1[2][i]
        cktid    = tmplist2[0][i]
        if wdgmva == 'SBASE':
            val1 = tmplist3[0][i]
            val2 = tmplist3[0][i+1]
            val3 = tmplist3[0][i+2]
        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:
            ratea_w1 = tmplist3[0][i]
            ratea_w2 = tmplist3[0][i+1]
            ratea_w3 = tmplist3[0][i+2]
            val1 = _min_rate(ratea_w1,ratea_w2)
            val2 = _min_rate(ratea_w2,ratea_w3)
            val3 = _min_rate(ratea_w3,ratea_w1)
        else:
            val1 = ''
            val2 = ''
            val3 = ''
            
        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}
   
    return two_wdg_xmers, three_wdg_xmers

#

# =====================

def change_winding_mva(rating=''):
    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''

    wdgmva = _check_wdgmva(rating)
    
    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:
        print(" No need to update working case.")
        return
    
    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()

    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        ckt  = brn[2]
        sbase12 = two_wdg_xmers[brn]['sbase12']
        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3]
        sbase12 = three_wdg_xmers[brn]['sbase12']
        sbase23 = three_wdg_xmers[brn]['sbase23']
        sbase31 = three_wdg_xmers[brn]['sbase31']    
        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,
                                                      realari8=sbase23, realari9=sbase31)
    
#

# =====================

def create_iecdata(wdgmva='',rptfile=''):
    '''Create IEC data file for all Transformers Winding MVA.'''

    wdgmva = _check_wdgmva(wdgmva)

    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    if rptfile:     # open report file to write
        p,nx = os.path.split(rptfile)
        if not p: p = os.getcwd()
        n,x = os.path.splitext(nx)
        if not x or x.lower() != '.txt': x = '.txt'
        nx = n + x
        rptfile = os.path.join(p,nx)
        rptfile_h = open(rptfile,'w')
        report       = rptfile_h.write
    else:           # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    # printing
    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\n')

    # Two Winding Transformers
    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()
    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = 0
        ckt  = brn[2].strip()
        sbase12 = two_wdg_xmers[brn]['sbase12']
        if sbase12:
            sbase12 = "%8.2f" % sbase12
        else:
            sbase12 = ''
        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\n' % vars())

    # Three Winding Transformers
    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3].strip()
        sbase12  = three_wdg_xmers[brn]['sbase12']
        sbase23  = three_wdg_xmers[brn]['sbase23']
        sbase31  = three_wdg_xmers[brn]['sbase31']    
        if sbase12:
            sbase12 = "%8.2f" % sbase12
            sbase23 = "%8.2f" % sbase23
            sbase31 = "%8.2f" % sbase31
        else:
            sbase12 = ''
            sbase23 = ''
            sbase31 = ''

        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\n' % vars())

    if rptfile:
        print(" Transformers IEC Data records saved in file %s." % rptfile)

#

# =====================

def docreate():
    psspy.prompt("PROVIDE WINDING MVA selection string and IEC DATA output text file name:\n\n\
        - ALLOWED WINDING MVA selection string\n\
             sbase, ratea, rateb, ratec or ''(empty string) \n")
    psspy.prompt("        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\n")
    psspy.prompt("TYPE inputs separated either by comma or space.")
    
    ierr, instr = psspy.userin()
    wndmva  = ''
    rptfile = ''

    if instr:
        instrlst = _splitstring_commaspace(instr)
        wndmva = instrlst[0]
        try:
            rptfile = instrlst[1]
        except:
            pass

    create_iecdata(wndmva, rptfile)
    
#

# =====================

'''
In some PSSE Saved Cases, especially some old sav files, all transformer data is provided on
System MVA base (SBASE). When this network data is to be used to calculate fault currents
according to "IEC 60909" standard, in order to calculate correct IEC impedance correction factors,
nameplate transformer winding MVA data is required.

This file is used to:
(1) Change working case to update transformers winding MVA derived from RATE A or B or C, and
    when winding MVA is 100 MVA and impedance data I/O code (CZ) is System MVA Base.
    Refer function: change_winding_mva(rating='')
    In some Saved case files, nameplate winding MVA data is stored as one of the ratings (RATE A, B, C),
    then this files can be used to change transformer winding MVA with selected Rating. 

(2) Create transformers IEC data file.
    Refer function: create_iecdata(wdgmva='',rptfile='')
    Create a text file with all transformer branches and then use this file to provide
    nameplate transformer winding MVA as part of transformer nameplate IEC data records.

# =====================

Functions:

(1) change_winding_mva(rating='')
    Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.

(2) create_iecdata(wdgmva='',rptfile='')
    Create IEC data file for all Transformers Winding MVA.
    Each IEC data record for a transformer has following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1

    Transformers IEC data records created here need to put in complete IEC data file.
        Refer POM Volume 1, API IECS for format of IEC data file.
        
    This function creates output file depending on the wndmva input provided.
    (1) If wndmva is not provided, it creates records in the following format.
    IBUS, JBUS, KBUS, CKT
    Then users would modify this file and manually input SBASE1-2, SBASE2-3, SBASE3-1 values.

    (2) If wndmva="SBASE", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    Then users would modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

    (3) If wndmva="RATEA" or "RATEB" or "RATEC", it creates records in the following format.
    IBUS, JBUS, KBUS, CKT, SBASE1-2, SBASE2-3, SBASE3-1
    where SBASE1-2 = min(Winding 1 Selected Rating, Winding 2 Selected Rating)
          SBASE2-3 = min(Winding 2 Selected Rating, Winding 3 Selected Rating)
          SBASE3-1 = min(Winding 3 Selected Rating, Winding 1 Selected Rating)
          If any of the winding MVA is zero, it is ignored.
    Users could modify this file and manually update SBASE1-2, SBASE2-3, SBASE3-1 values.

# =====================

How to use this file?

(1) Open the Saved Case using PSS(R)E GUI

(2) Without PROMPT for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    change_winding_mva(rating)
    or
    create_iecdata(wndmva, rptfile)

(3) With PROMPTS for inputing arguments:
    Call follwoing functions from CLI or another Python automation file:
    dochng()
    or
    docreate()
'''

import psspy, os

#

# =====================

def _splitstring_commaspace(tmpstr):
    '''Split string first at comma and then by space. Example:
    Input  tmpstr = a1       a2,  ,a4 a5 ,,,a8,a9
    Output strlst = ['a1', 'a2', ' ', 'a4', 'a5', ' ', ' ', 'a8', 'a9']
    '''
    strlst = []
    commalst = tmpstr.split(',')
    for each in commalst:
        eachlst = each.split()
        if eachlst:
            strlst.extend(eachlst)
        else:
            strlst.extend(' ')

    return strlst

#

# =====================

def _check_wdgmva(instr):
    '''check for valid wdgmva string.'''

    if type(instr) != str: instr = str(instr)
    instr0 = instr
    
    instr = instr.strip().lower()
    if not instr:
        retv = ''
    elif instr =='ratea':
        retv = "RATEA"
    elif instr =='rateb':
        retv = "RATEB"
    elif instr =='ratec':
        retv = "RATEC"
    elif instr =='sbase':
        retv = "SBASE"
    else:
        print(' Input value "%s" not recognized.\n' % str(instr0))
        retv = ''

    return retv

#

# =====================

def _get_xmer_data(wdgmva=''):

    '''
    wdgmva = 0 or ''    # return just transfomrer buses and ckt id
           = 'sbase'    # return transfomrer buses, ckt id with winding MVA as SBASE
           
           = 'ratea'    # return transfomrer buses, ckt id with winding MVA derived from
           = 'rateb'    # winding rating A or B or C
           = 'ratec'    # Example: sbase1-2 = min(winding 1 Rate A, winding 2 Rate A)
    '''
    
    sid   = -1       # all buses
    owner = 1        # ignored
    ties  = 1        # ignored

    # Get Two Winding Transformer Specified Rating
    flag  = 2        # =1 in-service transformers, =2 all
    entry = 1        # each branch once only

    ierr, tmplist1 = psspy.atrnint (sid, owner, ties, flag, entry, string=['FROMNUMBER','TONUMBER'])
    ierr, tmplist2 = psspy.atrnchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        if wdgmva == "SBASE":
            strval = "SBASE1"
        else:
            strval = wdgmva
        ierr, tmplist3 = psspy.atrnreal(sid, owner, ties, flag, entry, string=[strval])

    two_wdg_xmers = {}
    for i in range(len(tmplist1[0])):
        busi  = tmplist1[0][i]
        busj  = tmplist1[1][i]
        cktid = tmplist2[0][i]
        if wdgmva:
            val = tmplist3[0][i]
        else:
            val = ''
        two_wdg_xmers[(busi,busj,cktid)] = {'sbase12':val}

    # Three Winding Transformer Specified Rating
    flag  = 3        # =2 all windings of in-service transformers
                     # =3 all transformers
    entry = 2        # transformer name order, don't make this 1, following assignments (ratea_w1 etc.)
                     # need to be done differently when entry = 1

    ierr, tmplist1 = psspy.awndint (sid, owner, ties, flag, entry, string=['WIND1NUMBER','WIND2NUMBER','WIND3NUMBER'])
    ierr, tmplist2 = psspy.awndchar(sid, owner, ties, flag, entry, string=['ID'])
    if wdgmva:
        ierr, tmplist3 = psspy.awndreal(sid, owner, ties, flag, entry, string=[wdgmva])

    three_wdg_xmers = {}
    nwdgs = len(tmplist1[0])
    for i in range(0,nwdgs,3):
        busi     = tmplist1[0][i]
        busj     = tmplist1[1][i]
        busk     = tmplist1[2][i]
        cktid    = tmplist2[0][i]
        if wdgmva == 'SBASE':
            val1 = tmplist3[0][i]
            val2 = tmplist3[0][i+1]
            val3 = tmplist3[0][i+2]
        elif wdgmva in ['RATEA', 'RATEB', 'RATEC']:
            ratea_w1 = tmplist3[0][i]
            ratea_w2 = tmplist3[0][i+1]
            ratea_w3 = tmplist3[0][i+2]
            val1 = _min_rate(ratea_w1,ratea_w2)
            val2 = _min_rate(ratea_w2,ratea_w3)
            val3 = _min_rate(ratea_w3,ratea_w1)
        else:
            val1 = ''
            val2 = ''
            val3 = ''
            
        three_wdg_xmers[(busi,busj,busk,cktid)] = {'sbase12':val1, 'sbase23':val2, 'sbase31':val3}
   
    return two_wdg_xmers, three_wdg_xmers

#

# =====================

def change_winding_mva(rating=''):
    '''Change all Transformers Winding MVA to a MVA value derived from RATE A or B or C.'''

    wdgmva = _check_wdgmva(rating)
    
    if wdgmva not in ['RATEA', 'RATEB', 'RATEC']:
        print(" No need to update working case.")
        return
    
    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()

    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        ckt  = brn[2]
        sbase12 = two_wdg_xmers[brn]['sbase12']
        ierr,realaro = psspy.two_winding_data(ibus, jbus, ckt, realari3=sbase12)

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3]
        sbase12 = three_wdg_xmers[brn]['sbase12']
        sbase23 = three_wdg_xmers[brn]['sbase23']
        sbase31 = three_wdg_xmers[brn]['sbase31']    
        ierr,realaro = psspy.three_wnd_impedance_data(ibus, jbus, kbus, ckt, realari7=sbase12,
                                                      realari8=sbase23, realari9=sbase31)
    
#

# =====================

def create_iecdata(wdgmva='',rptfile=''):
    '''Create IEC data file for all Transformers Winding MVA.'''

    wdgmva = _check_wdgmva(wdgmva)

    two_wdg_xmers, three_wdg_xmers = _get_xmer_data(wdgmva)

    if rptfile:     # open report file to write
        p,nx = os.path.split(rptfile)
        if not p: p = os.getcwd()
        n,x = os.path.splitext(nx)
        if not x or x.lower() != '.txt': x = '.txt'
        nx = n + x
        rptfile = os.path.join(p,nx)
        rptfile_h = open(rptfile,'w')
        report       = rptfile_h.write
    else:           # send results to PSS(R)E report window
        psspy.beginreport()
        report = psspy.report

    # printing
    report('/  BUS I   BUS J   BUS K  CKT  SBASE1-2  SBASE2-3  SBASE3-1\n')

    # Two Winding Transformers
    lst2wdg = list(two_wdg_xmers.keys())
    lst2wdg.sort()
    for brn in lst2wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = 0
        ckt  = brn[2].strip()
        sbase12 = two_wdg_xmers[brn]['sbase12']
        if sbase12:
            sbase12 = "%8.2f" % sbase12
        else:
            sbase12 = ''
        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s\n' % vars())

    # Three Winding Transformers
    lst3wdg = list(three_wdg_xmers.keys())
    lst3wdg.sort()

    for brn in lst3wdg:
        ibus = brn[0]
        jbus = brn[1]
        kbus = brn[2]    
        ckt  = brn[3].strip()
        sbase12  = three_wdg_xmers[brn]['sbase12']
        sbase23  = three_wdg_xmers[brn]['sbase23']
        sbase31  = three_wdg_xmers[brn]['sbase31']    
        if sbase12:
            sbase12 = "%8.2f" % sbase12
            sbase23 = "%8.2f" % sbase23
            sbase31 = "%8.2f" % sbase31
        else:
            sbase12 = ''
            sbase23 = ''
            sbase31 = ''

        report('%(ibus)8d  %(jbus)6d  %(kbus)6d  %(ckt)3s  %(sbase12)s  %(sbase23)s  %(sbase31)s\n' % vars())

    if rptfile:
        print(" Transformers IEC Data records saved in file %s." % rptfile)

#

# =====================

def docreate():
    psspy.prompt("PROVIDE WINDING MVA selection string and IEC DATA output text file name:\n\n\
        - ALLOWED WINDING MVA selection string\n\
             sbase, ratea, rateb, ratec or ''(empty string) \n")
    psspy.prompt("        - OPTIONAL OUTPUT text file name (when not provided, output created in PSS(R)E report window)\n")
    psspy.prompt("TYPE inputs separated either by comma or space.")
    
    ierr, instr = psspy.userin()
    wndmva  = ''
    rptfile = ''

    if instr:
        instrlst = _splitstring_commaspace(instr)
        wndmva = instrlst[0]
        try:
            rptfile = instrlst[1]
        except:
            pass

    create_iecdata(wndmva, rptfile)
    
#

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example, where XX could be 33 or 34:
    import psseXX

- call any of the function as below
    accc()
    accc(accfile='savnw.acc', show=True, cosep=True)

    pv()
    pv(pvfile='savnw.pv', show=True)

    qv()
    qv(qvfile='savnw.qv', show=True)

# =====================

import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def accc(accfile='savnw.acc', outpath=None, show=True, cosep=True):
    import pssexcel

    if not os.path.exists(accfile):
        prgmsg = " Error: Input accfile '{0}' does not exist".format(accfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','e','b','i','v','l','g','p','a']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(accfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_accc_' + n)

    sheet = n + '_accc'
    overwritesheet = True

    baseflowvio = False
    basevoltvio = False
    flowlimit   = 0.0
    flowchange  = 0.0
    voltchange  = 0.0
    branchanglediff = True
    angdifmin=0.05

    pssexcel.accc(accfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show,
                  baseflowvio=baseflowvio, basevoltvio=basevoltvio, flowlimit=flowlimit,
                  flowchange=flowchange, voltchange=voltchange, angdifmin=angdifmin, cosep=cosep, branchanglediff=branchanglediff)

#

# =====================

def pv(pvfile='savnw.pv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g','l','b','i']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_pv_' + n)

    sheet = n + '_pv'
    overwritesheet = True

    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

#

# =====================

def qv(qvfile='savnw.qv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g']
    colabel = [] #'base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pssexcel_demo_qv_' + n)

    sheet = n + '_qv'
    overwritesheet = True

    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

#

# =====================

import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def excel_report(pvfile='savnw.pv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g','l','b','i']
    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'pv_export_' + n)

    sheet = n + '_pv'
    overwritesheet = True

    pssexcel.pv(pvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

#

# =====================

def text_report(pvfile='savnw.pv', outpath=None):

    import arrbox.pv_pp

    if not os.path.exists(pvfile):
        prgmsg = " Error: Input pvfile '{0}' does not exist".format(pvfile)
        print(prgmsg)
        return

    pvobj = arrbox.pv_pp.PV_PP(pvfile)

    p, nx = os.path.split(pvfile)
    n, x  = os.path.splitext(nx)

    smryfile = get_output_filename(outpath, 'pv_export_' + n +'_summary.txt')
    solnfile = get_output_filename(outpath, 'pv_export_' + n +'_solution.txt')

    ierr = pvobj.summary_report(smryfile)

    ierr = pvobj.solution_report(colabels=None,rptfile=solnfile)

#

# =====================

import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def excel_report(qvfile='savnw.qv', outpath=None, show=True):
    import pssexcel

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    # Change these values as required.
    string  = ['s','v','m','g']
    colabel = [] #['base case', 'trip1nuclear', 'trip2nuclear']

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    xlsfile = get_output_filename(outpath, 'qv_export_' + n)

    sheet = n + '_qv'
    overwritesheet = True

    pssexcel.qv(qvfile,string,colabel=colabel,xlsfile=xlsfile,sheet=sheet,overwritesheet=overwritesheet,show=show)

#

# =====================

def text_report(qvfile='savnw.qv', outpath=None):

    import arrbox.qv_pp

    if not os.path.exists(qvfile):
        prgmsg = " Error: Input qvfile '{0}' does not exist".format(qvfile)
        print(prgmsg)
        return

    qvobj = arrbox.qv_pp.QV_PP(qvfile)

    p, nx = os.path.split(qvfile)
    n, x  = os.path.splitext(nx)

    smryfile = get_output_filename(outpath, 'qv_export_' + n +'_summary.txt')
    solnfile = get_output_filename(outpath, 'qv_export_' + n +'_solution.txt')

    ierr = qvobj.summary_report(smryfile)

    ierr = qvobj.solution_report(colabels=None,rptfile=solnfile)

#

# =====================

'run_idle.py - This script starts up the IDLE interpreter (for Python 2.3).'

import sys

# Import IDLE's PyShell and run its main()
sys.argv=['','-n','-t','PSS/E-Python Shell'] #Arguments for IDLE
import idlelib.PyShell                       #Import the PyShell module
idlelib.PyShell.main()                       #Start IDLE

#[sample_add_substations.py]    Create sample_zils case with various Node Breaker Substation Configurations
#

# =====================

'''This file shows example of adding one or more substation configurations.
Uses sample.raw and sample.seq files.

This example uses substations data [latitude, longitude, RG] from sample_fv4.gic, but applies
different Substation Configurations.
'''
ss_config = {
    1: 'SB',        #'Single Bus',
    2: 'RB',        #'Ring Bus',
    3: 'DBDB',      #'Double Bus double breaker',
    4: 'BH',        #'Breaker and a half',
    5: 'DBSB',      #'Double Bus Single breaker',
    6: 'MBTB',      #'Main Bus Transfer Bus',
    }

sub_dict = {
     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211      ]},
     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022   ]},
     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154                    ]},
     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202              ]},
     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204]},
     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                ]},
     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002      ]},
     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005           ]},
     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018       ]},
    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                          ]},
    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                          ]},
    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212                          ]},
    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                          ]},
    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                          ]},
    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                          ]},
    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                 ]},
    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                         ]},
    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                         ]},
    }

rawfnam           = r"sample.raw"
seqfnam           = r"sample.seq"
rawoutfnam        = r"sample"
rawoutfnam_nb     = r"sample_nb"
rawoutfnam_nb_sec = r"sample_nb_sec"
prgfnam           = r"sample_nb_progress.txt"

import os

#

# =====================

def solve_pf():
    import psspy
    pf_options = [1,0,0,1,1,0,99,0]
    psspy.fdns(pf_options)
    psspy.fdns(pf_options)
    ival = psspy.solved()
    return ival

def save_case(rawfile, seqfile, savfnam, outpath):
    import psspy
    psspy.read(0, rawfile)
    psspy.resq(seqfile)
    ival = solve_pf()
    if ival==0:
        savfile = "{}.sav".format(savfnam)
        savfile = os.path.join(outpath, savfile)
        psspy.save(savfile)

#

# =====================

def run(datapath=None, outpath=None):
    import psspy

    if datapath is None:        # use Example folder
        psspy_dir = os.path.dirname(psspy.__file__)
        psse_dir, jnk = os.path.split(psspy_dir)
        datapath = os.path.join(psse_dir, 'Example')

    rawfile = os.path.join(datapath, rawfnam)
    seqfile = os.path.join(datapath, seqfnam)

    if not os.path.exists(rawfile):
        msg = "\n Error- RAW file not found, terminated:\n    {}".format(rawfile)
        print(msg)
        return

    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ file not found, terminated:\n    {}".format(seqfile)
        print(msg)
        return

    if outpath is None:
        outpath = os.path.dirname(__file__)
        outpath = os.path.join(outpath, 'output_sample_nb')
    if not os.path.exists(outpath): os.makedirs(outpath)

    psspy.psseinit()

    prgfile = os.path.join(outpath, prgfnam)

    psspy.progress_output(2,prgfile,[0,0])

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()
    _s = psspy.getdefaultchar()

    psspy.read(0, rawfile)
    psspy.resq(seqfile)

    ival_raw = solve_pf()
    if ival_raw>0:
        msg = "\n Error - Power flow non converged. RAW file:\n    {}".format(rawfile)
        print(msg)
        return

    sslst = list(sub_dict.keys())
    sslst.sort()

    for ss in sslst:
        vdict = sub_dict[ss]
        name  = sub_dict[ss]['name']
        lat   = sub_dict[ss]['lat']
        lon   = sub_dict[ss]['long']
        rg    = sub_dict[ss]['rg']
        config= sub_dict[ss]['config']
        buses = sub_dict[ss]['buses']

        s_ss = "{:{fill}2d}".format(ss, fill='0')
        s_config = ss_config[config]

        ss_name  = "SS{}_{}_TYP_{}_{}".format(s_ss, name, config, s_config)

        for b in buses:
            psspy.station_build_config(b,ss,_s,config)

        psspy.station_data(ss, [lat, lon, rg], ss_name)

    # Update/Change Node and Switching Device Names
    sid = -1
    flag = 1
    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])
    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])

    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'NODE', str(node)]
        newnam = '_'.join(newlst)
        psspy.station_node_chng(ss,node,[_i,_i],newnam)

    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])
    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])

    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]
        newnam = '_'.join(newlst)
        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)

    #

# =====================

# Solve power flow and save raw file
    ival_raw_nb = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, NO ZILS')
    rawfileout_nb = "{}.raw".format(rawoutfnam_nb)
    rawfileout_nb = os.path.join(outpath, rawfileout_nb)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)

    seqfileout_nb = "{}.seq".format(rawoutfnam_nb)
    seqfileout_nb = os.path.join(outpath, seqfileout_nb)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)

    if ival_raw_nb>0:
        msg = "\n Error - Power flow non converged after adding substations, SAV file not created."
        print(msg)

    #

# =====================

# Create substation sections
    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)

    #

# =====================

# Solve power flow and save raw file
    ival_raw_nb_sec = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, NO ZILS')
    rawfileout_nb_sec = "{}.raw".format(rawoutfnam_nb_sec)
    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)

    seqfileout_nb_sec = "{}.seq".format(rawoutfnam_nb_sec)
    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)

    if ival_raw_nb_sec>0:
        msg = "\n Error - Power flow non converged after adding substation sections, SAV file not created."
        print(msg)
        return

    #

# =====================

# Create .sav files
    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ sile not found:\n    {}".format(seqfile)
        print(msg)
        return

    # base case
    save_case(rawfile, seqfile, rawoutfnam, outpath)

    # base+NB case
    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)

    # base+NB+sections case
    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)

    #

# =====================

def test1():
    # Run from outside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

#

# =====================

def test2():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

#

# =====================

'''This file shows example of adding one or more substation configurations.
Uses sample_zils.raw and sample_zils.seq files.

This example uses substations data [latitude, longitude, RG] from sample_zils_fv4.gic, but applies
different Substation Configurations.
'''
ss_config = {
    1: 'SB',        #'Single Bus',
    2: 'RB',        #'Ring Bus',
    3: 'DBDB',      #'Double Bus double breaker',
    4: 'BH',        #'Breaker and a half',
    5: 'DBSB',      #'Double Bus Single breaker',
    6: 'MBTB',      #'Main Bus Transfer Bus',
    }

sub_dict = {
     1: {'name': 'NILE',        'lat': 34.6135,  'long': -86.67371,  'rg':0.11, 'config':3, 'buses': [101, 102, 151, 201, 211, 80102, 80151 ]},
     2: {'name': 'YANGTZE',     'lat': 32.5104,  'long': -86.3658 ,  'rg':0.12, 'config':6, 'buses': [152, 153, 3006, 3021, 3022, 803022    ]},
     3: {'name': 'ARKANSAS',    'lat': 32.1551,  'long': -83.6794 ,  'rg':0.13, 'config':4, 'buses': [154, 9154, 809154                     ]},
     4: {'name': 'COLORADO',    'lat': 33.7051,  'long': -84.6634 ,  'rg':0.15, 'config':5, 'buses': [202, 203, 70202, 80203                ]},
     5: {'name': 'MISSISSIPPI', 'lat': 33.3773,  'long': -82.6188 ,  'rg':0.16, 'config':5, 'buses': [204, 205, 206, 208, 215, 9204         ]},
     6: {'name': 'VOLGA',       'lat': 34.2522,  'long': -82.8363 ,  'rg':0.17, 'config':1, 'buses': [209, 217, 218                         ]},
     7: {'name': 'YUKON',       'lat': 33.5956,  'long': -88.798  ,  'rg':0.18, 'config':4, 'buses': [3001, 3002, 3011, 93002, 803002       ]},
     8: {'name': 'BRAHMAPUTRA', 'lat': 31.9123,  'long': -88.3123 ,  'rg':0.19, 'config':4, 'buses': [3004, 3005, 703005                    ]},
     9: {'name': 'INDUS',       'lat': 31.0133,  'long': -82.0133 ,  'rg':0.2 , 'config':6, 'buses': [3008, 3010, 3012, 3018, 803008, 803010, 803018]},
    10: {'name': 'DANUBE',      'lat': 32.0143,  'long': -82.5143 ,  'rg':0.21, 'config':4, 'buses': [155                                   ]},
    11: {'name': 'ALLEGHENY',   'lat': 35.2153,  'long': -86.0153 ,  'rg':0.22, 'config':2, 'buses': [207                                   ]},
    12: {'name': 'GANGES',      'lat': 33.5163,  'long': -81.0163 ,  'rg':0.23, 'config':2, 'buses': [212, 80212                            ]},
    13: {'name': 'OXUS',        'lat': 35.0173,  'long': -82.0173 ,  'rg':0.24, 'config':1, 'buses': [214                                   ]},
    14: {'name': 'SALWEEN',     'lat': 34.7183,  'long': -81.0183 ,  'rg':0.25, 'config':1, 'buses': [216                                   ]},
    15: {'name': 'HEILONG',     'lat': 35.0193,  'long': -84.0193 ,  'rg':0.26, 'config':3, 'buses': [213                                   ]},
    16: {'name': 'ZAIRE',       'lat': 35.003 ,  'long': -87.5203 ,  'rg':0.27, 'config':4, 'buses': [3003, 703003                          ]},
    17: {'name': 'ZAMBEZI',     'lat': 31.4213,  'long': -85.7213 ,  'rg':0.28, 'config':3, 'buses': [3007                                  ]},
    18: {'name': 'PILCOMAYO',   'lat': 31.4223,  'long': -81.0223 ,  'rg':0.29, 'config':2, 'buses': [3009                                  ]},
    19: {'name': 'DC2TERM',     'lat': 31.7104,  'long': -84.5694 ,  'rg':0.30, 'config':1, 'buses': [301, 80301                            ]},
    20: {'name': 'DCMTERM',     'lat': 33.9163,  'long': -81.9163 ,  'rg':0.31, 'config':1, 'buses': [401, 402, 80402                       ]},
    }

rawfnam           = r"sample_zils.raw"
seqfnam           = r"sample_zils.seq"
rawoutfnam        = r"sample_zils"
rawoutfnam_nb     = r"sample_zils_nb"
rawoutfnam_nb_sec = r"sample_zils_nb_sec"
prgfnam           = r"sample_zils_nb_progress.txt"

import os

#

# =====================

def solve_pf():
    import psspy
    pf_options = [1,0,0,1,1,0,99,0]
    psspy.fdns(pf_options)
    psspy.fdns(pf_options)
    ival = psspy.solved()
    return ival

def save_case(rawfile, seqfile, savfnam, outpath):
    import psspy
    psspy.read(0, rawfile)
    psspy.resq(seqfile)
    ival = solve_pf()
    if ival==0:
        savfile = "{}.sav".format(savfnam)
        savfile = os.path.join(outpath, savfile)
        psspy.save(savfile)

#

# =====================

def run(datapath=None, outpath=None):
    import psspy

    if datapath is None:        # use Example folder
        psspy_dir = os.path.dirname(psspy.__file__)
        psse_dir, jnk = os.path.split(psspy_dir)
        datapath = os.path.join(psse_dir, 'Example')

    rawfile = os.path.join(datapath, rawfnam)
    seqfile = os.path.join(datapath, seqfnam)

    if not os.path.exists(rawfile):
        msg = "\n Error- RAW file not found, terminated:\n    {}".format(rawfile)
        print(msg)
        return

    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ file not found, terminated:\n    {}".format(seqfile)
        print(msg)
        return

    if outpath is None:
        outpath = os.path.dirname(__file__)
        outpath = os.path.join(outpath, 'output_sample_nb')
    if not os.path.exists(outpath): os.makedirs(outpath)

    psspy.psseinit()

    prgfile = os.path.join(outpath, prgfnam)

    psspy.progress_output(2,prgfile,[0,0])

    _i = psspy.getdefaultint()
    _f = psspy.getdefaultreal()
    _s = psspy.getdefaultchar()

    psspy.read(0, rawfile)
    psspy.resq(seqfile)

    ival_raw = solve_pf()
    if ival_raw>0:
        msg = "\n Error - Power flow non converged. RAW file:\n    {}".format(rawfile)
        print(msg)
        return

    sslst = list(sub_dict.keys())
    sslst.sort()

    for ss in sslst:
        vdict = sub_dict[ss]
        name  = sub_dict[ss]['name']
        lat   = sub_dict[ss]['lat']
        lon   = sub_dict[ss]['long']
        rg    = sub_dict[ss]['rg']
        config= sub_dict[ss]['config']
        buses = sub_dict[ss]['buses']

        s_ss = "{:{fill}2d}".format(ss, fill='0')
        s_config = ss_config[config]

        ss_name  = "SS{}_{}_TYP_{}_{}".format(s_ss, name, config, s_config)

        for b in buses:
            psspy.station_build_config(b,ss,_s,config)

        psspy.station_data(ss, [lat, lon, rg], ss_name)

    # Update/Change Node and Switching Device Names
    sid = -1
    flag = 1
    ierr, (ss_num_lst, node_lst) = psspy.anodeint(sid, flag, ['STATION', 'NODE'])
    ierr, (ss_nam_lst,) = psspy.anodechar(sid, flag, ['STATIONNAME'])

    for ss,node,nam in zip(ss_num_lst, node_lst, ss_nam_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'NODE', str(node)]
        newnam = '_'.join(newlst)
        psspy.station_node_chng(ss,node,[_i,_i],newnam)

    ierr, (swd_ss_lst, fromnode_lst, tonode_lst) = psspy.astaswdevint(sid, flag, ['STATION','FROMNODE', 'TONODE'])
    ierr, (swd_ss_nam_lst, swd_id_lst) = psspy.astaswdevchar(sid, flag, ['STATIONNAME','ID'])

    for ss,fm,to,nam,iid in zip(swd_ss_lst, fromnode_lst, tonode_lst, swd_ss_nam_lst, swd_id_lst):
        nlst = nam.strip().split('_')
        newlst = ['SS', nlst[1], 'SWD', str(fm), str(to), iid]
        newnam = '_'.join(newlst)
        psspy.station_swd_chng(ss,fm,to,iid,[_i,_i,_i],[_f,0.0,_f,0.0],newnam)

    #

# =====================

# Solve power flow and save raw file
    ival_raw_nb = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKERS BUT NO SUBSTN SECTIONS, CONTAINS ZILS')
    rawfileout_nb = "{}.raw".format(rawoutfnam_nb)
    rawfileout_nb = os.path.join(outpath, rawfileout_nb)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb)

    seqfileout_nb = "{}.seq".format(rawoutfnam_nb)
    seqfileout_nb = os.path.join(outpath, seqfileout_nb)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb)

    if ival_raw_nb>0:
        msg = "\n Error - Power flow non converged after adding substations, SAV file not created."
        print(msg)

    #

# =====================

# Create substation sections
    psspy.station_swd_chng(3, 1, 4, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,10, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 1, 8, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(3, 2,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 7, 9, '1', [0,_i,_i], [_f,_f,_f,_f], _s)
    psspy.station_swd_chng(8, 8,14, '1', [0,_i,_i], [_f,_f,_f,_f], _s)

    #

# =====================

# Solve power flow and save raw file
    ival_raw_nb_sec = solve_pf()
    psspy.case_title_data(r'PSS(R)E SAMPLE CASE - ALL RECORD GROUPS WITH SEQ DATA',
                          r'CONTAINS NODE BREAKER AND SUBSTN SECTIONS, CONTAINS ZILS')
    rawfileout_nb_sec = "{}.raw".format(rawoutfnam_nb_sec)
    rawfileout_nb_sec = os.path.join(outpath, rawfileout_nb_sec)
    psspy.rawd_2(0,1,[1,1,1,0,0,0,0],0,rawfileout_nb_sec)

    seqfileout_nb_sec = "{}.seq".format(rawoutfnam_nb_sec)
    seqfileout_nb_sec = os.path.join(outpath, seqfileout_nb_sec)
    psspy.rwsq_2(0,1,[1,1,1,0,0],0,seqfileout_nb_sec)

    if ival_raw_nb_sec>0:
        msg = "\n Error - Power flow non converged after adding substation sections, SAV file not created."
        print(msg)
        return

    #

# =====================

# Create .sav files
    if not os.path.exists(seqfile):
        msg = "\n Error- SEQ sile not found:\n    {}".format(seqfile)
        print(msg)
        return

    # base case
    save_case(rawfile, seqfile, rawoutfnam, outpath)

    # base+NB case
    save_case(rawfileout_nb, seqfileout_nb, rawoutfnam_nb, outpath)

    # base+NB+sections case
    save_case(rawfileout_nb_sec, seqfileout_nb_sec, rawoutfnam_nb_sec, outpath)

    #

# =====================

def test1():
    # Run from outside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

#

# =====================

def test2():
    # Run from inside of PSSE GUI.
    # Use input sample RAW/SEQ files from specified folder [datapath].
    # Create output RAW/SEQ files in specified folder [outpath].
    import psse35
    datapath = os.getcwd()
    outpath  = os.getcwd()
    run(datapath=datapath, outpath=outpath)

#

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    run_demo()  OR
    run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None)
    You could modify various inputs in run)demo() as desired.
'''

#

# =====================

import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile):
    # Create Report
    import arrbox.sensitivity_flow_to_mw

    flow2mw = arrbox.sensitivity_flow_to_mw()

    ierr = flow2mw.sensitivity_flow_to_mw_report(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',
        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='',rptfile=rptfile)

#

# =====================

def demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys):
    # Access factor results in Python script
    import arrbox.sensitivity_flow_to_mw

    flow2mw = arrbox.sensitivity_flow_to_mw()

    robj = flow2mw.sensitivity_flow_to_mw(ibus,jbus,mainsys,dfxfile,kbus=0,ckt='1',netmod='dc',brnflowtyp='mw',
        transfertyp='import',oppsystyp='slack bus',dispmod=1,toln=None,oppsys='')

    print("\n Returned dictionary object as is:")
    print(robj)
    print('\n')

    print("  Getting 'ngenbuses' value by different ways:")
    print("     robj.ngenbuses    = {0:d}".format(robj.ngenbuses))
    print("     robj.ngenBuses    = {0:d}".format(robj.ngenBuses))
    print("     robj['ngenbuses'] = {0:d}".format(robj['ngenbuses']))
    print("     robj['NGENbuses'] = {0:d}".format(robj['NGENbuses']))
    print('\n')

    print("  Bus names for which generator factors are calculated:")
    print(list(robj.genvalues.keys()))
    print('\n')

    print("  Generator factors:")
    for bus, vdict in list(robj.genvalues.items()):
        tdct = {'bus':bus, 'pmax':vdict.pmax, 'pmin':vdict.pmin, 'pgen':vdict.pgen, 'sftr':vdict.factor}
        print("{bus:s}  {pmax:8.2f}  {pmin:8.2f} {pgen:8.2f}  {sftr:8.5f}".format(**tdct))

#

# =====================

def run_demo(savfile='savnw.sav', dfxfile='savnw.dfx', outpath=None):
    import psspy

    ibus        = 151
    jbus        = 152
    kbus        = 0
    ckt         = '1'
    mainsys     = 'STUDY'
    netmod      = 'dc'
    brnflowtyp  = 'mw'
    transfertyp = 'import'
    oppsystyp   = 'slack bus'
    dispmod     = 1
    toln        = None
    oppsys      = ''

    if not os.path.exists(savfile):
        prgmsg = " Error: Input savfile '{0}' does not exist".format(savfile)
        print(prgmsg)
        return

    if not os.path.exists(dfxfile):
        prgmsg = " Error: Input dfxfile '{0}' does not exist".format(dfxfile)
        print(prgmsg)
        return

    p, nx = os.path.split(dfxfile)
    n, x = os.path.splitext(nx)

    rptfile = get_output_filename(outpath, 'sensitivity_factors_' + n +'_report.txt')

    psspy.psseinit()

    psspy.case(savfile)

    create_report(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys,rptfile)

    demo_access(ibus,jbus,mainsys,dfxfile,kbus,ckt,netmod,brnflowtyp,transfertyp,oppsystyp,dispmod,toln,oppsys)

#

# =====================

# [	]     04/23/20     Python Functions to emulate GRPG
#
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#  *                                                                     *
#  *  THIS PROGRAM AND ITS DOCUMENTATION ARE TRADE SECRETS OF POWER      *
#  *  TECHNOLOGIES, INC. (PTI).  THEY HAVE BEEN LEASED TO                *
#  *                   client full name (clabr)                          *
#  *  SUBJECT TO TERMS WHICH PROHIBIT clabr FROM DISCLOSING OR TRANS-    *
#  *  FERRING THE PROGRAM OR ITS DOCUMENTATION, WHETHER IN ITS ORIGINAL  *
#  *  OR MODIFIED FORM, TO A THIRD PARTY, OR FROM USING THE PROGRAM FOR  *
#  *  ANY PURPOSE OTHER THAN COMPUTATION RELATING TO clabr'S OWN SYSTEM. *
#  *  ANY SUCH TRANSFER OR USE BY clabr OR ITS EMPLOYEES WILL CONSTI-    *
#  *  TUTE A BREACH OF CONFIDENCE AND OF THE CONTRACT UNDER WHICH        *
#  *  RIGHTS OF USE HAVE BEEN GRANTED.                                   *
#  *                                                                     *
#  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
'''The functions in this Python module return:
    - formatted text which can be used to put annotation on slider diagrams.
    - values which are used to generate formatted text above.
Example: function 'area_summary' returns formatted text and
         function 'area_summary_v' returns values used by 'area_summary'
         i.e, functions with name ending with "_v" return values
'''

import psspy

# =====================

def area_summary_v(arnum):
    '''Returns desired and net interchange, loads, generation and losses for
    area 'arnum'.
pdes,pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.area_summary_v(arnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.asys(sid, flag, [arnum])
    ierr, rdata = psspy.aareareal(sid,flag,
        ['PDES','PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])
    psspy.asysdef(sid, 0)
    if ierr==0:
        (pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata
        if len(pdes)>0:
           return pdes[0],pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]
    return None,None,None,None,None,None,None,None,None

def area_summary(arnum):
    '''Returns formatted text showing desired and net interchange, loads, generation
     and losses for area 'arnum'.
txt = pssgrpg.area_summary(arnum)
'''
    pdes,pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = area_summary_v(arnum)
    if pdes:
        txt = '''Area %(arnum)d Summary:
  Desired Interchange: %(pdes)9.2f MW
  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR
  Area loads         : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR
  Area generation    : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Area losses        : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    else:
        txt = '''Area %(arnum)d Summary:
  Desired Interchange: None
  Net Interchange    : None
  Area loads         : None
  Area generation    : None
  Area losses        : None''' % vars()
    return txt

def area_interchange_net_v(arnum):
    '''Returns desired and net interchange for area 'arnum'.
pdes,pint,qint = pssgrpg.area_interchange_net_v(arnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.asys(sid, flag, [arnum])
    ierr, rdata = psspy.aareareal(sid,flag,['PDES','PINT','QINT'])
    psspy.asysdef(sid, 0)
    if ierr==0:
        (pdes,pint,qint) = rdata
        if len(pdes)>0:
           return pdes[0],pint[0],qint[0]
    return None,None,None

def area_interchange_net(arnum):
    '''Returns formatted text showing desired and net interchange for area 'arnum'.
txt = pssgrpg.area_interchange_net(arnum)
'''
    pdes,pint,qint = area_interchange_net_v(arnum)
    if pdes:
        txt = '''Area %(arnum)d Interchange:
  Desired Interchange: %(pdes)9.2f MW
  Net Interchange    : %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Area %(arnum)d Interchange:
  Desired Interchange: None
  Net Interchange    : None''' % vars()
    return txt

def area_interchange_ij_v(iar,jar):
    '''Returns interchange from area 'iar' to area 'jar'.
p,q = pssgrpg.area_interchange_ij_v(iar,jar)
'''
    ierr, cmpval = psspy.aritoj(iar,jar)
    if ierr==0:
        return cmpval.real, cmpval.imag
    return None,None

def area_interchange_ij(iar,jar):
    '''Returns formatted text showing interchange from area 'iar' to area 'jar'.
txt = pssgrpg.area_interchange_ij(iar,jar)
'''
    pint,qint = area_interchange_ij_v(iar,jar)
    if pint:
        txt = '''Interchange from Area %(iar)d to Area %(jar)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Interchange from Area %(iar)d to Area %(jar)d: None''' % vars()
    return txt

# =====================

def zone_summary_v(znnum):
    '''Returns net interchange, loads, generation and losses for zone 'znnum'.
pint,qint,pload,qload,pgen,qgen,ploss,qloss = pssgrpg.zone_summary_v(znnum)
'''
    sid  = 3
    flag = 2
    ierr = psspy.zsys(sid, flag, [znnum])
    ierr, rdata = psspy.azonereal(sid,flag,
        ['PINT','QINT','PLOADLD','QLOADLD','PGEN','QGEN','PLOSS','QLOSS'])
    psspy.zsysdef(sid, 0)
    if ierr==0:
        (pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss) = rdata
        if len(pint)>0:
           return pint[0],qint[0],ploadld[0],qloadld[0],pgen[0],qgen[0],ploss[0],qloss[0]
    return None,None,None,None,None,None,None,None,None

def zone_summary(znnum):
    '''Returns formatted text showing net interchange, loads, generation and losses
    for zone 'znnum'.
txt = pssgrpg.zone_summary(znnum)
'''
    pint,qint,ploadld,qloadld,pgen,qgen,ploss,qloss = zone_summary_v(znnum)
    if pint:
        txt = '''Zone %(znnum)d Summary:
  Net Interchange : %(pint)9.2f MW, %(qint)9.2f MVAR
  Zone loads      : %(ploadld)9.2f MW, %(qloadld)9.2f MVAR
  Zone generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Zone losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    else:
        txt = '''Zone %(znnum)d Summary:
  Net Interchange : None
  Zone loads      : None
  Zone generation : None
  Zone losses     : None''' % vars()
    return txt

def zone_interchange_ij_v(izn,jzn):
    '''Returns interchange from zone 'izn' to zone 'jzn'.
p,q = pssgrpg.zone_interchange_ij_v(izn,jzn)
'''
    ierr, cmpval = psspy.znitoj(izn,jzn)
    if ierr==0:
        return cmpval.real, cmpval.imag
    return None,None

def zone_interchange_ij(izn,jzn):
    '''Returns formatted text showing interchange from zone 'izn' to zone 'jzn'.
txt = pssgrpg.zone_interchange_ij(izn,jzn)
'''
    pint,qint = zone_interchange_ij_v(izn,jzn)
    if pint:
        txt = '''Interchange from Zone %(izn)d to Area %(jzn)d: %(pint)9.2f MW, %(qint)9.2f MVAR''' % vars()
    else:
        txt = '''Interchange from Zone %(izn)d to Zone %(jzn)d: None''' % vars()
    return txt

# =====================

def system_summary_v():
    '''Returns working case loads, generation and losses.
pload,qload,pgen,qgen,ploss,qloss = pssgrpg.system_summary_v()
'''
    ierr, syslod = psspy.systot('LOAD')
    ierr, sysgen = psspy.systot('GEN')
    ierr, syslos = psspy.systot('LOSS')
    return syslod.real, syslod.imag, sysgen.real, sysgen.imag, syslos.real, syslos.imag

def system_summary():
    '''Returns formatted text showing working case loads, generation and losses.
txt = pssgrpg.system_summary()
'''
    pload,qload,pgen,qgen,ploss,qloss = system_summary_v()
    txt = '''Case Summary:
  Total loads      : %(pload)9.2f MW, %(qload)9.2f MVAR
  Total generation : %(pgen)9.2f MW, %(qgen)9.2f MVAR
  Total losses     : %(ploss)9.2f MW, %(qloss)9.2f MVAR''' % vars()
    return txt

# =====================

'''
WECCLF converter is used to convert PSLF Power Flow (.epc) and Sequence (.seq) Data
to PSSE Power Flow (.raw) and Sequence (.seq) Data.

Additionally it also compares PSSE and PSLF Power Flow Solutions.

WECCLF converter can be run from its own GUI:
>>> import wecclf_gui
>>> wecclf_gui.main()

This scripts shows different ways to run WECCLF Converter from Python Scripts.
'''

import os, sys

#

# =====================

def run_wecclf(pslf_version, pslf_epcfile, psse_version, workdir=os.getcwd(), testnum=2):

    import ndppslf

    if not os.path.exists(pslf_epcfile):
        msgtxt = " EPC file does not exist, WECCLF converter not run.\n    {}".format(pslf_epcfile)
        print(msgtxt)
        return

    p, nx = os.path.split(pslf_epcfile)
    nam, ext  = os.path.splitext(nx)

    outdir = 'wecclf_demo_output_v{}'.format(psse_version)
    workdir = os.path.join(workdir, outdir)
    if not os.path.exists(workdir): os.makedirs(workdir)

    rawfnam  = "{}_v{}.raw".format(nam, psse_version)
    rawfile  = os.path.join(workdir, rawfnam)

    prgsplit = False
    prgfull  = True

    if testnum==1:
        #(1) Convert and compare power flow solutions using all default options
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, ratea=1, rateb=2, ratec=3,
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull)

    elif testnum==2:
        #(2) Convert only
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, do_psse_pfsoln=False,
            workdir=workdir, compare_pfsoln=False, prgfull=prgfull, prgsplit=prgsplit)

    elif testnum==3:
        #(3) Convert and compare power flow solutions using options from epcfile and options as specified
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile,
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,
            pfmethod='RSOL', use_epcoptns=False, itmxn=100, flat=0, varlmt=99, nondiv=0,
            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,
            compare_pfsoln=True, show_ntop=-1, toler_vpu=-0.001,
            toler_pgen=-1.0, toler_qgen=-1.0, toler_bact=-0.01, toler_pitf=-1.0, toler_qitf=-1.0)

    elif testnum==4:
        #(4) Convert and compare power flow solutions using options as specified
        ndppslf.pslf2psse(pslf_version, pslf_epcfile, psse_version,
            psse_rawfile=rawfile, psse_autofile='',
            workdir=workdir, prgsplit=prgsplit, prgfull=prgfull,
            pfmethod='RSOL', use_epcoptns=False, itmxn=100, toln=0.1, thrshz=0.0001, tap=0,
            area=0, phshft=0, dctap=1, swsh=1,flat=0, varlmt=99, nondiv=0,
            rsol_pfmethod='FDNS', rsol_solnfail=0, rsol_mismatch=500.0, rsol_varband=5.0,
            compare_pfsoln=True, show_ntop=100, toler_vpu=0.02, toler_pgen=1.0,
            toler_qgen=-1.0, toler_bact=0.01, toler_pitf=1.0, toler_qitf=-1.0)

#

# =====================

def _run_how():
    pass
##    # EPC file version=18
##    epcfile18 = r"sample18.epc"
##    run_wecclf(18, epcfile18, psse_version=34, workdir=os.getcwd(), testnum=3)
##
##    # EPC file version=19
##    epcfile19 = r"sample19.epc"
##    run_wecclf(19, epcfile19, psse_version=34, workdir=os.getcwd(), testnum=3)
##
##    # EPC file version=21
##    epcfile21 = r"sample21.epc"
##    run_wecclf(21, epcfile21, psse_version=34, workdir=os.getcwd(), testnum=3)

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if __name__ == '__main__':
    pass
    # Here "import psse34" or "import psse35" as appropriate.
    # Then run required test. See _run_how() above for reference.
#[wordpy_demo.py]  Demo for using functions from wordpy module
#

# =====================

'''
'wordpy' module provides Pythonic Interface to Miscrosoft Word.
This module has functions to create new or update existing Microsoft Word document by:
- adding text into Word document
- inserting pictures/plots into Word document

This is an example file showing how to use various functions available in wordpy module.

# =====================

How to use this file?

As showed in __main__ (end of this file)
- Enable PSSE version specific environment, as an example:
    import psse35

- call any of the function as below
    run()  OR
    run(pssplt_eps_files, pict_files, docfile, outpath, show)
    You could modify various inputs in run)demo() as desired.

'''

#

# =====================

import sys, os

def get_output_dir(outpath):
    # if called from PSSE's Example Folder, create report in subfolder 'Output_Pyscript'

    if outpath:
        outdir = outpath
        if not os.path.exists(outdir): os.mkdir(outdir)
    else:
        outdir = os.getcwd()
        cwd = outdir.lower()
        i = cwd.find('pti')
        j = cwd.find('psse')
        k = cwd.find('example')
        if i>0 and j>i and k>j:     # called from Example folder
            outdir = os.path.join(outdir, 'Output_Pyscript')
            if not os.path.exists(outdir): os.mkdir(outdir)

    return outdir

#

# =====================

def run(pssplt_eps_files=[], pict_files=[], docfile='', outpath=None, show=True):
    """
Inputs:
pssplt_eps_files --> List of Multi-page 'eps' plot files created by PSSPLT
pict_files       --> List of any word compatible picture files (.eps, .wmf, .png, .bmp etc.)
docfile          --> Word file name
outpath          --> Outpath where Word file created/saved
Show             --> = True, Show Word
                     = False, Create and Save Word file but do not show
"""
    import wordpy

    pssplt_eps_files_lst = []
    for fnam in pssplt_eps_files:
        if not os.path.exists(fnam): continue
        pssplt_eps_files_lst.append(fnam)

    pict_files_lst   = []
    pict_caption_lst = []
    for fnam in pict_files:
        if not os.path.exists(fnam): continue
        p, nx = os.path.split(fnam)
        caption, x = os.path.splitext(nx)
        pict_files_lst.append(fnam)
        pict_caption_lst.append(caption)

    if  docfile:
        p, nx = os.path.split(docfile)
        docfnam, x = os.path.splitext(nx)
    else:
        docfnam = r'wordpy_demo_created'
        p = outpath

    # doc file
    docfile = get_output_filename(p, docfnam)

    docoverwrite = True

    # Picture Insert Options (see help(wordpy) for explaination)
    align      = 'center'
    captionpos = 'below'
    height     = None
    width      = None
    rotate     = None

    # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    # Put-it-together
    wdobj = wordpy.workdoc(docfile=docfile, overwrite=docoverwrite)
    if show:
        wdobj.show()

    wdobj.page_format(orientation="portrait",left=0.75,right=0.75,top=0.5,bottom=0.5,
                      header=0.25,footer=0.25)

    wdobj.add_styled_para('Use of Python and Word','Title')

    txt = "This file is produced by Python script, by inserting picture files into word document. \
    It uses python module 'wordpy'.\n\n\
    This module is mainly created to add plot files (.eps, .png, .wmf etc.) \
    created by PSSPLT/PSSPLOT to existing or new Word files.\n\n\
    Use PSSPLT to create .eps files, and PSSPLOT to create .wmf files. Then use \
    'wordpy' module to create Word document from those files.\n\n\
    How to use it?\n\n\
    Use 'workdoc' function to create Miscrosoft Word object and use 'add_picture(...)' or \
    'add_pictures(...)' methods to insert pictures into the doc file.\n\n"
    wdobj.add_text(txt)

    txt = """Use either of the following to create Word object:
    (1) When file does not exist, create new file.
        wdobj = wordpy.workdoc()
    (2) When file exists, do not remove the content and add data at the end.
        wdobj = wordpy.workdoc(r"c:\working dir\ex1.doc", overwrite=False)
    (3) When file exists, remove the content and create new file.
        wdobj = wordpy.workdoc(r"c:\working dir\ex1.doc", overwrite=True)
    """
    wdobj.add_text(txt)

    if pssplt_eps_files_lst:
        wdobj.insert_page_break()
        wdobj.add_styled_para('Inserting multi-page PSSPLT EPS Files - add_pssplt_eps(...)','Heading 1')
        for fnam in pssplt_eps_files_lst:
            wdobj.add_pssplt_eps(fnam, captionlst=True, align=align, captionpos=captionpos,
                                 height=height, width=width, rotate=rotate)
            wdobj.insert_page_break()

    if pict_files_lst:
        wdobj.add_styled_para('Inserting One Picture File - add_picture(...)','Heading 1')
        wdobj.add_picture(pictfile=pict_files_lst[0], caption=pict_caption_lst[0], align=align,
                          captionpos=captionpos, height=None, width=None, rotate=0.0)
        wdobj.insert_page_break()

    if pict_files_lst:
        wdobj.add_styled_para('Inserting Many Picture Files - add_pictures(...)','Heading 1')
        wdobj.add_pictures(pictfilelst=pict_files_lst, captionlst=pict_caption_lst, align=align,
                           captionpos=captionpos, height=height, width=width, rotate=0.0)

    wdobj.save()

    if not show:
        txt = "\n Word file created:\n     {0}".format(wdobj.DOCFNAM)
        wdobj.close()
        print(txt)

#